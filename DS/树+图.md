# 5.1.5 答案与解析  

# 一、单项选择题  

01.D
- 树是一种分层结构，它特别适合组织那些具有分支层次关系的数据。

02.A
- 树的基本性质
  - 除根结点外，其他每个结点都是某个结点的孩子
  - 所有结点的度数加1等于结点数
  - 所有结点的度数之和等于总结点数减1

03.A
- 树的路径长度
  - 树根到每个结点的路径长的总和
  - 根到每个结点的路径长度的最大值是树的高度减1
  - 与哈夫曼树的带权路径长度不同

04.A
- 度为4的树的最大高度
  - 每层结点数尽可能少
  - 除最后一层外，每层结点数为1
  - 最终树高度为 $n-3$
  - 树的度为4只表示存在结点最多有4个孩子结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c2acf0a7da6dab9b867bdeee644276bab169f8a3ce9c55f42f055efbe2d40898.jpg)

05.A
- 度为4、高度为 $h$ 的树
  - 最少结点数条件
    - 至少有一个结点有4个分支
    - 每层结点数尽可能少
    - 结点个数为 $h+3$
  - 最多结点数条件
    - 每个非叶结点度为4
    - 为满树
    - 总结点数最多为 $1+4+4^2+...+4^{h-1}$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/319130282b8c21b7aad8111328893a19cc0d7390c7079f8ec405a0db31354fb8.jpg)

06.C
- 完全三叉树的层次分布
  - 第1层：1个结点
  - 第2层：$3^1 = 3$个结点
  - 第3层：$3^2 = 9$个结点
  - 第4层：$3^3 = 27$个结点
  - 结点总和：$1+3+9+27=40$
  - 第5层：$50-40=10$个结点
  - 最小高度为5

07.B
- 结点度数关系
  - 总结点数：$n=n_0+n_1+n_2+n_3=6+n_1+1+2=n_1+9$
  - 总度数：$n-1=n_1+2n_2+3n_3=n_1+2+6=n_1+8$
  - $n_1$为大于等于9的任意整数

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d3f8afcf3229449d56c1d3a158ee20af4df2bc26b4b7044ed548cbd0e4ab56a7.jpg)

08.D
- 叶结点数计算
  - 设叶结点数为 $N_0$，总结点数为 $N$
  - $N=N_1+2N_2+3N_3+...+mN_m+1$
  - $N=N_0+N_1+N_2+N_3+...+N_m$
  - $N_0=N_2+2N_3+...+(m-1)N_m+1=\sum_{i=2}^m(i-1)N_i+1$

09.B
- 结点度数分析
  - 设度为 $i(i=0,1,2,3,4)$ 的结点数为 $n_i$
  - $n=1+n_1+2n_2+3n_3+4n_4=n_0+n_1+n_2+n_3+n_4$
  - $n_1+2n_2+3n_3+4n_4=122$
  - $n_1+n_2+n_3+n_4=41$
  - 得出 $n_0=82$

10.C
- 解法1：树的边数性质
  - $n$个结点的树有$n-1$条边
  - 结点数比边数多10 $(25-15=10)$
  - 共有10棵树

- 解法2：图的生成树性质
  - 顶点数为$n$的生成树含有$n-1$条边
  - 结点数比边数多1
  - 分析同解法1

# 二、综合应用题

01.【解答】
- 三叉树最小高度计算
  - 完全三叉树性质
    - 高度为$h$
    - 第$h$层至少1个结点
    - 最多有$3^{h-1}$个结点
  - 结点数关系
    - $1+3^1+3^2+...+3^{h-2}<n\leq1+3^1+3^2+...+3^{h-2}+3^{h-1}$
    - $(3^{h-1}-1)/2<n\leq(3^h-1)/2$
    - $3^{h-1}<2n+1\leq3^h$
  - 最小高度
    - $h<\log_3(2n+1)+1$
    - $h\geq\log_3(2n+1)$
    - $h=\lceil\log_3(2n+1)\rceil$

02.【解答】
- 树的结点度数分析
  - 设度为$i(i=0,1,2,3,4)$的结点数为$n_i$
  - 结点总数：$n=n_0+n_1+n_2+n_3+n_4=23+n_4$
  - 度数关系：$n=0+n_1+2n_2+3n_3+4n_4+1=17+4n_4$
  - 解得：$n_4=2$，$n=25$

03.【解答】
- 树的结点与度数关系
  - 结点数等于度数加1：$n=\sum_{i=0}^m in_i+1=n_1+2n_2+3n_3+...+mn_m+1$
  - 总结点数：$n=n_0+n_1+n_2+...+n_m$
  - 叶结点数：$n_0=n_2+2n_3+...+(m-1)n_m+1=1+\sum_{i=2}^m(i-1)n_i$

> attention:
- 常用结点与度数关系
  - 总结点数：$n_0+n_1+n_2+...+n_m$
  - 总分支数：$1n_1+2n_2+...+mn_m$
  - 总结点数=总分支数+1



# 5.2.4 答案与解析  

# 一、单项选择题  

01.C
- 二叉树与度为2的有序树比较
  - 孩子左右次序区分
    - 二叉树单孩子有确定左右次序
    - 度为2有序树单孩子无需区分左右
  - 完全二叉树性质
    - 度为1的结点最多一个且只有左孩子
    - 高度为 $\lceil\log_2(n+1)\rceil$ 或 $\lfloor\log_2n\rfloor+1$

02.C
- 空二叉树概念
  - 无结点不等于不存在
  - 类比空线性表、空树
  - 图不能为空

03.A
- 完全二叉树性质
  - 叶结点双亲的左兄弟必有孩子且在前
  - 叶结点数满足 $n_0=n_2+1$
  - 可采用顺序存储结构
  - 第i个结点左孩子不一定存在

04.B
- 度为2的结点数计算
  - 由 $n_0=n_2+1$ 得 $n_2=n_0-1=10-1=9$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ad1577274eda3fe97eb16978d4605b1c956728b5379cd66531918fc961d2062d.jpg)

05.B
- 最少结点数计算
  - 根结点层1个结点
  - 其他h-1层各2个结点
  - 总结点数 $=2(h-1)+1=2h-1$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/95a4c13d0ab9c34fb84df72c99b09f011ea9575976fd46e6202394347e746ca6.jpg)

06.D
- 二叉树形态数计算
  - n-1个结点各有左右两种可能
  - 共有 $2^{n-1}$ 种组合形态

07.C
- 最小高度计算
  - 完全二叉树高度最小
  - $h=\lfloor\log_2n\rfloor+1=\lfloor\log_250\rfloor+1=6$

08.C
- 度为1的结点数性质
  - 由 $n_0=n_2+1$ 和 $n=n_0+n_1+n_2$
  - 得 $n_1=2(n-n_2)-1$ 为奇数
  - 不可能有 $2m$ 个度为1的结点

09.C
- 二叉树高度范围
  - 单支树最大高度1025
  - 完全二叉树最小高度 $\lfloor\log_2n\rfloor+1=11$

10.C
- 总结点数与高度关系
  - 第一层1个结点
  - 其余h-1层各2个结点
  - 总结点数 $=1+2(h-1)=15$，得 $h=8$

11.C
- 完全二叉树最少结点数
  - 前h-1层为满二叉树，有 $2^{h-1}-1$ 个结点
  - 第h层至少1个结点
  - 最少结点数 $=2^{h-1}-1+1=2^{h-1}$

12.A
- 完全二叉树最少结点数
  - 第6层有8个叶结点
  - 前5层为满二叉树
  - 最少结点数 $=2^5-1+8=39$

13.A
- 叶结点数计算
  - 第5层16个结点
  - 第6层3个叶结点
  - 第5层剩余14个叶结点
  - 总叶结点数17个

14.D
- 叶结点数计算
  - 最后分支结点序号 $\lfloor1001/2\rfloor=500$
  - 叶结点数501

15.C
- 第7层最多结点数
  - 7层满二叉树127个结点
  - 第7层最多 $2^6-1=63$ 个结点

16.B
- 最大结点数计算
  - $n_0=n_2+1$ 得 $n_2=123$
  - $n=n_0+n_1+n_2=247+n_1$
  - 当 $n_1=1$ 时最大值248

17.B
- 空指针数计算
  - 非空指针数 $=n-1$
  - 总指针数 $=2n$
  - 空指针数 $=2n-(n-1)=n+1$

18.A
- 二叉链表和三叉链表空指针数量比较
  - 二叉链表空指针数为 $n+1$
  - 三叉链表空指针数为 $n+2$
  - 根结点度为2时只有左右孩子指向它
  - 单根结点树无指针指向根结点

19.A
- 完全二叉树结点层次关系
  - 编号为 $i$ 的结点所在层次为 $\lfloor\log_2i\rfloor+1$
  - 同层结点满足 $\lfloor\log_2p\rfloor=\lfloor\log_2q\rfloor$

20.C
- 完全二叉树祖先结点查找
  - 结点17的祖先下标:8,4,2,1
  - 结点19的祖先下标:9,4,2,1
  - 最近公共祖先下标为4

21.C
- 三叉树高度计算
  - 第 $i$ 层最多 $3^{i-1}$ 个结点
  - 总结点数上限 $(3^h-1)/2$
  - 求解 $50\leq(3^h-1)/2$
  - $h=\lceil\log_3101\rceil=5$

22.B
- 三叉链表空指针计算
  - 总指针域数 $3n$
  - 非空指针数 $n-1$
  - 空指针数 $2n+1$

23.D
- 满二叉树结点数关系
  - 总结点数 $n=2^0+2^1+\cdots+2^{h-1}=2^h-1$
  - 叶结点数 $m=2^{h-1}$

24.C
- 完全二叉树最大结点数
  - 第6层有8个叶结点
  - 第7层缺失16个叶结点
  - 最大结点数 $2^7-1-16=111$

25.C
- 叶结点数计算
  - 最后分支结点编号 $\lfloor768/2\rfloor=384$
  - 叶结点数 $768-384=384$
  - 另解:由 $n=2n_0+n_1-1$ 且 $n_1=1$ 得 $n_0=384$

26.A
- 满二叉树结点数关系
  - 高度为 $h$ 的满二叉树
  - 最后一层叶结点数 $2^{h-1}=k$
  - 总结点数 $2^h-1=2k-1$

27.A
- 顺序存储空间需求
  - 高度为5的二叉树
  - 需存储1~5层所有结点
  - 总存储单元数 $1+2+4+8+16=31$

28.C
- 三叉树高度分析
  - 高度5的满三叉树结点数121
  - 高度6的满三叉树结点数364
  - 结点数244介于两者之间
  - 最小高度为6
# 二、综合应用题  

01.【解答】
- 二叉树中度为0和度为2的结点关系
  - 基本关系: $n_0 = n_2 + 1$
  - 总结点数: $n = n_0 + n_1 + n_2 = 2n_0 + n_1 - 1$
  - 两种情况分析:
    - 当 $n_1 = 1$ 时
      - $n = 2n_0$
      - $h = \lceil\log_2(n+1)\rceil = \lceil\log_2(2n_0+1)\rceil$
    - 当 $n_1 = 0$ 时
      - $n = 2n_0 - 1$
      - $h = \lceil\log_2(n+1)\rceil = \lceil\log_2(2n_0)\rceil = \lceil\log_2(n_0)\rceil + 1$

02.【解答】
- 满二叉树特性分析
  - 基本关系
    - $n_1 = 0$
    - $n_0 = n_2 + 1$
    - $n_2 = n_0 - 1$
  - 结点数关系
    - $n = n_0 + n_1 + n_2 = 2n_0 - 1$
    - $n_0 = (n+1)/2$
    - 分支结点数: $n_2 = (n-1)/2$
  - 高度关系
    - 结点总数: $n = 2^h - 1$
    - 高度: $h = \log_2(n+1)$

03.【解答】
- 完全二叉树结点分析
  - 层次结构
    - 第9层有240个结点(未满)
    - 1~8层是满的
  - 结点数计算
    - 总结点数: $2^8 - 1 + 240 = 495$
    - 第8层叶结点: $2^{8-1} - 120 = 8$
    - 总叶结点数: $8 + 240 = 248$
  - 另解
    - 总结点关系: $n = n_0 + n_1 + n_2 = 2n_0 + n_1 - 1$
    - 当 $n_1 = 0$ 时: $2n_0 - 1 = 495$, 得 $n_0 = 248$

> attention:  
完全二叉树特点：只有最底层结点不满，其他层结点都是满的（第 $i$ 层有 $2^{i-1}$ 个结点）

04.【解答】
- m叉树的层次特性
  - 各层结点数
    - 第1层: $m^0 = 1$
    - 第2层: $m^1$
    - 第3层: $m^2$
    - 第i层: $m^{i-1}$ $(1 \leq i \leq h)$
  - 结点编号关系
    - 第1个子女编号: $j = (i-1)m + 2$
    - 双亲编号: $(i-2)/m + 1$ (i > 1)
    - 第k个子女编号: $(i-1)m + k + 1$ $(1 \leq k \leq m)$
  - 右兄弟判定
    - 条件: $i \leq \lfloor(i+m-2)/m\rfloor m$
    - 右兄弟编号: $i + 1$
    - 另一判定方法: $(i-1)\%m \neq 0$

05.【解答】
- 二叉树最近公共祖先查找
  - 基本原理
    - 任意两结点必有公共祖先
    - 结点i的双亲编号为i/2
  - 算法步骤
    - 当i > j时
      - 若i/2 = j，则j为最近公共祖先
      - 否则令i = i/2继续查找
    - 当j > i时
      - 若j/2 = i，则i为最近公共祖先
      - 否则令j = j/2继续查找

ElemType Comm Ancestor(SqTree T,int i,int j){
if(T[i] != '#'&&T[j]!='#'){
while(i != j){
if(i > j) i = i/2
else j = j/2;
return T[i];

06.【解答】
- 正则k叉树特性
  - 结点类型关系
    - 叶结点数: $n_0$
    - 度为k的分支结点数: $n_k = m$
    - 总结点数: $n = n_0 + m$
    - 边数关系: $e = mk = n - 1$
    - 叶结点数公式: $n_0 = (k-1)m + 1$
  - 最大最小结点数
    - 最大结点数
      - 除最后一层外都是分支结点
      - 总结点数: $M_1 = \frac{k^h-1}{k-1}$
    - 最小结点数
      - 每层(除根外)只有k个结点
      - 总结点数: $M_2 = 1 + (h-1)k$

# 5.3.4 答案与解析  

# 一、单项选择题  

01.C
- 二叉树中序遍历最后结点特性
  - 从根沿右子女指针到底
  - 若结点p不是叶结点
    - 前序遍历最后结点在左子树中
  - 若结点p是叶结点
    - 前序与中序遍历最后结点相同
  - 若p有左子女q且q为叶结点
    - q为前序遍历最后结点
    - q不是中序遍历最后结点

02.C
- 三种遍历方式特点
  - 都先遍历左子树再遍历右子树
  - b一定在c前访问

03.C
- 中序遍历n在m前的情况分析
  - 遍历顺序：左子树→根结点→右子树
  - n总在m的左方

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c8dfbbbff6ae56c3a36e875776bcce647d64015dd0dfcf999e8fb6318c9484c.jpg)

- 最近公共祖先p的情况
  - m和n在p的左右分支
  - m为祖先且n在左分支
  - n为祖先且m在右分支

04.D
- 后序遍历LRN的特点
  - n在N左子树、m在N右子树时n先访问
  - n是m子孙时n先访问
  - 需同层条件才能确定访问顺序

05.C
- 后序遍历查找路径方法
  - 递归方式
    - 退回时访问根结点
    - 自下向上输出路径结点
  - 非递归方式
    - 访问n时栈记录父指针路径
    - 可找到m到n路径

06.C
- 二叉树数组存储特点
  - 下标i结点的左孩子：$2i+1$
  - 下标i结点的右孩子：$2i+2$
  - 后序遍历序列：gdbhefca

07.B
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa6d8f24cab5aa92b27438714e0ea552714791a720fe2eaeba68cc0233a247df.jpg)
- 三种遍历方式特点
  - 左右子树访问顺序不变
  - 只是根结点访问顺序不同
  - 叶结点访问顺序相同

08.C
- 结点编号规则
  - 从1开始按序编号
  - 结点编号大于左右孩子编号
  - 左孩子编号小于右孩子编号
  - 符合后序遍历特点

09.B
- 结点编号特点分析
  - v编号小于左子树最小编号
  - 右子树最小编号大于左子树最大编号
  - v编号最小，符合先序遍历

10.D
- ABC前序遍历二叉树分析
  - 共5种不同二叉树
  - 后序为CBA的有4种单支树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/34221acdbf2a5f9f21856b9d382d537e9e3cd45d327be8acda64e2f8ee90de74.jpg)

11.C
- 7结点完全二叉树特点
  - 3层满二叉树
  - 根据后序序列填充
  - 先序遍历序列：ABCDEFG

12.C
- 二义树遍历序列分析
  - 前序NLR中X在Y前
  - 后序LRN中X在Y后
  - X在根位置满足要求

13.C
- 先序中序序列关系分析
  - 先序：$\cdots a\cdots b\cdots$
  - 中序：$\cdots b\cdots a\cdots$
  - b在a左子树中

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/642d1f563463bd5539d46487993763c0b724a04aebd2be9103fc251eb80649bb.jpg)

14.B
- 解法分析
  - 解法1：根据树的结构分析
  - 解法2：栈的入栈出栈分析
  - 解法3：序列构造二叉树验证

15.D
- 先序后序序列特点
  - 可确定根结点
  - 无法划分左右子树
  - 存在多种可能结构

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e27b68d581f4fb471640e3280e713e72c68fa75cf61242e5f7209e4566ed3e8.jpg)
16.B
- 中序遍历和后序遍历序列相同的条件
  - 中序遍历为"左根右"，后序遍历为"左右根"
  - 当结点无右子树时，两种遍历都是"左根"
  - 空树或只有根结点时，序列相同

17.D
- 根据后序和中序序列构造二叉树
  - 确定根结点
  - 确定左子树根结点
  - 确定剩余子树
  - 得到先序序列为CEDBA

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4cefbbc82ac6fc9969c3dc3c587dee80b1f5fed7de8b40713c50310eb0bf5f3a.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e8e141edfda28a636a0ce51573db02149bc3834aba03d4804069d134cff26df.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e109474afccc6679b8deb8740d93ca9e330ffc6dbe8718246d392440feb056a.jpg)

18.A
- 遍历序列问题解题思路
  - 根据遍历性质排除选项
  - 构造二义树验证
  - 根据先序和中序确定二叉树结构
    - 确定根结点位置
    - 划分左右子树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1aead16498b6de7d7cbdaa3c6d01338f073d72817739dd6eedbd644395296825.jpg)

19.B
- 二叉树构造
  - 根据给定序列构造二叉树
  - 得到先序序列为ABCDEF

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/27df33368b083839eedf3b0514ca7af88ed07bfe2a1949644c0aaa80fab81cc6.jpg)

20.B
- 后序遍历特点
  - 若a是b的祖先，后序遍历必先遍历b后遍历a

21.C
- 删除结点操作
  - 递归删除左右孩子
  - 释放存储空间
  - 符合后序遍历顺序

22.A
- 线索的作用
  - 建立前驱后继指针
  - 加快二叉树遍历

23.C
- 线索二叉树特点
  - 二义树是逻辑结构
  - 线索二叉树是物理结构

24.C
- 线索数量计算
  - $n$ 个结点共 $2n$ 个链域指针
  - $n-1$ 个指针指向结点
  - 剩余 $n+1$ 个链域建立线索

25.C
- 线索标识说明
  - ltag/rtag标识左/右指针域
  - 值为1表示线索
  - 值为0表示左/右孩子

26.D
- 先序线索化特点
  - 根结点左子树空且无前驱
  - 最后叶结点左右子树空，有前驱无后继
  - 空链域共2个

27.D
- 线索查找限制
  - 不是所有结点都能直接找到前驱后继
  - 先序线索树查找后继简单，前驱需知道双亲
  - 后序线索树查找前驱简单，后继需知道双亲

28.D
- 后序线索二叉树问题
  - 无法有效解决后序后继问题
  - 右指针可能指向右孩子而非后继结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9318f19145a8c0b4a573067e58e6f8d3647d9167959521a6ffd703d20ded8ee3.jpg)

29.C
- 中序线索树前驱特点
  - 结点有左孩子时
  - 前驱为左子树最右结点

30.A
- 后序遍历线索特点
  - 叶结点X的后继是其双亲
  - 右线索指向双亲结点
31.C
- 后序线索树遍历特点
  - 最后访问根结点
  - 从右孩子返回访问父结点时
    - 右孩子指针不一定为空
    - 右指针可能无法指向后继
    - 需要栈支持遍历

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f01e1f5c6bfa0ab8bd3496477988e32b56646f62f9a9f0dfb01b87aa9c670ced.jpg)

32.B
- 先序序列和后序序列相反的条件
  - 树只有根结点
  - 或根结点只有单个子树
  - 任意结点只有一个孩子
  - 树形为长链
  - 仅有一个叶结点

33.D
- RNL遍历序列特点
  - 根结点在中间访问
  - 右子树结点在左子树之前
  - 非基本遍历方法
  - 重在掌握遍历思想

34.D
- 后序序列dbca的线索化
  - 结点d
    - 无前驱和左子树,左链域空
    - 无右子树,右链域指向后继b
  - 结点b
    - 无左子树,左链域指向前驱d
  - 结点c
    - 无左子树,左链域指向前驱b
    - 无右子树,右链域指向后继a

35.C
- 前序后序相反的二叉树特点
  - 高度为4
  - 结点不能同时有左右孩子
  - 根结点1只能有单个孩子
  - 结点2只能有单个孩子

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d099fc600e15293c0170714c6edf949b02c8780239cab62e97f4a5e96d748617.jpg)

36.A
- 前序后序序列确定二叉树特点
  - 不能唯一确定树形
  - 可确定结点祖先关系
  - 前序XY后序YX时,X为Y祖先
  - a为根结点,e为a唯一孩子

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e13cc912f00d28b8c5a3bec288939e86c8cb0b0754b83808c75780f6542f39f.jpg)

37.A
- 后序线索二叉树叶结点特点
  - X为叶结点且有左兄弟
  - X为右孩子结点
  - 后序后继是父结点
  - 右线索指向父结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fbb372f30cb32518e9b3df19e5081a39269c66488b4aed85f920e92b2381459.jpg)

38.D
- 中序线索二叉树特点
  - 线索指向遍历序列的前驱后继
  - 中序序列debxac
  - x的左右线索为b,a

39.B
- 前序中序序列关系
  - 前序序列为入栈次序
  - 中序序列为出栈次序
  - n个不同元素出栈序列个数为$\frac{1}{n+1}C_{2n}^{n}=14$

40.B
- 后序遍历序列分析
  - 先访问左子树叶结点e
  - 再访问父结点a,c
  - 然后访问右子树叶结点b
  - 最后访问d,g,f
  - d与a同层

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/310cd850ebe2a0f810b9d0c1fede865efc5ef4c10f8c6920b4d153dd4a92a79c.jpg)

41.B
- 只有右子树的遍历特点
  - 先序序列:先父结点后右子树
  - 中序序列:先父结点后右子树
  - 两种序列访问顺序相同

42.B
- 中序遍历序列p,q相邻的情况分析
  - q是p的双亲可能
  - q是p的右孩子可能
  - q是p的右兄弟不可能
  - q是p双亲的双亲可能

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c591f62273d2efdf988f7bd9a8243e35fdfd2e0d1d0a44899a8560f7f7e740ab.jpg)

43.A
- 后序序列确定二叉树
  - 根据树形和后序序列填充结点
  - 先序遍历得到序列aedfbc

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0629617052231773263820303ba41813a70ec33b531926ab0f20663456bbcf6.jpg)

# 二、综合应用题  

01.【解答】
- 二叉树先序序列与后序序列反序相等的条件
  - 二叉树特点
    - 每层只有一个结点
    - 高度等于结点个数
  - 满足条件
    - L或R应为空

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/15e666d30bf5cb8d01e1ef955c018597ec9fe12c9f7ec6b39d30b712a5cb21cc.jpg)

02.【解答】
- 二叉树先序序列与后序序列相等的条件
  - 满足条件
    - L和R均为空
    - 只有一个根结点

03.【解答】
- 二叉树后序非递归遍历算法
  - 基本思路
    - 沿左孩子入栈直到为空
    - 检查栈顶右孩子
      - 不空且未访问则转向右
      - 否则出栈访问
    - 设辅助指针r指向最近访问结点
  - 代码实现

void PostOrder(BiTree T) {
    InitStack(S);
    BiTNode *p = T;
    BiTNode *r = NULL;
    while(p || !IsEmpty(S)) {
        if(p) {
            Push(S,p);
            p = p->lchild;
        } else {
            GetTop(S,p);
            if(p->rchild && p->rchild != r) {
                p = p->rchild;
            } else {
                Pop(S,p);
                visit(p->data);
                r = p;
                p = NULL;
            }
        }
    }
}


04.【解答】
- 自下而上、从右到左层次遍历算法
  - 基本思路
    - 正常层次遍历时结点入栈
    - 遍历完后从栈顶访问
  - 具体步骤
    - 根结点入队列
    - 出队列并入栈
    - 左右孩子入队列
    - 重复直到队空
    - 依次出栈访问
  - 代码实现

void InvertLevel(BiTree bt) {
    Stack s;
    Queue Q;
    if(bt != NULL) {
        InitStack(s);
        InitQueue(Q);
        EnQueue(Q,bt);
        while(!IsEmpty(Q)) {
            DeQueue(Q,p);
            Push(s,p);
            if(p->lchild) EnQueue(Q,p->lchild);
            if(p->rchild) EnQueue(Q,p->rchild);
        }
        while(!IsEmpty(s)) {
            Pop(s,p);
            visit(p->data);
        }
    }
}


05.【解答】
- 求二叉树高度的非递归算法
  - 层次遍历思路
    - 设level记录当前层数
    - last指向当前层最右结点
    - 出队时与last比较
    - 相等则层数加1
  - 递归实现思路
    - 空树高度为0
    - 返回左右子树最大高度加1
  - 代码实现

int Btdepth(BiTree T) {
    if(!T) return 0;
    int front = -1, rear = -1;
    int last = 0, level = 0;
    BiTree Q[MaxSize];
    Q[++rear] = T;
    BiTree p;
    while(front < rear) {
        p = Q[++front];
        if(p->lchild) Q[++rear] = p->lchild;
        if(p->rchild) Q[++rear] = p->rchild;
        if(front == last) {
            level++;
            last = rear;
        }
    }
    return level;
}

int Btdepth2(BiTree T) {
    if(T == NULL) return 0;
    int ldep = Btdepth2(T->lchild);
    int rdep = Btdepth2(T->rchild);
    return (ldep > rdep) ? (ldep + 1) : (rdep + 1);
}


06.【解答】
- 判断完全二叉树的算法
  - 基本思路
    - 层次遍历包含空结点
    - 遇空结点后检查是否有非空结点
  - 代码实现

bool IsComplete(BiTree T) {
    InitQueue(Q);
    if(!T) return true;
    EnQueue(Q,T);
    while(!IsEmpty(Q)) {
        DeQueue(Q,p);
        if(p) {
            EnQueue(Q,p->lchild);
            EnQueue(Q,p->rchild);
        } else {
            while(!IsEmpty(Q)) {
                DeQueue(Q,p);
                if(p) return false;
            }
        }
    }
    return true;
}


07.【解答】
- 计算双分支结点个数的递归算法
  - 递归模型
    - 空树返回0
    - 双分支结点递归左右子树并加1
    - 其他情况只递归左右子树
  - 代码实现

int DSonNodes(BiTree b) {
    if(b == NULL) return 0;
    else if(b->lchild != NULL && b->rchild != NULL)
        return DSonNodes(b->lchild) + DSonNodes(b->rchild) + 1;
    else 
        return DSonNodes(b->lchild) + DSonNodes(b->rchild);
}


08.【解答】
- 交换二叉树左右子树的算法
  - 后序遍历思想
    - 先交换左子树
    - 再交换右子树
    - 最后交换根结点左右孩子
  - 代码实现

void swap(BiTree b) {
    if(b) {
        swap(b->lchild);
        swap(b->rchild);
        temp = b->lchild;
        b->lchild = b->rchild;
        b->rchild = temp;
    }
}


09.【解答】
- 查找先序遍历第k个结点的算法
  - 基本思路
    - 全局变量i记录访问序号
    - 先序遍历查找第k个结点
  - 递归模型
    - 空树返回#
    - i=k返回当前结点值
    - 递归查找左右子树
  - 代码实现

ElemType PreNode(BiTree b, int k) {
    if(b == NULL)
        return '#';
    if(i == k)
        return b->data;
    i++;
    ch = PreNode(b->lchild,k);
    if(ch != '#')
        return ch;
    ch = PreNode(b->rchild,k);
    return ch;
}
10.【解答】
- 删除以元素值x为根的子树算法思想
  - 采用后序遍历
    - 删除值为x的结点需将父结点指针置空
    - 层次遍历易找到父结点
    - 需遍历完整棵二叉树
  - 代码实现

void DeleteXTree(BiTree &bt) {
    if(bt) {
        DeleteXTree(bt->lchild);
        DeleteXTree(bt->rchild);
        free(bt);
    }
}

void Search(BiTree bt, ElemType x) {
    BiTree Q[];
    if(bt) {
        if(bt->data == x) {
            DeleteXTree(bt);
            exit(0);
        }
        InitQueue(Q);
        EnQueue(Q,bt);
        while(!IsEmpty(Q)) {
            DeQueue(Q,p);
            if(p->lchild) {
                if(p->lchild->data == x) {
                    DeleteXTree(p->lchild);
                    p->lchild = NULL;
                } else {
                    EnQueue(Q,p->lchild);
                }
            }
            if(p->rchild) {
                if(p->rchild->data == x) {
                    DeleteXTree(p->rchild);
                    p->rchild = NULL;
                } else {
                    EnQueue(Q,p->rchild);
                }
            }
        }
    }
}


11.【解答】
- 查找值为x的结点并打印其所有祖先算法思想
  - 采用非递归后序遍历
    - 最后访问根结点
    - 访问到值为x的结点时栈中元素为其祖先
    - 依次出栈打印
  - 代码实现

typedef struct {
    BiTree t;
    int tag;
} stack;

void Search(BiTree bt, ElemType x) {
    stack s[];
    top = 0;
    while(bt != NULL || top > 0) {
        while(bt != NULL && bt->data != x) {
            s[++top].t = bt;
            s[top].tag = 0;
            bt = bt->lchild;
        }
        if(bt != NULL && bt->data == x) {
            printf("所查结点的所有祖先结点的值为：\n");
            for(i=1; i<=top; i++)
                printf("%d", s[i].t->data);
            exit(1);
        }
        while(top != 0 && s[top].tag == 1)
            top--;
        if(top != 0) {
            s[top].tag = 1;
            bt = s[top].t->rchild;
        }
    }
}


12.【解答】
- 查找p和q的最近公共祖先算法思想
  - 采用后序非递归遍历
    - 栈中存放结点指针
    - 访问到结点时栈中元素为其祖先
    - 先遍历到p时将栈复制到辅助栈
    - 继续遍历到q时从栈顶开始匹配
    - 第一个匹配元素即为最近公共祖先
  - 代码实现

typedef struct {
    BiTree t;
    int tag;
} stack;

BiTree Ancestor(BiTree ROOT, BiTNode *p, BiTNode *q) {
    stack s[], s1[];
    top = 0;
    bt = ROOT;
    while(bt != NULL || top > 0) {
        while(bt != NULL) {
            s[++top].t = bt;
            s[top].tag = 0;
            bt = bt->lchild;
        }
        while(top != 0 && s[top].tag == 1) {
            if(s[top].t == p) {
                for(i=1; i<=top; i++)
                    s1[i] = s[i];
                top1 = top;
            }
            if(s[top].t == q) {
                for(i=top; i>0; i--) {
                    for(j=top1; j>0; j--)
                        if(s1[j].t == s[i].t)
                            return s[i].t;
                }
            }
            top--;
        }
        if(top != 0) {
            s[top].tag = 1;
            bt = s[top].t->rchild;
        }
    }
    return NULL;
}


13.【解答】
- 求二叉树宽度算法思想
  - 采用层次遍历
    - 求出所有结点层次
    - 将结点和层次放入队列
    - 扫描队列求各层结点总数
    - 最大层结点总数即为宽度
  - 代码实现

typedef struct {
    BiTree data[MaxSize];
    int level[MaxSize];
    int front,rear;
} Qu;

int BTWidth(BiTree b) {
    BiTree p;
    int k,max,i,n;
    Qu.front = Qu.rear = -1;
    Qu.rear++;
    Qu.data[Qu.rear] = b;
    Qu.level[Qu.rear] = 1;
    while(Qu.front < Qu.rear) {
        Qu.front++;
        p = Qu.data[Qu.front];
        k = Qu.level[Qu.front];
        if(p->lchild != NULL) {
            Qu.rear++;
            Qu.data[Qu.rear] = p->lchild;
            Qu.level[Qu.rear] = k+1;
        }
        if(p->rchild != NULL) {
            Qu.rear++;
            Qu.data[Qu.rear] = p->rchild;
            Qu.level[Qu.rear] = k+1;
        }
    }
    max = 0;
    i = 0;
    k = 1;
    while(i <= Qu.rear) {
        n = 0;
        while(i <= Qu.rear && Qu.level[i] == k) {
            n++;
            i++;
        }
        k = Qu.level[i];
        if(n > max)
            max = n;
    }
    return max;
}


> attention:
本题队列中的结点，在出队后仍需要保留在队列中，以便求二叉树的宽度，所以设置的队列采用非环形队列，否则在出队后可能被其他结点覆盖，无法再求二叉树的宽度。

14.【解答】
- 先序序列转换为后序序列算法思想
  - 满二叉树特点
    - 任意结点左右子树结点数相等
    - 先序第一个结点为后序最后一个结点
  - 递归模型
    - 空树不做处理
    - 非空树处理根结点和左右子树
  - 代码实现

void PreToPost(ElemType pre[], int l1, int h1, ElemType post[], int l2, int h2) {
    int half;
    if(h1 >= l1) {
        post[h2] = pre[l1];
        half = (h1-l1)/2;
        PreToPost(pre,l1+1,l1+half,post,l2,l2+half-1);
        PreToPost(pre,l1+half+1,h1,post,l2+half,h2-1);
    }
}


15.【解答】
- 将叶结点按从左到右顺序链接成单链表算法思想
  - 采用中序遍历
    - 设置前驱结点指针pre初始为空
    - 第一个叶结点由head指向
    - 遍历到叶结点时将前驱rchild指向它
    - 最后一个叶结点rchild为空
  - 代码实现

LinkedList head, pre = NULL;

LinkedList InOrder(BiTree bt) {
    if(bt) {
        InOrder(bt->lchild);
        if(bt->lchild == NULL && bt->rchild == NULL) {
            if(pre == NULL) {
                head = bt;
                pre = bt;
            } else {
                pre->rchild = bt;
                pre = bt;
            }
        }
        InOrder(bt->rchild);
        pre->rchild = NULL;
        return head;
    }
}


16.【解答】
- 判断两棵二叉树是否相似算法思想
  - 递归思想
    - 都是空树则相似
    - 一个空一个非空则不相似
    - 递归比较左右子树是否相似
  - 代码实现

int similar(BiTree T1, BiTree T2) {
    int lefts, rights;
    if(T1 == NULL && T2 == NULL)
        return 1;
    else if(T1 == NULL || T2 == NULL)
        return 0;
    else {
        lefts = similar(T1->lchild, T2->lchild);
        rights = similar(T1->rchild, T2->rchild);
        return lefts && rights;
    }
}


17.【解答】
- 计算二叉树带权路径长度算法思想
  - 两种计算方法
    - 根据定义:叶结点带权路径长度之和
    - 根据性质:非叶结点权值之和
  - 递归实现
    - 遍历到叶结点返回带权路径长度
    - 否则返回左右子树带权路径长度之和
  - 代码实现

int WPL(BTree *root) {
    return WPL1(root,0);
}

int WPL1(BTree *root, int d) {
    if(root->left == NULL && root->right == NULL)
        return (root->weight * d);
    else
        return (WPL1(root->left,d+1) + WPL1(root->right,d+1));
}


18.【解答】
- 表达式树转中缀表达式算法思想
  - 基于中序遍历
    - 根结点和叶结点不需括号
    - 其他结点需要括号
    - 遍历左子树前加左括号
    - 遍历右子树后加右括号
  - 代码实现

void BtreeToE(BTree *root) {
    BtreeToExp(root,1);
}

void BtreeToExp(BTree *root, int deep) {
    if(root == NULL)
        return;
    else if(root->left == NULL && root->right == NULL)
        printf("%s",root->data);
    else {
        if(deep > 1)
            printf("(");
        BtreeToExp(root->left,deep+1);
        printf("%s",root->data);
        BtreeToExp(root->right,deep+1);
        if(deep > 1)
            printf(")");
    }
}


19.【解答】
- 判断顺序存储二叉树是否为二叉搜索树算法思想
  - 方法一:中序遍历
    - 记录已遍历结点最大值
    - 当前结点值小于等于最大值则返回false
    - 否则更新最大值
  - 方法二:结点值范围
    - 设置最大最小值数组
    - 从后向前扫描验证大小关系
  - 代码实现

bool judgeInOrderBST(SqBiTree bt, int k, int *val) {
    if(k < bt.ElemNum && bt.SqBiTNode[k] != -1) {
        if(!judgeInOrderBST(bt, 2*k+1, val))
            return false;
        if(bt.SqBiTNode[k] <= *val)
            return false;
        *val = bt.SqBiTNode[k];
        if(!judgeInOrderBST(bt, 2*k+2, val))
            return false;
    }
    return true;
}

bool judgeBST(SqBiTree bt) {
    int k, m, *pmin, *pmax;
    pmin = (int *)malloc(sizeof(int) * bt.ElemNum);
    pmax = (int *)malloc(sizeof(int) * bt.ElemNum);
    for(k=0; k<bt.ElemNum; k++)
        pmin[k] = pmax[k] = bt.SqBiTNode[k];
    for(k=bt.ElemNum-1; k>0; k--) {
        if(bt.SqBiTNode[k] != -1) {
            m = (k-1)/2;
            if(k%2 == 1 && bt.SqBiTNode[m] > pmax[k])
                pmin[m] = pmin[k];
            else if(k%2 == 0 && bt.SqBiTNode[m] < pmin[k])
                pmax[m] = pmax[k];
            else
                return false;
        }
    }
    return true;
}


# 5.4.5 答案与解析  

# 一、单项选择题  

01.D
- 二叉树性质分析
  - 单支树高度为 $n$ 
  - 完全二叉树特点
    - 最多一个度为1的结点且只有左孩子
    - 无左孩子则必是叶结点
  - 满二叉树特性
    
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e9ab7440fb0ba7ae2568a4d0cb457da7b029a76dee8eaa8d58dd29604f83da53.jpg)  

- 树转二叉树规则
  - 共同双亲的叶结点转换后只保留最右叶结点
  - 不同双亲的叶结点可能保持叶结点数相等

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/51b1988df9efa1bd0cfab2790e6a2fbc54938f6a60981ee51d79f38d299ef055.jpg)  

02.D
- 森林与二叉树转换
  - 采用"左孩子右兄弟"方法
  - 根结点右指针特点
    - 指向第二棵树根结点
    - 单树时为空
    - 可能为空或非空

03.D
- 森林转二叉树规则
  - 树根结点视为兄弟关系
  - 转换后特点
    - 树2作为树1根结点右子树
    - 树3作为树2根结点右子树
    - 根结点右子树结点数为 $M_2+M_3$

04.C
- 森林转二叉树结构
  - 根结点为第1棵树根
  - 左子树包含第1棵树所有孩子
  - 左子树结点数为 $a-1$

05.A
- 森林二叉树表示
  - 采用孩子兄弟法
  - 根结点及左子树为第一棵树
  - 第一棵树结点数为 $m-n$

06.D
- 森林转二叉树分析
  - 根结点及左子树来自第1棵树
  - 右子树来自剩余森林
  - 16结点完全二叉树特点
    - 右下遍历有4结点
    - 森林有4棵树
    - 第1棵树9个结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/038c61a6869824bb604ace6584a47963b2e2b68445265598b34b18b7a4f3b057.jpg)  

07.B
- 森林转换规则
  - 树根结点视为兄弟关系
  - 按"左孩子右兄弟"转化

08.C
- 右指针域分析
  - 最后一棵树根结点右指针为空
  - 非终端结点最后孩子右指针为空
  - 总计 $n+1$ 个右指针为空

09.B
- 孩子兄弟表示法
  - 叶结点左指针为空
  - 叶结点数为6
  - 左右指针都空为更严格条件

10.B
- 树与二叉树序列对应
  - 后根序列分析
    - 不对应后序序列
    - 叶结点访问顺序说明

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/811d0fe939354b3af51877b3369a3f9485bf59a8f5df68c786751a521cec7be5.jpg)  

11.C
- 二叉树重构与森林对应
  - 根据序列确定结构
    - A为根结点
    - 左子树BD关系
    - 右子树ECF关系
  - 森林特点
    - 3棵树
    - 根结点为A,C,F

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/68a02feaff287cc06c72c4994635bd4477104f0c03c73f4070947c9784d370e7.jpg)  

12.D
- 二叉树与树对应关系
  - X为双亲右孩子
  - 树中X必有左兄弟

13.B
- 森林二叉树表示特点
  - M和N父结点为根时
  - 位于不同树上
  - 可能无公共祖先

14.B
- 森林与二叉树转换规则
  - "左孩子右兄弟"原则
  - 转换后父子关系分析
    - 可能为兄弟关系
    - 可能为原父子关系
  - 情形分析
    - 情形I：第二个孩子结点转换
      - 变为第一个孩子的右孩子

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/23849acb7f1ad192690272d6eb62d837f5b522b5006188847d23c5a905fe3a8e.jpg)  
图1  

    - 情形II：兄弟结点间转换
      - 中间有兄弟结点k
      - v变为k的右孩子
      - k为u的右孩子

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/88e9d8be6c24673678554b626be8d4c64b38ada7141a9eb7d694b3392bfcc18c.jpg)  
图II  

    - 情形III：父结点为兄弟关系
      - 结点分布在不同子树
      - 不在同一路径

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bce7723f12689d6f9f179618b6607eb9e0bff9a08fdb9fbfdb37547c7fdf2773.jpg)  
图III  

- 另解分析
  - 四种情况转换
    - u为v父结点的父结点
    - u为v的父结点
    - u为v父结点的兄弟
    - u与v为兄弟关系
  - 结论：情形I和II正确

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b54bde337c355968b9e84921ef0a04014bff4ff4dfe57b3415c41729abd0277b.jpg)

15.D
- 树转二叉树特点
  - 最右子结点无右孩子
  - 根结点无右孩子
  - 无右孩子结点数计算
    - 分支结点数+1
    - $2011-116+1=1896$
- 特殊法分析
  - 仅前115个叶结点有右孩子
  - 无右孩子结点数=$2011-115=1896$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4a2a09690896ee7a1659e90819cb5a5265875656585a73a5949cce5a22350e9d.jpg)

16.C
- 森林转二叉树原理
  - 使用孩子兄弟表示法
  - 第一个孩子为左子树
  - 兄弟为右子树
- 叶结点特点
  - 无孩子转换后无左结点
  - F中叶结点数等于T中左指针为空结点数

17.B
- 后根遍历步骤
  - 从左到右访问孩子
  - 访问双亲结点
- 对应二叉树遍历
  - 树的后根遍历
  - 等同二叉树中序遍历
  - 序列示例：5,6,7,2,3,4,1

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7259d4cc4818fc1babba24630a5e11bdb2228c4e397ab621f3110ecf2e0b78d.jpg)

18.C
- 森林F与二叉树T遍历对应
  - 先根遍历对应先序遍历
  - 后根遍历对应中序遍历
- 序列分析
  - 先序：$a,b,c,d,e,f$
  - 中序：$b,a,d,f,e,c$
  - 后序：$b,f,e,d,c,a$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7a007c3660bceaf1cbc9774ddce74fc8ec45142d05e7ef96da09fcc94934f9b8.jpg)

19.C
- 二叉树构造
  - 根据先序和中序序列
  - 确定树的结构
- 森林特点分析
  - 根结点a、c、f通过右子树连接
  - 对应森林有3棵树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8ed6dd003c7f43d5f358dcca7ee0b04e888f8d9087591e61878e8d9c73e2df5e.jpg)

# 二、综合应用题  

01.【解答】
- 树与二叉树遍历对应关系
  - 树的先根遍历对应二叉树先序遍历
  - 树的后根遍历对应二叉树中序遍历
  - 遍历序列唯一确定树结构
- 示例分析
  - 对应二叉树序列
    - 先序序列: $1,2,3,4,5,6,8,7$
    - 中序序列: $3,4,8,6,7,5,2,1$
  - 原树序列
    - 先根遍历: $1,2,3,4,5,6,8,7$
    - 后根遍历: $3,4,8,6,7,5,2,1$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/085440873967ec7e8b0b8007f732cdbe14e22837c2beac68619ef756532352cc.jpg)

> attention:
树的先根遍历、后根遍历与对应二叉树的前序遍历、中序遍历对应。

02.【解答】
- 森林转二叉树步骤
  - 将根结点视为兄弟关系,连线
  - 仅保留第一子结点连线,删除其他
  - 以树根为轴心顺时针旋转45°

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8f4237f2bad0581db1b41bc5a56b06d5e6ed1cd4af1cd24fbbd0f3bccb027bb.jpg)

03.【解答】
- 二叉树转森林方法
  - 根据先序中序序列确定二叉树结构
  - 转换规则
    - 结点x为双亲y的左孩子时
    - 将x的右孩子及其右孩子与y连线
    - 删除所有双亲到右孩子连线

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bba7755a3db5d37961b23c0e266b087e86f30eadccea04d52b6debd6dac35031.jpg)

04.【解答】
- 叶结点计算原理
  - 孩子兄弟表示法
  - 无孩子结点为叶结点
  - 叶结点总数为孩子子树和兄弟子树叶结点之和
- 算法实现


typedef struct node {
    ElemType data;
    struct node *fch, *nsib;
} *Tree;

int Leaves(Tree t) {
    if(t == NULL) return 0;
    if(t->fch == NULL)
        return 1 + Leaves(t->nsib);
    else
        return Leaves(t->fch) + Leaves(t->nsib);
}


05.【解答】
- 树高度计算方法
  - 递归算法
    - 空树高度为0
    - 高度为第一子女树高度加1与兄弟子树高度的较大值
  - 非递归算法
    - 使用队列层次遍历
- 算法实现


int Height(CsTree bt) {
    int hc, hs;
    if(bt == NULL) return 0;
    else {
        hc = Height(bt->firstchild);
        hs = Height(bt->nextsibling);
        if(hc + 1 > hs) 
            return hc + 1;
        else 
            return hs;
    }
}

# 5.5.4 答案与解析  

# 一、单项选择题  

01.A
- 哈夫曼树结点度数特点
  - 只有度为0和2的结点
  - 满足 $n_0 = n_2 + 1$
  - 分支结点数 $n_2 = n - 1$
- 构造过程分析
  - n个结点需要n-1次合并
  - 每次合并新建一个分支结点

02.C
- 哈夫曼树构造步骤
  - 3和5合并为子树(权值8)
  - 8与6合并为新子树(权值14) 
  - 9与12合并为子树
  - 最后两子树合并为哈夫曼树

03.B
- 前缀编码定义
  - 任一编码不是其他编码的前缀
- 选项B分析
  - 0是00的前缀
  - 1是11的前缀

04.C
- 哈夫曼编码规则
  - 不能是其他编码的前缀
  - 3位编码可能情况
    - 001对应4位:0000和0001
    - 000对应4位:0010和0011
  - 4位编码可能:0000,0001,0010,0011

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9ff6aad7dd82f7a971bba44de0654ac095b92a8281d8f8b32cf08495abc724f8.jpg)

05.B
- 叶结点数计算
  - 根据总结点数计算:(215+1)/2=108
  - 不同码字数=叶结点数=108
- 另解分析
  - 结点总数n=n0+n2
  - n0=n2+1
  - n=215,n0=108

06.C
- 5个初始结点的哈夫曼树特点
  - 新建4个双分支结点
  - 最高高度为5

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42ca9973d8f18ebba36f6d07629e0d69db90a553d9e4104ad358480307c93f99.jpg)

07.D
- 哈夫曼树特性
  - 带权路径长度最小的扩充二叉树
  - 构造过程
    - 选权值最小的两棵树
    - 左右子树位置无限制
  - 结点度数特点
    - 只有度为0和2的结点
    - 无度为1的结点

08.C
- 哈夫曼树性质
  - 结点总数2n-1为奇数
  - 无度为1的结点
  - 带权路径长度计算方法
    - 所有叶结点带权路径长度之和
    - 所有分支结点权值之和

09.C
- m度哈夫曼树性质
  - 只有度为0和m的结点
  - 结点关系
    - 总数N=n0+nm
    - mnm=N-1=nm+n0-1
    - (m-1)nm=n0-1
    - nm=(n0-1)/(m-1)

10.B
- 并查集存储结构
  - 采用双亲表示法存储的树
  - 便于两个重要操作
11. C  

初始时， $_{0\sim9}$ 各自成一个集合。查找1-2时，合并{1}和{2}；查找3-4时，合并{3}和{4);查找5-6时，合并{5}和{6}；查找7-8时，合并{7}和{8}；查找8-9时，合并{7，8}和{9}；查找1-8时，合并{1,2}和{7,8,9}；查找0-5时，合并{0}和{5,6}；查找1-9时，它们属于同一个集合。最终的集合为0,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项℃。  

12.D  

依次探测图的各条边，用并查集检查该边依附的两个顶点是否已属于同一集合（两个顶点的根结点是否相同）。若是，则说明图中存在环路，A错误。经过路径优化后，并查集在最坏情况下的高度远小于 $O(n)$ ，B错误。Find操作总返回当前根结点作为集合的标志，C错误。  

13.D  

在用并查集实现Kruskal算法求图的最小生成树时：判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合（即判断加入这条边之后是否形成回路），若形成回路，则继续判断下一条边；若不形成回路，则将该边和边对应的顶点加入最小生成树T，并继续判断下一条边，直到所有顶点都已加入最小生成树 $T_{\circ}$ B正确。用并查集判断无向图连通性的方法：遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中，处理完所有边后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中。C正确。未做路径优化的并查集在最坏情况下的高度为 $n$ ，此时查找操作的时间复杂度为 $O(n)$ ，时间复杂度通常指最坏情况下的时间复杂度。D错误。  

14.A  

哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，选项B正确。构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，选项C正确。哈夫曼树中任意一个非叶结点的权值为其左、右子树根结点的权值之和，可知，哈夫曼树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值。  

15.D  

前缀编码的定义是在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。选项D中的编码110是编码1100的前缀，违反了前缀编码的规则，所以选项D不是前缀编码。  

16.D  

在哈夫曼树中，左右孩子权值之和为父结点权值。仅以分析选项A为例：若两个10分别属于两棵不同的子树，则根的权值不等于其孩子的权值和，不符；若两个10属同棵子树，则其权值不等于其两个孩子（叶结点）的权值和，不符。选项B、C选项的排除方法相同  
17.D  

哈夫曼编码是前缀编码，各个编码的前缀不同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为 $0100\,011\,001\,001\,011\,11\,0101$ ，译码结果是afeefgd。选项D正确。  

18.A  

根据各字符出现的次数构造的哈夫曼树如下图所示。由图可知，a、c和e的编码长度应该相同：a和c的第1个编码应该相同，且与e的第1个编码不同：b和d的前3个编码应该相同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/08e198998117d2d3790a9bc5f2d61fb413ce112cd731b071524be4f85aab49ea.jpg)  

19.C  

$n$ 个符号构造成哈夫曼树的过程中，共新建了 $_{n-1}$ 个结点（双分支结点），因此哈夫曼树的结点总数为 $2n\!-\!1\!=\!115$ ， $n$ 的值为58。  

20.B  

对于带权值的结点，构造出哈夫曼树的带权路径长度（WPL）最小，哈夫曼树的构造过程如 下图所示。求得其 $\mathrm{WPL}=(10+12)\times3+(30+16+21)\times2=200$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5ff281504ec4a9321197204f8297f883689249c454e3e6dccd555e03c6d3d0a.jpg)  

21.D  

可以画一个简单的特例来证明。图1是满足条件的二叉树  $T_{1}$  ，图2是满足条件的二叉树  $T_{2}$  结点中有值表示这个结点是编码字符。 $T_{1}$ 和 $T_{2}$ 的结点数不同，选项A错误。 $T_{1}$ 的高度等于 $T_{2}$ 的高度，选项B错误。出现频次不同的字符在 $T_{1}$ 中也可能处于相同的层，选项C错误。对于定长编码集，所有字符一定都在 $T_{2}$ 中处于相同的层，而且都是叶结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/10a86d2e849b5cca4dd47a358c1652320f8c46a9c7d2e40651769ea94d24c543.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/771c4823fc2fbe4fc51d66319b1fa0c108044a38391b95d0884d9d8ae1b4165e.jpg)  
图2  

22.B  

构建哈夫曼树的过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/149b825d15915e3ac02e787d001e0120d7f228d99a95e03573792a1ff45a0a36.jpg)  

对叶结点的哈夫曼编码，共有4个长度为3的叶结点、2个长度为2的叶结点，编码的加权 平均长度为 $[(3+4+5+6)\times3+(8+10)\times2]/(3+4+5+6+8+10)=2.5\,\mathrm{s}$  

# 二、综合应用题  

01.【解答】
- 哈夫曼树构造过程
  - 每次从森林中选取两个根结点值最小的树合并
  - 将原先的两棵树作为左、右子树
  - 新根结点的值为左、右孩子关键字之和

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/82f7046431340ab64837db08b393d12a65df83fad28acb985065875994652c70.jpg)

- 哈夫曼树WPL计算
  - $\mathrm{WPL}=(2+3)\times4+(5+6+7)\times3+(8+9)\times2=108$

> attention:  
- 哈夫曼树并不唯一，但带权路径长度一定是相同的

02.【解答】
- 最小合并次数分析
  - 类似于求最小带权路径长度，可用哈夫曼树
  - 每次选择表集合中长度最小的两个表合并

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/499ae6c6e4e94c0099ac2c3ffbf5e3e116f5b62142c0e24c0383a6e628cad01d.jpg)

- 合并过程
  - $\textcircled{\scriptsize{1}}$ 表集合{10,35,40,50,60,200}中，选择表A与表B合并，生成45个元素表AB
  - $\textcircled{2}$ 表集合{40,45,50,60,200}中，表AB与表C合并，生成85个元素表ABC
  - $\textcircled{3}$ 表集合{50,60,85,200}中，表D与表E合并，生成110个元素表DE
  - $\textcircled{4}$ 表集合{85,110,200}中，表ABC与表DE合并，生成195个元素表ABCDE
  - $\circledast$ 表集合{195,200}，表ABCDE与表F合并，生成395个元素表ABCDEF

- 最坏情况比较次数计算
  - 第1次合并：$44$ 次
  - 第2次合并：$84$ 次
  - 第3次合并：$109$ 次
  - 第4次合并：$194$ 次
  - 第5次合并：$394$ 次
  - 总次数：$825$ 次

- 合并策略
  - 对多个有序表两两合并时，表长不同时总比较次数依赖合并次序
  - 使用哈夫曼树思想，选择最短的两个表合并可获得最佳效率

03.【解答】
- 二叉树编码保存方法
  - 每个编码对应根到叶结点的路径
  - 路径长度等于编码位数
  - 叶结点保存对应字符

- 0/1串译码过程
  - 从左至右扫描各位
  - 根据0/1选择左右子指针下移
  - 到达叶结点输出字符
  - 重复直到扫描结束

- 前缀特性检测过程
  - 初始只有根结点
  - 依次处理每个编码，建立对应路径
  - 遇到三种情况：
    - $\textcircled{\scriptsize{1}}$ 遇到叶结点，不具前缀特性
    - $\circledcirc$ 未创建新结点，不具前缀特性
    - $\textcircled{3}$ 最后位创建新结点，继续验证
  - 全部通过则具有前缀特性# 6.1.3 答案与解析  

# 一、单项选择题  

01.A
- 路径定义解析
  - 不同教材定义略有差异
  - 顶点间关联的边可视为路径构成要素
  - 路径定义未要求不同顶点
  - 简单回路首尾顶点可相同
  - B选项未说明顶点间有边相联

02.D
- 无向图特性分析
  - n个顶点和n-1条边可构成生成树
  - 生成树特点
    - 连通无环
  - 再加一条边必构成环(不考虑重边)

03.B
- 选项分析
  - A错误：强连通图是有向图，与题意矛盾
  - B正确：无向连通图一次深度优先搜索可访问所有顶点
  - C错误：有回路不一定连通
  - D错误：连通图可能是树或存在环

04.C
- 图与树的区别分析
  - 逻辑区别而非边数区别
  - A错误：图边数可能小于树
  - B错误：E'边对应顶点须为V元素
  - C正确：极大连通子图为连通分量
  - D错误：遍历描述不准确

05.C
- 图的性质分析
  - 强连通有向图特点
    - 任意顶点间有路径
    - 未必有直接弧
  - 无向图入度等于出度
  - 有向图未必满足
  - 边集顶点必须在顶点集中

06.C
- 非连通图顶点数分析
  - 极端情况
    - 一个完全图加一个独立顶点
  - 完全图分析
    - 28条边对应8个顶点
    - 28 = n(n-1)/2 = 8×7/2
  - 总计9个顶点

07.A
- 最少边数分析
  - 连通无向图：构成树
  - 强连通有向图：构成有向环

08.D
- 顶点度数分析
  - n个顶点e条边满足
    - ∑TD(vi) = 2e
  - 度为2的顶点数为7
  - 共16个顶点

09.D
- 有向图度数特性
  - 顶点度 = 入度 + 出度
  - n个顶点最多与n-1个顶点有反向边
  - 仅讨论简单图

10.D
- 边数计算
  - 5顶点完全图需10条边
  - 第6个顶点连通需再加1条
  - 总共需11条边
11.D
- 连通图生成树特性分析
  - 生成树是极小连通子图
    - 无环性质
    - 选项III、IV正确
  - 极大连通子图概念
    - 称为连通分量
    - G'连通但非连通分量
    - 补充说明：非连通图中每个子部分包含所有顶点和边即为极大连通子图

12.C
- 连通分量数目最大化分析
  - 初始条件
    - 51个顶点的无向图G
    - 每个顶点为独立连通分量
  - 添加21条边策略
    - 尽可能在同一连通分量内添加
    - 7个顶点构成21条边的连通分量
    - 剩余44个独立顶点
    - 总计45个连通分量

13.B
- 强连通分量分析
  - 定义特点
    - 极大强连通子图
    - 顶点间有相反方向路径
  - 具体分析
    - 顶点B仅有出边，单独构成分量
    - A、C、D、E构成一个强连通分量

14.B
- 生成树数量分析
  - n个顶点生成树特征
    - n-1条边
    - 极小连通子图
  - 环到生成树转换
    - n条边的环
    - 去掉任意边得到生成树
    - 共n种不同生成树

15.C
- 森林树的数量计算
  - 方法一：添加节点法
    - n个节点，e条边
    - 添加一个连接点
    - x棵树转化为一棵树
    - 得出x=n-e
  - 方法二：边数关系法
    - 需x-1条边连接
    - 边数+1=顶点数
    - 同样得出x=n-e

16.A
- 无向图性质分析
  - 顶点度数和为偶数
    - 每条边计算两次
  - 生成树特性
    - III错误：边数=顶点数-1
  - 环的特性
    - IV错误：度为2的环存在

17.C
- 最少边数分析
  - 7个顶点连通要求
    - 6个顶点完全图
    - 加1条边连接第7个顶点
    - 最少需16条边
  - 示例说明
    - 5顶点情况图示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6670f866390407030b20e85bbe75f66f8be31f83e401718042801845ef69e03a.jpg)

18.B
- 最少顶点数计算
  - 度数关系
    - 边数2倍等于度数和
    - 部分顶点度为3
    - 其余顶点度为2
  - 计算过程
    - 4×3 + 3×4 + 2x = 16×2
    - 得出x=4
    - 总计11个顶点

19.D
- 图连通性分析
  - 临界情况一
    - 最小连通边数|V|-1
    - |E|<|V|-1时不连通
  - 临界情况二
    - 最大不连通边数
    - (|V|-1)(|V|-2)/2
    - 边数大于此值必连通

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d365d6fe671746d8b7f4d6f9f66c1fb1b3efb171fab922c052fc4c36d4daeeb6.jpg)
图1

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bb495ae5fd497815ebccdaad25436bee6ad203a9575cfee392daa488c7fe946.jpg)
图2
# 二、综合应用题  

01.【解答】
- 非连通无向图分析
  - 边数固定时顶点数最少情况
    - 由两个连通子图构成
      - 一个子图只含一个顶点(无边)
      - 另一个为完全图
  - 完全图边数计算
    - 边数公式 $n(n-1)/2=28$
    - 求解得 $n=8$
  - 总顶点数
    - 单顶点子图 1个
    - 完全图子图 8个
    - 总计 $1+8=9$ 个顶点

# 6.2.7 答案与解析  

# 一、单项选择题  

01.B
- 邻接矩阵存储空间分析
  - 不考虑压缩存储时为 $O(n^2)$，A正确
  - 邻接表存储无向图特点
    - 每条边视为两条方向相反的有向边
    - 需要存储两次，B错误
  - 拓扑序列存在性
    - 对角线以下元素全为0
    - 路径顶点编号递增
    - 不存在环，C正确
  - D正确

> attention:  
- 拓扑序列存在性说明
  - 邻接矩阵对角线以下(上)元素全为0
  - 必然不存在环
  - 拓扑序列一定存在
  - 但不能说明拓扑序列唯一

02.C
- 完全图特征
  - 主对角线外元素全为1
  - 任意两顶点间有边相连

03.D
- 无向图邻接矩阵特性
  - 矩阵大小为 $n^2$
  - 非零元素个数为 $2e$
  - 零元素个数为 $n^2-2e$

04.D
- 带权有向图邻接矩阵特点
  - 0和∞表示无有向边
  - 入度由列元素计算
  - 出度由行元素计算

05.B、D
- 度数计算规则
  - 有向图入度为第i列非0元素和
  - 无向图度为第i行或列非0元素和

06.B、B、D
- 邻接矩阵基本性质
  - 顶点数等于矩阵行(列)数
  - 有向图边数等于非零元素个数
  - 无向图边数等于非零元素个数一半

> attention:  
- 对称矩阵特性
  - 本题矩阵为对称矩阵
  - 非对称矩阵不可能是无向图

07.B
- 邻接表与矩阵唯一性比较
  - 邻接矩阵表示唯一
    - 边信息在矩阵中位置确定
  - 邻接表不唯一
    - 取决于边读入顺序
    - 取决于边表插入算法

08.A
- 邻接矩阵幂运算含义
  - 设图G邻接矩阵为A
  - $A^n$元素${a^n}_{i,j}$表示
    - 顶点i到j长度为n的路径数
  - $a_{i,j}^2=3$表示存在3条长度为2的路径

09.A
- 存储空间复杂度分析
  - 邻接表
    - 顶点数n决定顶点表大小
    - 边数e决定边表结点个数
    - 无向图每边存储两次
    - 总空间为$O(n+2e)$
  - 邻接矩阵
    - 只与顶点数有关
    - 空间为$O(n^2)$

10.D
- 有向图特征判断
  - 无向图邻接表边表结点为偶数
  - 边表结点为奇数说明
    - 必为有向图
    - 有奇数条边

11.C
- 边表特性分析
  - 不包括顶点表
  - 顶点u的边表存放
    - 以u为起点的边的另一顶点v
  - v在边表出现次数等于其入度

12.B
- 边表结点数量分析
  - 最多有$n(n-1)/2$条边
  - 每条边存储两次
  - 边表结点最多为$n(n-1)$个

13.A
- 邻接表建立时间复杂度
  - 需遍历所有顶点和边
  - 每个顶点有一个顶点表结点
  - 每条边创建一个边表结点
  - 需$n+2e$次操作
  - 时间复杂度$O(n+e)$

14.C
- 删除顶点操作分析
  - 相关边包括出边和入边
  - 出边删除
    - 遍历v的顶点表结点和边表
    - 最多$n-1$条
    - 时间复杂度$O(n)$
  - 入边删除
    - 扫描整个边表
    - 时间复杂度$O(n+e)$
  - 总时间复杂度$O(n+e)$

15.D
- 图操作特性分析
  - 无向图邻接表度数
    - 第i个链表结点数，A错
  - 邻接表和矩阵各有优势
    - B和C不准确
  - 有向图结点度数计算
    - 出度需遍历顶点表对应边表
    - 入度需遍历剩余边表

16.A
- 邻接多重表特点
  - 无向图存储结构

17.B
- 十字链表特点
  - 有向图存储结构

18.C
- 有向图度数计算
  - 非对称矩阵表示有向图
  - 度为入度与出度之和
  - 各顶点度计算
    - 行非零元素和(出度)
    - 列非零元素和(入度)

# 二、综合应用题  

01.【解答】
- 带权有向图G如图所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/df6e89b4cefa3f7daaf65b0fe56116fb237590d91c96f58515fb459c056f2809.jpg)

02.【解答】
- 邻接矩阵存储分析
  - 邻接表中每条边存储2次
  - 默认为无向图
  - 可视为具有对边的有向图
  - 对应图G如下

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e95de7c80d4299d3ee308bcfe57663e3fa6e77953b19f1d83e51f5bc4d4d4be.jpg)

03.【解答】
- 图的基本性质分析
  - 边数计算
    - 邻接矩阵表示无向图:矩阵中1的个数除以2
    - 邻接表表示无向图:边结点个数除以2
    - 邻接矩阵表示有向图:矩阵中1的个数
    - 邻接表表示有向图:边结点个数
  - 顶点连接判断
    - 邻接矩阵:arcs[i][j]或arcs[j][i]为1表示相连
    - 邻接表:从顶点i找到j或从j找到i的边表结点表示相连
  - 度数计算
    - 无向图
      - 邻接矩阵:第i行1的个数
      - 邻接表:顶点i的边表结点个数
    - 有向图
      - 邻接矩阵
        - 出度:第i行1的个数
        - 入度:第i列1的个数
      - 邻接表
        - 出度:顶点i的边表结点个数
        - 入度:编号为i的边表结点数

04.【解答】
- 顶点编号调整方法
  - 按出度排序
    - n个顶点最大出度为n-1
    - 最小出度为0
    - 出度大的编号靠前
  - 调整规则
    - 存在弧<i,j>时
    - i编号需在j之前
    - 确保1出现在上三角
  - 拓扑排序是更简便方法

05.【解答】
- 邻接表转邻接矩阵算法
  - 算法思想
    - 顶点存储在数组σ[n]
    - 初始化邻接矩阵
    - 遍历邻接表修改矩阵
    - 适用于无向图和有向图
  - 代码实现

void Convert(ALGraph &G, int arcs[M][N]) {
    for(i=0; i<n; i++) {
        p = G->v[i].firstarc;
        while(p!=NULL) {
            arcs[i][p->adjvex] = 1;
            p = p->nextarc;
        }
    }
}

06.【解答】
- 邻接矩阵性质分析
  - 图G的邻接矩阵A
  - A^2计算结果
    - 元素含义:长度为2的路径数
  - B^m性质
    - i行j列非零元素表示长度为m的路径数

07.【解答】
- EL路径判断算法
  - 算法思想
    - 计算各顶点度数
    - 统计奇数度顶点
    - 判断条件:0或2个奇数度
  - 代码实现

int IsExistEL(MGraph G) {
    int degree, i, j, count = 0;
    for(i=0; i<G.numVertices; i++) {
        degree = 0;
        for(j=0; j<G.numVertices; j++)
            degree += G.Edge[i][j];
        if(degree%2 != 0)
            count++;
    }
    if(count == 0 || count == 2)
        return 1;
    else 
        return 0;
}

  - 复杂度分析
    - 时间复杂度 $O(n^2)$
    - 空间复杂度 $O(1)$

08.【解答】
- K顶点输出算法
  - 算法思想
    - 邻接矩阵计算出入度
    - 统计满足条件顶点
  - 代码实现

int printVertices(MGraph G) {
    int indegree, outdegree, k, m, count = 0;
    for(k=0; k<G.numVertices; k++) {
        indegree = outdegree = 0;
        for(m=0; m<G.numVertices; m++) {
            outdegree += G.Edge[k][m];
        }
        for(m=0; m<G.numVertices; m++) {
            indegree += G.Edge[m][k];
        }
        if(outdegree > indegree) {
            printf("%c", G.VerticesList[k]);
            count++;
        }
    }
# 6.3.5 答案与解析  

# 一、单项选择题  

01.A
- 广度优先搜索特点
  - 以起始结点为中心，层层向外扩展遍历
  - 不适合求带权图的最短路径
  - 相当于树的层序遍历
  - 需要用到队列(深度优先用栈)

02.D
- 图的深度优先遍历特点
  - 遍历序列不唯一
  - 需要设置访问标志位避免重复访问
  - 可用于判断有向图是否有环
  - 非强连通图也可能一次遍历访问所有顶点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f18c9a9794241285abda35d9f051dd1b73b91191764e70668e41b5b17d47e38d.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33905d8575f91778c1644bbae05c138467d530c5a20818bc8bdc73d29d996ee7.jpg)  
图2  

03.C
- DFS/BFS用于计算连通分量
  - 一次遍历访问一个连通分量的所有顶点
  - 连通分量数等于DFS调用次数

04.C、A、C、A
- 深度优先遍历分析
  - 每个顶点和边均查找一次
  - 需要递归工作栈
  - 时间复杂度 $O(n+e)$
  - 空间复杂度 $O(n)$
- 广度优先遍历分析
  - 每个顶点和边均查找一次
  - 需要辅助队列
  - 时间复杂度 $O(n+e)$
  - 空间复杂度 $O(n)$

05.A
- 广度优先遍历过程
  - 访问顶点后做标记并入队
  - 队首顶点出队
  - 访问未访问的邻接顶点
  - 每个顶点最多入队一次

06.A、A
- 邻接矩阵表示的复杂度
  - 查找一个顶点所有出边 $O(n)$
  - n个顶点总时间复杂度 $O(n^2)$

07.D
- 遍历序列判断
  - 根据边的邻接关系判断
  - 访问未访问的邻接结点

08.D
- 深度优先遍历特点
  - 按栈退回顺序遍历
  - 遍历顺序要符合栈操作规则

09.B、D
- 搜索算法比较
  - 深度优先类似树的先根遍历
  - 广度优先类似树的层序遍历
  - 分别采用栈和队列辅助实现

10.A、B
- 遍历序列路径
  - DFS: $1 \rightarrow 2 \rightarrow 5 \rightarrow 4 \rightarrow 3 \rightarrow 6$
  - BFS: $1 \rightarrow 2 \rightarrow 4 \rightarrow 2,5 \rightarrow 3,6$
11.D  

- 解题步骤：

  - 画出 $V$ 和 $E$ 对应的图 $G$。
  - 根据搜索算法求解。

- 注意事项：

  - 为什么本题序列是不唯一的，而上题序列却是唯一的？
    - 上题给出了具体的存储结构，必须按照算法过程执行。
    - 每个顶点的邻接点顺序已固定。
    - 本题中每个顶点的邻接点顺序是非固定的。


12. C  

- 利用深度优先遍历判断回路：

  - 无向图：
    - 深度优先遍历遇到回边，则必定存在环。
  
  - 有向图：
    - 回边可能指向深度优先森林中另一棵生成树上的顶点。
    - 从顶点v出发进行深度优先遍历，若DFS(v)结束前出现从顶点u到顶点v的回边，且u是生成树上的子孙，则有向图必定存在包含顶点v和顶点u的环。


13.B  

- 连通分量的定义：
  - 是无向图的极大连通子图。
  - 包含连通分量中所有顶点及这些顶点之间的所有边。

- 连通分量的特性：
  - 连通分量中可能存在回路。
  - 由于包含所有边，所以连通分量不是生成树。


> attention:  

- 极大连通子图：
  - 是无向图的连通分量。
  - 包含连通分量中所有顶点及这些顶点之间的所有边。
  - 是在满足连通的前提下，针对边的数目而言的极大概念。

- 极小连通子图（生成树）：
  - 是连通无向图的生成树。
  - 包含连通图的全部顶点。
  - 使其连通的边数最少。
  - 是在满足连通的前提下，针对边的数目而言的极小概念。


14.A  

- 无向图的广度优先搜索生成树特性：
  - 起点到其他顶点的路径是图中对应的最短路径。
  - 所有生成树中树高最小。

- 深度优先搜索与广度优先搜索生成树的比较：
  - 深度优先总是尽可能“深”地搜索图。
  - 深度优先生成树的路径尽可能长。
  - 深度优先生成树的树高总是大于或等于广度优先生成树的树高。


15.C  

- 广度优先遍历的实现：
  - 需要借助队列实现。

- 广度优先遍历的时间复杂度分析：
  - 顶点表遍历：
    - 每个顶点均需入队一次。
    - 时间复杂度为 $O(n)$。
  - 出边表遍历：
    - 在搜索所有顶点的邻接点的过程中，每条边至少访问一次。
    - 时间复杂度为 $O(e)$。
  - 算法总的时间复杂度：
    - 为 $O(n+e)$。


16.D  

- 解决方案：
  - 掌握DFS和BFS的遍历过程。
  - 逐个代入，手工模拟。

- 结果分析：
  - 选项D是深度优先遍历。
  - 选项D不是广度优先遍历。

17.D  

- 深度优先遍历的可能序列：
  - 图的深度优先遍历共有5种可能序列。
  - $\nu_{0}, \nu_{1}, \nu_{3}, \nu_{2}$
  - $\nu_{0}, \nu_{2}, \nu_{3}, \nu_{1}$
  - $\nu_{0}, \nu_{2}, \nu_{1}, \nu_{3}$
  - $\nu_{0}, \nu_{3}, \nu_{2}, \nu_{1}$
  - $\nu_{0}, \nu_{3}, \nu_{1}, \nu_{2}$


![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b9810bad37c4e0283dff2dff1d7d2f28cfc25a750e9d9a33849ff61e54acba7d.jpg)  

18.D  

- 深度优先遍历策略：
  - 访问起始顶点 $V_1$。
  - 访问与 $V_1$ 邻接且未被访问的任意一个顶点（$V_2, V_3, V_5$）。
  - 访问 $V_5$，然后访问与 $V_5$ 邻接且未被访问的 $V_4$。
  - 从 $V_4$ 出发，访问与 $V_4$ 邻接且未被访问的 $V_3$。
  - 从 $V_3$ 出发，访问与 $V_3$ 邻接且未被访问的 $V_2$。
  - 结束遍历。

- B和C的分析方法：
  - 与A相同。

- D的错误分析：
  - 访问 $V_1$。
  - 访问与 $V_1$ 邻接且未被访问的任意一个顶点（$V_2, V_3, V_5$）。
  - 应该访问 $V_5$，但D访问了 $V_3$，违反深度优先遍历规则。

# 二、综合应用题  

01.【解答】  

- 图G的表示：
  - 邻接表可以画出图(a)。
  - ![图G](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0dacc0ce4ff245995248b13b690c879ad955fc670205a8e52e25d706a090489f.jpg)。

- 深度优先生成树：
  - ![深度优先生成树](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/65f684d2ae2fb3fba8211e9c60166480082d9063630a5647c81376dbdf577b35.jpg)。

- 广度优先生成树：
  - ![广度优先生成树](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2f2910ae8ec451afa1d4dc85b66487877920c98d80f03f76acf52c48c20e424b.jpg)。

- 深度优先遍历策略：
  - 总是尽可能“深”地搜索图。
  - 深度优先搜索的路径次序：$(1,2), (2,3), (3,4), (4,5)$。
  - 生成树如图(b)所示。
  - 存储结构固定时，生成树的树形也固定。

- 广度优先遍历策略：
  - 总是尽可能“广”地搜索图。
  - 一层一层地向外扩展。
  - 广度优先搜索的路径次序：$(1,2), (1,3), (1,4), (2,5)$。
  - 生成树如图(c)所示。


02.【解答】  

- 图的二分染色情况：
  - 右图不能被二分，左图能被二分。
  - 染色情况如下图所示：
    - ![染色情况](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40f9e1b96b4abbe71caac80ffad2c2c25d33eeea6ebdb2e2a7ae6ddcbe75020c.jpg)。

- 二分图遍历与染色算法：
  - 从任意一个结点开始，将其染成红色。
  - 对整个图进行遍历：
    - 若当前遍历的结点 $a$ 有一条边指向 $b$，则：
      - $b$ 未被染色：染成与 $a$ 不同的颜色，继续遍历与 $b$ 相连的结点。
      - $a$ 与 $b$ 的颜色相同：说明图不能被二分，直接返回。
      - $a$ 与 $b$ 的颜色不同：跳过 $b$ 点。

- 算法的时间复杂度：
  - 无论使用深度优先还是广度优先，时间复杂度均为 $O(n+m)$。
  - 其中 $n$ 是顶点数，$m$ 是边数。

- 算法的空间复杂度：
  - 需要一个数组来存储各结点的颜色及是否已访问。
  - 空间复杂度为 $O(n)$。


03.【解答】  

- 判断无向图是否为树的条件：
  - 必须是无回路的连通图或有 $n-1$ 条边的连通图。
  - 这里采用有 $n-1$ 条边的连通图作为判断条件。

- 连通性的判定方法：
  - 用能否一次遍历全部顶点来实现。

- 判断树的算法步骤：
  - 采用深度优先搜索算法遍历图。
  - 统计可能访问到的顶点个数和边的条数。
  - 若一次遍历能访问到 $n$ 个顶点和 $n-1$ 条边，则可断定此图是一棵树。

- 算法实现（代码格式）：

```cpp
bool isTree(Graph& G) {
    for (int i = 1; i <= G.vexnum; i++) visited[i] = FALSE; // 访问标记初始化
    int Vnum = 0, Enum = 0; // 记录顶点数和边数
    DFS(G, 1, Vnum, Enum, visited);
    if (Vnum == G.vexnum && Enum == G.vexnum - 1) return true; // 符合树的条件
    else return false; // 不符合树的条件
}

void DFS(Graph& G, int v, int& Vnum, int& Enum, int visited[]) {
    // 深度优先遍历图G，统计访问过的顶点数和边数，通过Vnum和Enum返回
    visited[v] = TRUE; Vnum++; // 作访问标记，顶点计数
    int w = FirstNeighbor(G, v); // 取v的第一个邻接顶点
    while (w != -1) { // 当邻接顶点存在
        Enum++; // 边存在，边计数
        if (!visited[w]) // 当该邻接顶点未访问过
            DFS(G, w, Vnum, Enum, visited);
        w = NextNeighbor(G, v, w); // 继续遍历下一个邻接顶点
    }
}
```
04.【解答】  

- 两个遍历算法的遍历路径判定：
  - 从顶点 $v_{i}$ 出发，依次遍历图中每个顶点。
  - 搜索到顶点 $v_{j}$ 时，说明存在从 $v_{i}$ 到 $v_{j}$ 的路径。

- 深度优先遍历算法实现：

```cpp
int visited[MAXSIZE] = {0}; // 访问标记数组
void DFS(ALGraph G, int i, int j, bool &canReach) {
    // 深度优先判断有向图G中顶点 v_i 到顶点 v_j 是否有路径，用canReach来标识
    if (i == j) { 
        canReach = true; 
        return;
    }
    visited[i] = 1; // 置访问标记
    for (int p = FirstNeighbor(G, i); p >= 0; p = NextNeighbor(G, i, p)) {
        if (!visited[p] && !canReach) // 递归检测邻接点
            DFS(G, p, j, canReach);
    }
}
- 广度优先遍历算法实现：

```cpp
int visited[MAXSIZE] = {0}; // 访问标记数组
int BFS(ALGraph G, int i, int j) {
    // 广度优先判断有向图G中顶点 v_i 到顶点 v_j 是否有路径，是则返回1，否则返回0
    InitQueue(Q);
    EnQueue(Q, i); // 顶点i入队
    while (!isEmpty(Q)) { // 非空循环
        DeQueue(Q, i); // 队头顶点出队
        visited[i] = 1; // 置访问标记
        if (i == j) return 1;
        for (int p = FirstNeighbor(G, i); p; p = NextNeighbor(G, i, p)) { // 检查所有邻接点
            if (p == j) return 1; // 若 p == j ，则查找成功
            if (!visited[p]) { // 否则，顶点p入队
                EnQueue(Q, p);
                visited[p] = 1;
            }
        }
    }
    return 0;
}
```

05.【解答】  

- 深度优先遍历算法用于查找路径：
  - 从结点u出发，递归深度优先遍历图中的结点。
  - 若访问到结点v，则输出该搜索路径上的结点。
  - 设置path数组存放路径上的结点（初始为空）。
  - d表示路径长度（初始为-1）。

- 查找从顶点u到v的简单路径过程：
  1. FindPath(G,u,v,path,d):
     - d++；path[d] = u。
     - 若找到u的未访问过的相邻结点ul，则继续递归调用FindPath(G,ul,v,path,d)。
     - 否则，置visited[u] = 0并返回。
  
  2. 递归调用FindPath(G,ul,v,path,d)：
     - d++；path[d] = ul。
     - 若找到ul的未访问过的相邻结点u2，则继续递归调用FindPath(G,u2,v,path,d)。
     - 否则，置visited[ul] = 0。

  3. 重复步骤2，直到u = v，输出path。

- 算法实现：

```cpp
void FindPath(AGraph *G, int u, int v, int path[], int d) {
    int w;
    ArcNode *p;
    d++; // 路径长度增1
    path[d] = u; // 将当前顶点添加到路径中
    visited[u] = 1; // 置已访问标记
    if (u == v) {
        // 找到一条路径则输出
        print(path[]); // 输出路径上的结点
    }
    p = G->adjlist[u].firstarc; // p指向u的第一个相邻点
    while (p != NULL) {
        w = p->adjvex; // 若顶点w未访问，递归访问它
        if (visited[w] == 0)
            FindPath(G, w, v, path, d);
        p = p->nextarc; // p指向u的下一个相邻点
    }
    visited[u] = 0; // 恢复环境，使该顶点可重新使用
}
```

# 6.4.7 答案与解析  

# 一、单项选择题  

- 最小生成树的唯一性
  01. A
  - 无向连通图存在权值相同的多条边时，最小生成树可能不唯一
  - 无向连通图必定存在最小生成树

  02. C  
  - 不同算法生成的最小生成树可能不同
  - 当最小生成树唯一时，不同算法生成结果相同

  03. A
  - 贪心策略选取最小权值边
  - 边权值不同时最小生成树唯一
  - 其他情况分析:
    - 图本身为树时最小生成树唯一
    - n-1条边可能构成回路
    - n个顶点n-1条边的子图可能不连通

  04. A
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f966785a56f7219b92bd3159fa9a6fdbd71ca4e605ed551f492e5391121c04e6.jpg)
  - 图的边数必须大于n-1
  - 权值相等不一定是最小权值边
  - 最小生成树代价相同
  - 边权值互不相等时最小生成树唯一

- 最短路径算法
  05. A
  - U={1,2,3}与V-U={4,5,...}之间的边为候选边

  06. C
  - 边(1,3)会构成回路

  07. A
  - Dijkstra算法特点:
    - 适合有回路的带权图
    - 可求任意两顶点最短路径
    - 不适合负权值
  - Floyd算法中path不一定是Δk-1的子集

  08. C
  - Dijkstra算法:
    - 不允许负权边
    - 求每对顶点最短路径时间复杂度O(n³)
  - Floyd算法:
    - 允许负边但不允许负回路

  09. B
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a12b8ef9ce0cdc2861a92c1c431f04efa89d5bbf617e04da0ef1c4278817060.jpg)
  - 最短路径为v₁→v₃→v₄→v₆→v₇
  - 路径长度:A=18,B=13,C=15,D=24

  10. D
  - Dijkstra算法只修改源点O到V-S中顶点的最短路径

- 有向图环的判断
  11. A
  - 深度优先遍历可检测环
  - 拓扑排序可判断环
  - 最短路径允许有环
  - 关键路径判断环存在争议

  12. D
  - 拓扑序列中前驱顶点必在后继顶点之前

  13. D
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ff4dc41e511401c95eac50d846e8847e107fe68c249b561958cb51d3e3b7d84.jpg)
  - 有环时无法完成拓扑排序
  - 无祖先子孙关系的顶点顺序任意
  - 拓扑序列唯一性分析
  - 入度/出度为0的顶点可作为起点/终点

  14. A
  - 强连通图存在环，不能拓扑排序
  - 入度为0的顶点间不一定有弧

  15. D
  - 不能拓扑排序说明存在强连通分量

  16. C
  - 可能的拓扑序列:
    - ABCFDEG
    - ABCDFEG
    - ABCDEFG
    - ABDCFEG
    - ABDCEFG

  17. A
  - 拓扑排序过程:
    - 找入度为0的顶点
    - 删除该顶点及其出边
    - 将顶点加入序列
    - 重复直至完成
18.B
- 无向图邻接矩阵存储特点
  - 每条边存储两次
  - $A[i][j]=A[j][i]$

19.C
- 有向图邻接矩阵与拓扑排序关系
  - 充分必要条件
    - 顶点适当编号使邻接矩阵为三角矩阵
    - 主对角元素全为零
    - 图可进行拓扑排序
  - 注意事项
    - 题目强调"有序"拓扑序列
    - 三角矩阵意味着无环
    - 无环必存在拓扑序列

20.A
- DFS实现拓扑排序
  - 基本原理
    - 顶点入栈后先遍历后继顶点
    - 后继遍历完成后出栈
    - 输出顺序为逆拓扑序列
  - 实例分析
    - 退出DFS栈顺序:efgdcahb
    - 对应拓扑序列:bhacdgfe

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/95e2e823926f924b2589d0b7dfdd674f5f69af8575edf6919732ef5b2aebcfa4.jpg)

21.C
- 图的性质分析
  - 邻接矩阵特点
    - 有向图出度计算
    - 对称性条件
  - 最小生成树性质
    - 边的选择不仅考虑权值
    - 需保证图连通
  - 拓扑序列特点
    - 唯一性不能确定图的唯一性

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b6edd2859df37c19f7a2db2bcc1addfd745b18f3c239b4dbcb5403f6e13b2b2.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba51729bd44321dd54583c4635c03ee9d8f3f509ea27ba9fa4af6069b7a12074.jpg)

22.C
- 最长路径分析
  - 路径:$V_{0}{\rightarrow}V_{1}{\rightarrow}V_{4}{\rightarrow}V_{6}{\rightarrow}V_{8}$
  - 长度:$6+1+9+2=18$

23.C
- 关键路径分析
  - 关键路径长度:21
  - 存在两条关键路径

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0339099fc2887d3db0ba13f94595ebdf8256da86fabd6b3f2a3fbddd434a4046.jpg)

24.C
- 事件时间计算
  - 最迟发生时间计算方法
  - 活动持续时间变化影响
    - 需重新计算关键活动
    - 可能导致关键路径改变

25.C
- 关键路径变化分析
  - 公共活动变化影响
  - 关键路径长度变化条件
  - 活动性质转换条件

26.A
- 邻接矩阵特征分析
  - 入边为零的意义
  - 关键路径存在性
  - 连通分量判断

27.B
- 拓扑排序过程分析
  - 可能的序列
    - abced
    - abecd
    - aebcd

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2fd17cb74237decb87b55ddb35fbe175806e2fdd5c49585e7e01c1047e081f09.jpg)

28.A
- 最小生成树性质
  - 代价唯一性
  - 权值最小边选择
  - 算法起点影响
  - Prim与Kruskal算法比较

29.C
- 最短路径求解过程
  - 目标顶点选择顺序
  - 路径长度比较

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e1d083369e54075c281c4d4de6652df149becbf1ef0a3e632872be29db82818.jpg)

30.C
- 邻接矩阵特征与拓扑序列
  - 对角线以下为零特征
    - 表示无环图
    - 必存在拓扑序列
  - 拓扑序列唯一性分析
  - 结论总结
    - 充分性与必要性
    - 顶点编号调整

31.C
- AOE网关键路径分析
  - 全部关键路径
    - bdcg
    - bdeh
    - bfh
  - 工期缩短条件
    - 需涵盖所有关键路径
    - 活动时间同时减少

32.D
- 拓扑排序过程
  - 入度为零顶点选择
  - 可能的拓扑序列
    - $3,1,4,2,6,5$
    - $3,1,4,6,2,5$

33.C
- Kruskal算法分析
  - 从V4开始的边选择
    - 权值最小边(V1,V4)
    - V1和V4可达后的边选择
  - 结论
    - 选项B错误
    - 选项A、D排除

34.C
- 图的基本概念与存储结构
  - 路径与回路
    - 回路定义：首尾顶点相同
    - 简单路径：顶点不重复
    - I错误：回路非简单路径
  - 存储结构选择
    - 稀疏图适合邻接表O(n+e)
    - 邻接矩阵空间O(n²)浪费
    - III错误
  - 拓扑序列特性
    - 存在回路无拓扑序列
    - III正确：剩余顶点有前驱表示存在回路

35.B
- Dijkstra算法最短路径求解
  - 从顶点1到其他顶点的最短路径长度计算
  - 最终dist数组值
  - 顶点选择顺序：1,5,2,3,6,4

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b1ee570975fd06919866d013d958d6995eba2e2c6d77d5c3c78ac13ff8afc28.jpg)

36.B
- 拓扑排序时间复杂度分析
  - 邻接表存储
    - 顶点操作：O(n)
    - 边处理：O(n+e)
  - 邻接矩阵存储
    - 边处理时间：O(n²)
  - 两种算法实现
    - 基于BFS的算法
    - 基于DFS的算法

37.D
- 拓扑序列分析
  - 入度为0的结点选择
  - 序列前两位特点
    - 只能是1,5或5,1
    - 其他结点入度限制

38.C
- AOE网活动时间计算
  - 活动d的时间计算
    - 最早开始时间：12
    - 最迟开始时间：14
  - 计算过程
    - 关键路径长度：27
    - 事件时间计算

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56bcc4f1f6756aaa5f9bd67269099b3a7f259e69c3a75559927b7d70f954a8c3.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f199d1399a50e953a7cf84fb0ada7c0eaf51aac09de82269325351cdd811b855.jpg)

39.A
- 表达式转换
  - 有向二叉树转换
  - 去重转换为有向无环图

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/212b218462bd3c21cb929472cb9866503e42aa62e53ef58d89185e96da6a061f.jpg)

40.A
- Kruskal算法最小生成树构造
  - 算法步骤
    - 初始森林构造
    - 边的选取过程
  - 生成过程展示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d92c0bb4e1010180cfab5498139f19295844da3cfdbe11ea5bae0493f511335d.jpg)

41.B
- DFS输出序列分析
  - 图G特性
    - 有向无环
    - 存在拓扑序列
  - DFS性质
  - 输出顺序特点
  - 结论：逆拓扑有序序列

42.B
- 关键路径特性
  - 权值和最大性质
  - 关键活动时间影响
  - 工期缩短条件

43.A
- 拓扑序列唯一性
  - 序列求解过程
  - 唯一性判断

44.C
- Dijkstra算法执行过程
  - 初始化步骤
  - 顶点选择与距离更新
  - dist数组变化

45.B
- AOE网时间余量计算
  - 计算公式
  - 各活动时间余量

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cf2196f56af2eb2bcc141ea6e9394b99733c7f9d6e445cc9dad0be542fd517b0.jpg)

46.B
- 最小生成树与最短路径
  - 算法特性比较
  - 示例说明

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/45e267869ed4acc552bd57cfb251c668895d9d327d24bba63cf807414b310f12.jpg)

# 二、综合应用题  

01.【解答】
- 破圈法正确性证明
  - 生成树构造
    - 无回路性质
    - 最小生成树性质证明
      - 反证法思路
      - 权值最小性证明
  - 过程示例图

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28e65480b50c412183861db54ef5344d3a80d792ce5d605b2212227b797687b2.jpg)

02.【解答】
- 图的基本分析
  - 邻接矩阵表示
  - 深度优先遍历序列: $1,2,3,5,7,4,6$
  - 强连通分量分析
    - 分量判定原则
    - 逐步分解过程
    - 最终结果:7个分量
  - 拓扑序列
    - 序列1: $1,2,4,6,3,5,7$
    - 序列2: $1,4,2,6,3,5,7$
  - 最小生成树构造
    - Prim算法过程
    - Kruskal算法过程示意图

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a88b5f3b18dfebf298354e38e440539a4b0bf43f1d0de9271086610afad2432.jpg)

03.【解答】
- Dijkstra算法最短路径计算过程表

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cc7c36b9797f2479b1cb2e54568d40f440bd2bedaca99c55c0b29d9983a46ed.jpg)

04.【解答】
- 图的邻接表表示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6d98cfa9ca142c73dc51d838d72012d3fb06dd226c39d7db95fbc1573275f36.jpg)

- 关键路径算法步骤
  - AOE网存储结构建立
  - 源点最早发生时间计算
  - 汇点最晚发生时间计算
  - 关键活动判定
- 关键路径分析结果
  - 最短完成时间:16
  - 关键路径: $(V_1,V_3,V_5,V_7,V_9)$
  - 可加速活动: $a_2,a_6,a_9,a_{12}$

05.【解答】
- AOE网构造与分析
  - 网络图示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/53237128e29e41fb7ef6db32656b88abe417f5a32bf28f732f659e4dbb6cf861.jpg)

  - 时间计算公式
    - 最早发生时间计算
    - 最迟发生时间计算
    - 活动时间计算
    - 时间余量计算
  - 计算结果表格
    - 事件时间表
    - 活动时间表
  - 关键路径确定: B、E、G
  - 最短完成时间: 8

06.【解答】
- Dijkstra与Prim算法比较
  - 算法特点对比
  - 反例说明
    - 示例图G
    - 两种算法结果比较
    - 权值差异分析

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d05a1566d1c8da4ef8df224254808eba76adf3d3deb612f894419835c7831327.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/64f33a9fef4a712f10af18ec2c7de356f42cb82d00698f14af96048d200fa482.jpg)

07.【解答】
- DFS实现拓扑排序
  - 算法实现代码

bool visited[MAX_VERTEX_NUM];
void DFS_Traverse(Graph G) {
    for(v = 0; v < G.vexnum; ++v)
        visited[v] = FALSE;
    time = 0;
    for(v = 0; v < G.vexnum; ++v)
        if(!visited[v]) 
            DFS(G,v);
}

void DFS(Graph G, int v) {
    visited[v] = TRUE;
    visit(v);
    for(w = FirstNeighbor(G,v); w >= 0; w = NextNeighbor(G,v,w))
        if(!visited[w])
            DFS(G,w);
    time = time + 1;
    finishTime[v] = time;
}
08.【解答】
- 最短路径分析
  - 该方法不一定能（或不能）求得最短路径
  - 反例说明
    - 从A到C的路径比较
      - 按题中原则: A→B→C
      - 实际最短: A→D→C

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5b9bdc22e89cd4a2703d5bc77424463c6ccdebc588048a0ec21ea6108cdbda72.jpg)

09.【解答】
- 上三角矩阵分析
  - 主对角线上方元素分布
    - 第1-5行元素个数: 5,4,3,2,1
    - 元素所属行分布图示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc242faacbd5ff2a4bbb0b3163909ea560bb24dc7d59e94a53c316898cec1c7c.jpg)

  - 平移思想应用
    - 元素移动规则
    - 邻接矩阵A表示

$
A\,{=}\,{\left[\begin{array}{l l l l l l}{0}&{4}&{6}&{\infty}&{\infty}&{\infty}\\ {\infty}&{0}&{5}&{\infty}&{\infty}&{\infty}\\ {\infty}&{\infty}&{0}&{4}&{3}&{\infty}\\ {\infty}&{\infty}&{\infty}&{0}&{\infty}&{3}\\ {\infty}&{\infty}&{\infty}&{\infty}&{0}&{3}\\ {\infty}&{\infty}&{\infty}&{\infty}&{\infty}&{0}\end{array}\right]}
$

- 有向带权图分析
  - 图G示意

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f246a1a9ffa3bac2b4e025337a668ae5b8bb0813a2554b1107fa9fe436c02729.jpg)

  - 事件时间计算
    - 最早发生时间ve()和vl()数组

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71c45a3721ff64c0c43703c8a63f9a52859a3f6e0ed933bad6dc2f29ddff5454.jpg)

    - 活动时间e()和l()计算

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4706f54e80dcf9cfb473b8312eaac94ee44d65b57604d08ac7a8e1aef5852690.jpg)

  - 关键路径确定
    - 满足l()-e()=0的路径
    - 关键路径: a0-1,a1-2,a2-3,a3-5
    - 路径长度: 4+5+4+3=16

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d2937832e7c5f605c93a412e766a82ebc26ac38bfd25625b580d09da03b76fa.jpg)

  - 求解建议
    - 直接穷举各条路径

10.【解答】
- 网络拓扑分析
  - 问题抽象
    - 简单网络拓扑图
    - 无向图表示
  - 存储结构选择
    - 邻接表法实现
    - 链式存储结构

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7dbfc41c69dca1bf179b1e180bb9e86403e3bda1ff588de297ff127505faa9b7.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bde19f77b71d686ba2f71be0c25d9ec98bd668550d671d4f6d77b054380aac90.jpg)

  - 数据类型定义
    
    typedef struct{ 
        unsigned int ID, IP; 
    }LinkNode;  //Link的结构
    
    typedef struct{ 
        unsigned int Prefix, Mask; 
    }NetNode;  //Net的结构
    
    typedef struct Node{ 
        int Flag;  //Flag=1为Link;Flag=2为Net
        union{
            LinkNode Lnode; 
            NetNode Nnode;
        }LinkORNet;
        unsigned int Metric;
        struct Node *next;
    }ArcNode;  //弧结点
    
    typedef struct hNode{
        unsigned int RouterID;
        ArcNode *link;
        struct hNode *next;
    }HNODE;  //表头结点
    

  - 存储结构示意图

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0011931a93d019337cf4a954057bb753baf0694837d72912f8f90dbba5458bca.jpg)

  - 计算结果表

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d329691b5cbd2906f23e4dfc9f6de81c302a8208ade214142e41f4c8799511e.jpg)

11.【解答】
- Prim算法分析
  - 算法特点
    - 贪心策略
    - 从任意顶点开始
    - 直到覆盖所有顶点
  - 算法步骤
    - S中顶点为A,候选边(A,D),(A,B),(A,E),选择(A,D)
    - S中顶点为A,D,候选边(A,B),(A,E),(D,E),(C,D),选择(D,E)
    - S中顶点为A,D,E,候选边(A,B),(C,D),(C,E),选择(C,E)
    - S中顶点为A,D,E,C,候选边(A,B),(B,C),选择(B,C)
  - 边的选择顺序
    - (A,D),(D,E),(C,E),(B,C)

- MST唯一性分析
  - 图G的MST唯一性证明
    - 包含权值最小的4条边
    - (A,E)替换分析
  - MST唯一性充分条件
    - 环中边权值均不相同

12.【解答】
- 最小生成树方案
  - 问题抽象
    - 无向带权图
    - 最小生成树求解
  - 两种构造方案

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f49f52813183cca54fe6fb810601191af11c959eb18194de436e554832930a1a.jpg)

  - 总费用: 16

- 实现方法
  - 存储结构
    - 邻接矩阵或邻接表
  - 算法选择
    - Prim或Kruskal算法

- TTL分析
  - TTL=5限制
    - 方案1: TL和BJ距离过远,H2不可达
    - 方案2: TL和BJ邻近,H2可达

