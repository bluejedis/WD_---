# 1.1.4 答案与解析  

# 一、单项选择题  

01.D  

抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用（数据对象，数据关系，基本操作集）这样的三元组来表示，从而可构成一个完整的数据结构定义。  

02.A  

树和图是典型的非线性数据结构，其他选项都属于线性数据结构。  

03.C  

顺序表、哈希表和单链表是三种不同的数据结构，既描述逻辑结构，又描述存储结构和数据运算。而有序表是指关键字有序的线性表，仅描述元素之间的逻辑关系，它既可以链式存储，又可以顺序存储，所以属于逻辑结构。  

04.A  

数据的逻辑结构是从面向实际问题的角度出发的，只采用抽象表达方式，独立于存储结构，数据的存储方式有多种不同的选择；而数据的存储结构是逻辑结构在计算机上的映射，它不能独立于逻辑结构而存在。数据结构包括三个要素，缺一不可。  

05.C  

在存储数据时，不仅要存储数据元素的值，而且要存储数据元素之间的关系。  

# 二、综合应用题  

01.【解答】  

应该注意到，数据的运算也是数据结构的一个重要方面，  

对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同。
比如二叉树和二叉排序树，二叉排序树可以采用二叉树的逻辑表示和存储方式，前者通常用于表示层次关系，而后者通常用于排序和查找。
虽然它们的运算都有建立树、插入结点、删除结点和查找结点等功能，但对于二叉树和二叉排序树，这些运算的定义是不同的，以查找结点为例，二叉树的平均时间复杂度为 $O(n)$ ，而二叉排序树的平均时间复杂度为 $O(\log_{2}n)$  

02.【解答】  

线性表既可以用顺序存储方式实现，又可以用链式存储方式实现。在顺序存储方式下，在线性表中插入和删除元素，平均要移动近一半的元素，时间复杂度为 $O(n)$ ；而在链式存储方式下，插入和删除的时间复杂度都是 $O(1)$  



# 1.2.4 答案与解析  

# 一、单项选择题  

01.B  

本题是中山大学往年真题，题目没有问题，考查的是算法的定义。程序不一定满足有穷性，如死循环、操作系统等，而算法必须有穷。算法代表对问题求解步骤的描述，而程序则是算法在计算机上的特定实现。不少读者认为C也对，它只是算法的必要条件，不能成为算法的定义。  

02.C  

时间复杂度为 $O(n^{2})$ ，说明算法的时间复杂度 $T(n)$ 满足 $\scriptstyle{T(n)\leqslant c n^{2}}$ （其中 $c$ 为比例常数），即 $T(n)=O(n^{2})$ ，时间复杂度 $T(n)$ 是问题规模 $n$ 的函数，其问题规模仍然是 $n$ 而不是 $n^{2}$  
03.B  

算法的空间复杂度为 $O(1)$ ，表示执行该算法所需的辅助空间大小相比输入数据的规模来说是一个常量，而不表示该算法执行时不需要任何空间或辅助空间。  

04.D  

A的最高阶是 $n\mathrm{log}_{2}n$ ，时间复杂度是 $O(n\mathrm{log}_{2}n)$ 。B的最高阶是 $n^{2}$ ，时间复杂度是 $O(n^{2})$ .C的最高阶是 $n\mathrm{log}_{2}n$ ，时间复杂度是 $O(n\log_{2}n)$ 。D的最高阶是 $\log_{2}\!n$ ，时间复杂度是 $O(\log_{2}\!n)$  

05.D  

$\scriptstyle{\dot{\mathbf{1}}}={\dot{\mathbf{1}}}\star2$   $t$   $2^{t}{\leqslant}n$   $t{\leqslant}\log_{2}n$   $T(n)=O(\log_{2}n)\,\circ$  更直观的方法：计算基本运算 $\scriptstyle{\dot{\mathbf{1}}}={\dot{\mathbf{1}}}^{\star}2$ 的执行次数（每执行一次i乘以2），其中判断条件可理解为  $2^{t}\!=\!n$  即  $t\!=\!\log_{2}\!n$  ，则  $T(n)=O(\log_{2}n)$  

06.C  

基本运算为 $\dot{\mathbf{i}}^{++}$ ，设执行次数为 $t$ 有 $\scriptstyle{t\times t\times t\leqslant n}$ ，即 $t^{3}{\leqslant}n.$ 因此有 $t\!\leqslant\!\sqrt[3]{n}$ ，则 $T(n)=O(\sqrt[3]{n}$  

07.D  

这是冒泡排序的算法代码，考查最坏情况下的元素交换次数（若觉得理解困难，则可在学完第8章后再回顾）。当所有相邻元素都为逆序时，则最后一行的语句每次都会执行。此时，  

$$
T(n)=\sum_{i=2}^{n-1}\sum_{j=1}^{i-1}1=\sum_{i=2}^{n-1}i-1=(n-2)(n-1)/2=O(n^{2})
$$  

所以在最坏情况下该语句的频度是 $O(n^{2})$  

08.A  

当程序段中有条件判断语句时，取分支路径上的最大时间复杂度。  

09.A  

$\mathrm{m++}$ 语句的执行次数为  

$$
\sum_{i=1}^{n}\sum_{j=1}^{2i}1=\sum_{i=1}^{n}2i=2\sum_{i=1}^{n}i=n(n+1)
$$  

10.C  

本题求的是递归调用的时间复杂度，递归调用可视为多重循环，每次递归执行的基本语句是if $\scriptstyle{\mathrm{==}}1$ ）return1；，因此可认为单层循环的执行次数为1，设递归次数为 $t,2^{t}{\leqslant}n$ ，即 $t{\leqslant}\log_{2}\!n$ 共执行了 $\log_{2}n$ 次递归调用，总执行次数 $T\!=\!\log_{2}\!n\times1$ ，所以时间复杂度为 $O(\log_{2}n)$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/aa8dedd06a9f028de2264878353fdb08edfddc818067525979b9fba87b412c3f.jpg)  

11.A  

基本运算（执行频率最高的语句）为 $\scriptstyle{\mathrm{x}=2}\star_{\mathrm{X}}$ ，每执行一次， $_\mathrm{x}$ 乘以2，设执行次数为t，则有 $2^{t+1}\!<\!n/2$ ，所以 $t<\log_{2}(n/2)-1=\log_{2}n-2$ ，得 $T(n)=O(\log_{2}n)$ 8  

12.B  

本题求的是递归调用的时间复杂度，递归调用可视为多重循环，每次递归执行的基本语句是if $\mathrm{n}\!<\!=\!1$ ）return1；，因此可认为单层循环的执行次数为1，共执行了 $n$ 次递归调用，总执行次数 $T=1+1+\cdots+1=n$ ，所以时间复杂度为 $O(n)$  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3ab9ce82545c510a967e2aa7380a6cff1ac13187c9ce99d37eb227b11041d1ad.jpg)  

13.C  

对于单层循环如for（ $\scriptstyle{\dot{\boldsymbol{\mathrm{\jmath}}}}={\boldsymbol{\mathrm{1}}}$  $\mathfrak{j}_{<=\mathtt{n}}$  $\dot{\mathbf{\omega}}_{\dot{\mathbf{\omega}}}+\dot{\mathbf{\omega}}_{+}$ sum $^{++}$ ，可以直接数出执行次数为 $n$ ，因此可将多层循环转换成多个并列的单层循环，且列出每个单层循环如下（假设 $t$ 为循环变量的幂次）：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a400bc01830453167d54fa241d4b38f2db460ad45444a287364591b203b67ae3.jpg)  

进入外层循环的条件是  $k\!\leqslant\!n$  ，当循环结束时，循环变量的幂次  $t$  满足  $2^{t}\!\leqslant\!n\!<\!2^{t+1}$  即  $t{\leqslant}\log_{2}\!n$  所以总执行次数 $T\!=\,n(t+1)=n\left(\log_{2}\!n+1\right)$ ，时间复杂度为 $O(n\mathrm{log}_{2}n)$ 6  

14.B  

基本运算为 $\mathtt{s u m}{+}{=}{+}{+}{\mathtt{i}}$ ，等价于“ ${++}\,{\dot{1}}$ ;sum $\mathrm{i}{=}$ sum+i”，每执行一次，i都自增1。当 $\scriptstyle{\dot{\Sigma}}={\bar{\Sigma}}$ 时，sum $\scriptstyle{i=0+1}$ ：当 $_{\dot{\mathbf{1}}=2}$ 时， $\scriptstyle{\mathrm{sum}}=0+1+2$ ：当 $_{\dot{\mathbf{1}}=3}$ 时，su $\mathtt{u m}{=}0{+}1{+}2{+}3$ ，以此类推，得出sum $\Vdash$  $0\!+\!\dot{\bf{1}}\!+\!2\!+\!3\!+\!\cdots+\!\dot{\bf{i}}\!=\!(1\!+\!\dot{\bf{i}})\times\!\dot{\bf{i}}/2$ ，可知循环次数 $t$ 满足 $(1+t)\!\times\!t/2<n$ ，故时间复杂度为 $O(n^{1/2})$  

# 注意  

统考真题中常将 $\log_{2}$ 书写为log，此时默认底数为2。  

15.B  

假设第 $k$ 次循环终止，则第 $k$ 次执行时， $(x\!+\!1)^{2}\!>\!n$ ， $x$ 的初始值为0，第 $k$ 次判断时， $x\!=\!k\!-\!1$ 即 $k^{2}\!>\!n$ ， $k\!>\!\sqrt{n}$ ，因此该程序段的时间复杂度为 $O({\sqrt{n}}\,)$  

16.B  

对于单层循环如for（ $\scriptstyle{\dot{\mathbf{\rho}}}=0$  ${<=}\dot{\Sigma}$  $\gimel^{++}$ )sum ${++}$ ；，可以直接数出执行次数为i，因此可将多层循环转换成多个并列的单层循环，且列出每个单层循环如下（假设 $t$ 为循环变量的幕次）：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ee2c2b9c81f65e302f00979b05a9498bd4beda72833e193092a1a2853947da0.jpg)  

进入外层循环的条件是 $i<n$ ，当循环结束时，循环变量的幂次 $t$ 满足 $2^{t}\!<\!n\!\leqslant\!2^{t+1}$ 。总执行次数 $T\!=\!1+2^{1}+2^{2}+\dots+2^{t}\!=\!2^{t+1}-1$ ，即 $n{-}1\leqslant T$ 且 $T<2n-1$ ，所以时间复杂度为 $O(n)$  
# 二、综合应用题  

01.【解答】  

$\textcircled{\scriptsize{1}}$ 基本语句 $\kappa{=}\kappa{+}10\star\dot{1}$ 共执行了 $_{n-2}$ 次，所以 $T(n)\,{=}\,O(n)$  

$\circledcirc$ 设循环体共执行 $t$ 次，每循环一次，循环变量 $y$ 加1，最终 $\scriptstyle t\,=\,y\,\circ$ 故 $t^{2}{\leqslant}n.$ 得 $T(n)=O(n^{1/2})$  $\textcircled{3}$ 内循环执行 $m$ 次，外循环执行 $n$ 次，根据乘法原理，共执行了 $m{\times}n$ 次，故 $T(m,n)=O(m{\times}n).$  


# 2.1.4 答案与解析  

# 单项选择题  

01.C  

线性表是由具有相同数据类型的有限数据元素组成的，数据元素是由数据项组成的。  

02.B  

线性表定义的要求为：相同数据类型、有限序列。选项C的元素个数是无穷个，错误：选项A集合中的元素没有前后驱关系，错误；选项D属于一种存储结构，本题要求选出的是一个具体的线性表，不要将二者混为一谈。只有选项B符合线性表定义的要求。X  

03.A  

线性表中，除最后一个（或第一个）元素外，每个元素都只有一个后继（或前驱）元素。  

04.A  

线性表中的第一个元素没有直接前驱，最后一个元素没有直接后继；当线性表中仅有一个元素时，该元素既没有直接前驱，又没有直接后继。  

# 2.2线性表的顺序表示  

# 2.2.1顺序表的定义  

（算法题）顺序表的应用（2010、2011、2018、2020）  

线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在顺序表的起始位置第i个元素的存储位置后面紧接着存储的是第 $i+1$ 个元素，称 $i$ 为元素 $a_{i}$ 在顺序表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其存储的物理顺序相同。  

假设顺序表L存储的起始位置为Loc（A），sizeof（ElemType）是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如图2.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/be429ac9c6545cfdfb42d2e69bd07d28e3670d31c3050a3298f9ba85cd4fd2f5.jpg)  
图2.1线性表的顺序存储结构  

每个数据元素的存储位置都和顺序表的起始位置相差一个和该数据元素的位序成正比的常数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。  
# 注意  

线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。假定线性表的元素类型为ElemType，则静态分配的顺序表存储结构描述为  

#define MaxSize 50//定义线性表的最大长度typedef struct{ ElemType data[MaxSize];/顺序表的元素int length;//顺序表的当前长度)SqList; //顺序表的类型定义  

一维数组可以是静态分配的，也可以是动态分配的。对数组进行静态分配时，因为数组的大小和空间事先已经固定，所以一旦空间占满，再加入新数据就会产生溢出，进而导致程序前溃。  

而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到扩充数组存储空间的目的，而不需要为线性表一次性地划分所有空间。  

动态分配的顺序表存储结构描述为  

#define InitSize 100//表长度的初始定义typedef struct{ ElemType \*data;//指示动态分配数组的指针int MaxSize,length;//数组的最大容量和当前个数)SeqList; //动态分配数组顺序表的类型定义  

C的初始动态分配语句为L.data  $=$  (ElemType\*)malloc(sizeof(ElemType)\*InitSize);  

$\mathrm{C++}$ 的初始动态分配语句为L.data $=$ new ElemType[InitSize];  

# 注意  

动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。  

顺序表的主要优点： $\textcircled{\scriptsize{1}}$ 可进行随机访问，即可通过首地址和元素序号可以在 $O(1)$ 时间内找到指定的元素； $\circledcirc$ 存储密度高，每个结点只存储数据元素。顺序表的缺点也很明显： $\textcircled{\scriptsize{1}}$ 元素的插入和删除需要移动大量的元素，插入操作平均需要移动 $n/2$ 个元素，删除操作平均需要移动 $(n-1)/2$ 个元素； $\circledcirc$ 顺序存储分配需要一段连续的存储空间，不够灵活。  

# 2.2.2顺序表上基本操作的实现  

命题追踪顺序表上操作的时间复杂度分析（2023）这里仅讨论顺序表的初始化、插入、删除和按值查找，其他基本操作的算法都很简单。  

# 注意  

在各种操作的实现中（包括严蔚敏老师撰写的教材），往往可以忽略边界条件判断、变量定义、内存分配不足等细节，即不要求代码具有可执行性，而重点在于算法的思想。  

# 1.顺序表的初始化  

静态分配和动态分配的顺序表的初始化操作是不同的。静态分配在声明一个顺序表时，就已为其分配了数组空间，因此初始化时只需将顺序表的当前长度设为0。  
/SqListL;/声明一个顺序表void InitList(SqList &L){ L.length  $=\!0$  //顺序表初始长度为0  

动态分配的初始化为顺序表分配一个预定义大小的数组空间，并将顺序表的当前长度设为0。MaxSize指示顺序表当前分配的存储空间大小，一旦因插入元素而空间不足，就进行再分配。  

void InitList（SeqList &L){L.data $=$ （ElemType\*）malloc（MaxSize\*sizeof（ElemType））;I/分配存储空间L.length  $=\!0$  /顺序表初始长度为0 L.MaxSize $=$ InitSize;/初始存储容量  

# 2.插入操作  

在顺序表工的第i（ $\scriptstyle1<=\mathrm{i}<=\mathrm{L}$ .length $^{+1}$ ）个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。  

bool ListInsert（SgList &L,int i,ElemType e）{if(i<llli>L.length  $^{+1}$  一 /判断i的范围是否有效 return false; if(L.length> $,=$ MaxSize)/当前存储空间已满，不能插入return false; for(int  $\scriptstyle{\dot{\mathbf{j}}}={\bar{\mathbf{L}}}$  .length;  $\scriptstyle{\mathrm{j}}>={\mathrm{i}}$  ;j--） //将第i个元素及之后的元素后移 L.data[j]  $\mathbf{\mu=}\mathbb{L}$  .data[j-1]; L.data $\scriptstyle\cdot\,\dot{\mathbf{1}}-\mathbf{1}]=\mathbf{e}$ 在位置i处放入eL.length++; 线性表长度加1 return true;  

# 注意  

区别顺序表的位序和数组下标。为何判断插入位置是否合法时if语句中用length $^{+1}$ ，而移动元素的for语句中只用length？  

最好情况：在表尾插入（即 $i\!=\!n+1$ ），元素后移语句将不执行，时间复杂度为 $O(1)$ 最坏情况：在表头插入（即 $i=1$ ），元素后移语句将执行 $n$ 次，时间复杂度为 $O(n)$  

平均情况：假设 $p_{i}$  $(p_{i}=1/(n+1)$ ）是在第 $i$ 个位置上插入一个结点的概率，则在长度为 $n$ 的线性表中插入一个结点时，所需移动结点的平均次数为  

$$
\sum_{i=1}^{n+1}p_{i}(n-i+1)=\sum_{i=1}^{n+1}{\cfrac{1}{n+1}}(n-i+1)={\cfrac{1}{n+1}}\sum_{i=1}^{n+1}(n-i+1)={\cfrac{1}{n+1}}{\cfrac{n(n+1)}{2}}={\cfrac{n}{2}}
$$  

因此，顺序表插入算法的平均时间复杂度为 $O(n)$  

# 3.删除操作  

删除顺序表 $\mathbb{L}$ 中第i（ $\scriptstyle1<=\mathrm{i}<=\mathrm{L}$ .length）个位置的元素，用引用变量e返回。若i的输入不合法，则返回false；否则，将被删元素赋给引用变量e，并将第 $_{\perp+1}$ 个元素及其后的所有元素依次往前移动一个位置，返回true。  

bool ListDelete（SgList &L,inti,ElemType&e){if（i<llli>L.length)/判断i的范围是否有效return false;  $\scriptstyle{\mathrm{e}}={\mathrm{L}}$  .data[i-l]; //将被删除的元素赋值给e  
for(int $\bf{j}\!=\!\!\mathrm{i}$  $\scriptstyle{\dot{\mathbf{j}}}<\mathtt{L}$ .length; $\,\mathsf{j}\,\mathsf{++}$ //将第i个位置后的元素前移L.data  $[\,\dot{\}-\!1\,]=\!\mathbb{L}$  .data[j]; L.length--; /线性表长度减1 return true;  

最好情况：删除表尾元素（即 $i\!=\!n$ ），无须移动元素，时间复杂度为 $O(1)$  

最坏情况：删除表头元素（即 $i=1$ ），需移动除表头元素外的所有元素，时间复杂度为 $O(n)$ 。平均情况：假设 $p_{i}$  $(p_{i}=1/n)$ 是删除第 $i$ 个位置上结点的概率，则在长度为 $n$ 的线性表中删除一个结点时，所需移动结点的平均次数为  

$$
\sum_{i=1}^{n}p_{i}(n-i)=\sum_{i=1}^{n}{\frac{1}{n}}(n-i)={\frac{1}{n}}\sum_{i=1}^{n}(n-i)={\frac{1}{n}}{\frac{n(n-1)}{2}}={\frac{n-1}{2}}
$$  

因此，顺序表删除算法的平均时间复杂度为 $O(n)$  

可见，顺序表中插入和删除操作的时间主要耗费在移动元素上，而移动元素的个数取决于插入和删除元素的位置。图2.2所示为一个顺序表在进行插入和删除操作前、后的状态，以及其数据元素在存储空间中的位置变化和表长变化。在图2.2（a）中，将第4个至第7个元素从后往前依次后移一个位置，在图2.2（b）中，将第5个至第7个元素从前往后依次前移一个位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fcdde81ce9ac45ac3a7dc87f6c157d7c94ff8c769f9bc96a5a2bee3573ec43ca.jpg)  
图2.2顺序表的插入和删除  

# 4.按值查找（顺序查找）  

在顺序表L中查找第一个元素值等于e的元素，并返回其位序。  

int LocateElem(SqList L,ElemType e){ inti; for(  $\scriptstyle{\dot{\mathbf{z}}}=0$   $\scriptstyle{\mathrm{~\vec{x}}}<{\mathrm{~\vec{L}}}$  .length;  $\ \ \mathrm{i++}$  if(L.data  $[\,\dot{\mathbf{i}}\,]\mathrm{==}\mathbf{e}$  returni+l; I/下标为i的元素值等于e，返回其位序  $\scriptstyle{\dot{\mathbf{x}}}+1$  return 0; /退出循环，说明查找失败  

最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为 $O(1)$ 最坏情况：查找的元素在表尾（或不存在）时，需要比较 $n$ 次，时间复杂度为 $O(n)$  

平均情况：假设 $p_{i}$  $(p_{i}=1/n)$ 是查找的元素在第i（ $\scriptstyle1<=\mathrm{i}<=\mathrm{L}$ .length）个位置上的概率，则在长度为 $n$ 的线性表中查找值为e的元素所需比较的平均次数为  

$$
\sum_{i=1}^{n}p_{i}\cdot i=\sum_{i=1}^{n}{\frac{1}{n}}\cdot i={\frac{1}{n}}{\frac{n(n+1)}{2}}={\frac{n+1}{2}}
$$  

因此，顺序表按值查找算法的平均时间复杂度为 $O(n)$ 顺序表的按序号查找非常简单，即直接根据数组下标访问数组元素，其时间复杂度为 $O(1)$  
# 2.2.3 本节试题精选  

# 一、单项选择题  

01.下述（）是顺序存储结构的优点。  

A.存储密度大 B.插入运算方便 C.删除运算方便D.方便地运用于各种逻辑结构的存储表示  

02.下列关于顺序表的叙述中，正确的是（）。  

A.顺序表可以利用一维数组表示，因此顺序表与一维数组在逻辑结构上是相同的B.在顺序表中，逻辑上相邻的元素物理位置上不一定相邻C.顺序表和一维数组一样，都可以进行随机存取D.在顺序表中，每个元素的类型不必相同  

03.线性表的顺序存储结构是一种（）  

A.随机存取的存储结构B.顺序存取的存储结构C.索引存取的存储结构D.散列存取的存储结构  

04.通常说顺序表具有随机存取的特性，指的是（）。  

A.查找值为 $x$ 的元素的时间与顺序表中元素个数 $n$ 无关B.查找值为 $x$ 的元素的时间与顺序表中元素个数 $n$ 有关C.查找序号为 $i$ 的元素的时间与顺序表中元素个数 $n$ 无关D.查找序号为 $i$ 的元素的时间与顺序表中元素个数 $n$ 有关  

05.一个顺序表所占用的存储空间大小与（）无关。  

A.表的长度 B.元素的存放顺序 C.元素的类型D.元素中各字段的类型  

06.若线性表最常用的操作是存取第 $i$ 个元素及其前驱和后继元素的值，为了提高效率，应采用（）的存储方式。  

A.单链表B.双向链表C.单循环链表D.顺序表  

07.一个线性表最常用的操作是存取任意一个指定序号的元素并在最后进行插入、删除操作则利用（）存储方式可以节省时间。  

A.顺序表B.双链表C.带头结点的双循环链表D.单循环链表  

08.在 $n$ 个元素的线性表的数组表示中，时间复杂度为 $O(1)$ 的操作是（）  

I.访问第i（ $1\!\leqslant\!i\!\leqslant\!n$ ）个结点和求第 $i$ C $2\!\leqslant\!i\!\leqslant\!n$ ）个结点的直接前驱II.在最后一个结点后插入一个新的结点IⅢ.删除第1个结点IV.在第 $i$ C $1\!\leqslant\!i\!\leqslant\!n$ ）个结点后插入一个结点  

A.1B.II、IIC.I、ⅡID.I、Ⅱ、Ⅲ  

09.设线性表有 $n$ 个元素，严格说来，以下操作中，（）在顺序表上实现要比在链表上实现的效率高。  

I.输出第i（ $1\!\leqslant\!i\!\leqslant\!n$ ）个元素值I1.交换第3个元素与第4个元素的值IⅢ.顺序输出这 $n$ 个元素的值  

A.1B.I、IIC.I、IID.II、IⅢI  
10.在一个长度为 $n$ 的顺序表中删除第 $i$  $1\!\leqslant\!i\!\leqslant\!n$ ）个元素时，需向前移动（）个元素。A.  $n$  B.i-1 C.  $n\!-\!i$  D.  $n\!-\!i+1$  11.对于顺序表，访问第 $i$ 个位置的元素和在第 $i$ 个位置插入一个元素的时间复杂度为（）。A. $O(n)$  $O(n)$ B. $O(n)$ ， $O(1)$ C. $O(1)$  $O(n)$ D. $O(1)$ ， $O(1)$ 12.对于顺序存储的线性表，其算法时间复杂度为 $O(1)$ 的运算应该是（）  

A.将  $n$  个元素从小到大排序 B.删除第 $i$ ( $1\!\leqslant\!i\!\leqslant\!n$ ）个元素C.改变第  $i$  (  $1\!\leqslant\!i\!\leqslant\!n$  ）个元素的值 D.在第 $i$ ( $1\!\leqslant\!i\!\leqslant\!n$ ）个元素后插入一个新元素  

13.若长度为 $n$ 的非空线性表采用顺序存储结构，在表的第 $i$ 个位置插入一个数据元素，则 $i$ 的合法值应该是（）。  

A.  $1\!\leqslant\!i\!\leqslant\!n$  B.  $1\!\leqslant\!i\!\leqslant\!n+1$  C.  $\scriptstyle0\leqslant i\leqslant n-1$  D.  $\scriptstyle0\leqslant i\leqslant n$  

14.顺序表的插入算法中，当 $n$ 个空间已满时，可再申请增加分配 $m$ 个空间，若申请失败，则说明系统没有（）可分配的存储空间。  

A.   $m$  个 B.  $m$  个连续 C.  $n+m$  个 D.  $n+m$  个连续  

15.【2023统考真题】在下列对顺序存储的有序表（长度为 $n$ ）实现给定操作的算法中，平均时间复杂度为 $O(1)$ 的是（)。  

A.查找包含指定值元素的算法B.插入包含指定值元素的算法C.删除第 $i$ ( $1\!\leqslant\!i\!\leqslant\!n$ ）个元素的算法D.获取第 $i$ C $1\!\leqslant\!i\!\leqslant\!n$ ）个元素的算法  

# 二、综合应用题  

01.从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。 $L$   $O(1).$  03.对长度为 $n$  $L$  $O(n)$  $O(1)$ 法删除顺序表中所有值为 $x$ 的数据元素。

04.从顺序表中删除其值在给定值 $s$ 和 $t$ 之间（包含 $s$ 和 $t$ ，要求 $s<t$ ）的所有元素，若 $s$ 或 $t$ 不合理或顺序表为空，则显示出错信息并退出运行。

05.从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。

06.将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表，

07.已知在一维数组 $A[m+n]$ 中依次存放两个线性表 $(a_{1},a_{2},a_{3},\cdots,a_{m})\not\approx(b_{1},b_{2},b_{3},\cdots,b_{n})_{\circ}$ 编写一个函数，将数组中两个顺序表的位置互换，即将 $(b_{1},b_{2},b_{3},\cdots,b_{n})$ 放在 $(a_{1},a_{2},a_{3},\cdots,a_{m})$ 的前面。

08.线性表 $(a_{1},a_{2},a_{3},\cdots,a_{n})$ 中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为 $x$ 的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。

09.给定三个序列 $A$ 、B、 $C$ ，长度均为 $n$ ，且均为无重复元素的递增序列，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。例如，数组 $A$ 为{1,2,3]，数组 $B$ 为{2,3,4]，数组 $C$ 为 $\{-1,0,2\}$ ，则输出2。要求：1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你的算法的时间复杂度和空间复杂度。  

10.【2010统考真题】设将 $n$  $n>1$ ）个整数存放到一维数组 $R$ 中。设计一个在时间和空间两方面都尽可能高效的算法。将 $R$ 中保存的序列循环左移 $p$ C $0<p<n$ ）个位置，即将 $R$ 中的数据由 $(X_{0},X_{1},\cdots,X_{n-1})$ 变换为 $(X_{p},X_{p+1},\cdots,X_{n-1},X_{0},X_{1},\cdots,X_{p-1})\,\circ$ 要求：  
1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 或Java语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

11.【2011统考真题】一个长度为 $L$ C $L{\geqslant}1$ ）的升序序列 $S$ ，处在第 $\cdot_{L/2}\cdot$ 个位置的数称为 $S$ 的中位数。例如，若序列 $S_{1}\!=(11,13,15,17,19$ ，则 $S_{1}$ 的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若 $S_{2}=(2,4,6,8,20)$ ，则 $S_{1}$ 和 $S_{2}$ 的中位数是11。现在有两个等长升序序列 $A$ 和 $B$ ，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列 $A$ 和 $B$ 的中位数。要求：  

1）给出算法的基本设计思想。  

2）根据设计思想，采用C或 $\mathrm{C++}$ 或Java语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

12.【2013统考真题】已知一个整数序列 $A=(a_{0},a_{1},\cdots,a_{n-1})$ ，其中 $0{\leqslant}a_{i}{<}n$ C $\scriptstyle0\leqslant i\leqslant n$ )。若存在 $\begin{array}{r}{a_{p1}\!=a_{p2}\!=\!\cdots\!=a_{p m}\!=x}\end{array}$ 且 $m\!>\!n/2$ （ $0\!\leqslant\!p_{k}\!<\!n$  $1\!\leqslant\!k\!\leqslant\!m$ )，则称 $x$ 为 $A$ 的主元素。例如 $A=(0,5,5,3,5,7,5,5)$ ，则5为主元素；又如 $A=(0,5,5,3,5,1,5,7)$ ，则 $A$ 中没有主元素。假设 $A$ 中的 $n$ 个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出 $A$ 的主元素。若存在主元素，则输出该元素；否则输出一1。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 或Java语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

13.【2018统考真题】给定一个含 $n$  $n{\geqslant}1$ ）个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5，3,2，3}中未出现的最小正整数是1；数组1，2，3！中未出现的最小正整数是4。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

14.【2020统考真题】定义三元组  $(a,b,c)(\,a,b,c\,$  均为整数)的距离  $D=\left|a-b\right|+\left|b-c\right|+\left|c-a\right|.$  给定3个非空整数集合 $S_{1}$  $S_{2}$ 和 $S_{3}$ ，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组 $(a,\,b,$ c) ( $a\!\in\!S_{1}$ ， $b\!\in\!S_{2}$  $c\!\in\!S_{3}$ ）中的最小距离。例如 $S_{1}=\{-1,0,9\}$ ， $S_{2}=\{-25$ ,-10, 10,11}, $S_{3}=\{2,9,17,30,41\}$ ，则最小距离为2，相应的三元组为(9，10,9)。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C语言或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

# 2.2.4 答案与解析  

# 一、单项选择题  

01.A  

顺序表不像链表那样要在结点中存放指针域，因此存储密度较大，选项A正确。选项B和C是链表的优点。选项D是错误的，比如对于树形结构，顺序表显然不如链表表示起来方便。  
02.C  

顺序表是顺序存储的线性表，表中所有元素的类型必须相同，且必须连续存放。一维数组中的元素可以不连续存放；此外，栈、队列和树等逻辑结构也可利用一维数组表示，但它与顺序表不属于相同的逻辑结构。在顺序表中，逻辑上相邻的元表物理位置上也相邻。  

03. A  

本题易误选B。注意，存取方式是指读/写方式。顺序表是一种支持随机存取的存储结构，根据起始地址加上元素的序号，可以很方便地访问任意一个元素，这就是随机存取的概念。  

04.C  

随机存取是指在 $O(1)$ 的时间访问下标为 $i$ 的元素，所需时间与顺序表中的元素个数 $n$ 无关。  

05.B  

顺序表所占的存储空间 $=$ 表长 $\times$ sizeof（元素的类型），表长和元素的类型显然会影响存储空间的大小。若元素为结构体类型，则元素中各字段的类型也会影响存储空间的大小。  

06.D  

题干实际要求能最快存取第i-1、i和 $i+1$ 个元素值。选项A、B、C都只能从头结点依次顺序查找，时间复杂度为 $O(n)$ ；只有顺序表可以按序号随机存取，时间复杂度为 $O(1)$  

07. A 只有顺序表可以按序号随机存取，且在最后进行插入和删除操作时不需要移动任何元素。  

08.C  

对于I，解析略；对于ⅡI，在最后位置插入新结点不需要移动元素，时间复杂度为 $O(1)$ ；对于ⅢI，被删结点后的结点需要依次前移，时间复杂度为 $O(n)$ ：对于IV，需要后移 $n\!-\!i$ 个结点，时间复杂度为 $O(n)$  

09.C  

对于ⅡI，顺序表只需要3次交换操作；链表则需要分别我到两个结点前驱，第4个结点断链后再插入到第2个结点后，效率较低。对于Ⅲ，需依次顺序访问每个元素，时间复杂度相同。  

10.C 需要将元素 $a_{i+1}{\sim}a_{n}$ 依次前移一位，共移动 $n-(i+1)+1=n-i$ 个元素。  

11.C 在第 $i$ 个位置插入一个元素，需要移动 $n-i+1$ 个元素，时间复杂度为 $O(n)$  

12.C 对 $n$ 个元素进行排序的时间复杂度最小也要 $O(n)$ （初始有序时)，通常为 $O(n\mathrm{log}_{2}n)$ 或 $O(n^{2})$ 通过第8章学习后会更理解。B和D显然错误。顺序表支持按序号的随机存取方式。  

13.B 线性表元素的序号是从1开始，而在第 $n+1$ 个位置插入相当于在表尾追加。  

14.D 顺序存储需要连续的存储空间，在申请时需申请 $n+m$ 个连续的存储空间，然后将线性表原来的 $n$ 个元素复制到新申请的 $n+m$ 个连续的存储空间的前 $n$ 个单元。  

15.D  

对于顺序存储的有序表，查找指定值元素可以采用顺序查找法或折半查找法，平均时间复杂度最少为 $O(\log n)$ 。插入指定值元素需要先我到插入位置，然后将该位置及之后的元素依次后移一个位置，最后将指定值元素插入到该位置，平均时间复杂度为 $O(n)$ 。删除第 $i$ 个元素需要将该元素之后的全部元素依次前移一个位置，平均时间复杂度为 $O(n)$ 。获取第 $i$ 个元素只需直接根据下标读取对应的数组元素即可，时间复杂度为 $O(1)$  
# 二、综合应用题  

01.【解答】  

算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置。  

本题代码如下：  

bool Del Min(SqList &L,ElemType &value) //删除顺序表L中最小值元素结点，并通过引用型参数value返回其值/若删除成功，则返回true：否则返回false if(L.length  $==0$  return false;/表空，中止操作返回value $\mathbf{\mu=}\mathbb{L}$ .data[0];int pos  $=\!0$  /假定0号元素的值最小 for（int $\scriptstyle{\dot{\boldsymbol{\perp}}}={\boldsymbol{\perp}}$ ;i<L.length; $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ /循环，寻找具有最小值的元素if(L.data[i]<value){/让value记忆当前具有最小值的元素value  $\mathbf{\omega}=\mathbf{L}$  .data[i]; pos  $\mathbf{\mu=\dot{\Sigma}}$  L.data[pos] $\mathbf{\omega=}\mathbb{L}$ .data[L.length-1];/空出的位置由最后一个元素填补L.length--;return true;//此时，value即为最小值  

# 注意  

本题也可用函数返回值返回，两者的区别是：函数返回值只能返回一个值，而参数返回（引用传参）可以返回多个值。  

02.【解答】  

算法思想：扫描顺序表 $L$ 的前半部分元素，对于元素L.data[i]（ $0\!<\!=\!\dot{\mathtt{1}}<\!\dot{\mathtt{L}}$ .length/2),将其与后半部分的对应元素L.data[L.length-i-1]进行交换。  

本题代码如下：  

void Reverse(SqList &L){ ElemType temp;/辅助变量for(int  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<L.length/2;  $\ \ \dot{\mathbf{i}}_{++}$  temp  $\mathbf{\mu=}\mathbb{L}$  .data[i]; /交换L.data[i]与L.data[L.length-i-1] L.data  $[\dot{\mathbf{\nabla}}]\!=\!\mathbb{L}$  .data[L.length-i-1]; L.data[L.length-i-1]  $=$  temp;  

03.【解答】  

解法1：用 $k$ 记录顺序表 $L$ 中不等于 $x$ 的元素个数（即需要保存的元素个数），扫描时将不等于 $x$ 的元素移动到下标 $k$ 的位置，并更新 $k$ 值。扫描结束后修改 $L$ 的长度。  

本题代码如下：  

void delx1（SqList &L,ElemType x){ 川/本算法实现册除顺序表工中所有值为 $\mathbf{x}$ 的数据元素int $\kappa{=}0$ i;//记录值不等于 $_\mathrm{x}$ 的元素个数for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\dot{\mathbf{1}}}<{\dot{\mathbf{L}}}$  .length;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  if（L.data[i] $!=\!\mathrm{x}$ ）（  
L.data[k]  $\mathbf{\mu=}\mathbb{L}$  .data[i];  $\kappa++$  I不等于  $\mathbf{x}$  的元素增1 L.length  $=\!\!k$  //顺序表工的长度等于  $\kappa$  

解法2：用 $k$ 记录顺序表 $L$ 中等于 $x$ 的元素个数，一边扫描L，一边统计k，并将不等于 $x$ 的元素前移 $k$ 个位置。扫描结束后修改 $L$ 的长度。  

本题代码如下：  

void del x 2（SqList &L,ElemType x）{int $\kappa{=}0$  $\scriptstyle{\dot{\mathbf{z}}}=0$ //k记录值等于 $\mathbf{x}$ 的元素个数while  $\scriptstyle{\mathrm{~i~}}<{\mathrm{L}}$  .length)( if（L.data[i]  $==$   $\kappa++$  else L.data[i-k] $\mathbf{\omega}=\mathbb{L}$ .data[i]；//当前元素前移 $\kappa$ 个位置 $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  L.length  $\mathbf{\mu=}\mathbb{L}$  .length-k; //顺序表L的长度递减  

此外，本题还可以考虑设头、尾两个指针（ $i=1,j=n$ ），从两端向中间移动，在遇到最左端值 $x$ 的元素时，直接将最右端值非 $x$ 的元素左移至值为 $x$ 的数据元素位置，直到两指针相遇。但这种方法会改变原表中元素的相对位置。  

# 04.【解答】  

算法思想：从前向后扫描顺序表 $L$ ，用 $k$ 记录值在 $s$ 和 $t$ 之间的元素个数（初始时 $k\!=\!0$ ）。对于当前扫描的元素，若其值不在 $s$ 和 $t$ 之间，则前移 $\boldsymbol{\mathrm{k}}$ 个位置；否则执行 $\kappa++$ 。由于每个不在 $s$ 和之间的元素仅移动一次，因此算法效率高。  

本题代码如下：  

bool Del s t（SqList &L,ElemType s,ElemType t)//删除顺序表L中值在给定值s和t（要求s<t）之间的所有元素inti,  $\kappa{=}0$  if(L.length  $==0$   $_{\tt S P=\tt C}$  return false;线性表为空或s、t不合法，返回for(  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\mathrm{~i}}<{\mathrm{L}}$  .length;  $\ \ \mathrm{i}_{\ ++}$  if（L.data[i]  $\scriptstyle{>=s}$  &&L.data[i]  $<=\dagger$   $\kappa++$  else L.data[i-k] $\mathbf{\mu=}\mathbb{L}$ .data[i]；//当前元素前移 $\kappa$ 个位置//for L.length-  $\scriptstyle{\varepsilon=k}$  //长度减小 returntrue;  

# 注意  

本题也可从后向前扫描顺序表，每遇到一个值在 $s$ 和 $t$ 之间的元素，就删除该元素，其后的所有元素全部前移。但移动次数远大于前者，效率不够高。  

# 05.【解答】  

算法思想：注意是有序顺序表，值相同的元素一定在连续的位置上，用类似于直接插入排序的思想，初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾为止。  
本题代码如下：  

bool Delete Same（SeqList& L)(if(L.length  $==0$  return false; inti，j; $/\mathrm{i}$ 存储第一个不相同的元素，为工作指针for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\dot{\boldsymbol{\mathrm{\beta}}}}=1$   $\mathfrak{j}^{<\!\mathtt{L}}$  .length;j++) if(L.data[i] $!\!=\!\!\mathbb{L}$ .data[j])查找下一个与上个元素值不同的元素L.data $[++\dot{\Sigma}]\!=\!\bar{\mathbb{L}}$ .data[j];//找到后，将元素前移L.length  $\scriptstyle{i={\dot{1}}+{\dot{1}}}$  returntrue;  

对于本题的算法，请读者用序列 $1,2,2,2,2,3,3,3,4,4,5$ 来手动模拟算法的执行过程，在模拟过程中要标注 $i$ 和i所指示的元素。  

思考：若将本题中的有序表改为无序表，你能想到时间复杂度为 $O(n)$ 的方法吗？  

（提示：使用散列表。）  

06.【解答】  

算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看哪个表还有剩余，将剩下的部分加到新的顺序表后面。  

本题代码如下：  

boolMerge（SeqList A,SeqList B,SeqList &C){//将有序顺序表A与B合并为一个新的有序顺序表Cif(A.length+B.length>C.maxSize)川大于顺序表的最大长度return false; int  $\scriptstyle{\dot{\mathbf{z}}}=0$   $\scriptstyle{\dot{\mathbf{j}}}=0$   $\kappa{=}0$  while $\scriptstyle{\mathrm{~\vec{x}}}<{\mathrm{~\vec{A}~}}$ .length&&j $\tt<B$ .length)(/循环，两两比较，小者存入结果表if(A.data[i]  $<=\mathtt{B}$  .data[j]) C.data  $[\mathsf{k}++]\mathsf{=}\mathsf{A}$  .data  $[\,\dot{\bot}\,+\,+\,]$  else C.data  $[\mathsf{k}++]\!=\!\mathsf{B}$  .data  $[\,\dot{\,}]^{++}\,]$  while( $\scriptstyle{\mathrm{~i}}<{\mathrm{A}}$ .length)//还剩一个没有比较完的顺序表C.data  $[\mathsf{k}++]\mathsf{=}\mathsf{A}$  .data  $[\,\dot{\bot}\,+\,+\,]$  while  $({\dot{\mathfrak{j}}}{<}{\mathtt{B}}$  .length) C.data  $[\mathsf{k}++]\!=\!\mathsf{B}$  .data  $[\dot{\mathbf{\nabla}}\mathbf{+}\mathbf{+}]$  C.length  $=\!\kappa$  return true;  

# 注意  

本算法的方法非常典型，需牢固掌握。  

07.【解答】  

算法思想：首先将数组 $A[m+n]$ 中的全部元素 $(a_{1},a_{2},a_{3},\cdots,a_{m},b_{1},b_{2},b_{3},\cdots,b_{n})$ 原地逆置为 $(b_{n},b_{n-1},b_{n-2},\cdots,b_{1},a_{m},a_{m-1},a_{m-2},\cdots,a_{1})$ ，然后对前 $n$ 个元素和后 $m$ 个元素分别使用逆置算法，即可得到 $(b_{1},b_{2},b_{3},\cdots,b_{n},a_{1},a_{2},a_{3},\cdots,a_{m})$ ，从而实现顺序表的位置互换。  
本题代码如下：  

typedef int DataType; void Reverse（DataType A[];int left,int right,int arraySize){//逆转（aleft，aleft+1,aleft $+2\cdots$ ,aright)为（aright,aright-l,,aleft)if(left）  $>=$  right ll right  $>=$  arraysize) return; int mid  $=$  (left+right)/2; for（int  $\scriptstyle{\dot{\mathbf{z}}}=0$   $\scriptstyle{\dot{\mathbf{1}}}<=$  mid-left;  $\ \ \mathrm{i}_{++}$  Data Type temp  $\scriptstyle\varphi=\mathtt{A}$  [left+i]; A[left+i]  $\mathtt{\ =}\mathtt{A}$  [right-i]; A[right-i]  $=$  temp; void Exchange（DataType A[],int m,int n,int arraySize){\*数组 $\mathtt{A}\left[\mathtt{m}\!+\!\mathtt{n}\right]$ 中，从0到 $\mathfrak{m}^{-1}$ 存放顺序表（al，a2，a3，…，am），从m到 $\mathrm{m+n-1}$ 存放顺序表（b1，b2，b3，，bn），算法将这两个表的位置互换\*/Reverse(A,0,m+n-l,arraySize); Reverse(A,0,n-l,arraySize); Reverse(A,n,  $\mathrm{m+n-1}$  ,arraysize);  

# 08.【解答】  

算法思想：顺序存储的线性表递增有序，可以顺序查找，也可以折半查找。题目要求“用最少的时间在表中查找数值为 $x$ 的元素”，这里应使用折半查找法。  

本题代码如下：  

void Search Exchange Insert（ElemType A[],ElemType x){ int low  $\scriptstyle{\prime=0}$  ,high  $\scriptstyle{=n-1}$  ,mid; /1low和high指向顺序表下界和上界的下标 while(low  $<=$  high)( mid $\bar{-}$ （low+high)/2;/找中间位置if(A[mid]  $==$  )break; /找到  $\mathrm{_x}$  ，退出while循环 else if（A[mid]  ${\tt<x}$  ）low  $=$  mid+1；/到中点mid的右半部去查 else high=mid-1;//到中点mid的左半部去查//下面两个if语句只会执行一个 if(A[mid] $==$ x&&mid $!\!=\!\!\mathrm{n}\!-\!\!1$ //若最后一个元素与 $_\mathrm{x}$ 相等，则不存在与其后继交换的操作 $\scriptstyle{\mathrm{~t=A~}}$  [mid];A[mid]  $\mathtt{\ =}\mathtt{A}$  [mid+1];A[mid+1]  $=\mathrm{c}$  if（low>high){//查找失败，插入数据元素xfor( $\scriptstyle{\mathrm{i}}=\mathrm{n}-1$ ;i>high;i--）A $\mathbb{\lambda}\left[\,\mathbb{i}\!+\!1\,\right]=\!\mathbb{\lambda}\left[\,\mathbb{i}\right.$ //后移元素A  $\mathbf{\lambda}_{\mathrm{if}}[\mathrm{i}+1]=\!\!\mathrm{x}$  //插入x //结束插入  

本题的算法也可写成三个函数：查找函数、交换后继函数与插入函数。写成三个函数的优点是逻辑清晰、易读。  

09.【解析】  

1）算法的基本设计思想。  

使用三个下标变量从小到大遍历数组。当三个下标变量指向的元素相等时，输出并向前推进指针，否则仅移动小于最大元素的下标变量，直到某个下标变量移出数组范围，即可停止。  
2）算法的实现。  

void samekey（int A[],int B[],int C[],intn）{int $\scriptstyle{\dot{\mathbf{z}}}=0$  $\mathord{\dot{\mathbf{\rho}}}_{0}=\!\!0$  $\kappa{=}0$ //定义三个工作指针while（i<n&&j<n&&k<n){/相同则输出，并集体后移if（A[i]  $\scriptstyle==\mathtt{B}$  [j]&&B[j]  $\scriptstyle=\mathbb{C}$  [k]){ printf("&d\n",A[i]);  $\ \ \dot{\mathbf{i}}_{++}$   $\j++$   $k++$  )elser intmaxNum=max（A[i],max（B[j],C[k])）;if（A[i]<maxNum) $\dot{\mathbf{1}}\!+\!+$ if(B[j]<maxNum) $\j++$ if(C[k]<maxNum)  $\kappa++$  

3）每个指针移动的次数不超过 $n$ 次，且每次循环至少有一个指针后移，所以时间复杂度为 $O(n)$ ，算法只用到了常数个变量，空间复杂度为 $O(1)$  

10.【解答】  

1）算法的基本设计思想：  

可将问题视为把数组 $_{a b}$ 转换成数组 $b a$  $.a$ 代表数组的前 $p$ 个元素， $^b$ 代表数组中余下的 $n\!-\!p$ 个元素），先将 $^a$ 逆置得到 $a^{-1}b$ ，再将 $^b$ 逆置得到 $a^{-1}b^{-1}$ ，最后将整个 $a^{-1}b^{-1}$ 逆置得到 $(a^{-1}b^{-1})^{-1}{=b a}$ 。设Reverse函数执行将数组逆置的操作，对abcdefgh向左循环移动3 $(p\!=\!3$ ）个位置的过程如下：  

Reverse $(\,0\,,\,\mathtt{p}^{-1}\,)$ 得到cbadefghReverse $(\mathsf{p},\mathsf{n}\!-\!1)$ 得到cbahgfed；Reverse $(\,0\,,\mathrm{n}{-}1\,)$ 得到defghabc。注：在Reyerse中，两个参数分别表示数组中待转换元素的始末位置，  

2）使用C语言描述算法如下：  

void Reverse（int R[],int from,int to）{ int i,temp; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $_{\mathrm{i}<}$  (to-from  $^{1+1}$  )/2;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  (temp  $\scriptstyle{\varepsilon=\mathtt{R}}$  [from  ${\boldsymbol{\cdot}}+\dot{\boldsymbol{\mathrm{1}}}$  ];R[from  ${\mathrm{i}}+{\mathrm{i}}$  1  $\scriptstyle=\mathbb{R}$  [to-i];R[to-i]  $=$  temp;) void Converse（int R[],int n,int p）(Reverse（R,0,p-1);Reverse(R,p,n-1);Reverse(R,0,n-1);  

3）上述算法中三个Reverse函数的时间复杂度分别为 $O(p/2)$ 、 $O((n\!-\!p)/2)$ 和 $O(n/2)$ ，故所设计的算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

【另解】借助辅助数组来实现。算法思想：创建大小为 $p$ 的辅助数组 $S$ ，将 $R$ 中前 $p$ 个整数依次暂存在 $S$ 中，同时将 $R$ 中后 $n\!-\!p$ 个整数左移，然后将 $S$ 中暂存的 $p$ 个数依次放回到 $R$ 中的后续单元。时间复杂度为 $O(n)$ ，空间复杂度为 $O(p)$ 。  

11.【解答】  

1）算法的基本设计思想如下。分别求两个升序序列4、 $B$ 的中位数，设为 $a$ 和 $b$ ，求序列 $A$ 、 $B$ 的中位数过程如下：  
$\textcircled{\scriptsize{1}}$ 若 $a=b$ ，则 $a$ 或 $b$ 即为所求中位数，算法结束。  

$\circledcirc$ 若 $a\!<\!b$ ，则舍弃序列 $A$ 中较小的一半，同时舍弃序列 $B$ 中较大的一半，要求两次舍弃的长度相等。 $\textcircled{3}$ 若 $a>b$ ，则舍弃序列 $A$ 中较大的一半，同时舍弃序列 $B$ 中较小的一半，要求两次舍弃的长度相等。  

在保留的两个升序序列中，重复过程 $\textcircled{\scriptsize{1}}$ 、 $\circledcirc$ 、 $\textcircled{3}$ ，直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。  

2）本题代码如下：  

int M Search（int A[],int B[],int n）{int s1,d1,m1,s2,d2，m2; S  $_{1=0}$   $\scriptstyle{\mathrm{d}}1=\mathrm{n}-1$   $_{s Z=1}$   $\scriptstyle{\mathrm{d}}2=\mathrm{n}-1$  while(s1!=d1lls2!=d2){  ${\mathfrak{m}}{\boldsymbol{\mathbb{1}}}=({\mathsf{s}}\,{\boldsymbol{\mathbb{1}}}+{\mathsf{d}}{\boldsymbol{\mathbb{1}}})$  /2;  $\begin{array}{r}{\mathfrak{m}{2}\!=\!\left(\mathsf{s}\,{2}\!+\!\mathsf{d}{2}\right)/2\,,}\end{array}$  if  $\scriptstyle(\mathtt{A}\,[\mathtt{m}\mathtt{1}\,]\,==\mathtt{B}$  [m2]) return A[ml];/满足条件 $\textcircled{\scriptsize{1}}$ if（A[m1] $\scriptstyle<\mathtt{B}$ [m2]）{//满足条件 $\circledcirc$ if（(s1+dl) $\scriptstyle82=0$ //若元素个数为奇数 $_{\mathsf{S1}=\mathsf{m1}}$ 川舍弃A中间点以前的部分，且保留中间点 $_{\mathrm{d}2=\mathrm{m}2}$ 川舍弃B中间点以后的部分，且保留中间点elsel1/元素个数为偶数 $\mathtt{s1}{=}\mathtt{m1}{+}\mathtt{1}$ I/舍弃A的前半部分 $_{\mathsf{d}2=\mathsf{m}2}$ 川舍弃B的后半部分elsef/满足条件 $\circledast$ if（（s1+d1) $\scriptstyle{\frac{8}{6}}Z==0$ 1/若元素个数为奇数 $_{\tt d1=m1}$ 川舍弃A中间点以后的部分，且保留中间点 $_{\mathrm{s}2=\mathrm{m}2}$ //舍弃B中间点以前的部分，且保留中间点elsel1/元素个数为偶数 ${\tt d1}{\tt=m1}$ //舍弃A的后半部分 $_{\mathsf{s2=m2+1}}$ //舍弃B的前半部分return A[s1]<B[s2]? A[s1]:B[s2];  

3）算法的时间复杂度为 $O(\log_{2}n)$ ，空间复杂度为 $O(1)$  

【另解】对两个长度为 $n$ 的升序序列 $A$ 和 $B$ 中的元素按从小到大的顺序依次访问，这里访问的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为 $O(1)$ 。按照上述规则访问第 $n$ 个元素时，这个元素即为两个序列 $A$ 和 $B$ 的中位数。  

12.【解答】  

1）算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素Num。然后重新计数，确认Num是否是主元素。  

算法可分为以下两步：  
$\textcircled{\scriptsize{1}}$ 选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。  

$\circledcirc$ 判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大于 $n/2$ ，则为主元素：否则，序列中不存在主元素。  

2）算法实现如下：  

int Majority（int A[],int n)( int i,c,count $^{=1}$ l/c用来保存候选主元素，count用来计数 $_{C=\mathbb{A}}$ [0];//设置A[0】为候选主元素for( $_\mathrm{i}\!=\!1$ ;i<n; $\ \ \mathrm{i}_{ Ḋ }+\+ Ḍ$ //查找候选主元素if  $\mathrm{{(\AA{[\AA{i}]}==_{C}}}$  count ${++}$ 对A中的候选主元素计数else if(count>0)//处理不是候选主元素的情况count--; elsef//更换候选主元素，重新计数 $\scriptstyle{C=\mathbb{A}}$  [i]; count  $^{=1}$  if(count>0) for(  $\dot{\mathbf{i}}=$  count  $=\!0$   $\scriptstyle{\dot{\mathbf{1}}}<{\mathrm{n}}$   $\ \ \dot{\mathbf{i}}_{++}$  川统计候选主元素的实际出现次数 if  $(\mathbb{A}\left[\dot{\mathbb{\tau}}\right]==_{\mathbb{C}}$  count  $^{++}$  if（count>n/2)return c;//确认候选主元素else return-1;I/不存在主元素  

3）实现的程序的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

说明：本题若采用先排好序再统计的方法【时间复杂度为 $O(n1\log_{2}n)$ ]，则只要解答正确，最高可拿11分。即便是写出 $O(n^{2})$ 的算法，最高也能拿10分，因此对于统考算法题，花费大量时间去思考最优解法是得不偿失的。  

# 13.【解答】  

1）算法的基本设计思想：  

要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用来记录A中是否出现了 $1\!\sim\!\mathrm{n}$ 中的正整数，B[0]对应正整数1，B[n-1]对应正整数 $\mathtt{n}$ ，初始化B中全部为0。由于A中含有 $\mathtt{n}$ 个整数，因此可能返回的值是 $\mathtt{1}\!\sim\!\mathrm{n}\!+\!1$ ，当A中 $\mathtt{n}$ 个数恰好为 $\mathtt{1}\!\sim\!\mathtt{n}$ 时返回 $_{\mathrm{n+1}}$ 。当数组A中出现了小于或等于0或大于 $\mathtt{n}$ 的值时，会导致 $\mathtt{1}\!\sim\!\mathtt{n}$ 中出现空余位置，返回结果必然在 $1\!\sim\!\mathrm{n}$ 中，因此对于A中出现了小于或等于0或大于 $\mathtt{n}$ 的值，可以不采取任何操作。  

经过以上分析可以得出算法流程：从A[0]开始遍历A，若 $0\!<\!\mathtt{A}\left[\mathrm{~i~}\right]\!<\!\!=\!\!\mathrm{n}$ ，则令 $\mathsf{B}\left[\mathbb{A}\left[\dot{\mathbb{i}}\right]\mathbb{-}\mathbb{1}\right]\mathsf{=}\mathbb{1}$ 否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足 $\mathtt{B}\left[\dot{\mathtt{L}}\right]\mathrm{==}0$ 的下标i，返回 $\geq\pm1$ 即为结果，此时说明A中未出现的最小正整数在1和 $\mathtt{n}$ 之间。若B[i]全部不为0，返回 $\mathtt{i}+1$ （跳出循环时 $\scriptstyle{\dot{\mathbf{\rho}}}={\boldsymbol{\mathrm{n}}}$ ， $\mathtt{i}+\mathtt{1}$ 等于 $_{\mathrm{n+1}}$ ），此时说明A中未出现的最小正整数是 $_{\mathrm{n+1}}$  

2）算法实现：  

int find Miss Min（int A[l,int n)  
inti, $\star_{\mathsf{B}}$ //标记数组 $\mathtt{B}\!=$ （int \*）malloc（sizeof（int) ${}^{\star}\mathrm{n})$ ：/分配空间memset(B,O,sizeof（int) $\star_{\mathrm{n}})$ /赋初值为0for  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\dot{\mathbf{1}}}\leq n$   $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  if $(\mathtt{A}\,[\,\mathtt{i}\,]>\!0\,\mathtt{f}\,\mathtt{f}\mathtt{A}\,[\,\mathtt{i}\,]<=\mathtt{n})$ /若A[i]的值介于 $\mathtt{1}\!\sim\!\mathtt{n}$ ，则标记数组BB[A[i]  $-1]=1$  for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\mathrm{~i~}}<{\mathrm{n}}$   $\ \ \ \ \ \ \ \mathrm{i}_{ Ḋ }+\++ Ḍ$  //扫描数组B，找到目标值 if  $(\textsf{B}[\dot{\mathrm{~\mathbf{i~}}}]==0$  break; return $\pm1$ /返回结果  

3）时间复杂度：遍历A一次，遍历B一次，两次循环内操作步骤为 $O(1)$ 量级，因此时间复杂度为 $O(n)$ 。空间复杂度：额外分配了B[n]，空间复杂度为 $O(n)$  

14.【解答】  

分析。由 $D=\left|a-b\right|+\left|b-c\right|+\left|c-a\right|\geq0$ 有如下结论  

$\textcircled{\scriptsize{1}}$ 当 $a=b=c$ 时，距离最小。 $\circledcirc$ 其余情况。不失一般性，假设 $\scriptstyle a\leqslant b\leqslant c$ ，观察下面的数轴：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d6964726b38ffa443e58331e9e888368e3ccb0103edcae2ddb0866240cdc33b.jpg)  

由 $D$ 的表达式可知，事实上决定 $D$ 大小的关键是 $a$ 和 $^c$ 之间的距离，于是问题就可以简化为每次固定 $^c$ 找一个 $a$ ，使得 $L_{3}\!=\!\left|c-a\right|$ 最小。  

1）算法的基本设计思想  

$\textcircled{\scriptsize{1}}$ 使用 $D_{\mathrm{min}}$ 记录所有已处理的三元组的最小距离，初值为一个足够大的整数。  

$\circledcirc$ 集合 $S_{1}$  $S_{2}$ 和 $S_{3}$ 分别保存在数组 $A$ 、B、 $C$ 中。数组的下标变量 $i=j=k=0$ ，当 $i<|S_{1}|$  $j<|S_{2}|$ 且 $k<|S_{3}|$ 时（IS表示集合 $S$ 中的元素个数），循环执行下面的a） $\sim\!\!\mathrm{c}\,,$ 。  

a）计算（A $\{[i],B[j],C[k]\}$ 的距离 $D$ （计算 $D$  

b）若  $D<D_{\mathrm{min}}$  ，则  $D_{\mathrm{min}}\!=\!D$  （更新  $D$  

c）将A[]、BU]、C[]中的最小值的下标 $\scriptstyle{(+1}$ （对照分析：最小值为 $a$ ，最大值为 $^c$ ，这里 $^c$ 不变而更新 $a$ ，试图寻找更小的距离 $D$  

$\textcircled{3}$ 输出 $D_{\mathrm{min}}$ ，结束。  

2）算法实现：  

#define INT MAX Ox 7 ffffff f intabs_（inta）（//计算绝对值if  $(a\!<\!0$  return -a; elsereturn a; boolxls min（int a，intb，intc）{//aif  $\mathsf{a}\!<\!\mathsf{b}\,\&\,\mathsf{a}\!<\!\mathsf{c}\,,$  return true; return false; int find Min of Trip（int A[],int n,int B[],int m,int C[],int p)( I/Dmin用于记录三元组的最小距离，初值赋为INTMAX  
int  $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$   $\gimel=0$   $\kappa{=}0$  ,Dmin  $\scriptstyle{i=}$  INT MAX,D; while（i<n&&j<m&&k<p&&Dmin  ${>}0$   $\v{D}=$ abs （A[i]-B[j])+abs（B[j]-C[k])+abs （C[k]-A[i]);//计算Dif（D<Dmin)Dmin=D; //更新D if（xlsmin（A[i]，B[j],C[k])）i++;//更新aelse if（xls min（B[j],C[k],A[i]))j++; else  $\kappa++$  return D min;  

3）设 $n=(|S_{1}|+|S_{2}|+|S_{3}|)$ ，时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

# 2.3线性表的链式表示  

顺序表的存储位置可以用一个简单直观的公式表示，它可以随机存取表中任一元素，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，它通过“链”建立元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。  

# 2.3.1单链表的定义  

命题追踪单链表的应用（2009、2012、2013、2015、2016、2019）  

线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息之外，还需要存放一个指向其后继的指针。单链表结点结构如图2.3所示，其中data为数据域，存放数据元素；next为指针域，存放其后继结点的地址。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6fa3673aad165e0ee89896f2a7bb07ea19710710e0020c80d5ad6ca1178ca94.jpg)  
图2.3单链表结点结构  

单链表中结点类型的描述如下：  

typedef struct LNode{//定义单链表结点类型ElemType data;//数据域struct LNode \*next; //指针域 )LNode,\*LinkList;  

利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。  

通常用头指针L（或head等）来标识一个单链表，指出链表的起始地址，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，头指针L指向头结点，如图2.4（a）所示。单链表不带头结点时，头指针 $\mathbb{L}$ 指向第一个数据结点，如图2.4（b）所示。表尾结点的指针域为NULL（用“^”表示）。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/398b067cdafa61f8538dbc41329cc712b80fb0acc641764020ead99ba201cc41.jpg)  
图2.4带头结点和不带头结点的单链表  

头结点和头指针的关系：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。  

引入头结点后，可以带来两个优点：  

$\textcircled{\scriptsize{1}}$ 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。 $\circledcirc$ 无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。  

# 2.3.2单链表上基本操作的实现  

带头结点单链表的操作代码书写较为方便，如无特殊说明，本节均默认链表带头结点。  

# 1.单链表的初始化  

带头结点和不带头结点的单链表的初始化操作是不同的。带头结点的单链表初始化时，需要创建一个头结点，并让头指针指向头结点，头结点的next域初始化为NULL。  

bool InitList（LinkList &L)（  $\scriptstyle{\mathbb{L}}=$  (LNode\*)malloc(sizeof（LNode)) L->next  $=$  NULL; returntrue;  

//带头结点的单链表的初始化

//创建头结点?

//头结点之后暂时还没有元素结点不带头结点的单链表初始化时，只需将头指针L初始化为NULL。  

bool InitList（LinkList &L）{/不带头结点的单链表的初始化 $\scriptstyle\mathbb{L}=$  NULL; return true;  

# 注意  

设p为指向链表结点的结构体指针，则 $\star_{\mathtt{P}}$ 表示结点本身，因此可用 $\mathtt{p}^{->}$ data或 $({}^{\star}\mathtt{p})$ .data访问 ${}^{\star}\mathtt{p}$ 这个结点的数据域，二者完全等价。成员运算符（，）左边是一个普通的结构体变量，而指向运算符（ $->$ ）左边是一个结构体指针。通过 $({}^{\star}\mathtt{p})$ .next可以得到指向下一个结点的指针，因此 $({}^{\star}{\mathsf{p}})$ .next）.data就是下一个结点中存放的数据，或者直接用p->next->data。  

# 2.求表长操作  

求表长操作是计算单链表中数据结点的个数，需要从第一个结点开始依次访问表中每个结点，为此需设置一个计数变量，每访问一个结点，其值加1，直到访问到空结点为止。  

int Length（LinkList L)( int len  $=\!0$  /计数变量，初始为0 LNode  $\star_{\mathbb{P}=\mathbb{L}}$  while(p->next!  $=$  NULL){ p=p->next;  
lentt;//每访问一个结点，计数加1} return len;  

求表长操作的时间复杂度为 $O(n)$ 。另需注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。  

# 3.按序号查找结点  

从单链表的第一个结点开始，沿着next域从前往后依次搜索，直到找到第i个结点为止，则返回该结点的指针；若1小于单链表的表长，则返回NULL。  

LNode \*GetElem（LinkList L,int i）LNode  $\scriptstyle{^{\star}\!\mathrm{p}=\mathrm{L}}$  //指针p指向当前扫描到的结点 int $\scriptstyle{\mathrm{j}}=0$ //记录当前结点的位序，头结点是第0个结点while(p！ $=$ NULL&&j<i){川循环找到第i个结点p=p->next; j++; returnp;//返回第i个结点的指针或NULL  

按序号查找操作的时间复杂度为 $O(n)$  

# 4.按值查找表结点  

从单链表的第一个结点开始，从前往后依次比较表中各结点的数据域，若某结点的data域等于给定值e，则返回该结点的指针：若整个单链表中没有这样的结点，则返回NULL。  

LNode \*LocateElem(LinkList L,ElemType e）(LNode  $\star_{\mathbb{P}=\mathbb{L}}$  ->next; while $({\mathfrak{p}}!=$ NULL&&p->data $!\!=\!\!\mathrm{e}$ ）//从第一个结点开始查找数据域为e的结点p=p->next; returnp;//找到后返回该结点指针，否则返回NULL  

按值查找操作的时间复杂度为 $O(n)$  

# 5.插入结点操作  

插入结点操作将值为x的新结点插入到单链表的第i个位置。先检查插入位置的合法性，然后找到待插入位置的前驱，即第i-1个结点，再在其后插入。其操作过程如图2.5所亲。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c0375c05b578e5cce59c4e076019d3589f8e5286d2baae292fc776a326f2b50.jpg)  
图2.5单链表的插入操作  

# 命题追踪单链表插入操作后地址或指针的变化（2016）  

首先查找第i-1个结点，假设第i-1个结点为\*p，然后令新结点\*s的指针域指向 ${}^{\star}\mathtt{p}$ 的后继，再令结点 $\star_{\mathsf{P}}$ 的指针域指向新插入的结点\*s。  

bool ListInsert（LinkList &L,int i,ElemType e）(LNode $\star_{\mathrm{p=L}}$ /指针指向当前扫描到的结点  
int $\scriptstyle{\dot{\mathbf{j}}}=0$ //记录当前结点的位序，头结点是第0个结点while（p!=NULL&&j<i-l){//循环找到第i-1个结点p=p->next; j++; 1 if( $\mathtt{p}^{==}$ NULL)//i值不合法return false; LNode  ${\bf\Pi}^{+}\,\mathbf{s}=$  （LNode\*)malloc（sizeof(LNode)); s->data  $\mathbf{\Sigma}=\mathbf{e}$  //图2.5中操作步骤  $^\mathrm{\textregistered}$  s->next=p->next; p->next  $=_{\mathrm{S}}$  //图2.5中操作步骤  $\circledcirc$  returntrue;  

插入时， $\textcircled{\scriptsize{1}}$ 和 $^{(\mathcal{Q})}$ 的顺序不能颠倒，否则，先执行p->next $=\scriptstyle{S}$ 后，指向其原后继的指针就不存在了，再执行s->next=p->next时，相当于执行了s->next $=\!s$ ，显然有误。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为 $O(n)$ 。若在指定结点后插入新结点，则时间复杂度仅为 $O(1)$ 。需注意的是，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。当链表带头结点时，插入位置i为1时不用做特殊处理。  

# 扩展：对某一结点进行前插操作。  

前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反。在单链表插入算法中，通常都采用后插操作。以上面的算法为例，先找到第i-1个结点，即插入结点的前驱，再对其执行后插操作。由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为 $O(n)$  

此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为\*s，将\*s插入到 ${}^{\star}\mathtt{p}$ 的前面。我们仍然将 $\star_{\mathrm{S}}$ 插入到 $\star_{\mathsf{P}}$ 的后面，然后将 $\mathtt{p}^{->}$ data与s->data交换，这样做既满足逻辑关系，又能使得时间复杂度为 $O(1)$ 。该方法的主要代码片段如下：  

s->next=p->next;/修改指针域，不能颠倒p->next  $=_{S}$  /交换数据域部分temp=p->data; p->data  $=s$  ->data; s->data  $=$  temp;  

# 6.删除结点操作  

删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱，再删除第i个结点。其操作过程如图2.6所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3cff0f15ae62a7658d4029b54b7c524e489abc7ce64fc2f8b4114f13cb1b6922.jpg)  
图2.6单链表结点的删除  

假设结点  ${}^{\star}\mathtt{p}$  为找到的被删结点的前驱，为实现这一操作后的逻辑关系的变化，仅需修改\*p 的指针域，将 ${}^{\star}\mathtt{p}$ 的指针域next指向 ${\star}_{\overline{{\mathbf{q}}}}$ 的下一结点，然后释放 ${\star}_{\overline{{\mathbf{q}}}}$ 的存储空间。  

bool ListDelete（LinkList &L,int i,ElemType &e）{LNode  $\scriptstyle{^{\star}\!\mathrm{p}=\mathrm{L}}$  //指针p指向当前扫描到的结点 int $\scriptstyle{\dot{\mathbf{j}}}=0$ //记录当前结点的位序，头结点是第0个结点  
while(p $=$ NULL&&j<i-l）{/循环找到第i-1个结点p=p->next; j++; if $\scriptstyle(\mathtt{p}==$ NULLIIp->next $==$ NULL）/i值不合法return false; LNode \*g=p->next;l/令g指向被删除结点e=g->data; //用e返回元素的值 p->next  $=$  q->next; //将\*g结点从链中“断开” free（g);//释放结点的存储空间return true;  

同插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为 $O(n)$ 。当链表不带头结点时，需要判断被删结点是否为首结点，若是，则要做特殊处理，将头指针工指向新的首结点。当链表带头结点时，删除首结点和册除其他结点的操作是相同的。  

# 扩展：删除结点\*p。  

要删除某个给定结点\*p，通常的做法是先从链表的头结点开始顺序找到其前驱，然后执行删除操作。其实，删除结点 $\star_{\mathsf{P}}$ 的操作可用删除 $\star_{\mathsf{P}}$ 的后继来实现，实质就是将其后继的值赋予其自身，然后再删除后继，也能使得时间复杂度为 $O(1)$ 。该方法的主要代码片段如下：  

g=p->next;l/令g指向\*p的后继结点p->data=p->next->data;//用后继结点的数据域覆盖p->next  $=$  q->next; //将\*g结点从链中“断开” free(q);/释放后继结点的存储空间  

# 7.采用头插法建立单链表  

该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后，如图2.7所示。算法实现如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a0f50bf826f84ac70af0ce65dd698cb2777cd8ad0fbbf5ade4fd81ade304e3b.jpg)  
图2.7头插法建立单链表  

Link List List Head Insert（LinkList&L）/逆向建立单链表LNode $\star_{\mathbb{S}}$ ;int x;//设元素类型为整型 $\scriptstyle{\mathrm{L}}=$  (LNode\*)malloc(sizeof(LNode)); //创建头结点 L->next $=$ NULL;//初始为空链表scanf（"d",&x）; //输入结点的值 while $(\mathbf{x}!=\!9\,9\,9\,9$ ）/输入9999表示结束 $s\mathrm{=}$ （LNode\*）malloc（sizeof（LNode））;//创建新结点s->data  $=\times$  s->next  $\mathbf{\mu=}\mathbb{L}$  ->next; L->next $=s$ /将新结点插入表中，L为头指针scanf（"d",&x）;  
return L;  

采用头插法建立单链表时，读入数据的顺序与生成的链表中元素的顺序是相反的，可用来实现链表的逆置。每个结点插入的时间为 $O(1)$ ，设单链表长为 $n$ ，则总时间复杂度为 $O(n)$  

思考：若单链表不带头结点，则上述代码中哪些地方需要修改？  

# 8.采用尾插法建立单链表  

头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点，如图2.8所示。算法实现如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/caee33cb8b607abfcd1c170d3d509e082c3a669d7ba7c8ce5ac880058ba46053.jpg)  
图2.8尾插法建立单链表  

LinkList List Tail Insert（LinkList&L）（//正向建立单链表intx; //设元素类型为整型  $\scriptstyle{\mathrm{L}}=$  (LNode\*)malloc(sizeof(LNode)); //创建头结点 LNode  $\star_{\textsf{S}}$  ，  $\star_{\mathbb{X}}=\mathbb{L}$  八  $//x$  为表尾指针 scanf("%d",  $\&x)$  /输入结点的值 while  $\{\mathbf{x}\}{\overset{}{=}}9999$  /输入9999表示结束  $s\mathrm{=}$  (LNode\*)malloc（sizeof（LNode)); s->data  $=\!\mathrm{x}$  r->next  $=_{S}$   $\scriptstyle{\boldsymbol{\mathtt{T}}}={\boldsymbol{\mathtt{S}}}$  $//x$ 指向新的表尾结点scanf（"d"，&x）; r->next $=$ NULL;//尾结点指针置空return L;  

因为附设了一个指向表尾结点的指针，所以时间复杂度和头插法的相同。  

# 注意  

单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通过画图的方法理清算法的思路，然后进行算法的编写。人  

# 2.3.3双链表  

单链表结点中只有一个指向其后继的指针，使得单链表只能从前往后依次遍历。要访问某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为 $O(n)$ 。为了克服单链表的这个缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其直接前驱和直接后继，如图2.9所示。表头结点的prior域和尾结点的next域都是NULL。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1635ec70559d4b6472f60c5d1cc749f0d1f5b25b6eea5c3edfbc5341580c00e.jpg)  
图2.9双链表示意图  

双链表中结点类型的描述如下：  

typedef struct DNode El em Type data;struct DNode \*prior,\*next; }DNode,\*DLinklist;  

//定义双链表结点类型

//数据域

//前驱和后继指针 双链表在单链表结点中增加了一个指向其前驱的指针prior，因此双链表的按值查我和按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对指针prior做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到当前结点的前驱，因此，插入、删除操作的时间复杂度仅为 $O(1)$  

# 1.双链表的插入操作  

在双链表中p所指的结点之后插入结点\*s，其指针的变化过程如图2.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83f654980bafc9b4794791269186265e596e1c3d8f28a962817e021ff1cd4ecb.jpg)  
图2.10双链表插入结点过程  

# 命题追踪双链表中插入操作的实现（2023）  

插入操作的代码片段如下：  

$\textcircled{\scriptsize{1}}$  s->next=p->next;

  $\circledcirc$  p->next->prior  $=_{\mathsf{S}}$   $\textcircled{3}$  s->prio  $\scriptstyle{\mathfrak{r}}={\mathfrak{p}}$   $\textcircled{4}$  p->next  $=\tt s$  

//将结点\*s插入到结点\*p之后  

上述代码的语句顺序不是唯一的，但也不是任意的， $\textcircled{\scriptsize{1}}$ 步必须在 $^{;(4)}$ 步之前，否则 $\star_{\mathbb{P}}$ 的后继结点的指针就会丢掉，导致插入失败。为了加深理解，读者可以在纸上画出示意图。若问题改成要求在结点 $\star_{\mathsf{P}}$ 之前插入结点 $\star_{\mathrm{S}}$ ，请读者思考具体的操作步骤。  

# 2.双链表的删除操作  

删除双链表中结点 $\star_{\mathsf{P}}$ 的后继结点 $\star_{\overline{{\mathbf{q}}}}$ ，其指针的变化过程如图2.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/07a13dc6f25520117417e37802a59a25f2e5a4c2ffabd489689bf7af1c7b9b20.jpg)  
图2.11双链表删除结点过程  

# 命题追踪循环双链表中删除操作的实现（2016）  

删除操作的代码片段如下：  
p->next=g->next; /图2.11中步骤  $^{(\!-)}$  g->next->prior  $\tt=p$  /图2.11中步骤  $\mathcal{Q}$  free（g);//释放结点空间  

若问题改成要求删除结点 ${\star}_{\mathbb{q}}$ 的前驱结点\*p，请读者思考具体的操作步骤。  

在建立双链表的操作中，也可采用如同单链表的头插法和尾插法，但在操作上需要注意指针的变化和单链表有所不同。  

# 2.3.4循环链表  

# 1.循环单链表  

循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环，如图2.12所示。  

在循环单链表中，表尾结点 $\star_{\underline{{{x}}}}$ 的next域指向L，敌表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针L。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1036b7d9f88e230ec8d510ec10fb16a52bbd3942f1269b375f972803c8fba3d.jpg)  
图2.12循环单链表  

# 命题追踪循环单链表中删除首元素的操作（2021）  

循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，所以在任何位置上的插入和删除操作都是等价的，而无须判断是否是表尾。  

在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表。有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。其原因是，若设的是头指针，对在表尾插入元素需要 $O(n)$ 的时间复杂度，而若设的是尾指针r，r->next即为头指针，对在表头或表尾插入元素都只需要 $O(1)$ 的时间复杂度。  

# 2.循环双链表  

由循环单链表的定义不难推出循环双链表。不同的是，在循环双链表中，头结点的prior指针还要指向表尾结点，如图2.13所示。当某结点 $\star_{\mathsf{P}}$ 为尾结点时， $\mathtt{p}$ ->next $==_{\mathbb{L}}$ ：当循环双链表为空表时，其头结点的prior域和next域都等于L。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f089f98aeac64cd154c17a4d590a4678fbf669cfc40bf052cc22d399064c7fb7.jpg)  
图2.13循环双链表  

# 2.3.5静态链表  

静态链表是用数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是结点在数组中的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。  

静态链表和单链表的对应关系如图2.14所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4344735f5bafa80a6ad93380b6299d5fabec7267fba214b27a248cce1475d949.jpg)  
图2.14静态链表存储示意图  

静态链表结构类型的描述如下：  

#define MaxSize 50//静态链表的最大长度typedef struct{ //静态链表结构类型的定义 ElemType data;//存储数据元素int next;//下一个元素的数组下标SLinkList[MaxSize];  

静态链表以next  $==-1$  作为其结束的标志。静态链表的插入、删除操作与动态链表的相同， 只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法。  

# 2.3.6 顺序表和链表的比较  

# 1.存取（读/写）方式  

顺序表可以顺序存取，也可以随机存取，链表只能从表头开始依次顺序存取。例如在第 $i$ 个位置上执行存取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问 $i$ 次。  

# 2.逻辑结构与物理结构  

采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的，  

# 3.查找、插入和删除操作  

对于按值查找，顺序表无序时，两者的时间复杂度均为 $O(n)$ ；顺序表有序时，可采用折半查找，此时的时间复杂度为 $O(\log_{2}n)$ 。对于按序号查找，顺序表支持随机访问，时间复杂度仅为 $O(1)$ 而链表的平均时间复杂度为 $O(n)$ 。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。  

# 4.空间分配  

顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。此外，由于链表的每个结点都带有指针域，因此存储密度不够大。  

在实际中应该怎样选取存储结构呢？  

# 1.基于存储的考虑  

难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。  
# 2.基于运算的考虑  

在顺序表中按序号访问 $a_{i}$ 的时间复杂度为 $O(1)$ ，而链表中按序号访问的时间复杂度为 $O(n)$ 因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。  

在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。  

# 3.基于环境的考虑  

顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。  

总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宣选择链式存储。  

# 注意  

只有熟练掌握顺序存储和链式存储，才能深刻理解它们的优缺点。  

# 2.3.7 本节试题精选  

# 一、单项选择题  

01.关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（）  

I.线性表的顺序存储结构优于其链式存储结构II.链式存储结构比顺序存储结构能更方便地表示各种逻辑结构III.若频繁使用插入和删除结点操作，则顺序存储结构更优于链式存储结构IV.顺序存储结构和链式存储结构都可以进行顺序存取  

A.I、ⅡI、ⅢIB.II、IVC.II、IⅢID.III、IV  

02.对于一个线性表，既要求能进行较快速地插入和删除，又要求存储结构能反映数据之间的逻辑关系，则应该用（）。  

A.顺序存储方式，B.．链式存储方式C.散列存储方式，D.以上均可以03.链式存储设计时，结点内的存储单元地址（）  

A.一定连续 B.一定不连续 C.不一定连续D.部分连续，部分不连续  

04.下列关于线性表说法中，正确的是（）  

1.顺序存储方式只能用于存储线性结构II.在一个设有头指针和尾指针的单链表中，删除表尾元素的时间复杂度与表长无关IⅢ1.带头结点的单循环链表中不存在空指针IV.在一个长度为 $n$ 的有序单链表中插入一个新结点并仍保持有序的时间复杂度为 $O(n)$ V.若用单链表来表示队列，则应该选用带尾指针的循环链表  

A.I、IⅡIB.I、IⅢI、IV、VC.IV、VD.IⅢI、IV、V05.设线性表中有 $2n$ 个元素，（）在单链表上实现要比在顺序表上实现效率更高  

A.删除所有值为 $x$ 的元素B.在最后一个元素的后面插入一个新元素  
C.顺序输出前 $k$ 个元素D.交换第  $i$  个元素和第  $2n\!-\!i\!-\!1$  个元素的值（  $i\!=\!0,\cdots,n\!-\!1\,)$  

06.在一个单链表中，已知g所指结点是p所指结点的前驱结点，若在 $\sphericalangle$ 和p之间插入结点S，则执行（）。  

A.s->next=p->next;p->next  $=_{S}$  B.p->next  $=$  s->next;s->next  $\tt=p$  C.q->next  $=_{\mathrm{S}}$  ;s->next=p; D.p->next  $=\scriptstyle{\mathrm{s}}$  ;s->next=q;  

07.给定有 $n$ 个元素的一维数组，建立一个有序单链表的最低时间复杂度是（）  

A. 0(1) B. O(n) C. 0(n²) D. O(nlog2n)  

08.将长度为 $n$ 的单链表链接在长度为 $m$ 的单链表后面，其算法的时间复杂度采用大 $O$ 形式表示应该是（）。  

A.0(1)K B.O(n) C. 0(m) D.O(n+m)  

09.单链表中，增加一个头结点的目的是（）  

A.使单链表至少有一个结点B.标识表结点中首结点的位置C.方便运算的实现D.说明单链表是线性表的链式存储  

10.在一个长度为 $n$ 的带头结点的单链表 $h$ 上，设有尾指针r，则执行（）操作与链表的表长有关。  

A.删除单链表中的第一个元素B.删除单链表中的最后一个元素C.在单链表第一个元素前插入一个新元素D.在单链表最后一个元素后插入一个新元素  

11.对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（）；对于不带头结点的单链表，判定空表的条件为（）。  

A.head  $==$  NULL B.head->next  $==$  NULL C.head->next  $==$  head D.head!  $=$  NULL  

12.在线性表 $a_{0},a_{1},\cdots,a_{100}$ 中，删除元素 $a_{50}$ 需要移动（）个元素。A.0 B.50 C.51 D.0或50

 13.通过含有 $n\left(\,n>1\,\right)$ 个元素的数组 $^a$ ，采用头插法建立单链表L，则 $L$ 中的元素次序（）  

A.与数组  $a$  的元素次序相同 B.与数组  $a$  的元素次序相反 C.与数组 $a$ 的元素次序无关D.以上都错误  

14.下面关于线性表的一些说法中，正确的是（）  

A.对一个设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度无关B.线性表中每个元素都有一个直接前驱和一个直接后继C.为了方便插入和删除数据，可以使用双链表存放数据D.取线性表第i个元素的时间与i的大小有关  

15.在双链表中向p所指的结点之前插入一个结点g的操作为（）  

A.p->prior  $\mathbf{\lambda=}\mathbf{q}$  ;q->next=p;p->prior->next=q;q->prior=p->prior; B.q->prior=p->prior;p->prior->next=q;q->next=p;p->prior=q->next; C.q->next  $\tt=p$  ;p->next  $=$  q;q->prior->next  $=$  q;q->next=p; D.p->prior->next=q;q->next=p;q->prior=p->prior;p->prior=q;  

16.在双向链表存储结构中，删除P所指的结点时必须修改指针（）。A.p->prior->next=p->next;p->next->prior=p->prior; B.p->prior=p->prior->prior;p->prior->next=p; C.p->next->prio  $x{=}{\mathfrak{p}}$  ;p->next  $=$  p->next->next; D.p->next=p->prior->prior;p->prior=p->next->next;  
17.在如下图所示的双链表中，已知指针p指向结点 $A$ ，若要在结点 $A$ 和 $C$ 之间插入指针g所指的结点 $B$ ，则依次执行的语句序列可以是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfe7fccc34231ff30ee932ab7f82fa0a0417709ae4cc8c37b92e75ae9234f245.jpg)  

$\textcircled{\scriptsize{1}}$  q->next=p->next;  $\textcircled{2}$  q->prio  $x{=}{\mathtt{p}}$   $\textcircled{3}$  p->next  $\mathbf{\Sigma}=\mathbf{q}_{i}$   $\textcircled{4}$  p->next->prior=q;  

A.  $\textcircled{\scriptsize{1}}$  24③ B.  $\mathbf{\mathscr{A}})\mathscr{Q})\mathscr{Q})\mathscr{Q})$  C.  $\circledcirc\!(4)\!(1)\!(2)$  D.①③④②  

18.在双链表的两个结点之间插入一个新结点，需要修改（）个指针域。  

A.1 B.3 C.4 D.2  

19.在长度为 $n$ 的有序单链表中插入一个新结点，并仍然保持有序的时间复杂度是（）  

A.  $O(1)$  B.O(n) C.  $O(n^{2})$  D.O(nlog2n)  

20.与单链表相比，双链表的优点之一是（）  

A.插入、删除操作更方便B.可以进行随机访问C.可以省略表头指针或表尾指针D.访问前后相邻结点更灵活  

21.对于一个带头结点的循环单链表工，判断该表为空表的条件是（）  

A.头结点的指针域为空B.L的值为NULLC.头结点的指针域与工的值相等D.头结点的指针域与工的地址相等  

22.对于一个带头结点的双循环链表工，判断该表为空表的条件是（）  

A.L->prior  $==$  L&&L->next  $==$  NULL B.L->prior  $\mathrel{\mathop:}=$  NULL&&L->next  $==$  NULL C.L->prior  $==$  NULL&&L->next  $==\mathbb{L}$  D.L->prior  $==$  L&&L->next  $==_{\mathbb{L}}$  

23.一个链表最常用的操作是在末尾插入结点和删除结点，则选用（）最节省时间。  

A.带头结点的双循环链表B.单循环链表C.带尾指针的单循环链表D.单链表  

24.设对 $n$  $n>1$ ）个元素的线性表的运算只有4种：删除第一个元素；删除最后一个元素在第一个元素之前插入新元素；在最后一个元素之后插入新元素，则最好使用（）。  

A.只有尾结点指针没有头结点指针的循环单链表B.只有尾结点指针没有头结点指针的非循环双链表C.只有头结点指针没有尾结点指针的循环双链表D.既有头结点指针又有尾结点指针的循环单链表  

25.设有两个长度为 $n$ 的循环单链表，若要求两个循环单链表的头尾相接的时间复杂度为 $O(1)$ ，则对应两个循环单链表各设置一个指针，分别指向（）。  

A.各自的头结点B.各自的尾结点C.各自的首结点D.一个表的头结点，另一个表的尾结点  

26.设有一个长度为 $n$ 的循环单链表，若从表中删除首元结点的时间复杂度达到 $O\left(n\right)$ ，则此时采用的循环单链表的结构可能是（）  

A.只有表头指针，没有头结点B.只有表尾指针，没有头结点C.只有表尾指针，带头结点D.只有表头指针，带头结点  
27.某线性表用带头结点的循环单链表存储，头指针为head，当head->next-  $\cdot>$  next  $==$  head成立时，线性表的长度可能是（）。  

A.0B.1C.2D.可能为0或1  

28.有两个长度都为 $n$ 的双链表，若以 $h_{1}$ 为头指针的双链表是非循环的，以 $h_{2}$ 为头指针的双链表是循环的，则下列叙述中正确的是（）。  

A.对于双链表 $h_{1}$ ，删除首结点的时间复杂度是 $O(n)$ B.对于双链表 $h_{2}$ ，删除首结点的时间复杂度是 $O(n)$ C.对于双链表  $h_{1}$  ，删除尾结点的时间复杂度是  $O(1)$  D.对于双链表  $h_{2}$  ，删除尾结点的时间复杂度是  $O(1)$  

29.一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素，则选用（）最节省时间。  

A.不带头结点的单循环链表B.双链表C.单链表D.不带头结点且有尾指针的单循环链表  

30：需要分配较大空间，插入和删除不需要移动元素的线性表，其存储结构为（）A.单链表B.静态链表C.顺序表D.双链表

31.下列关于静态链表的说法中，正确的是（）。  

工.静态链表兼具顺序表和单链表的优点，因此存取表中第 $i$ 个元素的时间与i无关II1.静态链表能容纳的最大元素个数在表定义时就确定了，以后不能增加II.静态链表与动态链表在元素的插入、删除上类似，不需要移动元素VI.相比动态链表，静态链表可能浪费较多的存储空间  

A.I、II、ⅢIB.II、II、VIC.I、ⅢI、VID.I、II、VI  

32.【2016统考真题】已知一个带有表头结点的双向循环链表L，结点结构为prevdatanext其中prev和next分别是指向其直接前驱和直接后继结点的指针。现要删除指针p所指的结点，正确的语句序列是（）。  

A.p->next->prev=p->prev;p->prev->next  $=$  p->prev;free（p); B.p->next->prev $=$ p->next;p->prev->next $=$ p->next;free（p);C.p->next->prev=p->next;p->prev->next=p->prev;free(p); D.p->next->prev=p->prev;p->prev->next $\scriptstyle\cdot^{*}$ p->next;free（p);  

33.【2016统考真题】已知表头元素为C的单链表在内存中的存储状态如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22bf0e36e19b549128121062fae1f3ba5a662570a091e157dcbedf35e81fc63e.jpg)  

现将f存放于1014H处并插入单链表，若f在逻辑上位于a和e之间，则a、e、f的“链接地址”依次是（）。  

A.1010H、1014H、1004HB.1010H、1004H、1014HC.1014H、1010H、1004HD.1014H、1004H、1010H  

34.【2021统考真题】已知头指针h指向一个带头结点的非空单循环链表，结点结构为datanext，其中 next 是指向直接后继结点的指针，p 是尾指针，α是临时指针。现要删除该链表的第一个元素，正确的语句序列是（）。  
A.h->next  $\mathrm{=h}\,.$  ->next->next;q=h->next;free(q); B.q=h->next;h->next  $\mathrm{=h}$  ->next->next;free(g); C.q=h->next;h->next $\scriptstyle{\cdot=}$ q->next;if $\scriptstyle(\mathtt{p}\;!=\mathtt{q})$  $\mathtt{p}{=}\mathtt{h}$ ;free（q);D.q=h->next;h->next $=$ q->next;if（ $\scriptstyle{\cdot{\bf p}=={\bf q}}.$  $\mathtt{p}^{=\mathtt{h}}$ ;free（q);  

35.【2023统考真题】现有非空双向链表L，其结点结构为prevdatanext，prev是指向直 接前驱结点的指针，next是指向直接后继结点的指针。若要在工中指针p所指向的结点（非尾结点）之后插入指针s指向的新结点，则在执行语句序列“s->next $=$ p->next;p->next $=\!\mathrm{S}$ ；”后，下列语句序列中还需要执行的是（）。  

A.s->next->prev  $\tt=p$  ;s->prev  $\tt=p$  B.p->next->prev  $\scriptstyle{\varepsilon=s}$  ;s->prev  $\tt=p$  C. s->prev  $=$  s->next->prev; s->next->prev  $=\!\mathrm{S}$  D.p->next->prev  $=\!s$  ->prev; s->next->prev  $\tt=p$  

# 二、综合应用题  

01.在带头结点的单链表L中，删除所有值为X的结点，并释放其空间，假设值为×的结点不唯一，试编写算法以实现上述操作。  

02.试编写在带头结点的单链表工中删除一个最小值结点的高效算法（假设该结点唯一）。  

03.试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为  $O(1).$  

04.设在一个带表头结点的单链表中，所有结点的元素值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素（若存在）。  

05.给定两个单链表，试分析找出两个链表的公共结点的思想（不用写代码）  

06.设 $C=\{a_{1},b_{1},a_{2},b_{2},\cdots,a_{n},b_{n}\}$ 为线性表，采用带头结点的单链表存放，设计一个就地算法，将其拆分为两个线性表，使得 $A=\{a_{1},a_{2},\cdots,a_{n}\}\,,\,\,\,B=\{b_{n},\cdots,b_{2},b_{1}\}\,.$  

07.在一个递增有序的单链表中，存在重复的元素。设计算法删除重复的元素，例如（7，10，10,21,30,42,42,42,51,70）将变为（7,10,21,30,42,51,70)。  

08.设 $A$ 和 $B$ 是两个单链表（带头结点），其中元素递增有序。设计一个算法从 $A$ 和 $B$ 中的公共元素产生单链表 $C$ ，要求不破坏 $A$ 、 $B$ 的结点。  

09.已知两个链表 $A$ 和 $B$ 分别表示两个集合，其元素递增排列。编制函数，求 $A$ 与 $B$ 的交集，并存放于 $A$ 链表中。  

10.两个整数序列 $A\,{=}\,a_{1},a_{2},a_{3},\cdots,a_{m}$ 和 $B\,{=}\,b_{1},\,b_{2},\,b_{3},\cdots,\,b_{n}$ 已经存入两个单链表中，设计一个算法，判断序列 $B$ 是否是序列 $A$ 的连续子序列。  

11.设计一个算法用于判断带头结点的循环双链表是否对称。  

12.有两个循环单链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表hl之后，要求链接后的链表仍保持循环链表形式。  

13.设有一个带头结点的非循环双链表L，其每个结点中除有pre、data和next域外，还有一个访问频度域freq，其值均初始化为零。每当在链表中进行一次Locate $(\mathbb{L},\mathbb{x})$ 运算时，令值为x的结点中freq域的值增1，并使此链表中的结点保持按访问频度递减的顺序排列，且最近访问的结点排在频度相同的结点之前，以使使频繁访问的结点总是靠近表头。试编写符合上述要求的Locate $\left(\mathbb{L},\mathbb{x}\right)$ 函数，返回找到结点的地址，类型为指针型。  
14.设将 $n$ C $n>1$ ）个整数存放到不带头结点的单链表 $L$ 中，设计算法将 $L$ 中保存的序列循环右移 $k$  $\ 0<k<n$ ）个位置。例如，若 $k\!=\!1$ ，则将链表 $\{0,1,2,3\}$ 变为 $\{3,0,1,2\}$ 。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

15.单链表有环，是指单链表的最后一个结点的指针指向了链表中的某个结点（通常单链表的最后一个结点的指针域是空的）。试编写算法判断单链表是否存在环。  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  

16．设有一个长度 $n$  $n$ 为偶数）的不带头结点的单链表，且结点值都大于0，设计算法求这个单链表的最大季生和。季生和定义为一个结点值与其季生结点值之和，对于第 $i$ 个结点（从0开始），其李生结点为第 $n-i-1$ 个结点。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你的算法的时间复杂度和空间复杂度。  

17.【2009统考真题】已知一个带有表头结点的单链表，结点结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/919d1d66f3efff88c71898e900a3282f3b88276548933ef8ea1a0b184a7f413c.jpg)  

假设该链表只给出了头指针1ist。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 $k$ 个位置上的结点（ $k$ 为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求：  

1）描述算法的基本设计思想2）描述算法的详细实现步骤。3）根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、 $\mathrm{C++}$ 或Java语言实现），关键之处请给出简要注释。  

18.【2012统考真题】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如，loading和being的存储映像如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c46a0dd05df7b90d2eac3b52c4725e4aca43dfd1cb63c2c093fa68a091c3cd63.jpg)  

设strl和Str2分别指向两个单词所在单链表的头结点，链表结点结构为datanext请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置（如图中字符i所在结点的位置p）。要求：  

1）给出算法的基本设计思想2）根据设计思想，采用C或 $\mathrm{C++}$ 或Java语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度。  

19.【2015统考真题】用单链表保存  $m$  个整数，结点的结构为[data][link]，且ldata| n( $n$ 为正整数）。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下：  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5c559430faffaf9831f3fa0fc9d77f2468da19e8c3e002953ae6c61d6eecc868.jpg)  

则删除结点后的head为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/93b511140044f3eb07ec01132460e67d4c3be8026d55a43a7521b90a01b51b34.jpg)  

要求：  

1）给出算法的基本设计思想。2）使用C或 $\mathrm{C++}$ 语言，给出单链表结点的数据类型定义。3）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释4）说明你所设计算法的时间复杂度和空间复杂度。  

20.【2019统考真题】设线性表  $L=(a_{1},a_{2},a_{3},\cdots,a_{n-2},a_{n-1},a_{n})$  采用带头结点的单链表保存，链 表中的结点定义如下：  

typedef struct node int data; struct node\*next; }NODE;  

请设计一个空间复杂度为 $O(1)$ 且时间上尽可能高效的算法，重新排列 $L$ 中的各结点，得到线性表 $L^{\prime}\,{=}\,(a_{1},a_{n},a_{2},a_{n-1},a_{3},a_{n-2},\cdots)$ ·要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计的算法的时间复杂度。  

# 2.3.8 答案与解析  

# 一、单项选择题  

01.B  

两种存储结构适用于不同的场合，不能简单地说谁好谁坏，1错误。链式存储用指针表示逻辑结构，而指针的设置是任意的，因此比顺序存储结构能更方便地表示各种逻辑结构，Ⅱ1正确。在顺序存储中，插入和删除结点需要移动大量元素，效率较低，1ⅢI的描述刚好相反。顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取，IV正确。必  

02.B  

首先直接排除A和D。散列存储通过散列函数映射到物理空间，不能反映数据之间的逻辑关系，排除C。链式存储能方便地表示各种逻辑关系，且插入和删除操作的时间复杂度为 $O(1)$  

03.A  

链式存储设计时，各个不同结点的存储空间可以不连续，但结点内的存储单元地址必须连续。  

04.D  

顺序存储方式同样适用于存储图和树，1错误。删除表尾结点时，必须从头开始找到表尾结点的前驱，其时间与表长有关，IⅡI错误。循环单链表中最后一个结点的指针不是NULL，而是指向头结点，整个链表形成一个环，因此不存在空指针，Ⅲ正确。有序单链表只能依次查找插入位置，时间复杂度为  $O(n)$  ，IV正确。队列需要在表头删除元素，表尾插入元素，采用带尾指针的循 环链表较为方便，插入和删除的时间复杂度都为 $O(1)$ ，V正确。  
05. A  

对于A，在单链表和顺序表上实现的时间复杂度都为 $O(n)$ ，但后者要移动很多元素，因此在单链表上实现效率更高。对于B和D，顺序表的效率更高。C无区别。  

06.C  

s插入后，g成为s的前驱，而p成为s的后继，选C。  

# 注意  

可能有读者认为选项C中的两条语句交换后才正确。实际上，因为本题插入位置的前后结点都有指针指示（这与前面介绍的插入操作是不同的），所以选项C中的语句顺序并不会造成断链。在此提醒读者在学习过程中一定要多动脑思考，而不要生搬硬套。  

07.D  

若先建立链表，然后依次插入建立有序表，则每插入一个元素就需遍历链表寻找插入位置，即直接插入排序，时间复杂度为 $O(n^{2})$ 。若先将数组排好序，然后建立链表，建立链表的时间复杂度为 $O(n)$ ，数组排序的最好时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，总时间复杂度为 $O(n\log_{2}n)$ 。故选D。  

08. C  

先遍历长度为 $m$ 的单链表，找到该单链表的尾结点，然后将其next域指向另一个单链表的首结点，其时间复杂度为 $O(m)$  

09. C  

单链表设置头结点的目的是方便运算的实现，主要好处体现在：第一，有头结点后，插入和删除数据元素的算法就统一了，不再需要判断是否在第一个元素之前插入或删除第一个元素；第二，不论链表是否为空，其头指针是指向头结点的非空指针，链表的头指针不变，因此空表和非空表的处理也就统一了。  

10.B  

删除单链表的最后一个结点需置其前驱结点的指针域为NULL，需要从头开始依次遍历找到该前驱结点，需要 $O(n)$ 的时间，与表长有关。其他操作均与表长无关，读者可自行模拟。  

11.B，A  

在带头结点的单链表中，头指针head指向头结点，头结点的next域指向第一个元素结点，head->next $==$ NULL表示该单链表为空。在不带头结点的单链表中，head直接指向第一个元素结点，head $==$ NULL表示该单链表为空。  

12.D  

线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素 $a_{50}$ 不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。  

13.B  

当采用头插法建立单链表时，数组后面的元素插入到单链表 $L$ 的最前端，所以 $L$ 中的元素次序与数组  $a$  的元素次序相反。  

14.C  

A显然错误。B表中第一个元素和最后一个元素不满足题设要求。双链表能很方便地访问前 驱和后继，敌删除和插入数据较为方便，C正确。D未考虑顺序存储的情况。  

15.D 为了在p之前插入结点q，可以将p的前一个结点的next域指向q，将g的next域指向p，将g的prior域指向p的前一个结点，将p的prior域指向q。仅D满足条件。  
16.A  

与上一题的分析基本类似，只不过这里是删除一个结点，注意将p的前、后两结点链接起来。关键是要保证在结点指针的修改过程中不断链！注意，请读者仔细对比上述两题，弄清双链表的插入和删除方法。  

17. A  

结点4和 $B$ 分别由指针p和g指示，但结点 $C$ 仅能由p->next间接指示，因此在改变p->next和p->next->prior之前，必须先将q->next指向结点 $C$ ，即 $^{(\!\astrosun)}$ 要在 $\textcircled{3}$ 和 $\textcircled{4}$ 前面，且 $^{(4)}$ 要在 $^{(3)}$ 前面（因为若先执行 $^{;}\!\mathcal{B}$ ，则 $\textcircled{4}$ 相当于q->prior指向其自身，显然矛盾)。故只能选A。  

18.C  

当在双链表的两个结点（分别用第一个、第二个结点表示）之间插入一个新结点时，需要修改四个指针域，分别是：新结点的前驱指针域，指向第一个结点；新结点的后继指针域，指向第二个结点：第一个结点的后继指针域，指向新结点；第二个结点的前驱指针域，指向新结点。  

19. B  

设单链表递增有序，首先要在单链表中找到第一个大于 $_\mathrm{x}$ 的结点的直接前驱p，在p之后插入该结点。查找的时间复杂度为 $O(n)$ ，插入的时间复杂度为 $O(1)$ ，总时间复杂度为 $O(n)$  

20.D  

在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂，A错误。双链表中可以快速访问任何一个结点的前驱和后继结点，D正确。  

21.C  

带头结点的循环单链表L为空表时，满足L->next $\mathbf{\omega=}\mathbb{L}$ ，即头结点的指针域与工的值相等，而不是头结点的指针域与工的地址相等。注意，带头结点的单循环链表中不存在空指针。  

22. D  

循环双链表L判空的条件是头结点（头指针）的prior和next域都指向它自身。  

23.A  

在链表的末尾插入和删除一个结点时，需要修改其相邻结点的指针域。而寻找尾结点及尾结点的前驱结点时，只有带头结点的双循环链表所需要的时间最少。  

24. C  

对于A，删除尾结点 ${}^{\star}\mathtt{p}$ 时，需要找到 ${}^{\star}\mathtt{p}$ 的前一个结点，时间复杂度为 $O(n)$ 。对于B，删除首结点 ${}^{\star}\mathtt{p}$ 时，需要找到 ${}^{\star}\mathtt{p}$ 结点，这里没有直接给出头结点指针，而通过尾结点的prior指针找到 ${}^{\star}\mathtt{p}$ 结点的时间复杂度为 $O(n)$ 。对于D，删除尾结点 ${}^{\star}\mathtt{p}$ 时，需要找到 ${}^{\star}\mathtt{p}$ 的前一个结点，时间复杂度为 $O(n)$ 。对于C，执行这四种算法的时间复杂度均为O(1)。  

25.B  

要求用 $O(1)$ 的时间将两个循环单链表头尾相接，并未指明哪个链表接在另一个链表之后，所以对两个链表都要在 $O(1)$ 的时间找到头结点和尾结点。因此，两个指针应都指向尾结点。  

26.A  

在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为 $O(1)$ 。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在 $O(1)$ 的时间找到尾结点；若只有表头指针，则需要遍历整个链表找到尾结点，时间为 $O\left(n\right)$  
27.D  

对一个空循环单链表，有head->next $==$ head，推理head->next->next $==$ head->next $==$ head。对含有一个元素的循环单链表，头结点（头指针head指示）的next域指向这个唯一的元素结点，该元素结点的next域指向头结点，因此也有head->next->next $=$ head。  

28.D  

对于两种双链表，删除首结点的时间复杂度都是 $O(1)$ 。对于非循环双链表，删除尾结点的时间复杂度是  $O(n)$  ；对于循环双链表，删除尾结点的时间复杂度是  $O(1)$  

29.D  

对于A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为 $O(n)$ 而删除第一个元素时，为保持单循环链表的性质（尾结点指向第一个结点），要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为 $O(n)$ 。对于B，双链表的情况与单链表的相同，一个是 $O(n)$ ，一个是 $O(1)$ 。对于C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置，时间复杂度为 $O(n)$ ：删除第一个元素的时间复杂度为 $O(1)$ 。对于D，与A的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为 $O(1)$  

30.B  

静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。  

31.B  

静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。由于并非每个空间都存储了元素，因此会造成存储空间的浪费。  

32.D  

A的第二句代码，相当于将p前驱结点的后继指针指向其自身，错误；B和C的第一句代码，相当于将p后继结点的前驱指针指向其自身，错误。只有D正确。  

33.D  

根据存储状态，单链表的结构如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b55a688d62e061aac2783fc9eb75defada7af6550a63e9c7b42b9d53b37c3156.jpg)  

其中“链接地址”是指结点next所指的内存地址。当结点f插入后，a指向f，f指向é，é指向b。显然a、e和f的“链接地址”分别是f、b和e的内存地址，即1014H、1004H和 $1010\mathrm{H}$  

34.D  

如图1所示，要删除带头结点的非空单循环链表中的第一个元素，就要先用临时指针g指向待删结点，  $\scriptstyle{\mathfrak{q}}={\mathfrak{h}}\cdot$  ->next；然后将q从链表中断开，h->next=q->next（这一步也可写成h->next= h->next->next）；此时要考虑一种特殊情况，若待删结点是链表的尾结点，即循环单链表中只有一个元素(p和q指向同一个结点),如图2所示,则在删除后要将尾指针指向头结点,即if( $({\tt p}{=}{\tt q})$  $\mathtt{p}^{=\mathtt{h}}$ ：最后释放g结点即可，答案选D。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40ecdba2635a5405a27a716a55ab619dbad757661cefd9ea9abd3703ec340d62.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb89761bdf04ec2379266087a002c11425642f0f57076c13332cc656353865a7.jpg)  
图2  

35.C  

链表的插入操作要保证不会造成断链，画图再依次判断选项。执行完语句“ $^{(\mathrm{\textregistered})}$ s->next=p->next; ${\mathcal{Q}}_{\mathsf{P}}$ ->next $=\!\mathrm{S}$ ；”后的结构如下图所示（虚线表示prev，实线表示next）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16abd2a2bd12a95c373225b152f3441b03f18d02706ed28c57dc271185f3bdb2.jpg)  

对于A，s->next->prev $\tt{\ddot{\tau}}_{\mathrm{p}}$ ，错误。对于B， $\mathtt{p}^{->}$ next->prev $\scriptstyle{\varepsilon=s}$ ，让s的prev指向s，错误。对于D，两句代码均错误。对于C，执行完语句“  $\textcircled{3}$  s->prev=s->next->prev; 4s->next->prev $\scriptstyle{\varepsilon=S}$ ；”后的结构如下图所示，满足插入的要求。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e0e53bff60da6a9d34e202f5bf9321d9e9f0a18db590b023d5ecaeaa3d68a085.jpg)  

# 二、综合应用题  

01.【解答】  

解法1：用p从头至尾扫描单链表，pre指向 $\star_{\mathsf{P}}$ 结点的前驱。若p所指结点的值为x，则删除，并让p移向下一个结点，否则让pre、p指针同步后移一个结点。  

本题代码如下：  

void Del X1（Linklist &L,ElemType x）{ LNode\*p=L->next,\*pre  $\mathbf{\mu=}\mathbb{L}$  ，\*g;//置p和pre的初始值 while(p!=NULL){ if(p->data  $==$  /lg指向被删结点q=p; p=p->next; /将\*g结点从链表中断开 pre->next=p; free（q);//释放\*g结点的空间elsel l/否则，pre和p同步后移 pre=p; p=p->next; //else }//while  

本算法是在无序单链表中删除满足某种条件的所有结点，这里的条件是结点的值为x。实际上，这个条件是可以任意指定的，只要修改if条件即可。比如，我们要求删除值介于mink和maxk之间的所有结点，则只需将if语句修改为if（p->data>mink&&p->data<maxk）。  

解法2：采用尾插法建立单链表。用p指针扫描L的所有结点，当其值不为 $_\mathrm{x}$ 时，将其链接到L之后，否则将其释放。  

本题代码如下：  
void Del X 2（Linklist &L,ElemType x）{ LNode\*p $\mathbf{\omega=}\mathbb{L}$ ->next, $\star_{\mathbb{T}}=\mathbb{L}$  $\star_{\mathbb{Q}}$  $//x$ 指向尾结点，其初值为头结点while(p!  $=$  NULL){ if(p->data $!\!=\!\!\times$ I/\*p结点值不为 $\mathbf{\nabla}\times$ 时将其链接到 $\mathbb{L}$ 尾部r->next=p;  $\scriptstyle{\underline{{\boldsymbol{\tau}}}}={\boldsymbol{\mathrm{p}}}$  p=p->next; /继续扫描 elsef  $//{\star_{\mathsf{P}}}$  结点值为  $\times$  时将其释放 q=p;  $\tt p^{=}\tt p$  ->next; /继续扫描 free(q);//释放空间)//while r->next $=$ NULL;/插入结束后置尾结点指针为NULL  

上述两个算法扫描一遍链表，时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

02.【解答】  

算法思想：用p从头至尾扫描单链表，pre指向 ${}^{\star}\mathtt{p}$ 结点的前驱，用minp保存值最小的结点指针（初值为p），minpre指向\*minp结点的前驱（初值为pre）。一边扫描，一边比较，若p->data小于minp->data，则将p、pre min p、minpre，如下图所示。当p扫 描完毕时，minp指向最小值结点，minpre指向最小值结点的前驱结点，再将minp所指结点删除即可。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/426fab6a29a1b98105d6229a52dc7ba3019b0fcf791fcd5eed97bd777d64f2d1.jpg)  

本题代码如下：  

LinkList Delete Min(LinkList &L）( LNode\*pre $\mathbf{\omega=}\mathbb{L}$ ,\*p=pre->next; $//{\mathfrak{p}}$ 为工作指针，pre指向其前驱LNode \*minpre=pre,\*minp  $\tt_{\tau=p}$  ：//保存最小值结点及其前驱 while(p!=NULL){ if(p->data<minp->data){ minp $\tt=p$ /找到比之前找到的最小值结点更小的结点minpre=pre; pre $\mathbf{\omega}_{\mathbb{P}}$ /继续扫描下一个结点 $\tt p\mathrm{=}\tt p$  ->next; minpre->next $=$ minp->next;1/册除最小值结点free(minp); return L;  

算法需要从头至尾扫描链表，时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 若本题改为不带头结点的单链表，则实现上会有所不同，请读者自行思考。  

03.【解答】  

解法1：将头结点摘下，然后从第一结点开始，依次插入到头结点的后面（头插法建立单链表），直到最后一个结点为止，这样就实现了链表的逆置，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8fb1d58c340cdc0b3385e86efb2b4444a351c4d8c9e303ee38554c09e7558076.jpg)  

本题代码如下：  

LinkList Reverse l（LinkList L）{ LNode\*p， $\star_{\Sigma}$ /p为工作指针，r为p的后继，以防断链 $\scriptstyle{\mathtt{p}}={\mathtt{L}}$ ->next;11从第一个元素结点开始L->next  $=$  NULL; /先将头结点L的next域置为NULL while(p!=NULL){ //依次将元素结点摘下 r=p->next; //暂存p的后继 p->next  $\mathbf{\omega=}\mathbf{L}$  ->next; //将p结点插入到头结点之后 L->next  $\tt=p$   $\scriptstyle{\mathtt{p}}={\mathtt{r}}$  return L;  

解法2：大部分辅导书都只介绍解法1，这对读者的理解和思维是不利的。为了将调整指针这个复杂的过程分析清楚，我们借助图形来进行直观的分析。  

假设pre、p和r指向三个相邻的结点，如下图所示。假设经过若干操作后，\*pre之前的结点的指针都已调整完毕，它们的next都指向其原前驱结点。现在令 ${}^{\star}\mathtt{p}$ 结点的next域指向

\*pre结点，注意到一旦调整指针的指向， ${}^{\star}\mathtt{p}$ 的后继结点的链就会断开，为此需要用r来指向原

 $\star_{\mathsf{P}}$ 的后继结点。处理时需要注意两点：一是在处理第一个结点时，应将其next域置为NULL，而不是指向头结点（因为它将作为新表的尾结点）：二是在处理完最后一个结点后，需要将头结点的指针指向它。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75abfb30b62d57bed70f7dbf7e20b96aaffc9536f0d9a70a136fadb4a7e9bf36.jpg)  

本题代码如下：  

LinkList Reverse 2（LinkList L)( LNode\*pre,  $\star_{\mathsf{P}}=\mathbb{L}$  ->next,  $\star_{\underline{{x}}=\underline{{\mathrm{p}}}}$  ->next; p->next $=$ NULL;//处理第一个结点while（r!=NULL){ $/\tau$ 为空，则说明p为最后一个结点pre $\tt=p$ /依次继续遍历 $\scriptstyle{\mathtt{p}}={\mathtt{r}}$  r=r->next; p->next=pre; //指针反转 L->next=p;//处理最后一个结点returnL;  

上述两个算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

04.【解答】  

因为链表是无序的，所以只能逐个结点进行检查，执行删除本题代码如下：  
void Range Delete（LinkList &L,int min,int max){ LNode  $\scriptstyle{^{\star}\mathrm{pr}=\mathrm{L}}$  ，  $\star_{\mathrm{p=L->}}$  link; /lp是检测指针，pr是其前驱 while(p!=NULL) if（p->data>min&&p->data<max）{//寻找到被删结点，删除pr->link=p->link; free(p); p=pr->link; elset//否则继续寻找被删结点pr=p; p=p->link;  

05.【解答】  

两个单链表有公共结点，即两个链表从某一结点开始，它们的next都指向同一结点。由于每个单链表结点只有一个next域，因此从第一个公共结点开始，之后的所有结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的单链表，拓扑形状看起来像Y，而不可能像X。  

本题极容易联想到“蛮”方法：在第一个链表上顺序遍历每个结点，每遍历一个结点，在第二个链表上顺序遍历所有结点，若找到两个相同的结点，则我到了它们的公共结点。显然，该算法的时间复杂度为 $O(\mathrm{len}1\times\mathrm{len}2)$  

接下来我们试着去寻找一个线性时间复杂度的算法。先把问题简化：如何判断两个单向链表有没有公共结点？应注意到这样一个事实：若两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的，即它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分时，只需要分别遍历两个链表到最后一个结点。若两个尾结点是一样的，则说明它们有公共结点，否则两个链表没有公共结点。  

然而，在上面的思路中，顺序遍历两个链表到尾结点时，并不能保证在两个链表上同时到达尾结点。这是因为两个链表长度不一定一样。但假设一个链表比另一个长 $k$ 个结点，我们先在长的链表上遍历 $k$ 个结点，之后再同步遍历，此时我们就能保证同时到达最后一个结点。由于两个链表从第一个公共结点开始到链表的尾结点，这一部分是重合的，因此它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。  

根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为 $O({\sf l e n l}+{\sf l e n}2)$  

# 06.【解答】  

算法思想：循环遍历链表C，采用尾插法将一个结点插入表A，这个结点为奇数号结点，这样建立的表A与原来的结点顺序相同：采用头插法将下一结点插入表B，这个结点为偶数号结点，这样建立的表B与原来的结点顺序正好相反。  

本题代码如下：  

LinkList DisCreat 2(LinkList &A){ LinkList $\scriptstyle{\mathrm{~B}}=$ (LinkList）malloc（sizeof（LNode））;//创建B表表头B->next $=$ NULL;//B表的初始化LNode $\star_{\mathsf{P}}{=}\mathbb{A}\,,$ ->next, ${\star}_{\overline{{\mathbf{q}}}}$ /lp为工作指针LNode  $\star_{\bar{x}\mathrm{a=A}}$  //ra始终指向A的尾结点 while（p!=NULL){  
ra->next=p; $\tt r a=p$ //将\*p链到A的表尾p=p->next; if（p!=NULL）{ q=p->next;/头插后， $\star_{\mathsf{P}}$ 将断链，因此用g记忆 $\star_{\mathtt{P}}$ 的后继p->next  $=$  B->next; /将  $\star_{\mathbb{P}}$  插入到B的前端 B->next=p;  $\scriptstyle{\mathbb{P}}^{={\overline{{\mathbb{q}}}}}$  ra->next $=$ NULL;//A尾结点的next域置空return B;  

该算法特别需要注意的是，采用头插法插入结点后， ${}^{\star}\mathtt{p}$ 的指针域已改变，若不设变量保存其后继结点，则会引起断链，从而导致算法出错。  

# 07.【解答】  

算法思想：由于是有序表，因此所有相同值域的结点都是相邻的。用p扫描递增单链表工，若 $\star_{\mathsf{P}}$ 结点的值域等于其后继结点的值域，则删除后者，否则p移向下一个结点。  

本题代码如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0058d92a881f85ba1e46fec044cd9bb432b880617610e3b87d17f8b78b320301.jpg)  

本算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

本题也可采用尾插法，将头结点摘下，然后从第一结点开始，依次与已经插入结点的链表的最后一个结点比较，若不等则直接插入，否则将当前遍历的结点删除并处理下一个结点，直到最后一个结点为止。  

08.【解答】  

算法思想：表A、B都有序，可从第一个元素起依次比较A、B两表的元素，若元素值不等，则值小的指针往后移，若元素值相等，则创建一个值等于两结点的元素值的新结点，使用尾插法插入到新的链表中，并将两个原表指针后移一位，直到其中一个链表遍历到表尾。  

本题代码如下：  

void Get Common（LinkList A,LinkList B）{LNode  $\star_{\mathtt{P}=\mathtt{A}}$  ->next,  $\scriptstyle{^\star\mathrm{q=B-}}$  >next,  $\star_{\Sigma}$   $\star_{\mathrm{~S~}}$  LinkList $\mathtt{C}=$ （LinkList）malloc（sizeof（LNode））;//建立表c $\scriptstyle{\boldsymbol{\mathtt{x}}}=\mathbf{C}$  $/\mathfrak{x}$ 始终指向C的尾结点while(p!=NULL&&q! $=$ NULL)(//循环跳出条件if(p->data<g->data)  
$\tt p^{=}\tt p$  ->next; //若A的当前元素较小，后移指针 else if(p->data>q->data) q=q->next; //若B的当前元素较小，后移指针 elser/找到公共元素结点 $s\mathrm{=}$  (LNode\*)malloc(sizeof(LNode)); s->data=p->data; 复制产生结点\*s r->next $=_{S}$ /将\*s链接到c上（尾插法） $\scriptstyle{\boldsymbol{\tau}}={\boldsymbol{\mathrm{s}}}$   $\tt p^{=}\tt p$  ->next; /表A和B继续向后扫描 q=q->next; r->next=NULL;//置c尾结点指针为空  

09.【解答】  

算法思想：采用归并的思想，设置两个工作指针pa和pb，对两个链表进行归并扫描，只有同时出现在两集合中的元素才链接到结果表中且仅保留一个，其他的结点全部释放。当一个链表遍历完毕后，释放另一个表中剩下的全部结点。  

本题代码如下：  

Link List Union（LinkList &la,LinkList &lb){ LNode\*pa $=$ la->next;//设工作指针分别为pa和pbLNode\*pb  $\mathbf{\beta}=$  lb->next; LNode \*u,  ${}^{\star}\mathtt{p c=1a}$  l/结果表中当前合并结点的前驱指针pc while(pa&&pb)( if(pa->data $==$ pb->data){交集并入结果表中pc->next=pa;I/A中结点链接到结果表pc=pa; pa  $\scriptstyle\varepsilon\;=$  pa->next; u=pb; I/B中结点释放 pb  $=$  pb->next; free(u); elseif（pa->data<pb->data）{/若A中当前结点值小于B中当前结点值u=pa; pa=pa->next; /后移指针 free(u);//释放A中当前结点elsef /若B中当前结点值小于A中当前结点值 u=pb; pb  $\scriptstyle{\varepsilon={}}$  pb->next; //后移指针 free(u);/释放B中当前结点//while结束 while(pa)( I/B已遍历完，A未完 u=pa; pa=pa->next; free(u);/释放A中剩余结点while(pb)( I/A已遍历完，B未完 u=pb; pb  $\scriptstyle{|=}$  pb->next;  
free(u);/释放B中剩余结点pc->next=NULL;//置结果链表尾指针为NULLfree（lb);/释放B表的头结点returnla;  

链表归并类型的试题在各学校历年真题中出现的频率很高，故应扎实掌握解决此类问题的思想。该算法的时间复杂度为 $O({\sf l e n l}+{\sf l e n}2)$ ，空间复杂度为 $O(1)$  

10.【解答】  

算法思想：因为两个整数序列已存入两个链表中，操作从两个链表的第一个结点开始，若对应数据相等，则后移指针：若对应数据不等，则A链表从上次开始比较结点的后继开始，B链表仍从第一个结点开始比较，直到B链表到尾表示匹配成功。A链表到尾而B链表未到尾表示失败。操作中应记住A链表每次的开始结点，以便下次匹配时好从其后继开始。  

本题代码如下：  

int Pattern（LinkList A,LinkListB){ LNode $\star_{\mathtt{P}=\mathtt{A}}$ /p为A链表的工作指针，本题假定A和B均无头结点LNode \*pre $\tt=p$ /pre记住每趟比较中A链表的开始结点LNode $\star_{\bar{\mathsf{q}}=\mathsf{B}}$ /lg是B链表的工作指针while(p&&q) if(p->data  $==$  q->data）（//结点值相同 p=p->next; q=g->next; elsef pre=pre->next; IA链表新的开始比较结点 ${\tt p}^{=}$  pre;  $\scriptstyle{\mathfrak{q}}={\mathfrak{B}}$ llg从B链表第一个结点开始if( $\scriptstyle{\mathfrak{q}}=$ NULL)//B已经比较结束return1;/说明B是A的子序列else return0;I/B不是A的子序列  

# 注意  

该题其实是字符串模式匹配的链式表示形式，读者应该结合字符串模式匹配的内容重新考虑能否优化该算法。  

11.【解答】  

算法思想：让p从左向右扫描，q从右向左扫描，直到它们指向同一结点（  $\scriptstyle{\cdot{\bf p}=={\bf q}}$  ，当循环 双链表中结点个数为奇数时）或相邻（p->next $\mathbf{\lambda}^{=}\mathbf{q}$ 或q->prior $\scriptstyle{\varphi}={\mathtt{p}}$ ，当循环双链表中结点个数为偶数时）为止，若它们所指结点值相同，则继续进行下去，否则返回0。若比较全部相等，则 返回1。  

本题代码如下：  

int Symmetry（DLinkList L) DNode $\star_{\mathtt{P}=\mathtt{L}}$ ->next, $\scriptstyle{^{\star}\!\mathtt{q}=\!\mathrm{L}^{-}}$ >prior;/两头工作指针while（p!=q&&q->next!=p)川循环跳出条件if(p->data  $==$  q->data){ //所指结点值相同则继续比较  
p=p->next; q=q->prior; else /否则，返回0 return 0; return 1; //比较结束后返回1  

# 注意  

while循环第二个判断条件易误写成 $\mathtt{p}^{->}$ next $!\!=\!\!\mathrm{q}$ ，分析这样会产生什么问题。  

12.【解答】  

算法思想：先找到两个链表的尾指针，将第一个链表的尾指针与第二个链表的头结点链接起来，再使之成为循环的。  

本题代码如下：  

Link List Link（LinkList &hl,LinkList&h2）{ //将循环链表h2链接到循环链表h1之后，使之仍保持循环链表的形式LNode\*p,\*q；川分别指向两个链表的尾结点 $_{\mathrm{p=h1}}$  while(p->next $!\!=\!\!\mathrm{h}1$ 寻找h1的尾结点p=p->next;  $\scriptstyle{\mathtt{q}}={\mathrm{h}}2$  while(g->next $!\!=\!\!\mathrm{h}2$ 1/寻找h2的尾结点q=q->next; p->next $\scriptstyle=\ln2$ //将h2链接到h1之后q->next  $\mathbf{\Sigma}=\mathbf{h}\mathbb{1}$  //令h2的尾结点指向h1 return hi;  

13.【解答】  

算法思想：首先在双向链表中查找数据值为×的结点，查到后，将结点从链表上摘下，然后顺着结点的前驱链查找该结点的插入位置（频度递减，且排在同频度的第一个，即向前找到第一个比它的频度大的结点，插入位置为该结点之后），并插入到该位置。  

本题代码如下：  

DLinkList Locate（DLinkList &L,ElemType x）DNode $\star_{\mathrm{p=L}}$ ->next,\*q;/lp为工作指针，g为p的前驱，用于查找插入位置while(p&&p->data  $!\!=\!\!\mathrm{x}$  /查找值为 $_\mathrm{x}$ 的结点p=p->next; if(!p) exit（0);/不存在值为 $_\mathrm{x}$ 的结点elsef p->freq++; 令元素值为  $\mathbf{x}$  的结点的freg域加1 if(p->pre  $==\mathbb{L}$  I1p->pre->freg>p->freq) return p; llp是链表首结点，或freg值小于前驱 if(p->next  $=$  NULL)p->next->pre=p->pre; p->pre->next=p->next; //将p结点从链表上摘下 q=p->pre;/以下查找p结点的插入位置while(g!=L&&q->freg<=p->freg) q=q->pre;  
p->next=g->next; if(g->next $!=$ NULL)g->next->pre $\tt=p$ ；/将p结点排在同频率的第一个p->pre=q; q->next  $\tt=p$  return p;/返回值为 $\mathbf{x}$ 的结点的指针  

14.【解答】  

1）算法的基本设计思想：  

首先，遍历链表计算表长 $n$ ，并找到链表的尾结点，将其与首结点相连，得到一个循环单链表。然后，找到新链表的尾结点，它为原链表的第 $n-k$ 个结点，令L指向新链表尾结点的下一个结点，并将环断开，得到新链表。  

2）本题代码如下：  

LNode\*Converse(LNode  ${\star}\mathbb{L}$  ,intk）{ int $\scriptstyle{\mathrm{~n}}=1$  $/\mathrm{n}$ 用来保存链表的长度LNode  $\scriptstyle{^{\star}\!\mathrm{p}=\mathrm{L}}$  /lp为工作指针 while(p->next! $=$ NULL)(//计算链表的长度p=p->next;  $\mathrm{n++}$  //循环执行完后，p指向链表尾结点p->next $\mathbf{\omega=}\mathbb{L}$ /将链表连成一个环for(int $_\pm=1$  $\scriptstyle{\dot{\mathbf{z}}}<={\mathrm{n}}$ -k; $\mathrm{i}_{++}$ //寻找链表的第 $\mathtt{n}\!-\!\mathtt{k}$ 个结点p=p->next;  $\scriptstyle{\mathrm{L}}={\mathrm{p}}$  ->next; 令L指向新链表尾结点的下一个结点 p->next=NULL; //将环断开 return L;  

3）本算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

15.【解答】  

1）算法的基本设计思想  

设置快慢两个指针分别为fast和slow最初都指向链表头head。slow每次走一步，即sloW  $=$  slow->next；fast每次走两步，即fast  $\scriptstyle\cdot^{*}$  fast->next->next。fast slow 快，若有环，则fast一定先进入环，而slow后进入环。两个指针都进入环后，经过若干操作后两个指针定能在环上相遇。这样就可以判断一个链表是否有环。  

如下图所示，当slow刚进入环时，fast早已进入环。因为fast每次比slow多走一步且fast与slow的距离小于环的长度，所以fast与slow相遇时，slow所走的距离不超过环的长度。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bdb7d910bfd7dd0ebfecea3a879b39d0c6e32a2b269503dc941ce0503a88e98d.jpg)  

如下图所示，设头结点到环的入口点的距离为a，环的入口点沿着环的方向到相遇点的距离为 $_\mathrm{x}$ ，环长为 $\boldsymbol{\mathfrak{x}}$ ，相遇时fast绕过了n圈。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d933b428b27dfd211713bf5b90ce363d4b59da08263ebc6724f6c84467006dc3.jpg)  

则有 ${\sf2}\left({\sf a}\!+\!{\sf x}\right){\sf=}{\sf a}\!+\!{\sf n}^{\star}{\sf x}\!+\!{\sf x}$ ，即 $\mathsf{a}\!=\!\mathsf{n}\,\mathsf{r}-\mathsf{x}$ 。显然从头结点到环的入口点的距离等于n倍的环长减去环的入口点到相遇点的距离。因此可设置两个指针，一个指向head，一个指向相遇点，两个指针同步移动（均为一次走一步），相遇点即为环的入口点。  

2）本题代码如下：  

LNode\*Find Loop Start（LNode\*head){LNode\*fast=head,\*slow  $=$  head; //设置快慢两个指针 while（fast!  $=$  NULL&&fast->next！  $=$  NULL)( slow  $=$  slow->next; //每次走一步 fast=fast->next->next; //每次走两步 if(slow=  $=$  fast)break; //相遇 if(fast  $==$  NULLIlfast->next  $==$  NULL) return NULL;没有环，返回NULLLNode  ${\star_{\mathrm{p1=1}}}$  head，\*p2=slow; 川分别指向开始点、相遇点 while(p1  $!\!=\!\!\mathrm{p}^{2}$  pl=pl->next; p2=p2->next; return pl;//返回入口点  

3）当fast与slow相遇时，slow肯定没有遍历完链表，故算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

16.【解答】  

1）算法的基本设计思想：  

设置快、慢两个指针分别为fast和slow，初始时slow指向L（第一个结点），fast指向L->next（第二个结点），之后slow每次走一步，fast每次走两步。当fast指向表尾（第 $n$ 个结点）时，slow正好指向链表的中间点（第 $n/2$ 个结点），即s1ow正好指向链表前半部分的最后一个结点。将链表的后半部分逆置，然后设置两个指针分别指向链表前半部分和后半部分的首结点，在遍历过程中计算两个指针所指结点的元素之和，并维护最大值。  

2）本题代码如下：  

int PairSum(LinkList L）LNode \*fast $\mathbf{\mu=}\mathbb{L}$ ->next,\*slow $\scriptstyle\mathrm=\mathrm{L}$ ：//利用快慢双指针找到链表的中间点while(fast!  $=$  NULL&&fast->next!  $=$  NULL){ fast $=$ fast->next->next;/快指针每次走两步slow  $=$  slow->next; /慢指针每次走一步 LNode \*newHead  $=$  NULL,  $\star_{\mathsf{P}}{=}\mathsf{s}$  low->next,\*tmp; while(p $!=$ NULL){//反转链表后一半部分的元素，采用头插法tmp=p->next;/lp指向当前待插入结点，令tmp指向其下一结点p->next  $=$  newHead; //将p所指结点插入到新链表的首结点之前 newHead $\tt=p$ 八//newHead指向刚才新插入的结点，作为新的首结点  
$\scriptstyle{\mathtt{p}}=\tan{\mathtt{p}}$ //当前待处理结点变为下一结点int $\scriptstyle{\mathrm{max}}=0$ ； $\scriptstyle{\mathtt{p}}=\mathtt{L}$ LNode  $\star_{\mathfrak{q}=}$  newHead; while(p! $=$ NULL){//用p和g分别遍历两个链表if（(p->data+g->data）>mx)//用 $\mathtt{m x}$ 记录最大值mx=p->data+q->data; p=p->next; q=q->next; returnmx;  

3）本算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

17.【解答】  

1）算法的基本设计思想如下：  

问题的关键是设计一个尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是：定义两个指针变量p和g，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，a指针开始与p指针同步移动；当p指针移动到最后一个结点时，g指针所指示结点为倒数第 $\mathtt{k}$ 个结点。以上过程对链表仅进行一遍扫描。  

2）算法的详细实现步骤如下：  

$\textcircled{\scriptsize{1}}$ count $_{:=0}$ ，p和g指向链表表头结点的下一个结点。  

$\circledast$  若p为空，转  $\circledast$  

$\textcircled{3}$ 若count等于 $\boldsymbol{\mathrm{k}}$ ，则g指向下一个结点；否则，count $=$ count $^{+1}$  

$\textcircled{4}$ p指向下一个结点，转 $\mathcal{Q}$  

$\circledast$  若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值 超过了线性表的长度，查找失败，返回0。  

$^\mathrm{\textregistered}$ 算法结束。  

3）算法实现如下：  

typedef int ElemType;//链表数据的类型定义typedef struct L Node//链表结点的结构定义ElemType data;//结点数据struct L Node\*link; //结点链接指针 )LNode,\*LinkList; int Search k（Link List list,intk){ LNode $\star_{\mathsf{P}}=\!\!1$ ist->link，\*g=list->link;//指针p、g指示第一个结点int count  $=\!0$  while（p!=NULL){/遍历链表直到最后一个结点if（count<k）count $^{++}$ /计数，若count<k只移动pelse q=q->link; p=p->link;//之后让p、g同步移动}//while if(count<k)return 0; /查找失败返回0 else 1/否则打印并返回1 printf("gd",g->data);  
return 1;  

评分说明：若所给出的算法采用一遍扫描方式就能得到正确结果，可给满分15分；若采用两遍或多遍扫描才能得到正确结果，最高分为10分。若采用递归算法得到正确结果，最高给10分若实现算法的空间复杂度过高（使用了大小与 $\kappa$ 有关的辅助数组），但结果正确，最高给10分。  

# 18.【解答】  

顺序遍历两个链表到尾结点时，并不能保证两个链表同时到达尾结点。这是因为两个链表的长度不同。假设一个链表比另一个链表长 $k$ 个结点，我们先在长链表上遍历 $k$ 个结点，之后同步遍历两个链表，这样就能够保证它们同时到达最后一个结点。因为两个链表从第一个公共结点到链表的尾结点都是重合的，所以它们肯定同时到达第一个公共结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/36d0acc99387087b02e725404b7d4955b6d7521febf196003c5d29f58896cb90.jpg)  

1）算法的基本设计思想如下：  

$\textcircled{\scriptsize{1}}$ 分别求出str1和str2所指的两个链表的长度 $m$ 和 $n$  

$\circledcirc$  将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点，若  $m{\geqslant}n$  ，则 指针p先走，使p指向链表中的第 $m\!-\!n+1$ 个结点：若 $m<n$ ，则使g指向链表中的第 $n\!-\!m+1$ 个结点，即使指针p和 $\mathbf{q}$ 所指的结点到表尾的长度相等。  

$\textcircled{3}$ 反复将指针p和g同步向后移动，，并判断它们是否指向同一结点。当p、g指向同一结点，则该点即为所求的共同后缀的起始位置。  

2）本题代码如下：  

typedef struct Node{ char data; struct Node \*next; )SNode;  

\*求链表长度的函数\*  

intlistlen(SNode\*head){intlen  $=\!0$  while(head->next!  $=$  NULL){ len++; head  $=$  head->next; returnlen;  

\*找出共同后缀的起始地址\*/  

SNode\* find 1ist（SNode \*strl,SNode \*str2）{  

int m,n; SNode  $\star_{\mathbb{P}}$   $\star_{\overline{{\mathbf{q}}}}$   $\mathfrak{m}=$  listlen(strl);  $\mathrm{n}=$  listlen(str2); for(  ${\tt p}^{=}$  str1;m>n;m--)  
p=p->next; for（q=str2;m<n;n--)诺 $\mathtt{m}\!<\!\mathtt{n}$ ，使g指向链表中的第 $\mathrm{n{-}m{+}1}$ 个结点q=q->next; while(p->next! $=$ NULL&&p->next！=g->next）{//查找共同后缀起始点p=p->next;//两个指针同步向后移动q=q->next; 3 return p->next;//返回共同后缀的起始地址  

3）时间复杂度为O（lenl+len2）或O（max（len1,len2))，其中len1、len2分别为两个链表的长度。  

19.【解答】  

1）算法的基本设计思想：  

·算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。  

·因为ldata $|\leqslant n$ ，故辅助数组g的大小为 $n+1$ ，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[ldatal]的值，若为0则保留该结点，并令q[ldata $\mid\;\mid=1$ ：香则将该结点从链表中删除。  

2）使用C语言描述的单链表结点的数据类型定义：  

typedef struct node{ int data; struct node \*link; )NODE; Typedef NODE\*PNODE;  

3）算法实现如下：  

void func（PNODE h,intn）{PNODE  $\scriptstyle{\mathtt{p}}={\mathrm{h}}$  r; int  $\star_{\overline{{\mathbf{q}}}},\mathbf{m}$   ${\mathfrak{q}}{=}$ (int $^{\star)}$ malloc（sizeof（int) $^{\star}\left(\mathfrak{n}\!+\!1\right)$ ）：/审请 $\mathtt{n+1}$ 个位置的辅助空间for(int  $\scriptstyle{\dot{\mathbf{z}}}=0$   $\scriptstyle{\mathrm{i}}<{\mathrm{n}}+1$   $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  /数组元素初值置0  ${\star\left({\sf q}\!+\!{\sf i}\right)=\!0}$  while  $(\mathtt{p}^{-->1}$  ink!  $=$  NULL) m=p->link->data>0?p->link->data:-p->link->data; if $({}^{\star}\left({\sf q}\!+\!{\sf m}\right)==0$ //判断该结点的data是否已出现过 $\star\left(\mathfrak{q}\!+\!\mathfrak{m}\right)\!=\!1$ //首次出现 $_{\mathrm{p=p->1ink}}$  //保留 elsel //重复出现 r=p->link; /删除 p->link  $\scriptstyle\varepsilon=$  r->link; free  $(x)$  free(g);  

4）参考答案所给算法的时间复杂度为 $O(m)$ ，空间复杂度为 $O(n)$  

20.【解答】  

1）算法的基本设计思想先观察 $L=(a_{1},a_{2},a_{3},\cdots,a_{n-2},a_{n-1},a_{n})$ 和 $L^{\prime}\,{=}\,(a_{1},a_{n},a_{2},a_{n-1},a_{3},a_{n-2},\cdots)$ ，发现 $L^{\prime}$ 是由 $L$ 摘取第一个元素，再摘取倒数第一个元素··依次合并而成的。为了方便链表后半段取元素，需要先将 $L$ 后半段原地逆置题目要求空间复杂度为 $O(1)$ ，不能借助栈」，否则每取最后一个结点都需要遍历一次链表。 $\textcircled{\scriptsize{1}}$ 先找出链表 $L$ 的中间结点，为此设置两个指针p和q，指针p每次走一步，指针g每次走两步，当指针g到达链尾时，指针p正好在链表的中间结点； $\circledcirc$ 然后将 $L$ 的后半段结点原地逆置。 $\textcircled{3}$ 从单链表前后两段中依次各取一个结点，按要求重排。  
2）算法实现  

void change list（NoDE  $\star_{\mathrm{h}}$  NODE\*p，\*g，\*r，\*s;  $\scriptstyle{\mathtt{p}}={\mathtt{q}}={\mathtt{h}}$  while(q->next! $=$ NULL)(寻找中间结点p=p->next; /p走一步 g=g->next; if(q->next!=NULL)q=q->next; //lg走两步 q=p->next; $//{\mathfrak{p}}$ 所指结点为中间结点，g为后半段链表的首结点p->next  $=$  NULL; while(q  $=$  NULL){ /将链表后半段逆置 r=q->next; q->next=p->next; p->next=q; q=r;  $_{\mathrm{s}=\mathrm{h}}$ ->next;lIs指向前半段的第一个数据结点，即插入点q=p->next;/lg指向后半段的第一个数据结点p->next  $=$  NULL; while(q! $=$ NULL){/将链表后半段的结点插入到指定位置 $x=$ q->next; $//x$ 指向后半段的下一个结点g->next $=_{\mathrm{S}}$ ->next；//将g所指结点插入到s所指结点之后s->next=q;  $s=$ q->next;//s指间前半段的下一个插入点 ${\mathfrak{q}}^{={\mathfrak{r}}}$  

3）第一步找中间结点的时间复杂度为 $O(n)$ ，第二步逆置的时间复杂度为 $O(n)$ ，第三步合并链表的时间复杂度为 $O(n)$ ，所以该算法的时间复杂度为 $O(n)$  

# 归纳总结  

本章是算法设计题的重点考查章节，因为线性表的算法题的代码量一般都比较少，又具有一定的算法设计技巧，因此适合笔试考查。考研题中常以三段式的结构命题。  

在给出题目背景和要求的情况下： $\textcircled{\scriptsize{1}}$ 给出算法的基本设计思想。 $\circledcirc$ 采用C或 $\mathrm{C++}$ 语言描述算法，并给出注释。 $\textcircled{3}$ 分析所设计算法的时间复杂度和空间复杂度。  

算法具体的设计思想干变方化，难以从一而定。因此读者一定要勤加练习，反复咀嚼本章的练习题，采用多种方法进行设计并比较它们的复杂度，逐渐熟悉各类题型的思考角度和最佳思路。  
这里，编者列出几种常用的算法设计技巧，仅供参考：对于链表，经常采用的方法有头插法、尾插法、逆置法、归并法、双指针法等，对具体问题需要灵活变通；对于顺序表，因为可以直接存取，所以经常结合排序和查找的几种算法设计思路进行设计，如归并排序、二分查找等。  

# 注意  

对于算法设计题，若能写出数据结构类型的定义、正确的算法思想，则至少会给一半的分数；若能用伪代码写出，则自然更好；比较复杂的地方可以直接用文字表达。  

# 思维拓展  

一个长度为n的整型数组A[1.n]，给定整数x，设计一个时间复杂度不超过 $O(n\mathrm{log}_{2}n)$ 的算法，查找出这个数组中所有两两之和等于 $_\mathrm{x}$ 的整数对（每个元素只输出一次）。  

提示：本题若想到排序，则问题便迎刃而解。先用一种时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的排序算法将A[1..n]从小到大排序，然后分别从数组的小端（ $\scriptstyle{\dot{\Sigma}}={\bar{\Sigma}}$ ）和大端（ ${\dot{\ }}={\mathsf{n}}$ ）开始查找：若 $\mathbb{A}\left[\dot{\mathtt{\alpha}}\right]\!+\!\mathbb{A}\left[\dot{\mathtt{\beta}}\right]\!<\!\mathbf{x}$  $\ \ \mathrm{i}_{++}$ ；若 $\mathbb{A}\left[\,\mathtt{i}\,\right]+\mathbb{A}\left[\,\mathtt{j}\,\right]>\mathbb{X}$ ，j--；否则输出A[i]、A[j]，然后 $\ \ \mathrm{i}_{++}$ ，j--；直到 $\scriptstyle{\dot{1}}>={\dot{1}}$ 时停止。  

请读者思考本题是否有其他求解算法。  
# 第3章栈、队列和数组  

# 【考纲内容】  

（一）栈和队列的基本概念（二）栈和队列的顺序存储结构（三）栈和队列的链式存储结构（四）多维数组的存储（五）特殊矩阵的压缩存储（六）栈、队列和数组的应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8673aabdcf1c2823e8b532d26b74c2cd29ebb988bfb15dc7924c46a2a1ba5995.jpg)  

# 【复习提示】  

本章通常以选择题的形式考查，题目不算难，但命题的形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。因为它们均是线性表的应用和推厂，所以也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是读者必须掌握的内容。  

# 3.1 栈  

# 3.1.1栈的基本概念  

1.栈的定义  

命题追踪栈的特点（2017）  

栈（Stack）是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如图3.1所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7106c13b6e1245e55ff693a1f8672ede610b5435b7a237926c8ead113245747c.jpg)  
图3.1栈的示意图  

栈顶（Top）。线性表允许进行插入删除的那一端。栈底（Bottom）。固定的，不允许进行插入和删除的另一端。空栈。不含任何元素的空表。  

# 命题追踪入栈序列和出栈序列之间的关系（2022）  

# 命题追踪特定条件下的出栈序列分析（2010、2011、2013、2018、2020）  

假设某个栈 $S=(a_{1},\,a_{2},\,a_{3},\,a_{4},\,a_{5})$ ，如图3.1所示，则 $a_{1}$ 为栈底元素， $a_{5}$ 为栈顶元素。栈只能在栈顶进行插入和删除操作，进栈次序依次为 $a_{1},a_{2},a_{3},a_{4},a_{5}$ ，而出栈次序为 $a_{5},a_{4},a_{3},a_{2},a_{1}$ 。由此可见，栈的操作特性可以明显地概括为后进先出（LastInFirstOut，LIFO）。  

# 注意  

每接触一种新的数据结构，都应从其逻辑结构、存储结构和运算三个方面着手。  

2.栈的基本操作  

各种辅导书中给出的基本操作的名称不尽相同，但所表达的意思大致是一样的。这里我们以严蔚敏编写的教材为准给出栈的基本操作，希望读者能熟记下面的基本操作。  

InitStack（&S）：初始化一个空栈S。StackEmpty（S）：判断一个栈是否为空，若栈s为空则返回true，否则返回false。Push（&S，x）：进栈，若栈s未满，则将 $_\mathrm{x}$ 加入使之成为新栈顶。Pop（&S，&x）：出栈，若栈s非空，则弹出栈顶元素，并用 $_\mathrm{x}$ 返回。GetTop（S，&x）：读栈顶元素，但不出栈，若栈s非空，则用 $_\mathrm{x}$ 返回栈顶元素。DestroyStack（&S）：销毁栈，并释放栈s占用的存储空间（“&”表示引用调用）。在解答算法题时，若题干未做出限制，则也可直接使用这些基本的操作函数。  

栈的数学性质：当 $n$ 个不同元素进栈时，出栈元素不同排列的个数为 $\frac{1}{n+1}C_{2n}^{n}$ 。这个公式称为卡特兰数（Catalan）公式，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。  

# 3.1.2栈的顺序存储结构  

栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。  

1.顺序栈的实现  

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。  
栈的顺序存储类型可描述为  

#define MaxSize 50//定义栈中元素的最大个数typedef struct{ Elemtype data[MaxSize];存放栈中元素int top; /栈顶指针 )SqStack;  

栈顶指针：s.top，初始时设置s.top $\scriptstyle{\mathfrak{s}}=-1$ ；栈顶元素：S.data[S.top]。  

进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶。出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1。  

栈空条件：S.top $==-1$ ：栈满条件：S.top $==$ MaxSize-1；栈长：S.top $^{+1}$  

另一种常见的方式是：初始设置栈顶指针S.top $_{:=0}$ ：进栈时先将值送到栈顶，栈顶指针再加1：出栈时，栈顶指针先减1，再取栈顶元素：栈空条件是S.top $==0$ ；栈满条件是S.top $==$ MaxSize。  

顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。  

# 注意  

栈和队列的判空、判满条件，会因实际给的条件不同而变化，下面的代码实现是在栈顶指针初始化为-1的条件下的相应方法，而其他情况则需具体问题具体分析。  

# 2.顺序栈的基本操作  

命题追踪出/入栈操作的模拟（2009）  

栈操作的示意图如图3.2所示，图3.2（a是空栈，图3.2（c）是A、B、C、D、E共5个元素依次入栈后的结果，图3.2（d）是在图3.2（c）之后E、D、C的相继出栈，此时栈中还有2个元素，或许最近出栈的元素C、D、E仍在原先的单元存储着，但top指针已经指向了新的栈顶，元素C、D、E已不在栈中，读者应通过该示意图深刻理解栈顶指针的作用。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33624a050419102d021d22fcad1a1b9b9ce7d2f891ec502117a6376ac3ae2992.jpg)  
图3.2栈顶指针和栈中元素之间的关系  

下面是顺序栈上常用的基本操作的实现。  

（1）初始化  

void InitStack（SqStack &S){ s.top  $\scriptstyle{\varepsilon=-1}$  /初始化栈顶指针  

（2）判栈空  

bool StackEmpty(SqStack S)(if(s.top  $==-1$  一 //栈 returntrue;  
elseI/不空return false;  

（3）进栈  

bool Push(SqStack &S,ElemType x){ if(s.top  $==$  MaxSize-1) /栈满，报错 return false; S.data[  $++\mathbb{S}$  .top]  $=\!\mathrm{x}$  /指针先加1，再入栈 returntrue;  

当栈不满时，top先加1，再入栈。若初始时将top定义为0，函数3和4应如何改写？（4）出栈  

bool Pop（SqStack &S,ElemType &x){ if(s.top  $==1$  /栈空，报错 return false;  $\scriptstyle{\mathrm{x}}={\mathrm{s}}$  .data[s.top--]; /先出栈，指针再减1 returntrue;  

（5）读栈顶元素  

bool GetTop（SqStack S,ElemType &x){if(s.top  $==-1$  一 /栈空，报错 return false;  $\scriptstyle{\mathrm{x}=\mathrm{S}}$ .data[s.top]; $/\mathrm{x}$ 记录栈顶元素return true;  

仅为读取栈顶元素，并没有出栈操作，因此原栈顶元素依然保留在栈中。  

# 注意  

这里的top指的是栈顶元素。于是，进栈操作为S.data $_{[++S.\thinspace t o p]=x}$ ，出栈操作为 $\scriptstyle{\mathrm{x}=\mathrm{S}}$ .data[s.top--]。若栈顶指针初始化为s.top $\scriptstyle{\boldsymbol{\mathbf{\varepsilon}}}=0$ ，即top指向栈顶元素的下一位置，则入栈操作变为S.data $\scriptstyle[S,\,\mathsf{t o p}^{++}\,]\,=\,\mathrm{x}$ 出栈操作变为 $\scriptstyle{\mathrm{x}=\mathrm{S}}$ .data[--S.top]。相应的栈空栈满条件也会发生变化。请读者仔细体会其中的不同之处，做题时要灵活应变。  

3.共享栈  

利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图3.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1c0004fb22716e3b1a316c37cc6ce28b1dd46cc1c751801d6c9ab8fc25d3ee2e.jpg)  
图3.3两个顺序栈共享存储空间  

两个栈的栈顶指针都指向栈顶元素，top $_{0=-1}$ 时0号栈为空，top1 $=$ Max Size 1空；仅当两个栈顶指针相邻（top1-top $_{;0=1}$ ）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反。  

共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满 时才发生上溢。其存取数据的时间复杂度均为 $O(1)$ ，所以对存取效率没有什么影响。  
# 3.1.3栈的链式存储结构  

采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead指向栈顶元素，如图3.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f0d7b95eed53c3a5dd03b6056fd4e1c3c4e1ee1245d21383134cea5854d80bfd.jpg)  
图3.4栈的链式存储  

栈的链式存储类型可描述为  

typedef struct Linknode{ ElemType data;//数据域struct Linknode \*next;/指针域)LiStack; /栈类型定义  

采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链 表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。  

# 3.1.4 本节试题精选  

# 一、单项选择题  

01.栈和队列具有相同的（）  

A.抽象数据类型B.逻辑结构C.存储结构D.运算  

02.栈是一种（）。  

A.顺序存储的线性结构B.链式存储的非线性结构C.限制存取点的线性结构D.限制存储点的非线性结构  

03.下列选项中，（）不是栈的基本操作。  

A.删除栈顶元素B.删除栈底元素C.判断栈是否为空D.将栈置为空栈  

04.假定用数组a[n]存储一个栈，初始栈顶指针top $\scriptstyle{\mathfrak{s}}=-1$ ，则元素 $_\mathrm{x}$ 进栈的操作是（）。A.a[--top] $=\!\mathrm{x}$ B. $\mathtt{a}\left[\mathtt{t o p--}\right]\mathtt{=}\mathtt{x}$ C. $\mathsf{a}\left[++\mathsf{t o p}\right]\mathrm{=x}$ D.a[top++]=x05.假定用数组a[1..n]存储一个栈，初始栈顶指针 $\mathsf{t o p}=1$ ，则元素 $\mathrm{_x}$ 进栈的操作是（）。  

A. datal  $\tt[t o p--]\mathrm{=x}$  B. data  $\scriptstyle[\,\mathtt{t o p}++\,]\,=\,\mathtt{X}$  C.data[--top] $=\!\mathrm{x}$ D.data $\scriptstyle[++\tan\tt{p}]\,=\,$  

06.假定用数组a[1..n]存储一个栈，初始栈顶指针top $\scriptstyle1=\mathrm{n}+1$ ，则元素 $\mathrm{_x}$ 进栈的操作是（）。  

A. data  $\scriptstyle[\,--\,\mathsf{t o p}\,]\,=\,\mathsf{X}$  B. data  $\scriptstyle[\,\mathsf{t o p}++\,]\,=\,\!\mathbf{x}$  C.data[top--] $\mathrm{max}$ D.data $\scriptstyle[++\tan\mathsf{p}]\,=\,\mathbf{x}$  

07.设有一个空栈，栈顶指针为1000H，栈向高地址方向增长，每个元素需要一个存储单元，执行Push、Push、Pop、Push、Pop、Push、Pop、Push操作后，栈顶指针的值为 ()。  

A.1002H B.1003H C.1004H D.1005H 08.和顺序栈相比，链栈有一个比较明显的优势，即（）  

A.通常不会出现栈满的情况B.通常不会出现栈空的情况C.插入操作更容易实现 D.删除操作更容易实现  
09.设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是（）。  

A.只有表头结点指针，没有表尾指针的双向循环链表B.只有表尾结点指针，没有表头指针的双向循环链表C.只有表头结点指针，没有表尾指针的单向循环链表D.只有表尾结点指针，没有表头指针的单向循环链表  

10.向一个栈顶指针为top的链栈（不带头结点）中插入一个x结点，则执行（）  

A.top->next=x B.x->next  $=$  top->next;top->next  $=\!\mathrm{x}$  C.x->next  $=$  top;top=x D.x->next  $=$  top;top  $\mathbf{\beta}=$  top->next  

11.链栈（不带头结点）执行PoP操作，并将出栈的元素存在x中，应该执行（）。  

A. $\times{}=$ top:top $,=$ top->nextB. $\times{}=$ top->dataC.top  $\mathbf{\eta}=$  top->next;  $\times{}=$  top->data D.  $\times=$  top->data;top  $\mathbf{\varepsilon}\!=$  top->next  

12.经过以下栈的操作后，变量×的值为（）InitStack（st）;Push（st,a);Push(st,b);Pop（st,x）;GetTop（st，x）;  

A.a B.b C. NULL D.false

 13.3个不同元素依次进栈，能得到（）种不同的出栈序列。A.4 B.5 C.6 D.7  

14.设a，b，c，d，e，f以所给的次序进栈，若在进栈操作时，允许出栈操作，则下面得不到的出栈序列为（）。  

A.fedcba B.bcafed C. dcefba D.cabdef

 15.4个元素依次进栈的次序为 $a,b,c,d$ ，则以 $c,d$ 开头的出栈序列的个数为（）A.1 B.2 C.3 D.4  

16.用S表示进栈操作，用X表示出栈操作，若元素的进栈顺序是1234，为了得到1342的出栈顺序，相应的S和 $\mathrm{X}$ 的操作序列为（）。  

A.SXSXSSXX B.SSSXXSXX C.SXSSXXSX D.SXSSXSXX  

17.若栈的输入序列是 $1,2,3,\cdots,n$ ，输出序列的第一个元素是 $n$ ，则第 $i$ 个输出元素是 $(\mathrm{~\,~})_{\circ}$ A.不确定 B.  $n\!-\!i$  C.  $n-i-1$  D.  $n\!-\!i\!+1$  

18.若栈的输入序列是 $1,2,3,\cdots,n$ ，输出序列的第一个元素是i，则第 $j$ 个输出元素是（）A. $i^{-}j^{-}1$ B. $i^{-}j$ C. $j^{-}i+1$ D.不确定

19.某栈的输入序列为 $a,b,c,d$ ，下面的4个序列中，不可能为其输出序列的是（）。A.  $a,b,c,d$  B.  $c,b,d,a$  C.  $d,c,a,b$  D.  $a,c,b,d$  20.若栈的输入序列是 $P_{1},P_{2},\cdots,P_{n}$ ，输出序列是 $1,2,3,\cdots,n$ ，若 $P_{3}\!=\!1$ ，则 $P_{1}$ 的值（）。A.可能是2B.一定是2C.不可能是2D.不可能是3

21.若栈的输入序列是 $P_{1},P_{2},\cdots,P_{n},$ 输出序列是 $1,2,3,\cdots,n,$ 若 $P_{3}\!=\!3$ ，则 $P_{1}$ 的值（）。A.可能是2B.不可能是1C.一定是1D.一定是2

22.已知栈的入栈序列是 $1,2,3,4$ ，其出栈序列为 $P_{1},P_{2},P_{3},P_{4}$ ，则 $P_{2},P_{4}$ 不可能是（）A.2,4 B.2,1 C.4,3 D.3,4  

23.设栈的初始状态为空，当字符序列“n1_”作为栈的输入时，输出长度为3，且可用做C语言标识符的序列有（）个。  

A.4 B.5 C.3 D.6  

24.采用共享栈的好处是（）A.减少存取时间，降低发生上溢的可能B.节省存储空间，降低发生上溢的可能C.减少存取时间，降低发生下溢的可能D.节省存储空间，降低发生下溢的可能  
25.设有一个顺序共享栈Share[0：n-1]，其中第一个栈顶指针top1的初值为-1，第二个栈顶指针top2的初值为n，则判断共享栈满的条件是（）。  

A. top2-topl  $==1$  B.topl-top2  $\scriptstyle{\left(==1\right)}$  C. topl  $==$  top2 D.都不对  

26.【2009统考真题】设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若 每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至 少是()。  

A.1 B.2 C.3 D.4  

27.【2010统考真题】若元素a,b,c,d,e,f依次进栈，允许进栈、退栈操作交替进行，但不允许连续3次进行退栈操作，不可能得到的出栈序列是（）。  

A. dcebfa B. cbdaef C. bcaefd D. afedcb  

28.【2011统考真题】元素  $a,b,c,d,e$  依次进入初始为空的栈中，若元素进栈后可停留、可出栈 直到所有元素都出栈，则在所有可能的出栈序列中，以元素 $d$ 开头的序列个数是（）。  

A.3 B.4 C.5 D.6  

29.【2013统考真题】一个栈的入栈序列为  $1,2,3,\cdots,n$  ，出栈序列是  $P_{1},P_{2},P_{3},\cdots,P_{n\circ}$  若  $P_{2}\!=\!3$  则 $P_{3}$ 可能取值的个数是（）。  

A. $n^{-3}$ B. $n^{-2}$ C. $n^{-1}$ D.无法确定  

30.【2020统考真题】对空栈S进行Push和Pop操作，入栈序列为 $a,b,c,d,e$ ，经过Push、Push、Pop、Push、Pop、Push、Push、Pop（）  

A.  $b,a,c$  B.  $b,a,e$  C.   $b,c,a$  D. b,c,e  

31.【2022统考真题】给定有限符号集S，in和out均为S中所有元素的任意排列。对于初始为空的栈ST，下列叙述中，正确的是（)。  

A.若in是ST的入栈序列，则不能判断out是否为其可能的出栈序列B.若out是ST的出栈序列，则不能判断in是否为其可能的入栈序列C.若in是ST的入栈序列，out是对应in的出栈序列，则in与out一定不同D.若in是ST的入栈序列，out是对应in的出栈序列，则in与out可能互为倒序  

# 二、综合应用题  

01.有5个元素，其入栈次序为 $A,\,B,\,C,\,D,\,E$ ，在各种可能的出栈次序中，第一个出栈元素为 $C$ 且第二个出栈元素为 $D$ 的出栈序列有哪几个？  

02.若元素的进栈序列为 $A,B,C,D,E$ ，运用栈操作，能否得到出栈序列 $B,C,A,E,D$ 和 $D,B,$  $A,C,E?$ 为什么？  

03.栈的初态和终态均为空，以I和O分别表示入栈和出栈，则出入栈的操作序列可表示为由I和〇组成的序列，可以操作的序列称为合法序列，否则称为非法序列。1）下面所示的序列中哪些是合法的？  

A. 1010I00 B.100I01O C.1OIO10 D. 1100I00  

2）通过对1）的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false（假定被判定的操作序列已存入一维数组中）。  
04.设单链表的表头指针为L，结点结构由data和next两个域构成，其中data域为字符型。试设计算法判断该链表的全部n个字符是否中心对称。例如xyx、XyYx都是中心对称。  

05.设有两个栈S1、S2都采用顺序栈方式，并共享一个存储区 $\left[\,0\,,\dots\right]$ maxsize-l]，为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。试设计S1、S2有关入栈和出栈的操作算法。  

# 3.1.5 答案与解析  

# 一、单项选择题  

01.B  

栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同。  

02.C  

首先栈是一种线性表，所以B、D错。按存储结构的不同可分为顺序栈和链栈，但不可以把栈局限在某种存储结构上，所以A错。栈和队列都是限制存取点的线性结构。  

03.B  

基本操作是指该结构最核心、最基本的运算，其他较复杂的操作可通过基本操作实现。删除栈底元素不属于栈的基本运算，但它可以通过调用栈的基本运算求得。  

04. C  

数组下标范围为 $0{\sim}\mathrm{n}{-}1$ ，初始时top为1，第一个元素入栈后，top为0，即top指向栈顶元素。栈向高地址方向增长，所以入栈时应先将指针top加1，然后存入元素 $_\mathrm{x}$ ，C正确。  

05.B  

数组下标范围为 $\mathtt{1}\!\sim\!\mathrm{n}$ ，初始时top为1，表示top指向栈顶元素的下一个元素。栈向高地址方向增长，所以入栈时应先存入元素 $\mathrm{_x}$ ，然后将指针top加1，B正确。  

06.A  

数组下标范围为 $1\!\sim\!\mathrm{n}$ ，初始时top为 $_{\mathrm{n+1}}$ ，表示top指向栈顶元素。栈向低地址方向增长，所以入栈时应先将指针top减1，然后存入元素 $_\mathrm{x}$ ，A正确。  

07. A  

每个元素需要1个存储单元，所以每入栈一次top加 1，出栈一次top减1。指针top的值依次为1001H,1002H,1001H,1002H,1001H,1002H,1001H,1002H。  

08. A  

顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间。  

09. C  

对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而单循环链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于C，插入和删除结点后，找尾结点所需的时间为 $O(n)$  

10.C  

链栈采用不带头结点的单链表表示时，进栈操作在首部插入一个结点 $_\mathrm{x}$ (即x->next $\scriptstyle{\cdot=}$ top),插入完后需将top指向该插入的结点x。请思考当链栈存在头结点时的情况。  

11.D  

这里假设栈顶指针指向的是栈顶元素，所以选D；而A中首先将top指针赋给了 $_\mathrm{x}$ ，错误；B中没有修改top指针的值；C为top指针指向栈顶元素的上一个元素时的答案。  
12.A  

执行前3句后，栈st内的值为a，b，其中b为栈顶元素；执行第4句后，栈顶元素b出栈， $\mathrm{_x}$ 的值为b；执行最后一句，读取栈顶元素的值， $\mathrm{_x}$ 的值为a。  

13.B  

当 $n$ 个不同元素进栈时，出栈序列的个数为  

$$
\frac{1}{n+1}C_{2n}^{n}=\frac{1}{n+1}\frac{(2n)!}{n!\times n!}=\frac{6\times5\times4}{4\times3\times2\times1}=5
$$  

考题中给出的 $n$ 值不会很大，可以根据栈的特点，若 $X_{i}$ 已经出栈，则 $X_{i}$ 前面的尚未出栈的元素一定逆置有序地出栈，因此可采用例举方法。如 $a,b,c$ 依次进栈的出栈序列有abc,acb,bac,bca,cba。另外，在一些考题中可能会问符合某个特定条件的出栈序列有多少种，比如此题中的问以 $^b$ 开头的出栈序列有几种，这种类型的题目一般都使用穷举法。  

14.D  

根据栈“先进后出”的特点，且在进栈操作的同时允许出栈操作，显然答案D中 $^c$ 最先出栈，则此时栈内必定为 $a$ 和 $^b$ ，但因为 $a$ 先于 $b$ 进栈，所以要晚出栈。对于某个出栈的元素，在它之前进栈却晚出栈的元素必定是按逆序出栈的，其余答案均是可能出现的情况。  

此题也可采用将各序列逐个代入的方法来确定是否有对应的进出栈序列（类似下题）。  

15.A  

假设出栈序列为 $c d.$ ，分析栈的操作序列： $^a$ 进栈， $^b$ 进栈， $c$ 进栈， $c$ 出栈， $d$ 进栈， $d$ 出栈，此后只能是 $^b$ 出栈和 $a$ 出栈一种情况，因此出栈序列只有cdba。  

16.D  

采用排除法，选项A，B，C得到的出栈序列分别为1243，3241，1324。由1234得到1342的进出栈序列为：1进，1出，2进，3进，3出，4进，4出，2出，所以选D。  

17.D  

第 $n$ 个元素第一个出栈，说明前 $n\!-\!1$ 个元素都已经按顺序入栈，由“先进后出”的特点可知，此时的输出序列一定是输入序列的逆序，所以答案选D。  

18.D  

当第 $i$ 个元素第一个出栈时，则 $i$ 之前的元素可以依次排在i之后出栈，但剩余的元素可以在此时进栈并且也会排在 $i$ 之前的元素出栈，所以第 $j$ 个出栈的元素是不确定的。  

19.C  

对于A，可能的顺序是a入， $a$ 出， $b$ 入， $^b$ 出， $c$ 入， $c$ 出， $d$ 入， $d$ 出。对于B，可能的顺序是a入， $^b$ 入， $c$ 入， $^c$ 出， $b$ 出， $d$ 入， $d$ 出， $a$ 出。对于D，可能的顺序是 $^a$ 入， $a$ 出， $^b$ 入 $c$ 入， $c$ 出， $^b$ 出， $d$ 入， $d$ 出。C没有对应的序列。  

【另解】若出栈序列的第一个元素为 $d$ ，则出栈序列只能是dcba。该思想通常也适用于出栈序列的局部分析：如12345入栈，问出栈序列34152是否正确？如何分析？若第一个出栈元素是3，则此时12必停留在栈中，它们出栈的相对顺序只能是21，所以34152错误。  

20. C  

入栈序列是 $P_{1},P_{2},\cdots,P_{n^{\circ}}$ 由于 $P_{3}\!=1$ ，即 $P_{1},P_{2},P_{3}$ 连续入栈后，第一个出栈元素是 $P_{3}$ ，说明 $P_{1},P_{2}$ 已经按序进栈，根据先进后出的特点可知， $P_{2}$ 必定在 $P_{1}$ 之前出栈，而第二个出栈元素是2，而此时 $P_{1}$ 不是栈顶元素，因此 $P_{1}$ 的值不可能是2。思考：哪些 $P_{\tau}$ 可能是2？  

21.A  

假设 $P_{1}$ 是1，进栈后立即出栈， $P_{2}$ 是2，进栈后立即出栈， $P_{3}$ 是3，进栈后立即出栈，得到的序列符合题意。假设 $P_{1}$ 是2， $P_{1}$ 是1， $P_{1}$  $P_{2}$ 依次进栈后全部出栈， $P_{3}$ 是3，进栈后立即出栈，得到的序列符合题意。因此， $P_{1}$ 既可能是1，又可能是2。  
22.C  

逐个判断每个选项可能的入栈出栈顺序。对于A，可能的顺序是1入，1出，2入，2出，3入，3出，4入，4出。对于B，可能的顺序是1入，2入，3入，3出，2出，4入，4出，1出。对于D，可能的顺序是1入，1出，2入，3入，3出，2出，4入，4出。C没有对应的序列，因为当4在栈中时，意味着前面的所有元素（1，2，3）都已在栈中或曾经入过栈，此时若4第二个出栈，即栈中还有两个元素，且这两个元素是有序的（对应入栈顺序)，只能为(1,2)(1,3),(2,3)，若是序列(1,2)，则3已在 $p_{1}$ 位置出栈，不可能再在 $p_{4}$ 位置出栈，若是(1,3)和(2,3)这种情况中的任意一种，则3一定是下一个出栈元素，即 $p_{3}$ 一定是3，所以 $p_{4}$ 不可能是3。  

【另解】对于C， $p_{2}$ 为最后一个入栈元素4，则只有 $p_{1}$ 或 $p_{3}$ 出栈的元素有可能为3（请读者分两种情况自行思考），而 $p_{4}$ 绝不可能为3。读者在解答此类题时，一定要注意出栈序列中的“最后一个入栈元素”，这样可以节省答题的时间。  

23. C  

标识符只能以英文字母或下画线开头，而不能以数字开头。于上，由n、1、_三个字符组合成的标识符有 $\mathrm{n1}_{-}$ 、n_1、_1n和_n1四种。第一种：n进栈再出栈，1进栈再出栈，_进栈再出栈。第二种：n进栈再出栈，1进栈，_进栈，_出栈，1出栈。第三种：n进栈，1进栈，_进栈，_出栈，1出栈，n出栈。而根据栈的操作特性，_n1这种情况不可能出现。  

24.B  

上溢是指存储器满，还往里写；下溢是指存储器空，还往外读。为了解决上溢，可给栈分配很大的存储空间，但这样又会造成存储空间的浪费。共享栈的提出就是为了在解决上溢的基础上节省存储空间，将两个栈放在同一段更大的存储空间内，这样，当一个栈的元素增加时，可使用另一个栈的空闲空间，从而降低发生上溢的可能性。  

25.A  

这种情况就是前面我们所描述的，详细内容请参见本节考点精析部分对共享栈的讲解。另外，读者可以思考若top1的初值为0，top2的初值为 $_{\mathrm{n-1}}$ 时栈满的条件。  

# 注意  

栈顶、队头与队尾的指针的定义是不唯一的，做题时务必仔细审题和思考。  

# 26.C  

时刻注意栈的特点是先进后出，下表是出入栈的详细过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/35ffdfafa42c62ee1e16c8b3b0996e73456b35e4a5e684971cc464ac9d7b353b.jpg)  
栈内的最大深度为3，所以栈S的容量至少是3。  

【另解】因为元素的出队顺序和入队顺序相同，所以元素的出栈顺序就是b,d $c,f,$ e,a,g,因此元素的出入栈次序为Push（S，a) $\mathrm{Push}(\mathrm{S},b)$ ,Pop(S, $b$ ),Push(S, $^{c)}$ ,Push(S, $^{d)}$ Pop(S, $^{d)}$  $\mathrm{Pop}(\mathrm{S},c)$ Push(S,e), $\operatorname{P u s h}(\mathrm{S},f$ ) $\mathrm{Pop}(\mathrm{S},f)$ ,Pop(S,e), $\mathrm{Pop}(\mathrm{S},a)$  $\mathrm{Push}(\mathrm{S},g)$  $\mathrm{Pop}(\mathrm{S},g)$ 。初始所需容量为0，每做一次Push操作，容量加1；每做一次Pop操作，容量减1，记录的容量最大值为3。  

27.D  

选项A由  $a$  进，  $^b$  进，  $c$  进，  $d$  进，  $d$  出，  $c$  出，  $e$  进，  $e$  出，  $^b$  出，  $f$  进，  $f$  出，  $a$  出得到：选 项B由  $a$  进，  $b$  进，  $c$  进，  $c$  出，  $b$  出，  $d$  进，  $d$  出，  $a$  出，  $e$  进，  $e$  出，  $f$  进，  $f$  出得到：选项C由  $a$  进，  $b$  进，  $b$  出，  $^c$  进，  $c$  出，  $a$  出，  $d$  进，  $e$  进，  $e$  出，  $f$  进，  $f$  出，  $d$  出得到：选项D由  $a$  进，  $a$  出，  $b$  进，  $c$  进，  $d$  进，  $e$  进，  $f$  进，  $f$  出，  $e$  出，  $d$  出，  $c$  出，  $b$  出得到，但题意要求不充许连续3 次退栈操作，选项D不符。  

【另解】先进栈的元素后出栈，进栈顺序为  $a,b,c,d,e,f,$  所以连续出栈时的子序列必然是按 字母表逆序的，若出栈序列中出现了长度大于或等于3的连续逆序子序列，则为所选序列。  

28.B  

d第一个出栈，则 $c,b,a$ 出栈的相对顺序是确定的，出栈顺序必为d_c_b_a_， $e$ 的顺序不定，在任意一个“”上都有可能。  

【另解】 $d$ 首先出栈，则 $_{a b c}$ 停留在栈中，此时栈的状态如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c2253c260f2e0f7135a64146ae00064f87c4da832ac52d12ec6e8a1b1eeb82a.jpg)  

此时可以有如下4种操作： $@e$ 进栈后出栈，则出栈序列为decba； $@c$ 出栈， $e$ 进栈后出栈，出栈序列为dceba：  $\operatorname{\mathcal{G}}c b$  出栈，  $e$  进栈后出栈，出栈序列为dcbea：  $\textcircled{4}$  cba出栈，  $e$  进栈后出栈 出栈序列为dcbae。思路和上面其实一样。  

29.C  

显然，3之后的 $4,5,\cdots,n$ 都是 $P_{3}$ 可取的数（一直进栈直到该数入栈后马上出栈）。接下来分析1和2是否可取： $P_{1}$ 可以是3之前入栈的数（可能是1或2），也可以是4，当 $P_{1}=1$ 时， $P_{3}$ 可取2；当 $P_{1}\!=\!2$ 时， $P_{3}$ 可取1。因此， $p_{3}$ 可能取除3外的所有数，个数为 $n\!-\!1$  

30.D  

按题意，出入栈操作的过程如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a24554276770537a27b7d0060d2e31cdbf6fd3201a21910e3e6471df3d8ae76b.jpg)  
因此，出栈序列为 $b,c,e$  

31.D  

通过模拟出入栈操作，可以判断入栈序列in和出栈序列out是否合法。因此，已知in序列可以判断out序列是否为可能的出栈序列：已知out序列也可以判断in序列是否为可能的入栈序列，A和B错误。若每个元素入栈后立即出栈，则in序列和out序列相同，C错误。若所有元素都入栈后才依次出栈，则in序列和out序列互为倒序，D正确。  

# 二、综合应用题  

01.【解答】  

$C D$ 出栈后的状态如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ccd4891f31b158fdad1290f9d184806b217185ca59cf2f16deb3c9d5016a2f96.jpg)  

此时有如下3种操作：  $\textcircled{\scriptsize{1}}E$  进栈后出栈，出栈序列为CDEBA；  $\scriptscriptstyle\mathcal{Q}B$  出栈，  $E$  进栈后出栈，出 栈序列为CDBEA；  $\textcircled{3B}$  出栈，  $A$  出栈，  $E$  进栈后出栈，出栈序列为CDBAE。  

所以，以 $C D$ C DEB A、CDBEA、CDBAE三种。  

02.【解答】  

能得到出栈序列  $B C A E D$  。可由  $A$  进，  $B$  进，  $B$  出，  $C$  进，  $C$  出，  $A$  出，  $D$  进，  $E$  进，  $E$  出，  $D$ 出得到。不能得到出栈序列DBACE。若出栈序列以 $D$ 开头，说明在 $D$ 之前的入栈元素是A、B和 $C$ ，三个元素中 $C$ 是栈顶元素， $B$ 和 $A$ 不可能早于 $C$ 出栈，所以不可能得到出栈序列 $D B A C E$  

03.【解答】  

1）A、D合法，而B、C不合法。在B中，先入栈1次，再连续出栈2次，错误。在C中，入栈和出栈次数不一致，会导致最终的栈不空。A、D均为合法序列，请自行模拟。注意：在操作过程中，入栈次数一定大于或等于出栈次数；结束时，栈一定为空。  

2）设被判定的操作序列已存入一维数组 $A$ 中。算法的基本设计思想：依次逐一扫描入栈出栈序列（即由“T”和“O”组成的字符串），每扫描至任意一个位置均需检查出栈次数（即“O”的个数）是否小于入栈次数（“1”的个数），若大于则为非法序列。扫描结束后，再判断入栈和出栈次数是否相等，若不相等则不合题意，为非法序列。  

bool Judge(char A[ ]）( int  $\scriptstyle{\dot{\mathbf{z}}}=0$  int $\scriptstyle{\dot{\boldsymbol{\mathrm{\omega}}}}={\boldsymbol{\mathrm{k}}}=0$ //i为下标，和 $\kappa$ 分别为字母1和0的个数while（A[i]!='\0'）{川未到字符数组尾switch(A[i]){ case'I':  $\gimel^{++}$  ;break; J1入栈次数增1 case'o':  $\kappa++$  if（k>j）{printf（"序列非法\n"）;exit（0）;） $\}\}_{\mathrm{i++}}$  /不论A[i]是I还是O，指针i均后移 if（j  $!\!=\!\!\kappa!,$  printf（"序列非法\n"）; return false; elsef printf（"序列合法\n"）;  
return true;  

【另解】入栈后，栈内元素个数加1：出栈后，栈内元素个数减1，因此可将判定一组出入栈序列是否合法转化为一组由 $+1$ 、-1组成的序列，它的任意前缀子序列的累加和不小于0（每次出栈或入栈操作后判断）则合法；否则非法。  

04.【解答】  

算法思想：使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈。在处理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，两个元素比较，若相等，则将链表中的下一个元素与栈中再弹出的元素比较，直至链表到尾。这时若栈是空栈，则得出链表中心对称的结论；否则，当链表中的一个元素与栈中弹出元素不等时，结论为链表非中心对称，结束算法的执行。  

int dc（LinkList L,int n）{int i; chars[n/2]; lls字符栈 LNode $\star_{\mathsf{P}}\!\!=\!\!\mathtt{L}->$ next;//工作指针p，指向待处理的当前元素for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<n/2;  $\ \dot{\mathbf{i}}^{++}$  //链表前一半元素进栈 s[i]  $\tt=p$  ->data; p=p->next; i--;//恢复最后的i值if $\mathfrak{n}\mathfrak{s}\mathfrak{2}\mathrm{==}\mathtt{1}$ //若n是奇数，后移过中心结点 $\tt p\mathrm{=}\tt p$  ->next; while(p! $=$ NULL&&S[i] $\scriptstyle==_{\mathtt{P}}$ ->data)(//检测是否中心对称 $\mathrm{i--}$  //i充当栈顶指针  $\scriptstyle{\mathtt{p}}={\mathtt{p}}$  ->next; if（  $\scriptstyle{\dot{\mathbf{i}}}\;==-1$  //栈为空栈 return1;/链表中心对称else return0;/链表不中心对称  

算法先将“链表的前一半”元素（字符）进栈。当n为偶数时，前一半和后一半的个数相同：当n为奇数时，链表中心结点字符不必比较，移动链表指针到下一字符开始比较。比较过程中遇到不相等时，立即退出while循环，不再进行比较。  

本题也可以先将单链表中的元素全部入栈，然后扫描单链表工并比较，直到比较到单链表工尾为止，但算法需要两次扫描单链表工，效率不及上述算法高。  

# 05.【解答】  

两个栈共享向量空间，将两个栈的栈底设在向量两端，初始时，S1栈顶指针为-1，S2栈顶指针为maxsize。两个栈顶指针相邻时为栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素。  

#define maxsize 100

 #define elemtpint typedef struct{ elemtp stack[maxsize]; int top[2];  

/两个栈共享顺序存储空间所能达到的最多元素数

/初始化为100

 /假设元素类型为整型

/栈空间

//top为两个栈顶指针  
)stk;  

stk S;  

lIs是如上定义的结构类型变量，为全局变量  

本题的关键在于，两个栈入栈和退栈时的栈顶指针的计算。S1栈是通常意义下的栈；而S2栈入栈操作时，其栈顶指针左移（减1），退栈时，栈顶指针右移（加1）。  

此外，对于所有栈的操作，都要注意“入栈判满、出栈判空”的检查。  

（1）入栈操作  

int push（int i,elemtp x）{ I/入栈操作。i为栈号， $_{\pm=0}$ 表示左边的S1栈， $_\mathrm{i=1}$ 表示右边的S2栈， $_\mathrm{x}$ 是入栈元素I/入栈成功返回1，否则返回0 if（i<0li>1){ printf（"栈号输入不对"）；exit(0); if(s.top[1]-s.top[0]  $==1$  printf（"栈已满\n"）；return 0; switch（i){ case 0:s.stack[  $++s$  .top[0]]=x;return 1；break; case1:s.stack[--s.top[1]  $]\!=\!\mathrm{x}$  ;return 1:  

（2）退栈操作  

/退栈算法。i代表栈号，  $\scriptstyle{\dot{\mathbf{z}}}=0$  时为S1栈，  $\scriptstyle{\dot{\Sigma}}\,=\,\!1$  时为s2栈 /退栈成功返回退栈元素，否则返回-1if（i<01li>1){ printf（"栈号输入错误\n"）; exit（0); switch(i){ case0: if(s.top[0]  $==-1$  printf（"栈空\n"）; return -1; else return s.stack[s.top[o]--];break; case 1: if(s.top[1]  $==$  maxsize){ printf（"栈空\n"）；return -1; else return s.stack[s.top  $[1]++]$  break;  
}//switch  

# 3.2 队列  

# 3.2.1队列的基本概念  

# 1.队列的定义  

队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队：删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（FirstInFirstOut，FIFO），如图3.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/da7e4f84e84162acb3f9824684070eb0b9c7296ec89a63d06b1c5dec814dbf84.jpg)  
图3.5队列示意图  

队头（Front）。允许删除的一端，又称队首。队尾（Rear）。允许插入的一端。空队列。不含任何元素的空表。  

# 2.队列常见的基本操作  

InitQueue（&Q）：初始化队列，构造一个空队列Q。  

EnQueue（&Q，x）：入队，若队列Q未满，将 $\mathrm{_x}$ 加入，使之成为新的队尾。DeQueue（&Q，&x）：出队，若队列Q非空，删除队头元素，并用 $_\mathrm{x}$ 返回。GetHead（Q，&x）：读队头元素，若队列Q非空，则将队头元素赋值给 $\mathbf{x}$  

需要注意的是，栈和队列是操作受限的线性表，因此不是任何对线性表的操作都可以作为栈和队列的操作。比如，不可以随便读取栈或队列中间的某个数据。  

# 3.2.2队列的顺序存储结构  

# 1.队列的顺序存储  

队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置（不同教材对front和rear的定义可能不同，例如，可以让rear指向队尾元素、front指尚队头元素。对于不同的定义，出队入队的操作是不同的，本节后面有一些相关的习题，读者可以结合习题思考）。  

队列的顺序存储类型可描述为  

#define MaxSize 50/定义队列中元素的最大个数typedef struct{ ElemType data[MaxSize];//用数组存放队列元素int front,rear; //队头指针和队尾指针 )SqQueue;  
初始时：Q.front $\scriptstyle=Q$ .rear $=\!0$ 。  

进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。  

出队操作：队不空时，先取队头元素值，再将队头指针加1。  

图3.6(a)所示为队列的初始状态，有Q.front $\scriptstyle{\mathcal{S}}=Q$ .rear $\scriptstyle{\mathrel{=}}=0$ 成立，该条件可以作为队列判空的条件。但能否用Q.rear $==$ MaxSize作为队列满的条件呢？显然不能，图3.6(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出”，但这种溢出并不是真正的溢出，在data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e760968acf7af6ebf1dbb79c2ec260ef38948b9bfa862117879af3c154b72de2.jpg)  
图3.6队列的操作  

# 2．循环队列  

上面指出了顺序队列“假溢出”的问题，这里引出循环队列的概念。将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front $=$ MaxSize-1后，再前进一个位置就自动到0，这可以利用除法取余运算（&）来实现。  

# 命题追踪特定条件下循环队列队头/队尾指针的初值（2011）  

初始时：Q.front $\scriptstyle=Q$ .rear $=\!0$ 。  

队首指针进1：Q.front  $=$  (Q.front  $^{+1}$  )oMaxSize. 队尾指针进1：Q.rear $=$ (Q.rear $^{+1}$ )%MaxSize。队列长度：（Q.rear+MaxSize-Q.front）%MaxSize。出队入队时：指针都按顺时针方向进1（如图3.7所示）。  

# 命题追踪特定条件下循环队列队空/队满的判断条件（2014）  

那么，循环队列队空和队满的判断条件是什么呢？显然，队空的条件是Q.front $==Q$ .rear。若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队首指针，如图3.7d1)所示，此时可以看出队满时也有Q.front $==Q$ .rear。循环队列出入队示意图如图3.7所示。  

为了区分是队空还是队满的情况，有三种处理方式：  

1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下一位置作为队满的标志”，如图3.7（d2)所示。  

队满条件：（Q.rear  $^{+1}$  )%MaxSize  $==Q$  .front.  

队空条件：Q.front  $==Q$  .rear.  

队列中元素的个数：（Q.rear-  $\cdot Q$  .front+MaxSize)%MaxSize。  

2）类型中增设size数据成员，表示元素个数。删除成功size减1，插入成功size加1。队空时Q.size $==0$ ；队满时Q.size $==$ MaxSize，两种情况都有Q.front $\scriptstyle{\mathcal{S}}=Q$ .rear。  

3）类型中增设tag数据成员，以区分是队满还是队空。删除成功置tag $:=0$ ，若导致Q.front  $==Q$  .rear，则为队空；插入成功置tag  $\scriptstyle{:=1}$  ，若导致Q.front  $==Q$  .rear，则  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b778995860d2f05b33eca711357acb81d2a1bb530366b1912ac965859336dc2.jpg)  
图3.7循环队列出入队示意图  

# 3.循环队列的操作  

（1）初始化  

void InitQueue（SqQueue &Q）Q.rear  $\scriptstyle=Q$  .front  $=\!0$  /初始化队首、队尾指针  

（2）判队空  

bool isEmpty(SqQueue Q)( if(Q.rear $==Q$ .front)//队空条件return true; else return false;  

（3）入队  

bool EnQueue（SqQueue &Q,ElemType x）{if((Q.rear  $^{+1}$  )MaxSize  $==Q$  .front) /队满则报错 return false; Q.data[Q.rear]  $=\!\mathrm{x}$  Q.rear  $=$  (Q.rear  $^{+1}$  )MaxSize; /队尾指针加1取模 return true;  

（4）出队  

bool DeQueue（SqQueue &Q,ElemType &x）{if(Q.rear  $\scriptstyle{\;=\;=Q}$  .front) //队空则报错 return false;  $\scriptstyle{\mathrm{x}}=Q$  .data[Q.front]; Q.front  $=$  (Q.front+l)&MaxSize; /队头指针加1取模 return true;  
# 3.2.3队列的链式存储结构  

# 1.队列的链式存储  

命题追踪 根据需求分析队列适合的存储结构（2019）  

队列的链式表示称为链队列，它实际上是一个同时有队头指针和队尾指针的单链表，如图3.8所示。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c9b89a689e0863f3050513c3d2d3c2e7227d9979b1c2302cf4a18fa7ab5c711e.jpg)  
图3.8不带头结点的链式队列  

队列的链式存储类型可描述为  

typedef struct LinkNode//链式队列结点ElemType data;struct LinkNode \*next; )LinkNode; typedef struct{/链式队列LinkNode \*front,\*rear; /队列的队头和队尾指针 )LinkOueue:  

不带头结点时，当Q.front $==$ NULL且Q.rear $==$ NULL时，链式队列为空。  

命题追踪链式队列队空的判断（2019）  

入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点（若原队列为空队，则令Q.front也指向该结点）。出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点（若该结点为最后一个结点，则置Q.front和Q.rear都为NULL）。  

不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样插入和删除操作就统一了，如图3.9所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8af42305c84b1db057b731c2ac6cbaf08a48cded83345ce64d0e00865086d911.jpg)  
图3.9带头结点的链式队列  

用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。  

# 2.链式队列的基本操作  

# 命题追踪链式队列出队/入队操作的基本过程（2019）  

（1）初始化  

void In it Queue（LinkQueue&Q）（//  
Q.front $\scriptstyle=Q$ .rear $=$ （LinkNode\*）malloc（sizeof（LinkNode））；//建立头结点Q.front->next $=$ NULL;/初始为空  

（2）判队空  

bool IsEmpty（LinkQueue Q){ if(Q.front $==Q$ .rear)//判空条件return true; else return false;  

（3）入队  

void EnQueue（LinkQueue &Q,ElemType x）LinkNode $\star_{\mathrm{S}}=$ （LinkNode\*）malloc（sizeof（LinkNode））;//创建新结点s->data  $=\!\mathrm{x}$  s->next  $=$  NULL; Q.rear->next  $=_{S}$  //插入链尾 Q.rear  $=\mathbf{S}$  /修改尾指针  

（4）出队  

bool DeQueue（LinkQueue &Q,ElemType &x）{if(Q.front  $==Q$  .rear) return false;/空队LinkNode  $\star_{\mathbb{P}=\mathbb{Q}}$  .front->next;  $\scriptstyle{\mathrm{x}}={\mathrm{p}}$  ->data; Q.front->next=p->next; if(Q.rear  $\scriptstyle==$  ) Q.rear $\scriptstyle{\varepsilon=Q}$ .front;若原队列中只有一个结点，删除后变空free(p); return true;  

# 3.2.4 双端队列  

双端队列是指充许两端都可以进行插入和删除操作的线性表，如图3.10所示。双端队列两端的地位是平等的，为了方便理解，将左端也视为前端，右端也视为后端。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1da10f24ae28a725f51be7ee497b0b1c18a8ec812393d08ded54926f0d6b961f.jpg)  
图3.10双端队列  

在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。思考：如何由入队序列 $\underline{{a,b,c,d}}$ 得到出队序列dc.a.b？  

# 命题追踪双端队列出队/入队操作模拟（2010、2021）  

输出受限的双端队列：充许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如图3.11所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/412059d5591f77b15fa5943928dd9fa3528f4d8a5e4e920475b56d30bb8b1afe.jpg)  
图3.11输出受限的双端队列  

输入受限的双端队列：充许在一端进行插入和删除，但在另一端只充许删除的双端队列称为输入受限的双端队列，如图3.12所示。若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a3703f98b201c6aadf0e90edf86536b6cf4c40b5e9399b80353440957b098fef.jpg)  
图3.12输入受限的双端队列  

例设有一个双端队列，输入序列为1，2，3，4，试分别求出以下条件的输出序列。  

（1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。（2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列。（3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列。  

解：先看输入受限的双端队列，如图3.13所示。假设end1端输入 $1,2,3,4$ ，则end2端的输出相当于队列的输出，即 $1,2,3,4$ ：而end1端的输出相当于栈的输出， $n=4$ 时仅通过end1端有14种输出序列（由Catalan公式得出），仅通过end1端不能得到的输出序列有 $4!-14=10$ 种：  

1,4,2,3 2,4,1,3  $3,4,1,2$  3,1,4,2 3,1,2,4 4,3,1,2 4,1,3,2 4,2,3,1  $4,2,1,3$  4,1,2,3  

通过end1和end2端混合输出，可以输出这10种中的8种，参看下表。其中， $S_{\mathrm{L}},X_{\mathrm{L}}$ 分别代表end1端的进队和出队， $X_{R}$ 代表end2端的出队。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c2677c806971860f4767ece3963de2c1b99e0969a172510b50a0cc0ae913a36f.jpg)  

剩下两种是不能通过输入受限的双端队列输出的，即 $4,2,3,1$ 和 $4,2,1,3$  

再看输出受限的双端队列，如图3.14所示。假设end1端和end2端都能输入，仅end2端可以输出。若都从end2端输入，就是一个栈了。当输入序列为 $1,2,3,4$ 时，输出序列有14种。对于其他10种不能得到的输出序列，交替从endl和end2端输入，还可以输出其中8种。设 $S_{\mathrm{{L}}}$ 代表endl端的输入， $S_{\mathrm{R}}$  $X_{\mathrm{{R}}}$ 分别代表end2端的输入和输出，则可能的输出序列见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7ee83752ae002490dec6ba352ef759b0311a3f65db52e714bddd5a7352cdca5a.jpg)  
图3.13输入受限的双端队列  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cfbdac15b091802d5970ceea862de0c0a58f0a2d29a4adb9cb4967e4c9bcc15c.jpg)  
图3.14输出受限的双端队列  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/224fbf5bfba12b3a501404b5a4aa8fe80f204a22b869d41a9a87709a7ab11172.jpg)  

通过输出受限的双端队列不能得到的两种输出序列是 $4,1,3,2$ 和4.2,3，1综上所述：  

1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的是4，1，3，2。2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的是4，2，1，3。3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的是4，2，3，1。  

提示：实际双端队列的考题不会这么复杂，通常仅判断序列是否满足题设条件，代入验证即可。  

# 3.2.5本节试题精选  

# 一、单项选择题  

01.栈和队列的主要区别在于（）  

A.它们的逻辑结构不一样 B.它们的存储结构不一样 C.所包含的元素不一样D.插入、删除操作的限定不一样  

02.队列的“先进先出”特性是指（）。  

I.最后插入队列中的元素总是最后被删除II.当同时进行插入、删除操作时，总是插入操作优先III.每当有删除操作时，总要先做一次插入操作IV.每次从队列中删除的总是最早插入的元素  

A.I B.I和IV C.II和ⅢII D.IV  

03.允许对队列进行的操作有（）  

A.对队列中的元素排序B.取出最近进队的元素C.在队列元素之间插入元素D.删除队头元素  

04.一个队列的入队顺序是1，2，3，4，则出队的输出顺序是（）A.4,3,2,1 B.1,2,3,4 C.1,4,3,2 D.3,2,4,1

 05.循环队列存储在数组A[0..n]中，入队时的操作为（）。  

A.rear $\smile$ rear $^{+1}$ B.rear $=$ (rear $^{+1}$ ）mod（n-1）C. rear  $\smile$  (rear  $^{+1}$  ）modn D.rear  $=$  （rear+1）mod  $(\mathtt{n}\!+\!1)$  

06.已知循环队列的存储空间为数组A[21]，front指向队头元素的前一个位置，rear指向队尾元素，假设当前front和rear的值分别为8和3，则该队列的长度为（）。  

A.5 B.6 C.16 D.17  

07.若用数组A[0..5]实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（）。  

A.3和4 B.3和0 C.5和0 D.5和1  

08.假设用数组Q[MaxSize]实现循环队列，队首指针front指向队首元素的前一位置队尾指针rear指向队尾元素，则判断该队列为空的条件是（）A.(Q.rear  $^{+1}$  )MaxSize  $==$  (Q.front  $^{+1}$  )%MaxSize B.（Q.rear  $^{+1}$  )MaxSize  $==Q$  .front+l C. (Q.rear  $^{+1}$  )%MaxSize  $==Q$  .front D.Q.rear  $\scriptstyle{\stackrel{\prime}{=}}=Q$  .front  
09.假设循环队列Q[MaxSize]的队头指针为front，队尾指针为rear，队列的最大容量为MaxSize，此外，该队列再没有其他数据成员，则判断该队列已满条件是（）。  

A.Q.front  $==Q$  .rear B.Q.front  $+Q$  .rear>  $>=$  MaxSize C.Q.front  $==$  (Q.rear  $^{+1}$  )MaxSize D.Q.rear  $==$  (Q.front  $^{+1}$  )MaxSize  

10.假设用A[o.n]实现循环队列，front、rear分别指向队首元素的前一个位置和队尾元素。若用（rear $^{+1}$ 一 $\gtrapprox$  $(\mathrm{n}{+}1)==$ front作为队满标志，则（）。  

A.可用front $==$ rear作为队空标志B.队列中最多可有 $_{\mathrm{n+1}}$ 个元素C.可用front>rear作为队空标志D.可用（front $^{+1}$ ) $(\mathsf{n}\!+\!\mathsf{1})==$ rear作为队空标志  

11.与顺序队列相比，链式队列（）。  

A优点是队列的长度不受限制B.优点是进队和出队时间效率更高C.缺点是不能进行顺序访问D.缺点是不能根据队首指针和队尾指针计算队列的长度  

12.最适合用作队列的链表是（）  

A.带队首指针和队尾指针的循环单链表B.带队首指针和队尾指针的非循环单链表C.只带队首指针的非循环单链表D.只带队首指针的循环单链表  

13.最不适合用作链式队列的链表是（）  

A.只带队首指针的非循环双链表B.只带队首指针的循环双链表C.只带队尾指针的循环双链表D.只带队尾指针的循环单链表  

14.在用单链表实现队列时，队头设在链表的（）位置。A.链头B.链尾C.链中D.以上都可以

15.用链式存储方式的队列进行删除操作时需要（）。  

A.仅修改头指针 B.仅修改尾指针 C.头尾指针都要修改D.头尾指针可能都要修改  

16.在一个链队列中，假设队头指针为front，队尾指针为rear，x所指向的元素需要入队，则需要执行的操作为（）。  

A.front  $_{\mathrm{max}}$  ,front  $=$  front->next B.x->next  $=$  front->next,front  $=\!\mathrm{x}$  C.rear->next  $=\!\times$  ,rear  $=\!\times$  D.rear->next  $=\times$  ,x->next  $=$  NULL,rear  $\scriptstyle{\times=\times}$  

17.假设循环单链表表示的队列长度为 $n$ ，队头固定在链表尾，若只设头指针，则进队操作的时间复杂度为（）。  

A.O(n) B.O(1) C. 0(n) D.O(nlog2n)

 18.假设输入序列为 $1,2,3,4,5$ ，利用两个队列进行出入队操作，不可能输出的序列是（）。A.1,2,3,4,5 B.5,2,3,4,1 C.1,3,2,4,5 D.4,1,5,2,3  
19.若以1，2，3，4作为双端队列的输入序列，则既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列是（）。  

A.1,2,3,4 B.4,1,3,2 C. 4,2,3,1 D.4,2,1,3  

20.【2010统考真题】某队列充许在其两端进行入队操作，但仅充许在一端进行出队操作。若元素 $a,b,c,d,e$ 依次入此队列后再进行出队操作，则不可能得到的出队序列是（）  

A.  $b,a,c,d,e$  B.  $d,b,a,c,e$  C.  $d,b,c,a,e$  D.  $e,c,b,a,d$  

21.【2011统考真题】已知循环队列存储在一维数组 $\mathbb{A}\left[0...\mathtt{n}\!-\!1\right]$ 中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[o］处，则初始时front和rear的值分别是（）。  

A.0,0 B.0，  $n\!-\!1$  C.  $n\!-\!1$  ，0 D.  $n-1\,,\;\;n-1$  

22.【2014统考真题】循环队列放在一维数组A[0..M-1]中，end1指向队头元素，end2指 向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是（）。  

A.队空：endl  $==$  end2; 队满：endl  $==$  (end2+1) mod M B.队空：endl  $==$  end2; 队满：end2  $==(\mathsf{e n d}1\!+\!1$  ）mod (M-1) C.队空：end2  $==$  (end1  $^{+1}$  )mod M; 队满：endl  $_{\mathrm{\Lambda}}==(\mathsf{e n d}2\!+\!1)$  ）mod M D.队空：end1  $==$  (end2  $^{+1}$  )mod M; 队满：end2  $==$  (end1+1) mod (M-1)  

23.【2018统考真题】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6（1在队头），S为空。若仅允许下列3种操作： $\textcircled{\scriptsize{1}}$ 出队并输出出队元素； $\circledcirc$ 出队并将出队元素入栈； $\textcircled{3}$ 出栈并输出出栈元素，则不能得到的输出序列是（）。  

A.  $1,2,5,6,4,3$  B.2,3,4,5,6,1 C.3,4,5,6,1,2 D.6,5,4,3,2,1  

24.【2021统考真题】初始为空的队列Q的一端仅能进行入队操作，另外一端既能进行入队操作又能进行出队操作。若Q的入队序列是1,2,3,4,5，则不能得到的出队序列是（）。  

A.5,4,3,1,2 B.5,3,1,2,4 C.4,2,1,3,5 D.4,1,3,2,5  

# 二、综合应用题  

01.若希望循环队列中的元素都能得到利用，则需设置一个标志域tag，并以tag的值为0或1来区分队头指针front和队尾指针rear相同时的队列状态是“空”还是“满”。试编写与此结构相应的入队和出队算法。  

02.Q是一个队列，S是一个空栈，实现将队列中的元素逆置的算法。  

03.利用两个栈S1和S2来模拟一个队列，已知栈的4个运算定义如下：  

Push (S,x) ; //元素x入栈S Pop(S,x);//s出栈并将出栈的值赋给 $_\mathrm{x}$ StackEmpty(S);//判断栈是否为空Stack Overflow(S);//判断栈是否满  

如何利用栈的运算来实现该队列的3个运算（形参由读者根据要求自己设计）？  

Enqueue;//将元素x入队Dequeue;//出队，并将出队元素存储在 $_\mathrm{x}$ 中QueueEmpty;//判断队列是否为空  

04.【2019统考真题】请设计一个队列，要求满足： $\textcircled{\scriptsize{1}}$ 初始时队列为空； $\circledcirc$ 入队时，允许增加队列占用空间； $\textcircled{3}$ 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减； $\textcircled{4}$ 入队操作和出队操作的时间复杂度始终保持为 $O(1).$ 请回答：1）该队列是应选择链式存储结构，还是应选择顺序存储结构？2）画出队列的初始状态，并给出判断队空和队满的条件。3）画出第一个元素入队后的队列状态。4）给出入队操作和出队操作的基本过程  
# 3.2.6 答案与解析  

# 一、单项选择题  

01.D  

栈和队列的逻辑结构都是线性结构，都可以采用顺序存储或链式存储，C显然也错误。只有D才是栈和队列的本质区别，限定表中插入和删除操作位置的不同。  

02.B  

队列“先进先出”的特性表现在：先进队列的元素先出队列，后进队列的元素后出队列，进 队列对应的是插入操作，出队列对应的是删除操作。I和IV均正确。  

03.D 删除队头元素即出队，是队列的基本操作之一，所以选D。  

04.B  

05.D  

数组下标范围 $_{0\sim\mathrm{n}}$ ，因此数组容量为 $_{\mathrm{n+1}}$ 。循环队列中元素入队的操作是rear $\Leftarrow$ (rear $^{\cdot+1}$ >modmaxsize，题中maxsize $\tt=\tt n+1$ 。因此入队操作应为rear $\smile$ (rear $^{+1}$ ）mod $(\mathtt{n}\!+\!1)$ 。  

06.C  

队列的长度为（rear-front+maxsize）&maxsize  $=$  (rear-front  $^{+21}$  一  $\approx\!21\!=\!1$  6。这种情 况和front指向当前元素，rear指向队尾元素的下一个元素的计算是相同的。  

# 注意  

数组A[n]的下标范围为 $0\sim\mathrm{n}{-}1$ 。若写成A[o..n]，则说明下标范围为 $0\sim\mathrm{n_{\circ}}$  

07.B  

循环队列中，每删除一个元素，队首指针front $=$ (front $^{+1}$ ）。6，每插入一个元素，队尾指针rear $=$ (rear $^{+1}$ ）%6。上述操作后，front $=\!0$ ，rear $^{;=3}$ 。  

08.D  

当队列中只有一个元素时，front指向该元素的前一个位置，rear指向该元素，因此当队列为空时，队首指针等于队尾指针，这样第一个元素进队后，才能符合题目要求。  

09.C  

既然不能附加任何其他数据成员，只能采用牺牲一个存储单元的方法来区分是队空还是队满，约定以“队列头指针在队尾指针的下一位置作为队满的标志”，因此选C。选项A是判断队列是否空的条件，选项B和D都是干扰项。  

# 注意  

对于这类具体问题，举一些特例判断往往比直接思考问题能更快得到答案。  

10.A  

若用（rear $^{+1}$  $(\mathsf{n}\!+\!\mathsf{1})==$ front作为队满标志，则说明题目采用了牺牲一个存储单元的方法来区分队空和队满，因此可用front $==$ rear作为队空标志。  
11.D  

虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的进队和出队时间均为 $O(1)$ 。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队头指针和队尾指针计算队列中的元素个数，而链式队列则不能。  

12.B  

因为队列需在双端进行操作，所以选项C和D的链表显然不太适合链队。对于A，链表在完成进队和出队后还要修改为循环的，对于队列来讲这是多余的（画蛇添足）。对于B，因为有首指针，所以适合删除首结点；因为有尾指针，所以适合在其后插入结点。  

13.A  

因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要 $O(n)$ 的时间。B、C和D均可在 $O(1)$ 的时间内找到队首和队尾。  

14. A 因为在队头做出队操作，为便于删除队头元素，所以总是选择链头作为队头。  

15.D  

队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素，则尾指针也需要被修改，当仅有一个元素时，删除后队列为空，需修改尾指针为rear $\smile$ front。  

16.D  

插入操作时，先将结点 $_\mathrm{x}$ 插入到链表尾部，再让rear指向这个结点 $_\mathrm{x}$ 。C的做法不够严密，因为是队尾，所以队尾 $\mathbf{x}$ ->next必须置为空。  

17. A  

依题意，进队操作是在队尾进行，即链表表头。题中已明确说明链表只设头指针，也即没有头结点和尾指针，进队后，循环单链表必须保持循环的性质，在只带头指针的循环单链表中寻找表尾结点的时间复杂度为 $O(n)$ ，所以进队的时间复杂度为 $O(n)$  

18.B  

此类题可对各选项进行模拟，假设队列为 $\mathrm{Q}_{1}$ 和 $\mathrm{Q}_{2}$ 。对于A，元素依次入队 $\mathrm{Q}_{1}$ ，然后依次出队。对于B，5最先出队，只可能是 $1,2,3,4$ 入队 $\mathrm{Q}_{1}$ ，5入队 $\mathbf{Q}_{2}$ ，然后5出队，只能得到5，1,23,4。对于℃，1,2,5入队 $\mathrm{Q}_{1}$ ，3,4入队 $\mathrm{Q}_{2}$ ，然后按要求出队。D的分析同C。  

19. C  

使用排除法。先看可由输入受限的双端队列产生的序列：设右端输入受限，1，2，3，4依次左入，则依次左出可得4,3,2，1，排除A；左出、右出、左出、左出可得到 $4,1,3,2$ ，排除B；再看可由输出受限的双端队列产生的序列：设右端输出受限，1，2，3，4依次左入、左入、右入、左入，依次左出可得到4,2，1,3，排除D。  

20.C  

本题的队列实际上是一个输出受限的双端队列，如图3.11所示。A操作： $a$ 左入（或右入） $^b$ 左入、 $c$ 右入、 $d$ 右入、 $e$ 右入。B操作： $a$ 左入（或右入）、 $b$ 左入、 $c$ 右入、 $d$ 左入、 $e$ 右入。D操作： $a$ 左入（或右入）、 $b$ 左入、 $c$ 左入、 $d$ 右入、 $e$ 左入。C操作： $a$ 左入（或右入）、 $b$ 右入、因 $d$ 未出，此时只能进队， $c$ 怎么进都不可能在 $^b$ 和 $a$ 之间。  

【另解】初始时队列为空，第1个元素 $a$ 左入（或右入）后，第2个元素 $^b$ 无论是左入还是右入都必与 $a$ 相邻，而选项C中 $a$ 与 $^b$ 不相邻，不合题意。  
21.B  

根据题意，第一个元素进入队列后存储在A[0]处，此时front和rear值都为0。入队时因为要执行（rear $^{+1}$ ）n操作，所以若入队后指针指向0，则rear初值为 $_{\mathrm{n-1}}$ ，而因为第一个元素在A[0]中，插入操作只改变rear指针，所以front为0不变。  

# 注意  

$\textcircled{\scriptsize{1}}$ 循环队列是指顺序存储的队列，而不是指逻辑上的循环，如循环单链表表示的队列不能称为循环队列。 $\textcircled{2}$ front和rear的初值并不是固定的。  

22.A  

end1指向队头元素，可知出队操作是先从A[end1]读数，然后end1再加1。end2指向队尾元素的后一个位置，可知入队操作是先存数到A[end2］，然后end2再加1。若用A[0]存储第一个元素，队列初始时，入队操作是先把数据放到A[0]中，然后end2自增，即可知end2初值为0：而end1指向的是队头元素，队头元素在数组A中的下标为0，所以得知end1的初值也为0，可知队空条件为end1 $==$ end2；然后考虑队列满时，因为队列最多能容纳M-1个元素，假设队列存储在下标为0到M-2的M-1个区域，队头为A[0]，队尾为A[M-2]，此时队列满，考虑在这种情况下end1和end2的状态，end1指向队头元素，可知end1 $=\!0$ ,end2指向队尾元素的后一个位置，可知end2 $\scriptstyle{\mathrm{\Sigma}}=\mathbf{M}-2+1=\mathbf{M}-1$ ，所以队满的条件为end1 $==$ (end2+1)modM。  

23. C  

选项A的操作顺序为①①②②①①③③。选项B的操作顺序为  $\scriptstyle\left({\mathfrak{Q}}({\mathfrak{Q}}({\mathfrak{Q}}({\mathfrak{Q}}({\mathfrak{Q}}({\mathfrak{Q}})){\mathfrak{Q}}){\mathfrak{Q}})\right)$  。选项D的 操作顺序为②②②②②①③③③③③。对于C：首先输出3，说明1和2必须先依次入栈，而此 后2肯定比1先输出，因此无法得到1，2的输出顺序。  

24.D  

假设队列左端允许入队和出队，右端只能入队。对于A，依次从右端入队1，2，再从左端 入队3，4，5。对于B，从右端入队1，2，然后从左端入队3，再从右端入队4，最后从左端入队5。对于C，从左端入队1，2，然后从右端入队3，再从左端入队4，最后从右端入队5。无法验证D的序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/787d203e22b7fec4520a4cca00193f260c6a167c436c780f9efc73cfd1809866.jpg)  

二、综合应用题  

01.【解答】  

在循环队列的类型结构中，增设一个tag 的整型变量，进队时置tag 为1，出队时置tag为0(因为只有入队操作可能导致队满，也只有出队操作可能导致队空)。队列Q初始时，置tag $\mathrm{=}0$ front $=$ rear $:=0$ 。这样队列的4要素如下：  

队空条件：Q.front  $==Q$  .rear且Q.tag  $==0$  

队满条件：Q.front  $==Q$  .rear且Q.tag  $==1$  进队操作：Q.data[Q.rear] $=\!\mathrm{x}$ ; Q.rear $=$ (Q.rear $^{\prime+1}$ ) %MaxSize; Q.tag $_{=1}$ 。出队操作： $\scriptstyle{\mathrm{x}}=Q$ .data[Q.front]; Q.front $=$ (Q.front $^{+1}$ ) %MaxSize; Q.tag $=\!0$ 。1）设“tag”法的循环队列入队算法：  
int EnQueuel（SqQueue &Q,ElemType x）(if(Q.front $==Q$ .rear&&Q.tag $==1$ 一return0; //两个条件都满足时则队满 Q.data[Q.rear]  $=\!\mathrm{x}$  Q.rear  $=$  (Q.rear  $^{+1}$  )MaxSize; Q.tag $^{=1}$ //可能队满return 1;  

2）设“tag”法的循环队列出队算法：  

int DeQueuel（SqQueue &Q，ElemType &x）{if(Q.front  $==Q$  .rear&&Q.tag  $\scriptstyle{\mathrel{=}}0$  return 0; 1/两个条件都满足时则队空  $\scriptstyle{\mathrm{x}}=Q$  .data[Q.front]; Q.front  $=$  (Q.front+1)&MaxSize; Q.tag $=\!0$ /可能队空return1;  

02.【解答】  

本题主要考查大家对队列和栈的特性与操作的理解。因为对队列的一系列操作不可能将其中的元素逆置，而栈可以将入栈的元素逆序提取出来，所以我们可以让队列中的元素逐个地出队列，入栈；全部入栈后再逐个出栈，入队列。  

算法的实现如下：  

void Inverser（Stack &S,Queue &Q）川本算法实现将队列中的元素逆置while(!QueueEmpty(Q)){  $\mathrm{x}{=}$ DeQueue（Q);//队列中全部元素依次出队Push（S,x);1元素依次入栈while(!StackEmpty(S)){ Pop(S,x);/栈中全部元素依次出栈EnQueue（Q，x）;//再入队  

03.【解答】  

利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用s1来存放已输入的元素，即S1执行入栈操作。当需要出队时，则对S2执行出栈操作。因为从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而在执行此操作前必须判断S2是否为空，否则会导致顺序混乱。当栈S1和S2都为空时队列为空。  

总结如下：  

1）对s2的出栈操作用做出队，若S2为空，则先将S1中的所有元素送入S2。  

2）对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中的元素全部插入S2中。  

入队算法：  

int EnQueue（Stack &Sl,Stack &S2,ElemType e){  
if(!Stack Overflow(Sl))Push(Sl,e);returnl; if(Stack Overflow(S1)&&!StackEmpty(S2)){ printf（"队列满"）; return 0; if（Stack Overflow(S1)&&StackEmpty(S2)){while(!StackEmpty(Sl)){ Pop(S1,x）; Push  $(\mathbb{S}2,\mathbb{x})$  Push(Sl,e);return 1;  

出队算法：  

void DeQueue（Stack &S1,Stack &S2,ElemType &x)if(!StackEmpty(S2)){ Pop(S2,x);else if(StackEmpty(Sl))printf（"队列为空"）；elsef while(!StackEmpty(Sl)) Pop(S1,x);Push  $(S2,x)$  Pop(S2,x）;  

判断队列为空的算法：  

int QueueEmpty(Stack S1,Stack S2){ if(StackEmpty(S1)&&StackEmpty(S2))return1；else return0；  

04.【解答】  

1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要求 $\textcircled{\scriptsize{1}}$ 容易满足：链式存储方便开辟新空间，要求 $\circledcirc$ 容易满足：对于要求 $^{(3)}$ ，出队后的结点并不真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作和出队操作的时间复杂度均为 $O(1)$ ，要求 $^{(4)}$ 可以满足。  
因此，采用链式存储结构（两段式单向循环链表），队头指针为front，队尾指针为rear。2）该循环链式队列的实现可以参考循环队列，不同之处在于循环链式队列可以方便地增加空简，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空闲结点的循环单链表，头指针front和尾指针rear均指向空闲结点，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/380c264a1128fdb1df6ed7dfb1ef3d1684cd6e6ab71433fa1d3a19bf35a7a8c7.jpg)  

队空的判定条件：front $==$ rear。队满的判定条件：front  $==$  rear->next.  

3）插入第一个元素后的状态如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ebe831b2e73eb16d67dd91c3dbb644c74e082a79f54dc9de8725737ab0d7f2b2.jpg)  

4）操作的基本过程如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7a08ad28343bc900eb3c7413b361bbc507540302fc355d120f096827603aceb.jpg)  

# 3.3栈和队列的应用  

要熟练掌握栈和队列，必须学习栈和队列的应用，把握其中的规律，然后举一反三。接下来将简单介绍栈和队列的一些常见应用。  

# 3.3.1栈在括号匹配中的应用  

假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序任意即（[]（））或[（[][]）]等均为正确的格式，【（]）或（[（））或（（）]均为不正确的格式。  

考虑下列括号序列：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0cd3915f55655148ee9e4f297d3c26daed9b7f1d084ad8250aa813568d341f5a.jpg)  

分析如下：  

1）计算机接收第1个括号“”后，期待与之匹配的第8个括号“]”出现。2）获得了第2个括号“（”，此时第1个括号“[”暂时放在一边，而急迫期待与之匹配的第  
7个括号“）”出现。  

3）获得了第3个括号“[”，此时第2个括号“（”暂时放在一边，而急迫期待与之匹配的第4个括号“”出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又成为当前最急道的任务。  

4）以此类推，可见该处理过程与栈的思想吻合。  

算法的思想如下：  

1）初始设置一个空栈，顺序读入括号。  

2）若是左括号，则作为一个新的更急追的期待压入栈中，自然使原有的栈中所有未消解的期待的急迫性降了一级。  

3）若是右括号，则或使置于栈顶的最急迫期待得以消解，或是不合法的情况（括号序列不匹配，退出程序）。算法结束时，栈为空，否则括号序列不匹配。  

# 3.3.2栈在表达式求值中的应用  

表达式求值是程序设计语言编译中一个最基本的问题，它是栈应用的一个典型范例。  

# 1.算术表达式  

中缀表达式（如3+4）是人们常用的算术表达式，操作符以中缀形式处于操作数的中间。与前缀表达式（如+34）或后缀表达式（如 $34+$ ）相比，中缀表达式不容易被计算机解析，但仍被许多程序语言使用，因为它更符合人们的思维习惯。  

与前缀表达式或后缀表达式不同的是，中缀表达式中的括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。后缀表达式的运算符在操作数后面后缀表达式中考虑了运算符的优先级，没有括号，只有操作数和运算符。  

中缀表达式 $\mathtt{A}\!+\!\mathtt{B}^{\star}$ （C-D）-E/F对应的后缀表达式为ABCD- $\star+\mathtt{E F}/-$ ，将后缀表达式与原表达式对应的表达式树（图3.15）的后序遍历序列进行比较，可发现它们有异曲同工之妙。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f8f4edba937b98723b163204e382184bedf71a343caf83f2f893e1ded9054c59.jpg)  
图3.15 $\mathbb{A}\!+\!\mathbb{B}^{\star}$ （C-D）-E/F对应的表达式树  

# 2.中缀表达式转后缀表达式  

下面先给出一种由中缀表达式转后缀表达式?的手算方法。  

1）按照运算符的运算顺序对所有运算单位加括号。2）将运算符移至对应括号的后面，相当于按“左操作数右操作数运算符”重新组合。 3）去除所有括号。例如，中缀表达式 $\mathsf{A}\!+\!\mathsf{B}^{\star}\left(\mathsf{C}\!-\!\mathsf{D}\right)-\!\mathsf{E}\big/\,\mathrm{F}$ 转后缀表达的过程如下（下标表示运算符的运算顺序）：1）加括号： $\begin{array}{r}{\mathrm{~\left(~\left(Z+\mathcal{G}\right)\left(B^{\star}\mathcal{D}\right)\left(C-\mathcal{G}_{\mathcal{D}}\right)~\right)~\rangle~}-\mathrm{\mathcal{G}\left(E/\mathcal{G}\right)F}\mathrm{~\rangle~}}\end{array}$  
2）运算符后移： $\left(\left(\mathbb{A}\left(\mathbb{B}\left(\mathbb{C}\mathbb{D}\right)-_{(\mathbb{D})}\right)\star_{(\mathbb{D})}\right)+_{(\mathbb{B})}\left(\mathbb{E}\mathbb{F}\right)/_{(\mathbb{A})}\right)-_{(\mathbb{B})\circ}$ 3）去除括号后，得到后缀表达式：ABCD- $\scriptstyle(\bigoplus^{\star}(\mathcal{D})^{+}(\mathcal{D})\mathtt{E F}/_{(\mathcal{A})^{-}(\mathcal{B})^{\circ}}$  

命题追踪中缀表达式转后缀表达式的过程（2012、2014）  

在计算机中，中缀表达式转后缀表达式时需要借助一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右依次扫描中缀表达式中的每一项，具体转化过程如下：  

1）遇到操作数。直接加入后缀表达式。  

2）遇到界限符。若为“（”，则直接入栈；若为“）”，则依次弹出栈中的运算符，并加入后缀表达式，直到弹出“（”为止。注意，“（”直接删除，不加入后缀表达式。  

3）遇到运算符。若其优先级高于除“（”外的栈顶运算符，则直接入栈。否则，从栈顶开始，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，直到遇到一个优先级低于它的运算符或遇到“（”时为止，之后将当前运算符入栈。  

按上述方法扫描所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。例如，中缀表达式 $\mathtt{A}\!+\!\mathtt{B}^{\star}$ （C-D）-E/F转后缀表达式的过程如表3.1所示。  

表3.1中缀表达式 $\tt A+\tt B^{+}$ (C-D）-E/F转后缀表达式的过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7d59a1e6b98dabe04671cea9f7370d964faf9cc2185c70ec263d36354a0bf00f.jpg)  

# 命题追踪栈的深度分析（2009、2012）  

所谓栈的深度，是指栈中的元素个数，通常是给出进栈和出栈序列，求最大深度（栈的容量应大于或等于最大深度）。有时会间接给出进栈和出栈序列，例如以中缀表达式和后缀表达式的形式给出进栈和出栈序列。掌握栈的先进后出的特点进行手工模拟是解决这类问题的有效方法。  

3.后级表达式求值  

# 命题追踪用栈实现表达式求值的分析（2018）  

通过后缀表示计算表达式值的过程：从左往右依次扫描表达式的每一项，若该项是操作数，则将其压入栈中;若该项是操作符<op>,则从栈中退出两个操作数Y和x,形成运算指令X<op>Y，并将计算结果压入栈中。当所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。例如，后缀表达式ABCD一 $\star+\mathrm{EF}/-$ 求值的过程需要12步，见表3.2。  
表3.2后缀表达式 $\mathtt{A B C D-star+E F}/$ 一求值的过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/009b49fea9da6b6600cee3e7f9f793fc89dbabc4280106bfa145e14317d4e668.jpg)  

# 3.3.3栈在递归中的应用  

递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。  

它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。但在通常情况下，它的效率并不是太高。  

以斐波那契数列为例，其定义为  

$$
F(n)={\left\{\begin{array}{l l}{F(n-1)+F(n-2),\;n>1}\\ {1,\qquad\qquad\quad n=1}\\ {0,\qquad\qquad\quad n=0}\end{array}\right.}
$$  

这就是递归的一个典型例子，用程序实现时如下：int F（intn)( 1/斐波那契数列的实现  

if  $\mathrm{{dn}}{=}{0}$  return0;/边界条件elseif $\scriptstyle{\mathrm{==}}1$ 一return1;//边界条件else returnF（n-1)+F（n-2）;/递归表达式  

必须注意递归模型不能是循环定义的，其必须满足下面的两个条件：  

递归表达式（递归体）。·边界条件（递归出口）。递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题，  

在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。下面以 $n=5$ 为例，列出递归调用执行过程，如图3.16所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b1765aa7b3b4d8bce1ae3fe8341015f640cd60fb984c62cec77f3cc6d17e1f8c.jpg)  
图3.16F（5）的递归执行过程  

显然，在递归调用的过程中，F（3）被计算2次，F（2）被计算3次。F（1）被调用5次，F（0）被调用3次。所以，递归的效率低下，但优点是代码简单，容易理解。在第5章的树中利用了递归的思想，代码变得十分简单。通常情况下，初学者很难理解递归的调用过程，若读者想具体了解递归是如何实现的，可以参阅编译原理教材中的相关内容。  

可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。  

# 3.3.4队列在层次遍历中的应用  

在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。下面用二叉树（见图3.17）层次遍历的例子，说明队列的应用。表3.3显示了层次遍历二叉树的过程  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2b923f9d4833a808612db9c30f2b85b5133d8a56cbfeb7966bdd34458b5317ce.jpg)  

表3.3层次遍历二叉树的过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8cb24cb677bef69da981cbb6d7b317e1b439554c47c344cfb7888cd321a0604.jpg)  
(续表) 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0046326bdaef5b60248505d24f7bbb224e8462e86a9e27e83c0d92838d5788e3.jpg)  

该过程的简单描述如下：  

$\textcircled{\scriptsize{1}}$ 根结点入队。  

$\circledcirc$ 若队空（所有结点都已处理完毕），则结束遍历；否则重复 $\textcircled{3}$ 操作。 $\textcircled{3}$ 队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回 $^{(2)}$  

# 3.3.5队列在计算机系统中的应用  

队列在计算机系统中的应用非常广泛，以下仅从两个方面来阐述：第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。  

# 命题追踪缓冲区的逻辑结构（2009）  

对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，因为速度不匹配，若直接把输出的数据送给打印机打印，则显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓 冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。  

# 命题追踪多队列出队/入队操作的应用（2016）  

对于第二个方面，CPU（即中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU能够正常运行。  

# 3.3.6 本节试题精选  

# 一、单项选择题  

01.栈的应用不包括（）。  

A.递归B.表达式求值C.括号匹配D.缓冲区  

02.表达式a\* $(\mathtt{b}+\mathtt{C}$ ）-d的后缀表达式是（）  

A.abcd\*+- B.abc+\*dC.abc\*+dD.-+\*abcd  

03．下面（）用到了队列。  

A.括号匹配B.表达式求值C.递归D.FIFO页面替换算法  
04.利用栈求表达式的值时，设立运算数栈OPEN。假设OPEN只有两个存储单元，则在下列表达式中，不会发生溢出的是（）。  

A. $\mathbb{A}{\mathrm{-}}\mathbb{B}*\left(\mathbb{C}{\mathrm{-}}\mathbb{D}\right)$ B.（A-B）\*C-DC.（A-B\*C)-DD.（A-B）\*（C-D）  

05.执行完下列语句段后， $i$ 的值为（）  

int f（int x）{ return  $\{\begin{array}{l}{({\bf x}{>}0)~?~~{\bf x}^{\star}\,{\bf f}~({\bf x}{-}1):2)}\end{array}$  int i; i=f（f（1））;  

A.2 XB.4 C.8 D.无限递归

 06.设有如下递归函数，则计算F（8）需要调用该递归函数的次数为（）  

int F（int n）{if  $\mathrm{{Kn}}{<}{=}3$  ）return1; elsereturn  $\mathtt{F}\left(\mathtt{n}\!-\!2\right)+\mathtt{F}\left(\mathtt{n}\!-\!4\right)+1$  八  

A.7 B.8 C.9 D.10

 07.设有如下递归函数，在func（func（5））的执行过程中，第4个被执行的func函数是（）。  

intfunc（int x）{ if  $\scriptstyle\times<=3$  )return2; else return func（x-2)+func（x-4);  

A.func（2） B.func（3） C.func（4） D.func（5)

 08.对于一个问题的递归算法求解和其相对应的非递归算法求解，（）。  

A.递归算法通常效率高一些B.非递归算法通常效率高一些C.两者相同D.无法比较  

09.执行函数时，其局部变量一般采用（）进行存储。A.树形结构B.静态链表C.栈结构D.队列结构

10.执行（）操作时，需要使用队列作为辅助存储空间。  

A.查找散列（哈希）表B.广度优先搜索图C.前序（根）遍历二叉树D.深度优先搜索图  

11.下列说法中，正确的是（）。  

A.消除递归不一定需要使用栈B.对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同C.通常使用队列来处理函数或过程调用D.队列和栈都是运算受限的线性表，只允许在表的两端进行运算  

12.【2009统考真题】为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（）。  

A.栈B.队列C.树D.图  

13.【2012统考真题】已知操作符包括“ $^+$ ”“_”“ $^*$ ”“/”“（”和“）”。将中缀表达式 $\mathsf{a}\!+\!\mathsf{b}\!-\!\mathsf{a}^{\star}\left(\mathsf{\Omega}\left(\mathsf{c}\!+\!\mathsf{d}\right)/\mathsf{e}\!-\!\mathsf{f}\right)+\!\mathsf{g}$ 转换为等价的后缀表达式ab+acd+e/f-\*-g+时，用栈来存放暂时还不能确定运算次序的操作符。栈初始时为空时，转换过程中同时保存在栈中的操作符的最大个数是（）  
A.5 B.7 C. 8 D.11  

14.【2014统考真题】假设栈初始为空，将中缀表达式a/b+（c\*d-e\*f）/g转换为等价的后 缀表达式的过程中，当扫描到f时，栈中的元素依次是（）。  

A.  $+\left(\star_{-}\right.$  B.  $\;+\;(-\,^{\star}$  C.  $/+(^{\star}-^{\star}$  D./+-\*  

15.【2015统考真题】已知程序如下：  

int S（intn) return $\mathrm{{n}}{<}{=}0$ ）？0:S（n-1）+n;)voidmain() cout<<S（1);}  

程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是（）  

Amain()→S（1)→S（0)B.S（0)→S（1)→main（）C. main()→S（0)→S(1) D.S(1)→S（0)→main()  

16.【2016统考真题】设有如下图所示的火车车轨，入口和出口之间有 $n$ 条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1～9的9列列车，驶入的次序依次是 $8,4,2,5,3,9,1,6,7.$ 若期望驶出的次序依次为1\~9，则 $n$ 至少是()。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7fb459bcb832881cf8a44ec7c30e40528f0f21524023118e1e6197241f2d5d65.jpg)  

A.2B.3C.4D.5

17.【2017统考真题】下列关于栈的叙述中，错误的是（）  

1.采用非递归方式重写递归程序时必须使用栈I1.函数调用时，系统要用栈保存必要的信息I1I.只要确定了入栈次序，即可确定出栈次序IV.栈是一种受限的线性表，允许在其两端进行操作  

A.仅IB.仅I、ⅡI、IIIC.仅I、III、IVD.仅ⅡI、III、IV  

18.【2018统考真题】若栈S1中保存整数，栈S2中保存运算符，函数E（）依次执行下述各步操作：  

1）从S1中依次弹出两个操作数a和b 2）从S2中弹出一个运算符oP。3）执行相应的运算bopa。4）将运算结果压入S1中。假定S1中的操作数依次是5，8,3，2（2在栈顶），S2中的运算符依次是\*、-、+（+在栈顶）。调用3次F（）后，S1栈顶保存的值是（）。  

A.-15 B.15 C.-20 D.20  

二、综合应用题  

01.假设一个算术表达式中包含圆括号、方括号和花括号3种类型的括号，编写一个算法来判别表达式中的括号是否配对，以字符“0”作为算术表达式的结束符。  
# 3.3.7 答案与解析  

# 一、单项选择题  

01.D  

缓冲区是用队列实现的，A、B、C都是的典型应用。  

02.B  

后缀表达式中，每个计算符号均直接位于其两个操作数的后面，按照这样的方式逐步根据计算的优先级将每个计算式进行变换，即可得到后缀表达式。  

另解：将两个直接操作数用括号括起来，再将操作符提到括号后，最后去掉括号。例如，对于 $\left(\mathfrak{O}\left(\mathfrak{O}^{\mathfrak{a}^{\star}}\left(\mathfrak{O}^{\mathfrak{b}+\mathfrak{c}}\right)\ \right)-\mathfrak{d}\right)$ ，提出操作符并去掉括号后，可得后缀表达式为abc+\*d-。  

学完第5章后，可将表达式画成二叉树的形式，再用后序遍历即可求得后缀表达式  

03.D  

FIFO页面替换算法用到了队列。其余的都只用到了栈。  

04.B  

利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得R1，C入栈，计算得R2，D入栈，计算得R3，由此得栈深为2。A、C、D依次计算得栈深为4、3、3。因此选B。  

技巧：根据算符优先级，统计已依次进栈，但还没有参与计算的运算符的个数。以选项C为例，当“（”“A”“_”入栈时，“（”和“_”还没有参与运算，此时运算符栈大小为2，“B”和“”入栈时运算符大小为3，“C”入栈时“B\*C”运算，此时运算符栈大小为2，以此类推。  

05.B  

栈与递归有着紧密的联系。递归模型包括递归出口和递归体两个方面。递归出口是递归算法的出口，即终止递归的条件。递归体是一个递推的关系式。根据题意有  

f  $(0){=}2$  f  $(1){=}1^{\star}\,\mathtt{f}\,(\,0\,){=}2$   $\textsf{f}(\textsf{f}(\mathbb{1})\ )=\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\$  6  

06.C  

计算F（8）的递归调用树如下图所示  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/748a9385d350d2b15e01cd71af324a050e09a739feb1950922e64d938adba8c6.jpg)  

由图可知，递归函数F（）调用的次数为9  

07.C  

首先，执行内层参数func（5） $=$ func(3) $^+$ func $(\mathbb{1})\!=\!4$ ，共执行3次func函数。然后，执行func（func（5）） $=$ func（4） $=$ func（2)+func（0） ${=}4$ ，因此第4个被执行的func函数是func（4）。也可以采用画出递归调用树的方式，即某个函数的执行次序等于其在递归调用树的层次遍历中的次序。  

08.B  
通常情况下，递归算法在计算机实际执行的过程中包含很多的重复计算，所以效率会低。  

09.C  

调用函数时，系统会为调用者构造一个由参数表和返回地址组成的活动记录，并将记录压入系统提供的栈中，若被调用函数有局部变量，也要压入栈中。  

10.B  

本题涉及第5章和第6章的内容，图的广度优先搜索类似于树的层序遍历，都要借助于队列。  

11.A  

使用栈可以模拟递归的过程，以此来消除递归，但对于单向递归和尾递归而言，可以用迭代的方式来消除递归，A正确。不同的进栈和出栈组合操作，会产生许多不同的输出序列，B错误。通常使用栈来处理函数或过程调用，C错误。队列和栈都是操作受限的线性表，但只有队列充许在表的两端进行运算，而栈只允许在栈顶方向进行操作，D错误。  

12.B  

在提取数据时必须保持原来数据的顺序，所以缓冲区的特性是先进先出。  

13.A  

在中缀表达式转后缀表达式的过程中，扫描到操作数时直接输出，扫描到操作符时根据其优先级进行相应的出入栈操作。有几点需要注意： $\textcircled{\scriptsize{1}}$ 若遇到界限符“（”，则直接入栈： $\circledcirc$ 若遇到界限符“）”，则不入栈，且会依次弹出栈顶运算符，直到遇到“（”为止，并删除“（”； $\textcircled{3}$ 若当前运算符的优先级高于栈顶运算符或者遇到栈顶为“（”，则直接入栈： $\textcircled{4}$ 若当前运算符的优先级低于或等于栈顶运算符，则依次弹出，直到遇到一个优先级高于它的运算符或者遇到“（”为止，之后将当前运算符入栈。  

求栈中操作符的最大个数时，为简单起见，可省略对操作数的处理。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/78d512e78db05c1a412424d4c4cc766b5e1e1194fb52e210182b3de3f31dd898.jpg)  

由上述过程可知，栈中操作符的最大个数为5。  

14.B  

中缀表达式 $\mathsf{a}/\mathsf{b}+\left(\mathsf{c}^{\star}\mathsf{d}{\mathsf{-e}}^{\star}\mathsf{f}\right)/\mathsf{g}$ 转换为后缀表达式的过程如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e075fb533b14cf49d93eac009ae1901b31b1e028be2a6e81c37f79b6306778e.jpg)  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/38d9c0ad26a5ef626d629d8777642f355830d0424202669aaea4c5abc6992a02.jpg)  

由此可知，当扫描到f时，栈中的元素依次是 $^+$ (一\*  

【另解】采用手算方法，得出中缀式 $\mathsf{a}/\mathsf{b}+\left(\mathsf{c}^{\star}\mathsf{d}\mathsf{-e}^{\star}\mathsf{f}\right)/\mathsf{g}$ 对应的后缀式为ab/cd\*ef\*-g/+。中缀表达式转后缀表达式时，操作数都直接输出，因此操作数的顺序是固定的。扫描到f时，在后缀表达式f后面的运算符要么还未入栈，要么还在栈中，需要结合中缀式来判断，f后面依次出栈的运算符为 $\star_{-}/+$ ，/在中缀表达式f之后，此时还未入栈，因此栈中的运算符（从栈底到栈顶）为 $+-\star$ ；此外，已入栈的界限符(此时还未消解，因此（也还在栈中，栈中的元素依次是+（-\*。  

15.A  

递归调用函数时，在系统栈中保存的函数信息需满足先进后出的特点，依次调用了main（），S（1）,S（0），所以栈底到栈顶的信息依次是main（），S（1），S（0）。  

# 注意  

在递归中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来存储  

16.C  

根据题意：入队顺序为 $8,4,2,5,3,9,1,6,7,$ ，出队顺序为 $1\!\sim\!9$ 。入口和出口之间有多个队列（n条轨道），且每个队列（轨道）可容纳多个元素（多列列车），为便于区分，队列用字母编号。分析如下：显然先入队的元素必须小于后入队的元素（否则，若8和4入同一个队列，8在4前面，则出队时也只能8在4前面），这样8入队列A，4入队列B，2入队列C，5入队列B（按照前述原则“大的元素在小的元素后面”也可将5入队列C，但这时剩下的元素3就必须放入一个新的队列中，无法确保“至少”），3入队列C，9入队列A，这时共占了3个队列，后面还有元素1，直接再用一个新的队列D，1从队列D出队后，剩下的元素6和7或入队列B，或入队列C。综上，共占用了4个队列。当然还有其他的入队、出队情况，请读者自己推演，但要确保满足： $\textcircled{\scriptsize{1}}$ 队列中后面的元素大于前面的元素； $\circledcirc$ 确保占用最少（即满足题意中“至少”）的队列。  

17.C  

I的反例：计算斐波拉契数列选代实现只需要一个循环即可实。ⅢI的反例：入栈序列为1,2，进行Push，Push，Pop，Pop操作，出栈次序为2、1；进行Push，Pop，Push，Pop操作，出栈次序为12。IV，栈是一种受限的线性表，只充许在一端进行操作。Ⅱ正确。  
18.B  

第一次调用： $\textcircled{\scriptsize{1}}$ 从S1中弹出2和3： $\circledcirc$ 从S2中弹出 $^{+}$  $\textcircled{3}$ 执行 $_{3+2=5}$ ； $\textcircled{4}$ 将5压入S1中，第一次调用结束后S1中剩余5、8、5（5在栈顶），S2中剩余\*、－（-在栈顶）。第二次调用： $\textcircled{\scriptsize{1}}$ 从S1中弹出5和8： $\circledcirc$ 从s2中弹出-： $\textcircled{3}$ 执行 $8\!-\!5\!\!=\!3$ ； $\textcircled{4}$ 将3压入S1中，第二次调用结束后S1中剩余5、3（3在栈顶），S2中剩余\*。第三次调用： $\textcircled{\scriptsize{1}}$ 从S1中弹出3和5； $\circledcirc$ 从S2中弹出\*； $\circledast$ 执行 $5^{\star}3{=}15$ ： $\textcircled{4})$ 将15压入S1中，第三次调用结束后S1中仅剩余15，S2为空。  

# 二、综合应用题  

01.【解答】  

括号匹配是栈的一个典型应用，给出这道题是希望读者好好掌握栈的应用。算法的基本思想是扫描每个字符，遇到花、中、圆的左括号时进栈，遇到花、中、圆的右括号时检查栈顶元素是否为相应的左括号，若是，退栈，查则配对错误。最后栈若不为空也为错误。  

ool Brackets Check(char \*str）{ InitStack(S); /初始化栈 int  $\scriptstyle{\dot{\mathbf{z}}}=0$  while(str[i]  $!="\setminus0"$  switch(str[i]){ //左括号入栈 case'(':Push(s，(');break; case'[':push(S,'[');break; case'(':push(s,'(');break; //遇到右括号，检测栈顶 case')':Pop（S,e）;if（  $\Xi:=^{\prime}({}^{\prime})$  return false; break; case']':Pop（S,e); if(  $\in{!=!}$  return false; break; case')':Pop（S,e); if(e  $!\!=\!\!^{\prime}\{{}^{\prime}\}$  return false; break; default: break; )//switch  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  }//while if(!IsEmpty(S)){ printf（括号不匹配\n"）；return false; else{ printf（"括号匹配\n"）；return true;  
# 3.4 数组和特殊矩阵  

矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据。所以，我们不研究矩阵及其运算等，而把精力放在如向将矩阵更有效地存储在内存中，并能方便地提取矩阵中的元素。  

# 3.4.1数组的定义  

数组是由 $n$  $n{\geqslant}1$ ）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在 $n$ 个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。  

数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素是定长数组的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。  

# 3.4.2数组的存储结构  

大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可采用计算机语言中的数组数据类型进行存储，一个数组的所有元素在内存中占用一段连续的存储空间。  

以一维数组 $\mathbb{A}\left[0...\mathrm{n}{-}1\right]$ 为例，其存储结构关系式为  

$$
\mathrm{LOC}(a_{i})=\mathrm{LOC}(a_{0})+i\times L\;\;(0{\leqslant}i{<}n)
$$  

其中， $L$ 是每个数组元素所占的存储单元。  

# 命题追踪二维数组按行优先存储的下标对应关系（2021）  

对于多维数组，有两种映射方法：按行优先和按列优先。以二维数组为例，按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组的行下标与列下标的范围分别为 $[0,h_{1}]$ 与 $[0,h_{2}]$ ，则存储结构关系式为  

$$
\mathrm{LOC}(a_{i,j})=\mathrm{LOC}(a_{0,0})+[i\times(h_{2}+1)+j]\times L
$$  

例如，对于数组 $\pmb{A}_{[2][3]}$ ，它按行优先方式在内存中的存储形式如图3.18所示。  

当以列优先方式存储时，得出存储结构关系式为  

$$
\mathrm{LOC}(a_{i,j})=\mathrm{LOC}(a_{0,0})+[j\times(h_{1}+1)+i]\times L
$$  

例如，对于数组 $\pmb{A}_{[2][3]}$ ，它按列优先方式在内存中的存储形式如图3.19所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/431323970be87b0380983b68a2fdb2ce80b5cbf7a18caf848ab1a8260d81a826.jpg)  
# 3.4.3 特殊矩阵的压缩存储  

压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配空间。  

特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。  

特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。  

# 1.对称矩阵  

# 命题追踪对称矩阵压缩存储的下标对应关系（2018、2020）  

若对一个 $n$ 阶矩阵 $_A$ 中的任意一个元素 $a_{i,j}$ 都有 $a_{i j}=a_{j,i}$  $(1\!\leqslant\!i,j\!\leqslant\!n)$ ），则称其为对称矩阵。其中的元素可以划分为3个部分，即上三角区、主对角线和下三角区，如图3.20所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e4256158c828de1e2cb6d0685d7ddee56c4f7c884ab10abb7d55e1bf9d481b93.jpg)  
图3.20 $n$ 阶矩阵的划分  

对于 $n$ 阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将 $n$ 阶对称矩阵 $\pmb{A}$ 存放在一维数组 $\mathsf{B}\left[\mathsf{n}\left(\mathsf{n}\!+\!1\right)/2\right]$ 中，即元素 $a_{i,j}$ 存放在 $b_{k}$ 中。比如只存放下三角部分（含主对角）的元素。  

在数组B中，位于元素 $a_{i,j}$  $i{\geqslant}j$ ）前面的元素个数为第1行：1个元素（ $a_{1,1}$ )第2行：2个元素 $(a_{2,1},a_{2,2})$  

第i-1行：i-1个元素 $(a_{i-1,1},a_{i-1,2},\cdots,a_{i-1,i-1})$  

第 $i$ 行： $j-1$ 个元素 $(a_{i,1},a_{i,2},\cdots,a_{i,j-1})$  

因此，元素 $a_{i,j}$ 在数组B中的下标 $k=1+2+\cdots+(i-1)+j-1=i(i-1)\,/\,2+j-1$ （数组下标从0开始）。因此，元素下标之间的对应关系如下：  

当数组下标从1开始时，可以采用同样的推导方法，请读者自行思考。  

# 注意  

二维数组A[n][n]和 $\mathbb{A}\left[0...{\mathsf{n}}{-}\mathbb{1}\right]\left[0...{\mathsf{n}}{-}\mathbb{1}\right]$ 的写法是等价的。若数组写为 $\mathbb{A}\left[\mathbb{1}...\mathbb{n}\right]\left[\mathbb{1}...\mathbb{n}\right]$ 则说明指定了从下标1开始存储元素。二维数组元素写为a[i][j]，注意数组元素下标i和j通常是从0开始的。矩阵元素通常写为 $a_{i,j}$ 或 $\mathsf{a}_{\mathrm{\tiny~(i)~}\mathrm{\tiny~(j)}}$ ，注意行号i和列号j是从1开始的。  
# 2.三角矩阵  

下三角矩阵［见图3.22（a）]中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，所以可以将n阶下三角矩阵 $_A$ 压缩存储在B[n $(\mathrm{n+1}$ /2+1]中。  

元素下标之间的对应关系为  

下三角矩阵在内存中的压缩存储形式如图3.21所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/25122d74975c8650cafab2687461cdad7ae6a123b006675775407fbf29de80b4.jpg)  
图3.21下三角矩阵的压缩存储  

# 命题追踪上三角矩阵采用行优先存储的应用（2011）  

上三角矩阵[见图3.22（b)]中，下三角区的所有元素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在B[n（ $_{\mathrm{n+1}}$ /2+1]中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3ea00e4c5b645bf0ee30817d65282d10453885d9b14108abe3c7b909285b1689.jpg)  
图3.22三角矩阵  

在数组B中，位于元素 $a_{i,j}$  $i{\leqslant}j$ ）前面的元素个数为  

第1行： $n$ 个元素第2行： $n-1$ 个元素第 $i-1$ 行： $n-i+2$ 个元素第 $i$ 行： $j-i$ 个元素因此，元素 $a_{i,j}$ 在数组B中的下标  

$$
k=n+(n-1)+\cdots+(n-i+2)+(j-i+1)-1=(i-1)(2n-i\;\;\;+2)\,/\,2+(j-i)
$$  

因此，元素下标之间的对应关系如下：  

上三角矩阵在内存中的压缩存储形式如图3.23所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4670216ebcead756acc2d02dac75f00a5dd009e8b6bd46d16a48af92ccd17946.jpg)  
以上推导均假设数组的下标从0开始，若题设有具体要求，则应该灵活应对。  

3.三对角矩阵  

对角矩阵也称带状矩阵。对 $n$ 阶矩阵 $_{A}$ 中的任意一个元素 $a_{i,j}$ ，龙当 $||i-j|>1$ 时，若有 $a_{i,j}=0$  $(1\!\leqslant\!i,j\!\leqslant\!n)$ ，则称为三对角矩阵，如图3.24所示。在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/09f60287f1be3fd30a39118a9dfc6d7ae692305a94a6e48506db74f20a23429f.jpg)  
图3.24三对角矩阵A  

三对角矩阵 $_{A}$ 也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且 $a_{1,1}$ 存放于B[0］中，其存储形式如图3.25所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21fa8fffa9f2183e60a1ad04942217b8362649967cba87a22370801c0e42845a.jpg)  

# 命题追踪三对角矩阵压缩存储的下标对应关系（2016）  

由此可以计算矩阵 $_A$ 中3条对角线上的元素 $a_{i,j}$  $\scriptstyle{1\leqslant i,\;j\leqslant n,}$  $|i\!-\!j|\!\leqslant\!1$ ）在一维数组B中存放的下标为 $k\,{=}\,2i\,{+}\,j\,{-}\,3$  

反之，若已知三对角矩阵中的某个元素 $a_{i,j}$ 存放在一维数组B的第 $k$ 个位置，则有 $i\!=\!\lfloor(k\!+1)/3\!+1\rfloor$  $j\,{=}\,k\,{-}\,2i\,{+}\,3$ 。例如，当 $k\!=\!0$ 时， $i=\lfloor(0+1)/3+1\rfloor\!=1$  $j=0-2{\times}1+3=1$ ，存放的是 $a_{1,1}$ 当 $k\!=$ 2时， $i=\lfloor(2+1)/3+1\rfloor\!\!=2$  $j=2-2\!\times\!2+3=1$ ，存放的是 $a_{2,1}$ 当 $k\!=\!4$ 时， $i=\left.\lfloor(4+1)/\,3+1\rfloor\!=2\right.$  $j=4-2\!\times\!2+3=3$ ，存放的是 $a_{2,3}$ 。  

# 3.4.4 稀疏矩阵  

矩阵中非零元素的个数 $t,$ 相对矩阵元素的个数 $s$ 来说非常少，即 $s\!\gg\!t$ 的矩阵称为稀疏矩阵。例如，一个矩阵的阶为 $100{\times}100$ ，该矩阵中只有少于100个非零元素。  

# 命题追踪存储稀疏矩阵需要保存的信息（2023）  

若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组（行标i，列标，值 $a_{i j})$ ，如图3.26所示。然后按照某种规律存储这些三元组线性表。稀疏矩阵压缩存储后便失去了随机存取特性。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0c42fe0d8732a593781e47414cea74094d463474100aa7492a58b47b74fc271.jpg)  
图3.26稀疏矩阵及其对应的三元组  
# 命题追踪适合稀疏矩阵压缩存储的存储结构（2017）  

稀疏矩阵的三元组表既可以采用数组存储，又可以采用十字链表存储（见6.2节）。当存储稀疏矩阵时，不仅要保存三元组表，而且要保存稀疏矩阵的行数、列数和非零元素的个数。  

# 3.4.5 本节试题精选  

# 单项选择题  

01.对特殊矩阵采用压缩存储的主要目的是（）。  

A.表达变得简单 B.对矩阵元素的存取变得简单 C.去掉矩阵中的多余元素D.减少不必要的存储空间  

02.对 $n$ 阶对称矩阵压缩存储时，需要表长为（）的顺序表。  

A. n/2 B.  $n{\times}n/2$  C.  $n(n+1)/2$  D.  $n(n-1)/2$  

03.有一个 $_{n\times n}$ 的对称矩阵 $_{A}$ ，将其下三角部分按行存放在一维数组B中，而A[0］[0]存放于B[0］中，则第 $i+1$ 行的对角元素A[i][i]存放于B中的（）处。  

A.  $(i+3)i/2$  B.  $(i+1)i/2$  C.  $(2n-i+1)i/2$  D.  $(2n-i-1)i/2$  

04.在二维数组A中，假设每个数组元素的长度为3个存储单元，行下标 $i$ 为 $0\sim8$ ，列下标 $j$ 为0～9，从首地址SA开始连续存放。在这种情况下，元素A[8][5]的起始地址为（）。  

A.  $\mathtt{S A}\!+\!141$  B.SA+144 C.SA+222 D.SA+255  

05.二维数组 $A$ 按行优先存储，其中每个元素占1个存储单元。若A[1][1]的存储地址为420，A[3][3]的存储地址为446，则A[5][5]的存储地址为（）。  

A.472 B.471 C.458 D.457  

05.将三角矩阵即数组A[1..100][1..100]按行优先存入一维数组B[1..298]中，数组A中元素A[66][65]在数组B中的位置 $k$ 为()。  

A.198 B.195 C.197 D.196  

06.若将 $n$ 阶上三角矩阵 $_A$ 按列优先级压缩存放在一维数组 $\mathsf{B}\left[\mathbb{1}...\mathsf{n}\left(\mathsf{n}\!+\!\mathbb{1}\right)/2\!+\!\mathbb{1}\right]$ 中，则存放到B[k]中的非零元素 $a_{i j}$ （ $1\!\leqslant\!i,j\!\leqslant\!n$ ）的下标 $i,\ j$ 与 $k$ 的对应关系是（）。  

A.  $i(i+1)/2+j$  B.  $i(i-1)/2+j-1$  C.  $j(j\!-\!1)/2+i$  D.  $j(j\!-\!\!1)/2+i\!-\!1$  

07.若将 $n$ 阶下三角矩阵 $\pmb{A}$ 按列优先顺序压缩存放在一维数组 $\mathsf{B}\left[\mathbb{1}...\mathsf{n}\left(\mathsf{n}\!+\!\mathbb{1}\right)/2\!+\!\mathbb{1}\right]$ 中，则存放到B[k]中的非零元素 $a_{i,j}$ （ $1\!\leqslant\!i,j\!\leqslant\!n\!~;$ ）的下标 $i,j$ 与 $k$ 的对应关系是（）。  

A.  $(j-1)\,(2n-j+1)/2+i-j$  B.  $\left(j-1\right)\left(2n-j+2\right)/2+i-j+1$  C.   $(j-1)\,(2n-j+2)/2+i-j$  D.  $(j-1)\,(2n\!-\!j+1)/2+i\!-\!j\!-1$  

09.稀疏矩阵采用压缩存储后的缺点主要是（）。  

A.无法判断矩阵的行列数B.丧失随机存取的特性C.无法由行、列值查找某个矩阵元素 D.使矩阵元素之间的逻辑关系更复杂  

10.下列关于矩阵的说法中，正确的是（）I.在 $n$ ( $n>3$ ）阶三对角矩阵中，每行都有3个非零元IIL.稀疏矩阵的特点是矩阵中的元素较少  

A.仅I B.仅ⅡI C.1和ⅡI D.无正确项  

11.【2016统考真题】有一个100阶的三对角矩阵 $M$ ，其元素 $m_{i,j}$ (1≤i, $j{\leqslant}100$ ）按行优先依次压缩存入下标从O开始的一维数组N中。元素 $m_{30,30}$ 在N中的下标是（）。  

A.86 B.87 C. 88 D. 89  
12.【2017统考真题】适用于压缩存储稀疏矩阵的两种存储结构是（）。  

A.三元组表和十字链表B.三元组表和邻接矩阵C.十字链表和二叉链表D.邻接矩阵和十字链表  

13.【2018统考真题】设有一个 $12\!\times\!12$ 阶对称矩阵 $M,$ 将其上三角部分的元素 $m_{i,j}(1\!\leqslant\!i\!\leqslant\!j\!\leqslant\!12$ 按行优先存入C语言的一维数组N中，元素 $m_{6,6}$ 在N中的下标是（）。  

A.50 B.51 C.55 D.66  

14.【2020统考真题】将一个 $10\!\times\!10$ 阶对称矩阵 $M$ 的上三角部分的元素 $m_{i,j}$ C $1\!\leqslant\!i\!\leqslant\!j\!\leqslant\!10$ 按列优先存入C语言的一维数组N中，元素 $m_{7,2}$ 在N中的下标是（）。  

A. 15 B.16 C. 22 D.23  

15.【2021统考真题】二维数组 $A$ 按行优先方式存储，每个元素占用1个存储单元。若元素A[0][0]的存储地址是100，A[3][3]的存储地址是220，则元素A[5][5]的存储地址 是()。  

A.295 B.300 C. 301 D. 306  

16.【2023统考真题】若采用三元组表存储结构存储稀疏矩阵 $M$ ，则除三元组表外，下列数据中还需要保存的是（）  

I.M的行数I1. $M$ 中包含非零元素的行数III. $M$ 的列数IV. $M$ 中包含非零元素的列数A.仅I、IⅢIB.仅I、IVC.仅II、IVD.1、II、ⅢI、IV  

# 3.4.6 答案与解析  

单项选择题  

01.D 特殊矩阵中含有很多相同元素或零元素，所以可采用压缩存储，以节省存储空间。  

02.C 只需存储其上三角或下三角部分（含对角线)，元素个数为 $n+(n-1)+\cdots+1=n(n+1)/2$  

03.A  

此题要注意3个细节：矩阵的最小下标为0；数组下标也是从0开始的；矩阵按行优先存在数组中。注意到此三点，答案不难得到为A。此外，本类题建议采用特殊值代入法求解，例如，A[1][1]对应的下标应为2，代入后只有A满足条件。  

技巧：对于特殊三角矩阵压缩存储的题，心中应有“平移”搬动的思想，并结合草图，这样会比较形象，在计算时再注意矩阵和数组的起始下标，就不容易出错。  

04. D  

二维数组计算地址（按行优先顺序）的公式为  

$$
\mathrm{LOC}(i,j)=\mathrm{LOC}(0,0)+(\,i\times m+j)\times L
$$  

其中， $\mathrm{LOC}(0,\,0)=\mathrm{SA}$ ，是数组存放的首地址； $L=3$ 是每个数组元素的长度； $m=9-0\,+\,1=10$ 是数组的列数。因此有 $\mathrm{LOC}(8,5)=\mathrm{SA}+(8{\times}10+5){\times}3=\mathrm{SA}+255$ ，所以选 $\mathrm{D}$ 。  

05.A  

本题未直接给出数组A的行数和列数，因此需要根据题目中的信息来推理。因为该二维数组按行优先存储，且A[3][3]的存储地址为446，所以A[3][1]的存储地址为444，又A[1][1]的存储地址为420,显然A[1][1]和A[3][1]正好相差2行,所以该矩阵的列数为12。而A[5][3]和A[3][3]正好相差2行，A[5][5]和A[5][3]又相差2个元素，所以A[5][5]的存储地址  
是 $446+24+2=472$  

06.B  

对于三对角矩阵，将A[1..n][1..n]压缩至B[1...3n-2]时， $a_{i,j}$ 与 $b_{k}$ 的对应关系为 $k\!=\!2i+j\!-2$ 则A中的元素A[66][65]在数组B中的位置 $k$ 为 $2{\times}66+65-2=195.$  

07.C  

按列优先存储，所以元素 $a_{i j}$ 前面有 $j-1$ 列，共有 $1+2+3+\cdots+j-1=j(j-1)/2$ 个元素，元素 $a_{i j}$ 在第 $j$ 列上是第 $i$ 个元素，数组 $B$ 的下标是从1开始，因此 $k\!=\!j(j\!-\!1)/2+i.$  

08.B  

按列优先存储，所以元素 $a_{i,j}$ 之前有 $j-1$ 列，共有 $n+(n-1)+\cdots+(\,n-j+2\,)=(j-1)(2n-j+2)/2$ 个元素，元素 $a_{i j}$ 是第j列上第 $i-j+1$ 个元素，数组B的下标从1开始， $k\!=\!(j\!-\!1)(2n\!-\!j+2)/2+i\!-\!j\!+1$  

09.B  

稀疏矩阵通常采用三元组来压缩存储，存储矩阵元素的行列下标和相应的值，因此不能根据矩阵元素的行列下标快速定位矩阵元素，失去了随机存取的特性。  

10. D  

在三对角矩阵中，第1行和最后1行只有2个非零元，其余各行均有3个非零元。稀疏矩阵的特点是矩阵中非零元的个数较少。  

11.B  

三对角矩阵如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa3ea5f7260fe17e292865159b0d1cf5053f88bb67bd6ff07d67a0253a39a290.jpg)  

采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且 $a_{1,1}$ 存放于B[0]中，其存储形式如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4a30b3705b2457b9d0660a6c5cea4144340219f749e3e8965305d2cd9bc62523.jpg)  

可以计算矩阵 $_{A}$ 中3条对角线上的元素 $a_{i,j}$  $_{j}\,(\,1\!\leqslant\!i,j\!\leqslant\!n,|i\!-\!j|\!\leqslant\!1\,)$ 在一维数组B中存放的下标为 $k\!=\!2i+j\!-3$ ，公式很难记忆，我们通常采用解法2。  

解法1：针对该题，仅需将数字逐一代入公式： $k=2{\times}30+30-3=87$ ，结果为87。  

解法2：观察上图的三对角矩阵不难发现，第一行有两个元素，剩下的在元素 $m_{30,30}$ 所在行之前的28行（注意下标 $1\!\leqslant\!i,j\!\leqslant\!100$ ）中，每行都有3个元素，而 $m_{30,30}$ 之前仅有一个元素 $m_{30,29}$ 不难发现元素 $m_{30,30}$ 在数组 $N$ 中的下标是 $2+28{\times}3+2-1=87.$  

# 注意  

矩阵和数组的下标从0或1开始（如矩阵可能从 $a_{0,0}$ 或 $a_{1,1}$ 开始，数组可能从B[0]或B[1]开始），这时就需要适时调整计算方法（方法无非是多计算1或少计算1的问题）。  

12.A  

三元组表的结点存储了行（row）、列（col）、值（value）三种信息，是主要用来存储稀疏矩阵的一种数据结构。十字链表将行单链表和列单链表结合起来存储稀疏矩阵。邻接矩阵空间复杂度达 $O(n^{2})$ ，不适合于存储稀疏矩阵。二叉链表又名左孩子右兄弟表示法，可用于表示树或森林。  
13.A  

在C语言中，数组 $N$ 的下标从0开始。第一个元素 $m_{1,1}$ 对应存入 $n_{0}$ ，矩阵 $M$ 的第一行有12个元素，第二行有11个，第三行有10个，第四行有9个，第五行有8个，所以 $m_{6,6}$ 是第 $12+11+10+9+8+1=51$ 个元素，下标应为50。  

14.C  

上三角矩阵按列优先存储，先存储只有1个元素的第一列，再存储有2个元素的第二列，以此类推。 $m_{7,2}$ 位于左下角，对应右上角的元素为 $m_{2,7}$ ，在 $m_{2,7}$ 之前存有  

第1列：1  

第2列：2  

第6列：6  

第7列：1  

前面共存储有 $1+2+3+4+5+6+1=22$ 个元素（数组下标范围为 $_{0\sim21}$ ），注意数组下标从0开始，所以 $m_{2,7}$ 在数组 $_\mathrm{N}$ 中的下标为22，即 $m_{7,2}$ 在数组N中的下标为22。  

15.B  

二维数组A按行优先存储，每个元素占用1个存储单元，由A[0][0]和A[3][3]的存储地址可知A[3】[3】是二维数组A中的第121个元素，假设二维数组 $\mathtt{A}$ 的每行有 $n$ 个元素，则 $n\!\times\!3\!+\!4\!=\!121$ 求得 $n\!=\!39$ ，所以元素A[5][5]的存储地址为 $100+39{\times}5+6-1=300$  

16.A  

用三元组表存储结构存储稀疏矩阵 $M$ 时，每个非零元素都由三元组（行标、列标、关键字值）组成。但是，仅通过三元组表中的元素无法判断稀疏矩阵 $M$ 的大小，因此还要保存 $M$ 的行数和列数。此外，还可以保存 $M$ 的非零元素个数。例如，如下两个稀疏矩阵的三元组表是相同的，若不保存行数和列数，则无法判断两个稀蔬矩阵的大小。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a54777d3f203e604cf3c0c26607b75871ce9c9e6b44ee665c9ba64b1b45637a6.jpg)  

# 归纳总结  

本章所讲的几种数据结构类型是线性表的应用和推广，在考试中主要以选择题形式进行考查，但栈和队列也仍然有可能出现在算法设计题中。很多读者看到课本上有好多个函数时很恐惧，若考到了栈或队列的大题，难道要把每个操作的函数都写出来吗？  

其实，在考试中，栈或队列都是作为一个工具来解决其他问题的，我们可以把栈或队列的声明和操作写得很简单，而不必分函数写出。以顺序栈的操作为例：  

（1）声明一个栈并初始化：  

Elemtype stack[maxSize];int top $\scriptstyle{1\equiv-1}$ ；//两句话连声明带初始化都有了  

（2）元素进栈：  
（3）元素x出栈  

$\mathrm{Xe}$ stack[top--];/单目运算符在变量之前表示“先运算后使用”，之后则相反  

对于链式栈，同样只需定义一个结构体，然后从讲解中摘取必要的语句组合在自己的函数代码中即可。另外，在考研真题中，链式栈出现的概率要比顺序栈低得多，因此大家应该有所侧重，多训练与顺序栈相关的题目。  

# 思维拓展  

设计一个栈，使它可以在 $O(1)$ 的时间复杂度内实现Push、Pop和min操作。所谓min操作，是指得到栈中最小的元素。  

提示：使用双栈，两个栈是同步关系。主栈是普通栈，用来实现栈的基本操作Push和Pop；辅助栈用来记录同步的最小值min，例如元素 $_\mathrm{x}$ 进栈，stack min[top ${\mathrel{+{+}}}$ 1 $=$ （x<min）？x：min；即在每次Push中，都将当前最小元素放到stack_min的栈顶。在主栈中Pop最小元素y时，stackmin栈中相同位置的最小元素y也会随着top--而出栈。因此stackmin的栈顶元素必然是y之前入栈的最小元素。本题是典型的以空间换时间的算法。  
# 第4章串  

# 【考纲内容】  

字符串模式匹配  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f061b239de2b34348120ddfb7d51e6b0d959096c06bc59915915483d48c09ca4.jpg)  

【复习提示】  

本章是统考大纲第6章内容，采纳读者建议单独作为一章，大纲只要求掌握字符串模式匹配，重点掌握KMP匹配算法的原理及next数组的推理过程，手工求next数组可以先计算出部分匹配值表然后变形，或根据公式来求解。了解nextva1数组的求解方法。  

#  $\mathbf{\delta*}4.1$  串的定义和实现  

字符串简称串，计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统（如搜索引擎）、文本编辑程序（如Word）、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。本章详细介绍字符串的存储结构及相应的操作。  

# 4.1.1串的定义  

串（string）是由零个或多个字符组成的有限序列。一般记为  

$$
S={}^{;}a_{1}a_{2}\cdots a_{n}{}^{;}\quad(n\geqslant0)
$$  

其中， $S$ 是串名，单引号括起来的字符序列是串的值； $a_{i}$ 可以是字母、数字或其他字符；串中字符的个数 $n$ 称为串的长度。 $n\!=\!0$ 时的串称为空串（用 $\emptyset$ 表示）  
串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。某个字符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第1个字符在主串中的位置来表示。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。  

例如，有串 $\mathtt{A}\!=$ 'China Beijing'， $\mathtt{B}\!=$ 'Beijing'， $\mathtt{C}{=}$ China'，则它们的长度分别为13、7和5。B和C是A的子串，B在A中的位置是7，C在A中的位置是1。  

需要注意的是，由一个或多个空格（空格是特殊字符）组成的串称为空格串（注意，空格串不是空串），其长度为串中空格字符的个数。  

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。  

# 4.1.2串的存储结构  

# 1.定长顺序存储表示  

类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。  

#define MAXLEN 255/预定义最大串长为255typedef struct{ char ch[MAXLEN];//每个分量存储一个字符int length;/串的实际长度)sString;  

串的实际长度只能小于或等于MAXLEN，超过预定义长度的串值会被舍去，称为截断。串长有两种表示方法：一是如上述定义描述的那样，用一个额外的变量1en来存放串的长度；二是在串值后面加一个不计入串长的结束标记字符“\0”，此时的串长为隐含值。  

在一些串的操作（如插入、联接等）中，若串值序列的长度超过上界MAXLEN，约定用“截断”法处理，要克服这种弊端，只能不限定事长的最大长度，即采用动态分配的方式。  

# 2.堆分配存储表示  

堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f872b2bd2b132f3ab95a92fe5e40c026db9b3e63ed13be51fbf161f5c6c88850.jpg)  

在C语言中，存在一个称之为“堆”的自由存储区，并用malloc（)和free（)函数来完成动态存储管理。利用malloc（)为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为事的基地址，这个串由ch指针来指示；若分配失败，则返回NULL。已分配的空间可用free（）释放掉。  

上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。  

# 3.块链存储表示  

类似于线性表的链式存储结构，也可采用链表方式存储串值。由于事的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a是结点大小为4（即每个结点存放4个字符）的链表，最后一个结点占不满时通常用“#”补上；图4.1（b）是结点大小为1的链表。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56cc1c53a1bb3c19c28d76a784be4cbd4669057a969be98f64ffd7f9effa73a8.jpg)  
图4.1串值的链式存储方式  

# 4.1.3串的基本操作  

StrAssign（&T，chars）：赋值操作。T chars。StrCopy（&T，S）：复制操作。由串s复制得到串T。StrEmpty（S）：判空操作。若s为空串，则返回TRUE，否则返回FALSE。StrCompare（S，T）：比较操作。若  $_{\textrm{S>T}}$  ，则返回值  ${>}0$  ；若  $\scriptstyle{\mathrm{S}}={\mathrm{T}}$  ，则返回值  $\scriptstyle{\varepsilon=0}$  ；若  $_{\textrm{S<T}}$  则返回值<0。StrLength（S）：求串长。返回串s的元素个数。SubString（&Sub，S，pos，len）：求子串。sub s poslen的子串。Concat（&T，S1，S2）：串联接。用T返回由S1和s2联接而成的新串。Index（S，T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。ClearString（&S）：清空操作。将s清为空串。Destroy String（&S）：销毁串。将串s销毁。  

不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值StrAssign、Str Compare、Str Length、Con cat SubString 五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/58c16cb2c203cc522dc8aed7ac52477005f00433ef381dd0da5a46ad0e7f7bc7.jpg)  

# 串的模式匹配  

# 4.2.1简单的模式匹配算法  

子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。  

int Index(SString S,SString T)( int  $\scriptstyle{\dot{\mathbf{z}}}={\boldsymbol{\mathbf{1}}},\;{\dot{\mathbf{\rho}}}={\boldsymbol{\mathbf{1}}}$  while(  $\scriptstyle{\dot{\mathbf{z}}}\,<=\,{\mathsf{S}}$  .length&&  $\scriptstyle{\dot{\mathbf{\rho}}}<=\operatorname{\mathbf{T}}$  .length)( if(S.ch[i]  $==\mathrm{T}$  .ch[j]）{  ${\mathrel{+{+\mathrm{i}}}}$   ${\bf++j}$  /继续比较后继字符 elsel  $\scriptstyle{\dot{\mathbf{i}}}={\dot{\mathbf{i}}}-{\dot{\mathbf{j}}}+2$  $\scriptstyle{\dot{\mathbf{j}}}={\boldsymbol{\mathbf{1}}}$ //指针后退重新开始匹配  
if(j>T.length)return i-T.length; else return 0;  

在上述算法中，分别用计数指针i和j指示主串S和模式串T中当前正待比较的字符位置。算法思想为：从主串s的第一个字符起，与模式串T的第一个字符比较，若相等，则继续逐个比较后续字符：否则从主串的下一个字符起，重新和模式串的字符比较；以此类推，直至模式串T中的每个字符依次和主串s中的一个连续的字符序列相等，则称匹配成功，函数值为与模式串T中第一个字符相等的字符在主串s中的序号，否则称匹配不成功，函数值为零。图4.2展示了模式串 $\mathrm{T}{=}$ abcac和主串s的匹配过程，每次匹配失败后，都把模式串T后移一位。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54e4ba107cb0eeb37086c69a0ca3069646b67af9d59c2e4b38b72e9d968ba3a6.jpg)  
图4.2简单模式匹配算法举例  

简单模式匹配算法的最坏时间复杂度为 $O(n m)$ ，其中 $n$ 和 $m$ 分别为主串和模式串的长度。例如，当模式串为0000001，而主串为0000000000000000000000000000000000000000000001，时，由于模式串中的前6个字符均为?0+，主串中的前45个字符均为 $_{0}\cdot$ ，每趟匹配都是比较到模式串中的最后一个字符时才发现不等，指针i需要回溯39次，总比较次数为 $40{\times}7=280$ 次。  

# 4.2.2串的模式匹配算法KMP算法  

根据图4.2的匹配过程，在第三趟匹配中， $\scriptstyle{\dot{\mathbf{1}}}=7$  $\div]{=}5$ 的字符比较，结果不等，于是又从 $\scriptstyle{\dot{\boldsymbol{\mathbf{1}}}}\,=\,4$  $\scriptstyle{\dot{\bar{\jmath}}}=1$ 重新开始比较。然而，仔细观察会发现， $_\mathrm{i}\!=\!4$ 和 $\scriptstyle{\dot{\boldsymbol{\mathrm{\jmath}}}}={\boldsymbol{\mathrm{1}}}$ ， $_{\dot{\mathbf{1}}=5}$ 和 $\scriptstyle{\dot{\boldsymbol{\mathrm{\phi}}}}=1$ 及 $_\mathrm{i}{=}6$ 和 $\scriptstyle{\dot{\boldsymbol{\mathrm{\phi}}}}=1$ 这三次比较都是不必进行的。从第三趟部分匹配的结果可知，主串的第4个、第5个和第6个字符是b'、c和'a（即模式串的第2个、第3个和第4个字符），因为模式串的第1个字符是+a'，所以无须再和这三个字符进行比较，而只需将模式串向右滑动三个字符的位置，继续进行 $\mathtt{i}\!=\!7\setminus\mathtt{j}\!=\!2$ 时的比较即可。  
在暴力匹配中，每趟匹配失败都是模式串后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式事的某个前缀，这种频繁的重复比较相当于模式串不断地进行自我比较，这就是其低效率的根源。因此，可以从分析模式串本身的结构着手，若已匹配相等的前缀序列中有某个后缀正好是模式事的前缀，则可将模式事向后滑动到与这些相等字符对齐的位置，主事i指针无须回溯，并从该位置开始继续比较。而模式事向后滑动位数的计算仅与模式串本身的结构有关，而与主串无关（这里理解起来比较困难，没关系，带着这个问题继续往后看）。  

# 1.字符串的前缀、后缀和部分匹配值  

要了解子串的结构，首先要弄清楚几个概念：前缀、后缀和部分匹配值。前缀指除最后一个字符以外，字符串的所有头部子串：后缀指除第一个字符外，字符串的所有尾部子串：部分匹配值则为字符事的前缀和后缀的最长相等前后缀长度。下面以+ababa'为例进行说明：  

'a'的前缀和后缀都为空集，最长相等前后缀长度为0。'ab'的前缀为{a}，后缀为 $\{{\sf b}\}$ ， $\{\sf a\}\cap\{\sf b\}\!=\!\emptyset$ ，最长相等前后缀长度为0。'aba'的前缀为{a,ab}，后缀为{a,ba}，{a,ab}n{a,ba $\boldsymbol{\mathbf{\rho}}\}=\left\{\,\mathsf{a}\,\right\}$ ，最长相等前后缀长度为1。'abab'的前缀{a，ab，aba}n后缀{b，ab，bab} $=\cdot$ [ab），最长相等前后缀长度为2。'ababa'的前缀{a，ab，aba,abab}n后缀{a,ba,aba,baba $\mathbf{\omega}\}=\left\{\mathbf{\omega}\mathbf{a}\mathbf{\beta}\right.$ ,aba），公共元素有两个，最长相等前后缀长度为3。  

因此，字符串'ababa'的部分匹配值为00123。  

这个部分匹配值有什么作用呢？  

回到最初的问题，a bab cab cac bab，子串为abcac。  

利用上述方法容易写出子串+abcac·的部分匹配值为00010，将部分匹配值写成数组形式，就得到了部分匹配值（PartialMatch，PM）的表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/377aad20736ed34d8161d83be96787936c200fb1acb2b79e434aac502c5bebb4.jpg)  

下面用PM表来进行字符串匹配：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2d937d17d0e58b6a37d99b239f990479ce6b593e3a4c44886709745a86ba0658.jpg)  

第一趟匹配过程：  

发现c与a不匹配，前面的2个字符'ab'是匹配的，查表可知，最后一个匹配字符b对应的部分匹配值为0，因此按照下面的公式算出子串需要向后移动的位数：  

移动位数 $=$ 已匹配的字符数－对应的部分匹配值因为 $2-0=2$ ，所以将子串向后移动2位，如下进行第二趟匹配：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c878b55e5555f3562affbaf3c7438a4ab69ae4a9606ed12fc034b57fdf254a7.jpg)  

第二趟匹配过程：  

发现c与b不匹配，前面4个字符+abca'是匹配的，最后一个匹配字符a对应的部分匹配值为1， $4-1=3$ ，将子串向后移动3位，如下进行第三趟匹配：  
主串ababCbaCbab子串abCaC  

第三趟匹配过程：  

子事全部比较完成，匹配成功。整个匹配过程中，主串始终没有回退，所以KMP算法可以在 $O(n+m)$ 的时间数量级上完成事的模式匹配操作，大大提高了匹配效率。  

某趟发生失配时，若对应的部分匹配值为0，则表示已匹配相等序列中没有相等的前后缀，此时移动的位数最大，直接将子串首字符后移到主串当前位置进行下一趟比较：若已匹配相等序列中存在最大相等前后缀（可理解为首尾重合），则将子串向右滑动到和该相等前后缀对齐（这部分字符下一趟显然不需要比较），然后从主事当前位置进行下一趟比较。  

# 2.KMP算法的原理是什么  

我们刚刚学会了怎样计算字符串的部分匹配值、怎样利用子串的部分匹配值快速地进行字符串匹配操作，但公式“移动位数 $=$ 已匹配的学符数三对应的部分匹配值”的意义是什么呢？  

如图4.3所示，当c与b不匹配时，已匹配，abca，的前缀a和后缀a为最长公共元素。已知前缀a与b、c均不同，与后缀a相同，因此无须比较，直接将子事移动“已匹配的字符数-对应的部分匹配值”，用子事前缀后面的元素与主事匹配失败的元素开始比较即可，如图4.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/aad83da896298bac9915ea9c4489fa67e12556a127bd80d1503ca19c153b2b4f.jpg)  

对算法的改进方法：  

已知：右移位数 $=$ 已匹配的字符数一对应的部分匹配值。  

写成：Move $=$ （j-1)-PM[j-1]。  

使用部分匹配值时，每当匹配失败，就去找它前一个元素的部分匹配值，这样使用起来有些不方便，所以将PM表右移一位，这样哪个元素匹配失败，直接看它自己的部分匹配值即可。  

将上例中字符串abcac的PM表右移一位，就得到了next数组：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ad045d891fd388f999f29e3a5d57bd91ca2d1f0c91de842b0ae7fd127508ce30.jpg)  

我们注意到：  

1）第一个元素右移以后空缺的用-1来填充，因为若是第一个元素匹配失败，则需要将子串向右移动一位，而不需要计算子串移动的位数。  

2）最后一个元素在右移的过程中溢出，因为原来的子串中，最后一个元素的部分匹配值是其下一个元素使用的，但显然已没有下一个元素，所以可以舍去。  
这样，上式就改写为  

相当于将子串的比较指针回退到  

有时为了使公式更加简洁、计算简单，将next数组整体 $^{+1}$  

因此，上述子串的next数组也可以写成  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7ac119d782f92328295099076ea25ef796b9b4ad845f5b5ae4fafe2968fd1116.jpg)  

# 命题追踪KMP匹配过程中指针变化的分析（2015）  

最终得到子串指针变化公式 ${\dot{\mathsf{j}}}=$ next[j］。在实际匹配过程中，子串在内存中是不会移动的，而是指针发生变化，画图举例只是为了让问题描述得更形象。next[i]的含义是：当子串的第i个字符与主串发生失配时，跳到子串的next[il位置重新与主串当前位置进行比较。  

如何推理next数组的一般公式？设主串为 $\mathsf{S}_{1}\mathsf{S}_{2}\cdots\mathsf{S}_{\mathrm{n}}\,,$ ，模式串为 ${\mathsf{p}}_{1}{\mathsf{p}}_{2}\cdots{\mathsf{p}}_{\mathtt{m}}\,,$ ，当主串中第i个字符与模式串中第个字符失配时，子串应向右滑动多远，然后与模式中的哪个字符比较？  

假设此时应与模式串的第 $\kappa$ ( $\k{<}\dot{\mathsf{I}}$ ）个字符继续比较，则模式串中前k-1个字符的子串必须满足下列条件，且不可能存在 $\mathtt{k}^{\prime}{>}\mathtt{k}$ 满足下列条件：  

$$
\mathrm{"p_{1}p_{2}\cdots p_{k-1}\prime=!p_{j-k+1}p_{j-k+2}\cdots p_{j-1}\prime}
$$  

若存在满足如上条件的子串，则发生失配时，仅需将模式串向右滑动至模式串的第 $\mathtt{k}$ 个字符和主串的第i个字符对齐，此时模式串中的前k-1个字符的子串必定与主串中第i个字符之前长度为k-1的子串相等，由此，只需从模式事的第 $\mathtt{k}$ 个字符与主串的第i个字符继续比较即可，如图4.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2dbfa2d11030630a5c13a0b2b3423e37db24b5080dda10d4eee8e48614d8ca4d.jpg)  

当模式串已匹配相等序列中不存在满足上述条件的子串时（可视为 $\kappa{=}1$ )，显然应该将模式串右移j-1位，让主串的第i个字符和模式串的第1个字符进行比较，此时右移位数最大。  

当模式串的第1个字符（ $({\dot{\ }}{\dot{\ }}{=}{1}$ ）与主串的第i个字符发生失配时，规定 $\mathrm{ensuremath}\left[1\right]\mathrm{=}0^{\scriptscriptstyle()}$ 。将模式串右移一位，从主串的下一个位置（i+1）和模式串的第1个字符继续比较。  

通过上述分析可以得出next函数的公式：  

上述公式不难理解，实际做题求next值时，用之前的方法也很好求，但要想用代码来实现，貌似难度还真不小，我们来尝试推理求解的科学步骤。  

首先由公式可知  
设 $\mathrm{next}\,[\,\dot{\,}\,]\,{=}\,\mathrm{k}$ ，此时 $\boldsymbol{\mathrm{k}}$ 应满足的条件在上文中已描述。  

此时next $[\,\dot{\,\,}]\,{+}\,1\,]\,{=}\,?$ 可能有两种情况：  

（1）若 $\mathtt{p}_{\mathrm{k}}{=}\mathtt{p}_{\mathrm{j}}$ ，则表明在模式串中  

并且不可能存在 $\mathtt{k}\prime{>}\mathtt{k}$ 满足上述条件，此时next $[\ \dot{]}^{+1}]=\succ+1$ ，即  

（2）若 $\mathtt{p}_{\mathtt k}\not=\mathtt{p}_{\mathtt j}$ ，则表明在模式串中  

$$
\mathrm{\Delta^{\prime}p_{1}\cdots p_{k-1}p_{k}\,^{\prime}\nearrow\,p_{j-k+1}\cdots p_{j-1}p_{j}\,^{\prime}}
$$  

此时可将求next函数值的问题视为一个模式匹配的问题。用前缀 $\mathtt{p}_{1}\cdots\mathtt{p}_{k}$ 去与后缀 $\mathsf{p}_{\mathrm{j-k+1}}\cdots\mathsf{p}_{\mathrm{j}}$ 匹配，当 $\mathtt{p}_{\mathrm{k}}\not=\mathtt{p}_{\mathrm{j}}$ 时，应将 $\mathtt{p}_{1}\cdots\mathtt{p}_{k}$ 向右滑动至以第next[k]个字符与 $\mathtt{P}_{3}$ 比较，若 Pnext[k]与 $\mathtt{P_{j}}$ 仍不匹配，则需要寻找长度更短的相等前后缀，下一步继续用Pnext[next[kj]与 ${\tt p}_{j}$ 比较，以此类推，直到找到某个更小的 $\kappa\prime=$ next[next...[k]] $\scriptstyle\left(1<\mathbf{k}^{\prime}<\mathbf{k}<\mathbf{j}\right)$ ），满足条件  

则next $\scriptstyle[\,\dot{\,}]\,+\,1\,]\,=\,k^{\prime}\,+\,1$ 。  

也可能不存在任何 $\kappa^{\prime}$ 满足上述条件，即不存在长度更短的相等前缀后缀，令next $[\,\dot{\,}]\,{+}\,1\,]\,{=}\,1$  

理解起来有一点费劲？下面举一个简单的例子。  

图4.6的模式串中已求得6个字符的next值，现求next[7]，因为next $[6]\!=\!3$ ，又 $\mathtt{p}_{6}\not=\mathtt{p}_{3}$ 则需比较 ${\bf p}_{6}$ 和 $\mathtt{p}_{1}{}^{\prime}$ （因next $[\,3\,]\,{=}1$ ），由于 $\mathtt{p_{6}}\mathrm{\neq}\mathtt{p_{1}}$ ,而next $[\,\beth]\,{=}\,0$ ，因此next $[\,7\,]\,{=}1$ ；求next[8]，因 $\scriptstyle{\mathbb{P}}7^{=}{\mathbb{P}}_{1}$ ，则next $[8]=$ next[7]+1=2；求next[9]，因 $\mathbb{P}_{8}\!\!=\!\!\mathbb{P}_{2}$ ，则next $[9]\!=\!3$ 6  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fd6fc648f51ead06104f3b6607b7412dd6e3e3d3020eac6f6751cbd3eaaf9d00.jpg)  

通过上述分析写出求next值的程序如下：  

woid get next（SString T,int next[]){ int $_\pm=1$ ， $\scriptstyle{\dot{\mathbf{j}}}=0$ next  $[\,\underline{{\boldsymbol{1}}}\,]\!=\!0$  while(  $\scriptstyle{\dot{\mathbf{1}}}<{\mathrm{T}}$  .length)( if（j  $==0$  [|T.ch[i]  $\scriptstyle{\mathrm{~\omega~}}={\mathrm{T}}$  .ch[j]){  ${++}\,{\mathrm{i}}$   ${++j}$  next  $[\dot{\bot}]\!=\!\dot{\!\bar{\!\!\!\!\mathrm{j}}}$  ；/诺  $\mathtt{p}_{\mathrm{i}}{=}\mathtt{p}_{\mathrm{j}}$  ，则next[j+1]  $=$  next[j]+1 else  ${\dot{\mathbf{\rho}}}{\dot{\mathbf{\rho}}}=$ next[j]；//否则令 ${\dot{\mathsf{j}}}=$ mext[j]，循环继续  

计算机执行起来效率很高，但对于我们手工计算来说会很难。因此，当我们需要手工计算时，还是用最初的方法。  

与next数组的求解相比，KMP的匹配算法相对要简单很多，它在形式上与简单的模式匹配算法很相似。不同之处仅在于当匹配过程产生失配时，指针i不变，指针j退回到next[j]的位置并重新进行比较，并且当指针为0时，指针i和j同时加1。即若主事的第i个位置和模式事的第1个字符不等，则应从主事的第i+1个位置开始匹配。具体代码如下：  
int Index KMP(SString S,SString T,int next[l) int $\scriptstyle{\dot{\Sigma}}={\bar{\Sigma}}$ ， $\scriptstyle{\dot{\mathbf{j}}}=1$ while(  $\scriptstyle{\dot{\mathbf{z}}}\,<={\mathbf{S}}$  .length&&j  $<=\operatorname{T}$  .length)( if(  $\scriptstyle{\mathrm{j}}==0$  IIs.ch[i]  $\scriptstyle==\mathrm{T}$  .ch[j]）{  ${\mathbf{++i}}$   ${++j}$  /继续比较后继字符 else j=next[j];/模式串向右移动if(j>T.length) returni-T.length; //匹配成功 else return0;  

宗KMP匹配过程中比较次数的分析（2019）  

尽管普通模式匹配的时间复杂度是 $O(m n)$ ，KMIP算法的时间复杂度是 $O(m+n)$ ，但在一般情况下，普通模式匹配的实际执行时间近似为 $O(m+n)$ ，因此至今仍被采用。KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快得多，其主要优点是主串不回溯。  

# 4.2.3KMP算法的进一步优化  

前面定义的next数组在某些情况下尚有缺陷，还可以进一步优化。如图4.7所示，模式串aaaab在和主串'aaa baa aab：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/89c15cad9b3226daad524eb2c8f2a36edfa137b898562d900f05e8bab1751ffd.jpg)  

当 $\mathtt{i}\!=\!4$ 、 $\gimel4$ 时，S4跟 $\mathtt{p}_{4}$  $\mathrm{b}\!\neq\!\mathrm{a}$ ）失配，若用之前的next数组，则还需要进行 $\mathbb{S}_{4}$ 与p3、S4与 $\mathtt{p}_{2}$ 、S4与 $\mathtt{p}_{1}$ 这3次比较。事实上，因为 $\mathsf{p_{n e x t\,[\,4\,]=3}{=}p_{4}{=}a}.$ Pnext[3] $\mathsf{\Gamma}_{2}\mathsf{=}\mathsf{p}_{3}\mathsf{=}\mathsf{a}$ 、Pnext[21-1=p2=a,显然后面3次用一个和 $\mathtt{p}_{4}$ 相同的字符跟 $S_{4}$ 比较毫无意义，必然失配。那么问题出在哪里呢？  

问题在于不应该出现 $\mathsf{p}_{\mathrm{j}}\mathrm{=}\mathsf{p}_{\mathrm{next}\,[\mathrm{j}\,]}$ 。理由是：当 $\mathtt{p}_{\mathrm{j}}\not=\mathtt{s}_{\mathrm{j}}$ 时，下次匹配必然是 $\mathtt{P h e x t\left[j\right]}$ 跟 $\mathsf{s}_{\mathrm{j}}$ 比较，若 $\tt p_{j}{=}p_{i}$ next[j]，则相当于拿一个和 ${\tt p}_{\tt j}$ 相等的字符跟s比较，这必然导致继续失配，这样的比较毫无意义。若出现 $\mathsf{p_{j}}\mathrm{{=}}\mathsf{p_{n e x t\,[\,\mathrm{{j}\,]}}}$ ，则如何处理呢？  

若出现  $\mathsf{p_{j}}\mathrm{{=}}\mathsf{p_{n e x t\,[\,j\,]}}$  ，则需要再次递归，将next[j]修正为next[next[j]]，直至两者不相 等为止，更新后的数组命名为nextval。计算next数组修正值的算法如下，此时匹配算法不变。  

void get nextval（SString T,int nextval[l){  

int $\scriptstyle{\dot{\Sigma}}={\bar{\Sigma}}$ ， $\scriptstyle{\dot{\mathbf{\rho}}}=0$ nextval  $[\,\!1\,]\!=\!0$  while(  $\scriptstyle{\dot{\mathbf{1}}}<{\mathrm{T}}$  .length){ if（j  $\scriptstyle{|==0}$  [|T.ch[i]  $\scriptstyle{\mathrm{~\!~\!~\!~\!~}}={\mathrm{T}}$  .ch[j]){  ${++i}$ ： ${++j}$ if（T.ch[i]  $!=\!\mathrm{T}$  .ch[j]) nextval[i]  $={\dot{\mathsf{j}}}$  else next val[i]  $=$  nextval[j];  
else  ${\dot{\bar{\mathbf{\rho}}}}^{=}$  nextval[j];  

KMIP算法对于初学者来说可能不太容易理解，读者可以尝试多读几遍本章的内容，并参考一些其他教材的相关内容来巩固这个知识点。  

# 4.2.4 本节试题精选  

# 一、单项选择题  

01.设有两个串 $S_{1}$ 和 $S_{2}$ ，求 $S_{2}$ 在 $S_{1}$ 中首次出现的位置的运算称为（）A.求子串B.判断是否相等C.模式匹配D.连接02.KMP算法的特点是在模式匹配时，指示主串的指针（）A.不会变大B.不会变小C.都有可能D.无法判断  

03.设主串的长度为 $n$ ，子串的长度为 $m$ ，则简单的模式匹配算法的时间复杂度为（），KMP算法的时间复杂度为（）。  

A.O(m) B.O(n) C.O(mn) D.  $O(m+n)$  

04.在KMP匹配中，用next数组存放模式串的部分匹配信息，当模式串位j与主串位i比较时，两个字符不相等，则1的位移方式是（）。  

A.  $\scriptstyle{\dot{\mathbf{j}}}=0$  B.  $\scriptstyle{\dot{\boldsymbol{\jmath}}}={\dot{\boldsymbol{\jmath}}}+1$  C.j不变 D.  ${\dot{\mathsf{j}}}=$  next[j]  

05.在KMP匹配中，用next数组存放模式串的部分匹配信息，当模式串位j与主串位i比较时，两个字符不相等，则i的位移方式是（）。  

A.  $\scriptstyle{\dot{\mathbf{1}}}\,=$  next[i] B.i不变 C.  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$  D.i=i+1 06.已知串 $s{=}$ aaab'，其next数组值为（）A.0123 B.0112 C.0231 D.1211 07.串'ababa a ababa a'的next数组值为（）  

A.01234567899 B.012121111212 C.011234223456 D.0123012322345  

08.串'ababa a ababa a next（）  

A.-1,0,1,2,3,4,5,6,7,8,8,8B. $\begin{array}{r}{-1,0,1,0,1,0,0,0,0,1,0,}\end{array}$ 一C.  $-1,0,0,1,2,3,1,1,2,3,4,5$  D.-1，0,1,2,-1,0,1,2,1,1,2,3  

09.串'ababa a ababa a'next val（）  

A.  $0,1,0,1,1,2,0,1,0,1,0,2$  B.  $0,1,0,1,1,4,1,1,0,1,0,2$  C.  $0,\,1,\,0,\,1,\,0,\,4,\,2,\,1,\,0,\,1,\,0,\,4$  D.  $0,1,1,1,0,2,1,1,0,1,0,4$  

10.【2015统考真题】已知字符串S为'aba aba abaca caa baa bcc，模式串t为'abaabc' 采用KMP算法进行匹配，第一次出现“失配”（s[i]≠t[j]）时， $\scriptstyle{\dot{\Sigma}}={\dot{\Sigma}}=5$ ，则下次开始匹配时，i和j的值分别是（）。  

A. $\scriptstyle{\dot{\Sigma}}={\boldsymbol{\perp}}$ ， $\scriptstyle{\dot{\mathbf{\rho}}}=0$ B. $\mathtt{i}\!=\!5$ ， $\mathord{\dot{\j}}\!=\!0$ C. $\mathtt{i}\!=\!5$ ， $\scriptstyle{\dot{\boldsymbol{\jmath}}}=2$ D. $\mathtt{i}\!=\!6$ ， $\scriptstyle{\dot{\boldsymbol{\jmath}}}=2$  

11.【2019统考真题】设主串  $\scriptstyle{\mathrm{T}}=$  aba aba abc aba abc'，模式串  $s{=}$  abaabc'，采用KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是（）。  

A.9 B.10 C.12 D.15  

# 二、综合应用题  

01.在字符串模式匹配的KMP算法中，求模式的next数组值的定义如下：  
1）当 $\scriptstyle{j=1}$ 时，为什么要取next[1] $\scriptstyle=0^{\prime}$ 2）为什么要取max[k），k最大是多少？3）其他情况是什么情况，为什么取next[j] $^{=1}$ ?  

02.设有字符串  $s{=}$  'a a baa baa baa c',  $\mathbb{P}=$  'aabaac'  

1）求出P的next数组2）若S作主串，P作模式串，试给出KMP算法的匹配过程。  

# 4.2.5 答案与解析  

# 一、单项选择题  

01.C 求子串操作是从事 $S$ 中截取第 $i$ 个字符起长度为 $l$ 的子串，A错误。B、D明显错误。  

02.B 在KMP算法的比较过程中，主串不会回溯，所以主串的指针不会变小。  

03.C、D  

尽管实际应用中，一般情况下简单的模式匹配算法的时间复杂度近似为 $O(m+n)$ ，但它的理论时间复杂度还是 $O(m n)$ 。KMP算法的时间复杂度为 $O(m+n)$  

04.D  

在KMP匹配中，当主串的第i个字符和模式串的第j个字符不匹配时，主串的位指针i不变，将主串的第i个字符与模式串的第next[j]个字符比较，即 $\dagger=$ next[j]  

05.B  

在KMP匹配中，当主串的第i个字符和模式串的第j个字符不匹配时，主串位i不回溯。  

06.A  

1）设next  $[\,\beth\,]\,{=}\,0$  ,next  $[2]\!=\!1$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/324e552c289ad685020a346e6c10b4da169a93c653a6a302719332def4a9e9ae.jpg)  

2) $\scriptstyle{\dot{\bar{\jmath}}}=3$ 时 $\k=$ next[j-1] $=$ next $[2]\!=\!1$ ，观察s[j-1]（S[2]）与S[k]（S[1]）是否相等 ${\sf S}\left[2\right]\sf=\sf{a}$  ${\sf S}\left[\mathbb{1}\right]\sf=\sf a$ ， ${\sf S}\left[2\right]{=}{\sf S}\left[1\right]$ ，所以next[j $]\!=\!\!\mathrm{k}\!+\!1\!=\!2$ 。  

$\downarrow\dot{\cdot}{-}1{=}2$  a a a b a a a b  $\uparrow k{=}1$  

3) $\dot{\mathfrak{j}}\!=\!4$ 时 $\kappa=$ next[j-1] $=$ next[3] $^{=2}$ ，观察s[j-1]（S[3]）与s[k]（S[2]）是否相等， ${\sf S}\left[3\right]\sf=\sf a$  ${\sf S}\left[2\right]\sf=\sf{a}$ ， ${\textsf{S}}[3]\!=\!\mathrm{S}\left[2\right]$ ，所以next[j] $\mathbf{\lambda=}k\!+\!1\!=\!3$  

$\downarrow\downarrow-1=3$  b a a a a a a b  $\uparrow\downarrow\downarrow=2$  
最后的结果如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fd25b926cb0b642929e708ed40c60eb724b8877345e33bc310a47d3bb1eccf02.jpg)  

本题采用next的推理原理求解，若字符串较长，则求解过程会比较烦琐。  

07.C  

这道题采用手工求next数组的方法。先求串 $s{=}$ ababa a ababa a：  

a的前后缀都为空，最长相等前后缀长度为0。ab的前缀（a}n后缀 $\{{\sf b}\}\!=\!\emptyset$ ，最长相等前后缀长度为0。aba'的前缀（a，ab)n后缀 $\left\{\mathsf{a}\,,\mathsf{b a}\right\}\!=\!\left\{\mathsf{a}\right\}$ ，最长相等前后缀长度为1。abab的前缀（a，ab，aba}n后缀{b，ab，bab） $=i$ [ab），最长相等前后缀长度为2。  

依次求出的部分匹配值见下表第3行，将其整体右移一位，低位用-1填充，见下表第4行。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6bea1d1bb4e3b00ee7431d4358ab0208321daf0a7f67dc8347bec33eabce6564.jpg)  

选项中next[1]等于0，所以将next数组整体加1  

# 08.C  

解析见上题。注意，next数组是否整体加1都正确，需根据题意具体分析。  

# 注意  

在实际KMP算法中，为了使公式更简洁、计算简单，若串的位序是从1开始的，则next数组才需要整体加1；若串的位序是从 $0$ 开始的，则next数组不需要整体加1。  

# 09.C  

nextval从0开始，可知串的位序从1开始。第一步，令nextval $[\,\!1\,]\,{=}$ next[1]=0。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0723a252b86c7588ad313efb041b992a9eea1625ac727c4fc5d1fef9bfcac637.jpg)  

从 $\gimel$ 开始，依次判断 ${\tt p}_{\mathrm{j}}$ 是否等于 $\mathtt{P h e x t}\{\dot{\mathtt{j}}\}$ ？若是则将next[j]修正为next[next[j]]，直至两者不相等为止。由下述推理可知，答案选C。  

第2步： $\mathtt{p}_{2}\mathtt{=}\mathtt{b}$ Pnext[2] $=\mathrm{a}$  $\mathsf{p}_{2}\not=\mathsf{p}_{\mathrm{{neg}}\,[2]}$ ,nextval[2] $=$ next $[2]=1$ 第3步： $\mathtt{p}_{3}\mathrm{=}\mathrm{a}$ Pnext[3] $=\mathtt{a}$  $\mathsf{p}_{3}\mathrm{{=}}\mathsf{p}_{\mathrm{{neg}}\,[3]}$ ,nextval[3] $=$ nextval[next[3]] $=$ nextval $[\,\underline{{1}}\,]\!=\!0$ 第4步： $\mathtt{p}_{4}\mathrm{=}\mathtt{b}.$ Pnext[4] $\mathbf{\epsilon}_{=b}$  $\mathsf{p_{4}=p_{n e x t\left[4\right]}}$ , nextval[4] $=$ nextval[next[4]] $=$ nextval[2] $^{=1}$ 第5步： $\mathtt{p_{5}}\mathrm{=}\mathrm{a}$ Pnext[5）=a,ps=Pnext[5]nextval[5] $=$ nextval[next[5]] $=$ nextval[3] $=\!0$ 第6步： ${\tt p}_{6}{=}{\tt a}.$ Pnext[6] $\tt=b$ p≠Pnext[6], nextval[6] $=$ next[6] ${=}4$ 第7步：  ${\tt p}_{7}{=}{\tt a}.$   $\mathsf{p}_{\mathrm{next}\left[7\right]}\mathrm{=b}$  p≠Pnext[7] nextval[7]  $=$  next[7]  $^{=2}$  
第8步:  $\mathtt{p_{8}=b}.$   Pnext[8]  $\mathbf{\epsilon}_{=b}$   Pa=Pnext[8] nextval[8]  $=$  nextval [next[8]]  $=$  nextval[2]  $\mathbf{\Phi}=\mathbb{1}$  第9步: ${\tt p}_{9}{=}{\tt a}$ 、Pnext[9]=a, $\mathsf{p_{9}=p_{n e x t\,[9]}}$ , nextva1[9] $=$ nextval[next[9]] $=$ nextval[3] $=\!0$ ：第10步: $\mathtt{p}_{10}\mathrm{=}\mathtt{b}.$  Pnext [10] $\mathbf{\epsilon}_{=\mathrm{b}}$  P1o=Pnext[1o] nextval[10] $=$ nextval[next[10]] $=$ nextva1[4] $\mathbf{\Phi}=\mathbb{1}$ ： $\mathtt{p}_{11}\mathrm{=}\mathrm{a}.$  $\mathsf{p}_{\mathrm{{neg}\,[11]}}\mathrm{{=a}}$  $=$  $=$  $=\!0$ ：第12步: $\mathtt{p}_{12}\mathrm{=}\mathrm{a}_{1}$ Pnext [12] $=\!a$ P1o=Pnext[12], nextval [12] $=$ nextval [next[12]] $=$ nextval[6] ${=}4$ ：在第5步的推理中， $\mathsf{p_{5}{=}p_{n e x t\,[5]}{=}a}$ ，按前面的讲解部分，应该继续让p3和pnext[3j比较（恰好

 $\mathsf{p}_{3}\mathrm{=}\mathsf{p}_{\mathrm{next}\,[3]\mathrm{=}1}\,,$ ),注意到此时 nextval[3]的值已存在,故直接将 nextval[5]赋值为 nextval[3]。对于一般情况，nextval 数组是从前往后逐步求解的，发生 $\mathsf{p_{j}=p_{n e x t\,[\,\mathfrak{j}\,]}}$ 时，因为 nextval

[next[j]]早已求得，next val[j］赋值为 nextval[next[j]］。  

10.C  

由题中“失配s[i]≠t[j]时， $\mathtt{i}\!=\!\mathtt{i}=\!5$ ”，可知题中的主串和模式串的位序都是从0开始的

（要注意灵活应变）。按照next数组生成算法，对于t有  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7419483a1e17abfc50c7bc83070a668a57165a793d61316e9e9988e89083dc7.jpg)  

发生失配时，主串指针i 不变，子串指针」回退到next[j]位置重新比较，当s[i] $\neq\top$ [j]时， $\mathtt{i}\!=\!\mathtt{i}=\!5$ ，next next[j] $=$ next $[\,5\,]\!=\!2$ （位序从0开始)。因此， $\mathtt{i}\!=\!5$ ， $\scriptstyle{\dot{\boldsymbol{\jmath}}}=2$ 。  

11.B  

假设位序从0开始的，按照next数组生成算法，对于s有  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c41bfc001746badce009efd4560a1d524fa970b8f563698660ab33b0c2137932.jpg)  

第一趟连续比较6次，在模式串的5号位和主串的5号位匹配失败，模式串的下一个比较位置为next[5]，即下一次比较从模式串的2号位和主串的5号位开始，然后直到模式串的5号位和主串的8号位匹配，第二趟比较4次，匹配成功。单个字符的比较次数为10次。  

# 二、综合应用题  

01．【解答】  

1）当模式串的第1个字符与主串的当前字符比较不相等时，next $[\,\beth\,]\,{=}\,0$ ，表示模式串应右移一位，主串当前指针后移一位，再和模式串的第1个字符进行比较。  

2）当主串的第i个字符与模式串的第」个字符失配时，主串i不回溯，则假定模式串的第 $\boldsymbol{\mathrm{k}}$ 个字符与主串的第i个字符比较， $\boldsymbol{\mathrm{k}}$ 值应满足条件 $\scriptstyle1<\ k<j$ 且 $\mathrm{\Delta^{\prime}p_{1}\cdots p_{k-1}\Delta^{\prime}=\Delta^{\prime}p_{j-k+1}\cdots p_{j-1}\Delta^{\prime}}$ ，即 $\kappa$ 为模式事的下次比较位置。 $\kappa$ 值可能有多个，为了不使向右移动丢失可能的匹配，右移距离应该取最小，因为 $\dot{\mathsf{j}}\!-\!\mathsf{k}$ 表示右移的距离，所以取 $\operatorname*{max}\{k\}$ 。 $\mathtt{k}$ 的最大值为-1。  

3）除上面两种情况外，发生失配时，主串指针i不回溯，在最坏情况下，模式串从第1个字符开始与主串的第i个字符比较。  

# 02.【解答】  

1） $\mathbb{P}=$ 'aabaac'，按照next数组生成算法，对于P有： $\textcircled{\scriptsize{1}}$  设next  $[\,\beth]\,{=}\,0$  ，next  $[2]\!=\!1$  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33da1e25addb096029df22cc29324ca13eb7c1919006d88596b1badec99ab2c3.jpg)  

$\circledcirc$  $\scriptstyle{\dot{\bar{\jmath}}}=3$ 时 $\kappa=$ next[j-1] $=$ next $[2]\!=\!1$ ，观察s[j-1]（S[2]）与s[k]（S[1]）是否相等， ${\sf S}\left[2\right]\sf=\!{\sf a}$ ， ${\sf S}\left[\mathbb{1}\right]\sf=\sf{a}$ ， $\mathrm{~S~}[\,2\,]\!=\!\mathrm{S}\;[\,1\,]$ ，所以next[ $\lfloor{\bf\omega}\rfloor\!=\!\!\mathrm{k}\!+\!1\!=\!2$ 。  

$\textcircled{3}$  $\gimel4$ 时 $\kappa=$ next[j-1] $=$ next[3] $^{=2}$ ，观察s[j-1]（S[3]）与s[k]（S[2]）是否相等， ${\sf S}\left[\,3\,\right]=\sf b$ ， ${\sf S}\left[2\right]\sf=\!{\sf a}$ ,S[3] $!\!=\!\!\mathrm{S}\left[\,2\,\right]$ 。  

$\downarrow\dot{\cdot}\!-\!1\!=\!3$  a a b a a C a a b a a C  $\uparrow\downarrow\!\!k\!\!=\!\!2$  

此时 $\kappa=$ next $[k]\!=\!1$ ，观察s[3]与S[k]（S[1]）是否相等，S $[\,3\,]\,{=}\mathrm{b}$  ${\sf S}\left[\mathbb{1}\right]\mathrm{{=a}}$ S[3] $!\mathrm{{=}}\mathrm{{S}}$ [1]。 $\ k=$ next $[\,k\,]\!=\!0$ ，因为 $k{=}0$ ，所以next $[\,\dot{\,}]\,{=}1$  

↓j-1=3 a a b a a C a a b a a C  $\uparrow\downarrow\downarrow=0$  

$^{(4)}$  $\mathord{\dot{\bar{\mathbf{\beta}}}}\!=\!5$ 时 $\ k=$ next $[\,\dot{\,}]\,{-}\,1\,]\,{=}$ next $[4]\!=\!1$ ，观察s[j-1]（S[4]）与s[k]（S[1]）是否相等，  ${\mathsf{S}}\;[\,4\,]\,{=}\mathsf{a}$  ，  ${\sf S}\left[\mathbb{1}\right]\sf=\sf a$  ，  ${\textsf{S}}[\,4\,]\!=\!\!{\mathsf{S}}\left[\,1\,\right]$  ，所以next[j]  $|\!=\!\!\mathrm{k}\!+\!1\!=\!2$  

$\downarrow\dot{\,}^{-1=4}$  a a b a a C a a b a a C  $\uparrow\downarrow\downarrow=\downarrow$  

$\circledast$  $\dot{\bar{\jmath}}\!=\!6$ 时 $\ k=$ next[j-1] $=$ next $[5]\!=\!2$ ，观察s[j-1]（S[5]）与s[k]（S[2]）是否相等， ${\sf S}\left[5\right]\sf=\!{\sf a}$ ， ${\sf S}\left[2\right]\sf=\sf{a}$  ${\sf S}\left[\,5\,\right]=\sf{S}\left[\,2\,\right]$ ，所以next[j $\mathbf{\tau})\!=\!\mathbf{k}\!+\!\mathbf{1}\!=\!3$ 。  

最后的结果为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/68a30a346398668800b6915c5bbde3ac4b6c3572d849990bcfa280d328ccda81.jpg)  

也可以通过求部分匹配值表的方法来求next数组。  

2）利用KMP算法的匹配过程如下第一趟：从主串和模式串的第1个字符开始比较，失配时 $\scriptstyle{\dot{\Sigma}}\,=\,6$  $\dot{\bar{\mathbf{\rho}}}\!=\!6$  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f97f6994a195ed7e0d5c402153422ba83cbe971d14bee5c7d07b5dc42e00979.jpg)  

第二趟：next $[6]\!=\!3$ ，主串当前位置和模式串的第3个字符继续比较，失配时 $\scriptstyle{\dot{\Sigma}}=9$  $\dot{\bar{\mathbf{\alpha}}}\!=\!6$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/901777c03628ada8b4fed4ed18c04a2a23d27eb6f0e1f59d3b77eb6e68401b87.jpg)  

第三趟：next $[\,6\,]\!=\!3$ ，主串当前位置和模式串的第3个字符继续比较，匹配成功。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dc3881603a934d8d91d42a98e822344d4f2057e15d15fe8a255a756e8e4e8e98.jpg)  

# 归纳总结  

学习KMP算法时，应从分析暴力法的端入手，思考如何去优化它。实际上，已匹配相等的序列就是模式串的某个前缀，因此每次回溯就相当于模式串与模式串的某个前缀比较，这种频繁的重复比较是效率低的原因。这时，可从分析模式串本身的结构入手，以便得知当匹配到某个字符不等时，应该向后滑动到什么位置，即已匹配相等的前缀和模式串若首尾重合，则对齐它们，对齐部分显然无须再比较，下一步则是直接从主串的当前位置继续进行比较。  

# 思维拓展  

编程实现：模式串在主串中有多少个完全匹配的子串？注意，统考不会考KMP算法题。  
# 第5章树与二叉树  

# 【考纲内容】  

（一）树的基本概念  

（二）二叉树  

二叉树的定义及其主要特征：二叉树的顺序存储结构和链式存储结构：二叉树的遍历：线索二叉树的基本概念和构造  

（三）树、森林树的存储结构：森林与二叉树的转换；树和森林的遍历  

（四）树与二叉树的应用哈夫曼（Huffman）树和哈夫曼编码：并查集及其应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d54ca676f546045fcd23c9d722b45ed4375e969ecfffd2829a916600c7dcb654.jpg)  

【复习提示】  

本章内容多以选择题或综合题的形式考查，但统考也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，都是选择题必然会涉及的内容。  

# 5.1树的基本概念  

5.1.1树的定义  

树是 $n$  $n{\geqslant}0$ ）个结点的有限集。当 $n=0$ 时，称为空树。在任意一棵非空树中应满足  
1）有且仅有一个特定的称为根的结点。  

2）当 $n>1$ 时，其余结点可分为 $m$  $m\!>\!0$ ）个互不相交的有限集 $T_{1},T_{2},\cdots,T_{m}$ ，其中每个集合本身又是一棵树，并且称为根的子树。显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：1）树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。  

2）树中所有结点都可以有零个或多个后继。  

树适用于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n\!-\!1$ 条边。而树中每个结点与其下一层的零个或多个结点（即其孩子结点）都有直接关系。  

# 5.1.2基本术语  

下面结合图5.1中的树来说明一些基本术语和概念。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/19c3d1765bb49ccc50656074b4b2909d9ab012f0a47d45e72e85165ba4b81d5f.jpg)  
图5.1树的树形表示  

1）祖先、子孙、双亲、孩子、兄弟和堂兄弟。  

考虑结点 $K$ ，从根 $A$ 到结点 $K$ 的唯一路径上的所有其他结点，称为结点 $K$ 的祖先。如结点 $B$ 是结点 $K$ 的祖先，而 $K$ 是 $B$ 的子孙，结点 $B$ 的子孙包括 $E,F,K,L$ 。路径上最接近结点 $K$ 的结点 $E$ 称为 $K$ 的双亲，而 $K$ 为 $E$ 的孩子。根 $A$ 是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟，如结点 $K$ 和结点 $L$ 有相同的双亲 $E$ ，即 $K$ 和 $L$ 为兄弟。双亲在同一层的结点互为堂兄弟，结点 $G$ 与 $E,F,H,I,J$ 互为堂兄弟。  

2）结点的度和树的度。  

树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。如结点B的度为2，结点 $D$ 的度为3，树的度为3。  

3）分支结点和叶结点。  

度大于0的结点称为分支结点（又称非终端结点）；度为0（没有孩子结点）的结点称为叶结点（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。  

4）结点的深度、高度和层次。  

结点的层次从树根开始定义，根结点为第1层，它的孩子为第2层，以此类推。结点的深度就是结点所在的层次。树的高度（或深度）是树中结点的最大层数。结点的高度是以该结点为根的子树的高度。图5.1中树的高度为4。  

5）有序树和无序树。  

树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。  
假设图5.1为有序树，若将子结点位置互换，则变成一棵不同的树。  

6）路径和路径长度。  

树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。  

# 注意  

因为树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。  

7）森林。  

# 命题追踪森林中树的数量、边数和结点数的关系（2016）  

森林是 $m$ ( $m{\gtrsim}0$ ）棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给 $m$ 棵独立的树加上一个结点，并把这 $m$ 棵树作为该结点的子树，则森林就变成了树。  

# 注意  

上述概念无须刻意记忆，根据实例理解即可。考研时不大可能直接考查概念，而都是结合具体的题目考查。做题时，遇到不熟悉的概念可以翻书，练习得多自然就记住了。  

# 5.1.3 树的性质  

树具有如下最基本的性质：  

# 命题追踪树中结点数和度数的关系的应用（2010、2016）  

1）树的结点数 $n$ 等于所有结点的度数之和加1。  

结点的度是指该结点的孩子数量，每个结点与其每个孩子都由唯一的边相连，因此树中所有结点的度数之和等于树中的边数之和。树中的结点（除根外）都有唯一的双亲，因此结点数 $n$ 等于边数之和加1，即所有结点的度数之和加1。  

2）度为  $m$  的树中第  $i$  层上至多有  $m^{i-1}$  个结点（  $i\!\geqslant\!1$  

第1层至多有1个结点（即根结点），第2层至多有 $m$ 个结点，第3层至多有 $m^{2}$ 个结点，以此类推。使用数学归纳法可推出第 $i$ 层至多有 $m^{i-1}$ 个结点。  

3）高度为  $h$  的  $m$  叉树至多有  $(m^{h}\!-\!1)/(m\!-\!1)$  个结点。 当各层结点数达到最大时，树中至多有 $1+m+m^{2}+\cdots+m^{h-1}=(m^{h}-1)/(m-1)$ 个结点。命题追踪指定结点数的三叉树的最小高度分析（2022）4）度为 $m$ 、具有 $n$ 个结点的树的最小高度 $h$ 为 $\lceil\log_{m}(n(m-1)+1)\rceil.$  

为使树的高度最小，在前 $h-1$ 层中，每层的结点数都要达到最大，前 $h-1$ 层最多有 $(m^{h-l}-1)/(m-1)$ 个结点，前 $h$ 层最多有 $(m^{h}\!-\!1)/(m\!-\!1)$ 个结点。因此 $(m^{h-l}-1)/(m-1)<n\leqslant$  $(m^{h}\!-\!1)\,/(m\!-\!1)$ ，即 $h-1<\log_{m}(n(m-1)+1){\leqslant}h$ ，解得 $h_{\mathrm{min}}\!=\!\lceil\log_{m}\!(n(m\!-\!1)\!+\!1)\rceil.$  

5）度为 $m$ 、具有 $n$ 个结点的树的最大高度 $h$ 为 $\begin{array}{r}{n\!-\!m+1.}\end{array}$  

由于树的度为 $m$ ，因此至少有一个结点有 $m$ 个孩子，它们处于同一层。为使树的高度最大，其他层可仅有一个结点，因此最大高度（层数）为 $n-m+1$ 。由此，也可逆推出高度为  $h$  、度为  $m$  的树至少有  $h+m-1$  个结点。  
# 5.1.4 本节试题精选  

# 一、单项选择题  

01.树最适合用来表示（）的数据。  

A.有序 B.无序 C.任意元素之间具有多种联系D.元素之间具有分支层次关系  

02.一棵有 $n$ 个结点的树的所有结点的度数之和为（）A.n-1 B.  $n$  C.  $n+1$  D.2n

 03.树的路径长度是从树根到每个结点的路径长度的（）A.总和B.最小值C.最大值D.平均值

04.对于一棵具有 $n$ 个结点、度为4的树来说，（）  

A.树的高度至多是 $n-3$ B.树的高度至多是 $n\!-\!4$ C.第 $i$ 层上至多有 $4(i-1)$ 个结点D.至少在某一层上正好有4个结点  

05.度为4、高度为 $h$ 的树，（）  

A.至少有  $h+3$  个结点 B.至多有  $4h-1$  个结点 C.至多有  $_{4h}$  个结点 D.至少有  $h+4$  个结点  

06.假定一棵度为3的树中，结点数为50，则其最小高度为（）。A.3 B.4 C.5 D.6  

07.设有一棵度为3的树，其中度为3的结点数 $n_{3}=2$ ，度为2的结点数 $n_{2}=1$ ，叶结点数 $n_{0}\!=\!6$ ，则该树的结点总数为（）。  

A.12B.9C.10D. ${\geqslant}9$ 的任意整数  

08.设一棵  $m$  叉树中有  $N_{1}$  个度数为1的结点，  $N_{2}$  个度数为2的结点····  $\cdot N_{m}$  个度数为  $m$  的结 点，则该树中共有（）个叶结点。  

$\sum_{i=1}^{m}(i-1)N_{i}$  m m A. B. Mv C. Z(i-1)N, D. ∑(i-1)N, +1 i=1 i=2 i=2  

09.【2010统考真题】在一棵度为4的树 $T$ 中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树 $T$ 的叶结点个数是（）。  

A.41 B.82 C.113 D.122

 10.【2016统考真题】若森林 $F$ 有15条边、25个结点，则 $F$ 包含树的个数是（）A.8T B.9 C.10 D.11  

# 二、综合应用题  

01.含有 $n$ 个结点的三叉树的最小高度是多少？  

02.已知一棵度为4的树中，度为 $0,1,2,3$ 的结点数分别为 $14,4,3,2$ ，求该树的结点总数 $n$ 和度为4的结点个数，并给出推导过程。  

03.已知一棵度为 $m$ 的树中，有 $n_{1}$ 个度为1的结点，有 $n_{2}$ 个度为2的结点..有 $n_{m}$ 个度为 $m$ 的结点，问该树有多少个叶结点？  

# 5.1.5 答案与解析  

# 一、单项选择题  

01.D  

树是一种分层结构，它特别适合组织那些具有分支层次关系的数据。  
02.A  

除根结点外，其他每个结点都是某个结点的孩子，因此树中所有结点的度数加1等于结点数，也即所有结点的度数之和等于总结点数减1。这是一个重要的结论，做题时经常用到。  

03.A  

树的路径长度是指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值应是 树的高度减1。注意与哈夫曼树的带权路径长度相区别。  

04.A  

要使得具有 $n$ 个结点、度为4的树的高度最大，就要使得每层的结点数尽可能少，类似下图所示的树，除最后一层外，每层的结点数是1，最终该树的高度为 $_{n-3}$ 。树的度为4只能说明存在某结点正好（也最多）有4个孩子结点，D错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c2acf0a7da6dab9b867bdeee644276bab169f8a3ce9c55f42f055efbe2d40898.jpg)  

05.A  

要使得度为4、高度为 $h$ 的树的总结点数最少，需要满足以下两个条件：  

$\textcircled{\scriptsize{1}}$ 至少有一个结点有4个分支。 $\circledcirc$ 每层的结点数目尽可能少。情况类似下图所示的树，结点个数为 $h+3$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/319130282b8c21b7aad8111328893a19cc0d7390c7079f8ec405a0db31354fb8.jpg)  

要使得度为4、高度为 $h$ 的树的总结点数最多，应使每个非叶结点的度均为4，即为满树，总结点个数最多为 $1+4+4^{2}+\ldots+4^{h-1}$  

对于上面的两题，应画出草图来求解，就能一自了然。  

06.C  

要求满足条件的树，那么该树是一棵完全三叉树。在度为3的完全三叉树中，第1层有1个结点，第2层有 $3^{1}\,{=}\,3$ 个结点，第3层有 $3^{2}\,{=}\,9$ 个结点，第4层有 $3^{3}\,{=}\,27$ 个结点，因此结点数之和为 $1+3+9+27=40$ ，第5层的结点数 $=50\,{-}\,40=10$ 个，因此最小高度为5。  

07.B  

总结点数 $n=n_{0}+n_{1}+n_{2}+n_{3}=6+n_{1}+1+2=n_{1}+9,$ 总度数 $=n-1=n_{1}+2n_{2}+3n_{3}=n_{1}+2+6=$  $n_{1}+\,8$ ，根据题目条件无法得出 $n_{1}$ 的具体值，只能证明 $n_{1}$ 是一个大于或等于9的任意整数。画出满足题目条件的树，可以是如下图所示的一棵树，该树中无法确定 $n_{1}$ 的具体数量。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d3f8afcf3229449d56c1d3a158ee20af4df2bc26b4b7044ed548cbd0e4ab56a7.jpg)  

08.D  

设叶结点数为 $N_{0}$ ，总结点数为 $N$ 则 $N\!=\!N_{1}\!+2N_{2}\!+3N_{3}\!+\!\dots+m N_{m}\!+1$ 又因为 $N\!=\!N_{0}\!+\!N_{1}\!+\!N_{2}\!+$  $N_{3}\,{+}\,{\cdots}\,{+}\,N_{m}$ ，所以 $N_{0}=N_{2}+2N_{3}+\cdots+(m-1)N_{m}+1=\sum_{i=2}^{m}(i-1)N_{i}+1\,,$  

09.B  

设树中度为 $\textit{i}(i=0,\,1,\,2,\,3,\,4\,)$ ）的结点数分别为 $n_{i}$ ，树中结点总数为 $n$ ，则 $n=$ 分支数 $+1$ 而分支数又等于树中各结点的度之和，即 $n=1+n_{1}+2n_{2}+3n_{3}+4n_{4}=n_{0}+n_{1}+n_{2}+n_{3}+n_{4}$ 。依题意， $n_{1}+2n_{2}+3n_{3}+4n_{4}=10+2+30+80=122.$  $n_{1}+n_{2}+n_{3}+n_{4}=10+1+10+20=41$ ，可得出 $n_{0}\,{=}\,82$ ，即树 $T$ 的叶结点的个数是82。  

10.C  

解法1：树有一个重要性质，即在 $n$ 个结点的树中有 $n\!-\!1$ 条边，“那么对于每棵树，其结点数比边数多1”。本题森林中的结点数比边数多10（即 $25-15=10\,.$ ），显然共有10棵树。  

解法2：仔细分析后发现此题也是考查图的性质：生成树和生成森林。对于图的生成树有一个重要的性质，即图中顶点数若为 $n$ ，则其生成树含有 $n-1$ 条边。对比解法1中树的性质，不难发现两种解法都用到了性质“树中结点数比边数多1”，后面的分析如解法1。  

# 二、综合应用题  

01.【解答】  

要求含有 $n$ 个结点的三叉树的最小高度，那么满足条件的一定是一棵完全三叉树，设含有 $n$ 个结点的完全三叉树的高度为 $h$ ，第 $h$ 层至少有1个结点，至多有 $3^{h-1}$ 个结点。则有  

$1+3^{1}+3^{2}+\cdots+3^{h-2}\!<\!n\!\leqslant\!1+3^{1}+3^{2}+\cdots+3^{h-2}+3^{h-1}$  

即 $|(3^{h-1}-1)/2<n\leqslant(3^{h}-1)/2$ ，得 $3^{h-1}\!<\!2n+1\!\leqslant\!3^{h}$ ，也即 $h<\log_{3}(2n+1)+1$ ， $h{\geqslant}\log_{3}(2n+1)$ 。  

因为 $h$ 只能为正整数， $h=\lceil\log_{3}(2n+1)\rceil$ ，所这种三叉树的最小高度是 $\lceil\log_{3}(2n+1)\rceil_{\circ}$  

02.【解答】  

设树中度为  $i\left(i\!=\!0,1,2,3,4\right)$  的结点数为  $n_{i}$  ，则结点总数  $n\!=\!n_{0}+n_{1}+n_{2}+n_{3}+n_{4},$  即  $n\!=\!23+n_{4}$  根据“树中所有结点的度数加1等于结点数”的结论，有 $n=0+n_{1}+2n_{2}+3n_{3}+4n_{4}+1$ ，即有 $n=$  $17+4n_{4}\mathrm{o}$  

综合两式得 $n_{4}\!=\!2,~n\!=\!25$ 。所以该树的结点总数为25，度为4的结点个数为2。  

03.【解答】  

树中的结点数等于所有结点的度数加1，因此有 $n=\sum_{i=0}^{m}i n_{i}+1=n_{1}+2n_{2}+3n_{3}+\cdots+m n_{m}+1\,.$  

又有 $n=n_{0}+n_{1}+n_{2}+\cdots+n_{m}$ ，所以  

$$
\begin{array}{l}{n_{0}=(n_{1}+2n_{2}+3n_{3}+\cdots+m n_{m}+1)-(n_{1}+n_{2}+\cdots+n_{m})}\\ {\quad=n_{2}+2n_{3}+\cdots+(m-1)n_{m}+1=1+\displaystyle\sum_{i=2}^{m}{(i-1)n_{i}}}\end{array}
$$  
# 注意  

综合以上几题，常用于求解树结点与度之间关系的有：  

$\textcircled{\scriptsize{1}}$ 总结点数 $=n_{0}+n_{1}+n_{2}+\ldots+n_{m}.$  

$\textcircled{2}$ 总分支数 $=1n_{1}+2n_{2}+\ldots+m n_{m}$ （度为 $m$ 的结点引出 $m$ 条分支）  

$\textcircled{3}$ 总结点数 $=$ 总分支数 $+1$  

这类题目常在选择题中出现，读者对以上关系应当熟练掌握并灵活应用。  

# 5.2 二叉树的概念  

# 5.2.1二叉树的定义及其主要特性  

# 1.二叉树的定义  

二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。  

与树相似，二叉树也以递归的形式定义。二叉树是 $n$  $n{\geqslant}0$ ）个结点的有限集合：  

$\textcircled{\scriptsize{1}}$ 或者为空二叉树，即 $n=0$  

$\circledcirc$ 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。  

二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图5.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a9c401a0608c49b1b443c3b48c43f6a1ee4376c25cae2385958287b1cf7a89d5.jpg)  
图5.2二叉树的5种基本形态  

二叉树与度为2的有序树的区别：  

$\textcircled{\scriptsize{1}}$ 度为2的树至少有3个结点，而二叉树可以为空。  

$\circledcirc$ 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。  

# 2.儿种特殊的二叉树  

1）满二叉树。一棵高度为 $h$ ，且有 $2^{h}\!-\!1$ 个结点的二叉树称为满二叉树，即二叉树中的每层都含有最多的结点，如图5.3（a）所示。满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2。  

可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为i/2，若有左孩子，则左孩子为2i：若有右孩子，则右孩子为 $2i+1$  
2）完全二叉树。高度为 $h$ 、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为 $1\!\sim\!n$ 的结点一一对应时，称为完全二叉树，如图5.3（b）所示。其特点如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bdec3149d9bd6e25b24dc7017ddcb7cbf0abc9f5ff55b78c04ee30a8463a64aa.jpg)  
图5.3两种特殊形态的二叉树  

$\textcircled{\scriptsize{1}}$ 若 $i{\leqslant}\lfloor n/2\rfloor$ ，则结点 $i$ 为分支结点，否则为叶结点。 $\circledcirc$ 叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排列在该层最左边的位置上。 $\textcircled{3}$ 若有度为1的结点，则最多只可能有一个，且该结点只有左孩子而无右孩子。 $\textcircled{4}$ 按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点。 $\circledast$ 若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子：若 $n$ 为偶数，则编号最大的分支结点（编号为 $n/2$ ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。  

3）二叉排序树。左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。  

4）平衡二叉树。树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。关于二叉排序树和平衡二叉树的详细介绍，见本书中的73节。  

# 命题追踪正则 $\pmb{k}$ 叉树树高和结点数的关系的应用（2016）  

5）正则二叉树。树中每个分支结点都有2个孩子，即树中只有度为0或2的结点。  

# 3.二叉树的性质  

1）非空二叉树上的叶结点数等于度为2的结点数加1，即 $n_{0}\!=\!n_{2}+1$  

证明：设度为0.1和2的结点个数分别为 $n_{0},n_{1}$ 和 $n_{2}$ ，结点总数 $n\!=\!n_{0}+n_{1}+n_{2}.$ 再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n\,{=}\,B+1$ 。由于这些分支是由度为1或2的结点射出的，因此又有 $B\,{=}\,n_{1}+2n_{2}$ 于是得 $n_{0}+n_{1}+n_{2}=n_{1}+2n_{2}+1$ ，则 $n_{0}\!=\!n_{2}+1$ 。  

# 注意  

该性质经常在选择题中涉及，希望读者牢记并灵活应用。  
2）非空二叉树的第  $k$  层最多有  $2^{k-1}$  个结点（  $k\!\geqslant\!1$  

第1层最多有 $2^{1-1}\!=\!1$ 个结点（根），第2层最多有 $2^{2-1}\!=\!2$ 个结点，以此类推，可以证明其为一个公比为2的等比数列 $2^{k-1}$  

3）高度为  $h$  的二叉树至多有  $2^{h}\!-\!1$  个结点（  $h{\geqslant}1$  该性质利用性质2求前 $h$ 项的和，即等比数列求和的结果。  

# 注意  

性质2和性质3还可以拓展到 $m$ 叉树的情况，即 $m$ 叉树的第 $k$ 层最多有 $m^{k-1}$ 个结点，高度为  $h$  的  $m$  叉树至多有  $(2^{h}\!-\!1)/(m\!-\!1)$  个结点。  

4）对完全二叉树按从上到下、从左到右的顺序依次编号 $1,2,\cdots,n$ ，则有以下关系：  

$\textcircled{\scriptsize{1}}$ 若 $i{\leqslant}\lfloor n/2\rfloor$ ，则结点 $i$ 为分支结点，否则为叶结点，即最后一个分支结点的编号为 $\lfloor n/2\rfloor$ 。 $\circledcirc$ 叶结点只可能在层次最大的两层上出现（若删除满二叉树中最底层、最右边的连续2个或以上的叶结点，则倒数第二层将会出现叶结点）。 $\textcircled{3}$ 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（度为1的分支结点只可能是最后一个分支结点，其结点编号为 $\lfloor n/2\rfloor$ )。 $\textcircled{4}$ 按层序编号后，一旦出现某结点（如结点i）为叶结点或只有左孩子的情况，则编号大于 $i$ 的结点均为叶结点（与结论 $\circledcirc$ 和结论 $^{(3)}$ 是相通的）。 $\circledast$ 若 $n$ 为奇数，则每个分支结点都有左、右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $n/2$ ）只有左孩子，没有右孩子，其余分支结点都有左、右孩子。 $\circledcirc$ 当 $i>1$ 时，结点 $i$ 的双亲结点的编号为Li/2]。 $\circleddash$ 若结点 $i$ 有左、右孩子，则左孩子编号为 $2i$ ，右孩子编号为 $2i+1$ 6 $\textcircled{8}$ 结点 $i$ 所在层次（深度）为 $\lfloor\log_{2}i\rfloor+1$  

5）具有 $n$ 个( $n>0$ ）结点的完全二叉树的高度为 $\lceil\log_{2}(n+1)\rceil$ 或 $\lfloor\log_{2}\!n\rfloor+1.$ 设高度为 $h$ ，根据性质3和完全二叉树的定义有  

得 $2^{h-1}<n+1\leqslant2^{h}$ ，即 $h-1<\log_{2}(n+1){\leqslant}h$ ，因为 $h$ 为正整数，所以 $h=\lceil\log_{2}(n+1)\rceil$ ，或者得 $h-1\!\leqslant\!\log_{2}\!n<h$ ，所以 $h\!=\!\!\lfloor\log_{2}\!n\rfloor\!+1$  

# 5.2.2二叉树的存储结构  

# 1.顺序存储结构  

二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为-1的分量中。  

依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。  

# 命题追踪特定条件下二叉树树形及占用存储空间的分析（2020）  

但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 $h$ 且只有 $h$ 个结点的单支树却需要占据近 $2^{h}\!-\!1$ 个存储单元。二叉树的顺序存储结构如图5.4所示，其中0表示并不存在的空结点。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1f9ce9f8887f82c175b169c3e33e125a549ecefdeb97d371167ce7f968695b4a.jpg)  
图5.4二叉树的顺序存储结构  

# 注意  

建议从数组下标1开始存储树中的结点，保证数组下标和结点编号一致。  

# 2.链式存储结构  

由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域data、左指针域1child和右指针域rchild，如图5.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ee0d9ff6fcf5b36a43fcb3916082d9458841fc02d0057838e76bb0fbd67621ad.jpg)  
图5.5二叉树链式存储的结点结构  

图5.6所示为一棵二叉树及其对应的二叉链表。而实际上在不同的应用中，还可以增加某些指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc755ffdb13a30c0f9b94e9364d417701c44e786b9f5aaa944f9db48ce9145e5.jpg)  
图5.6二叉链表的存储结构  

二叉树的链式存储结构描述如下：  

typedef struct BiTNode{ El em Type data;//数据域struct BiTNode\*lchild,\*rchild;川左、右孩子指针)BiTNode,\*BiTree;  

使用不同的存储结构时，实现二叉树操作的算法也会不同，因此要根据实际应用场合（二叉树的形态和需要进行的运算）来选择合适的存储结构。  

容易验证，在含有 $n$ 个结点的二叉链表中，含有 $n+1$ 个空链域（重要结论，经常出现在选择题中）。在下一节中，我们将利用这些空链域来组成另一种链表结构一一线索链表。  

# 5.2.3 本节试题精选  

# 一、单项选择题  

01.下列关于二叉树的说法中，正确的是（）。  
A.度为2的有序树就是二叉树B.含有  $n$  个结点的二叉树的高度为  $\lfloor\log_{2}\!n\rfloor+1$  C.在完全二叉树中，若一个结点没有左孩子，则它必是叶结点D.含有 $n$ 个结点的完全二叉树的高度为log2n  

02.“二叉树为空”意味着二叉树（）。  

A.根结点没有子树B.不存在C.没有结点D.由一些没有赋值的空结点构成  

03.以下说法中，正确的是（）。  

A.在完全二叉树中，叶结点的双亲的左兄弟（若存在）一定不是叶结点B.任何一棵二叉树中，叶结点数为度为2的结点数减1，即 $n_{0}\!=\!n_{2}\!-\!1$ C.完全二叉树不适合顺序存储结构，只有满二叉树适合顺序存储结构D.结点按完全二叉树层序编号的二叉树中，第 $i$ 个结点的左孩子的编号为 $2i$  

04.具有10个叶结点的二叉树中有（）个度为2的结点。A.8 B.9 C.10 D.11  

05.设高度为 $h$ 的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为()。  

A.h B.2h-1 C.2h+1 D.h+1

 06.具有 $n$ 个结点且高度为 $n$ 的二叉树的数目为（）A.logn B.n/2 C.n D.  $2^{n-1}$  07.假设一棵二叉树的结点个数为50，则它的最小高度是（）。A.4 B.5 D.7

 08.设二叉树有 $2n$ 个结点，且 $m\!<\!n$ ，则不可能存在（）的结点。  

A.  $n$  个度为0 B.2m个度为0 C.  $2m$  个度为1 D.  $2m$  个度为2  

09.一个具有1025个结点的二叉树的高 $h$ 为（）A.11 B.10 C.11\~1025 D.10\~1024

 10.设二叉树只有度为0和2的结点，其结点个数为15，则该二叉树的最大深度为（）。A.4 B.5 C.8 D.9

 11.高度为 $h$ 的完全二叉树最少有（）个结点。A.2h B.  $2^{h}+1$  C.  $2^{h-1}$  D.  $2^{h}\!-\!1$  

12.已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则完全二叉树的结点个数最少是（）。  

A.39 B.52 C.111 D.119

 13.若一棵深度为6的完全二叉树的第6层有3个叶结点，则该二叉树共有（）个叶结点。A.17 B.18 C.19 D.20

 14.一棵完全二叉树上有1001个结点，其中叶结点的个数是（）A.250 B.500 C.254 D.501

 15.若一棵二叉树有126个结点，在第7层（根结点在第1层）至多有（）个结点。A.32B.64xc.63D.不存在第7层

16.一棵有124个叶结点的完全二叉树，最多有（）个结点。A.247 B.248 C.249 D.250  
17.一棵有 $n$ 个结点的二叉树采用二叉链存储结点，其中空指针数为（）A.  $n$  B.  $n+1$  C.  $n-1$  D.2n  

18.设有 $n$  $n{\geqslant}1$ ）个结点的二叉树采用三叉链表表示，其中每个结点包含三个指针，分别指向其左孩子、右孩子及双亲（若不存在，则置为空），则下列说法中正确的是（）。  

1.树中空指针的数量为 $n+2$ II.所有度为2的结点均被三个指针指向III.每个叶结点均被一个指针所指向  

A.IB.I、IIC.I、IⅢID.II、III  

19.在一棵完全二叉树中，其根的序号为1，（）可判定序号为 $p$ 和 $q$ 的两个结点是否在同一层。  

A.  $\scriptstyle\lfloor\log_{2}\!p\rfloor=\lfloor\log_{2}\!q\rfloor$  B.  $\log_{2}\!p=\log_{2}\!q$  C.  $\lfloor\log_{2}\!p\rfloor\!+1=\!\lfloor\log_{2}\!q\rfloor$   $\scriptstyle\operatorname{D.}\ \lfloor\log_{2}\!p\rfloor=\lfloor\log_{2}\!q\rfloor+1$  

20.在一个用数组表示的完全二叉树中，根结点的下标为1，那么下标为17和19的结点的最近公共祖先的下标是（）。  

A.1 B.2 C.4 D.8

 21.假定一棵三叉树的结点数为50，则它的最小高度为（）A.3 B.4 C.5 D.6

 22.具有 $n$ 个结点的三叉树用三叉链表表示，则树中空指针域的个数为（）A.  $3n+1$  B.  $2n+1$   $\mathrm{C.}\ \ 3n-1$  D.3n

 23.对于一棵满二叉树，共有 $n$ 个结点和 $m$ 个叶结点，高度为 $h$ ，则（）A.  $n=h+m$  B.  $n+m=2h$  C.  $m=h-1$  D.  $n\,{=}\,2^{h}\!-\!1$  

24.【2009统考真题】已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是（）。  

A.39 B.52 C.111 D.119

 25.【2011统考真题】若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数是（）A.257 B.258 C.384 D.385  

26.【2018统考真题】设一棵非空完全二叉树 $T$ 的所有叶结点均位于同一层，且每个非叶结点都有2个子结点。若T有 $k$ 个叶结点，则 $T$ 的结点总数是（）。  

A.2k-1 B.  $2k$  C.  $k^{2}$  D.  $2^{k}\!-\!1$  

27.【2020统考真题】对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元数量至少是（）。  

A. 31 B.16 C.15 D.10

 28.【2022统考真题】若三叉树 $T$ 中有244个结点（叶结点的高度为1），则 $T$ 的高度至少是（）A.8 B.7 C.6 D.5  

# 二、综合应用题  

01.在一棵完全二叉树中，含有 $n_{0}$ 个叶结点，当度为1的结点数为1时，该树的高度是多少？当度为1的结点数为0时，该树的高度是多少？  

02.一棵有 $n$ 个结点的满二叉树有多少个分支结点和多少个叶结点？该满二叉树的高度是多少？  

03.已知完全二叉树的第9层有240个结点，则整个完全二叉树有多少个结点？有多少个叶结点？  
04.一棵高度为 $h$ 的满 $m$ 叉树有如下性质：根结点所在层次为第1层，第 $h$ 层上的结点都是叶结点，其余各层上每个结点都有 $m$ 棵非空子树，若按层次自顶向下，同一层自左向右，顺序从1开始对全部结点进行编号，试问：  

1）各层的结点个数是多少？  

2）编号为i的结点的双亲结点（若存在）的编号是多少？3）编号为 $i$ 的结点的第 $k$ 个孩子结点（若存在）的编号是多少？4）编号为 $i$ 的结点有右兄弟的条件是什么？其右兄弟结点的编号是多少？  

05.已知一棵二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为 $i$ 和 $j$ 的两个结点的最近的公共祖先结点的值。  

06.【2016统考真题】若一棵非空 $k$  $k\!\geqslant\!2$ ）叉树 $T$ 中的每个非叶结点都有 $k$ 个孩子，则称 $T$ 为正则 $k$ 叉树。请回答下列问题并给出推导过程。  

1）若 $T$ 有 $m$ 个非叶结点，则 $T$ 中的叶结点有多少个？2）若 $T$ 的高度为h（单结点的树 $h=1$ )，则 $T$ 的结点数最多为多少个？最少为多少个？  

# 5.2.4 答案与解析  

# 一、单项选择题  

01.C  

在二叉树中，若某个结点只有一个孩子，则这个孩子的左右次序是确定的；而在度为2的有序树中，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，选项A错误。选项B仅当是完全二叉树时才有意义，对于任意一棵二叉树，高度可能为 $\lfloor\log_{2}\!n\rfloor\!+\!1\!\sim\!n$ 。在完全二叉树中，若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子，选项C正确。完全二叉树的高度为  $\lceil\log_{2}(n+1)\rceil$  或  $\lfloor\log_{2}\!n\rfloor+1$  ，也可以通过举例  $n\,{=}\,4$  来排除，选项D错误。  

02.C  

“二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图（图中不能没有结点）。  

03.A  

在完全二叉树中，叶结点的双亲的左兄弟的孩子一定在其前面（且一定存在），所以双亲的左兄弟（若存在）一定不是叶结点，选项A正确。 $n_{0}$ 应等于 $n_{2}+1$ ，选项B错误。完全二叉树和满二叉树均可以采用顺序存储结构，选项C错误。第 $i$ 个结点的左孩子不一定存在，选项D错误。  

选项B的这种通用公式适用于所有二叉树，我们应能立即联想到采用特殊值代入法验证，如画一个只含3个结点的满二叉树的草图来验证是否满足条件。  

04.B  

由二叉树的性质 $n_{0}\!=\!n_{2}+1$ ，得 $n_{2}\,{=}\,n_{0}\,{-}\,1\,{=}\,10\,{-}\,1\,{=}\,9$  

【另解】画出草图，如下图所示。首先画出10个叶结点，然后每2个结点向上合并，构造一个新的度为2的分支结点，直到构成如下图所示的二叉树，其中度为2的分支结点数为9。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ad1577274eda3fe97eb16978d4605b1c956728b5379cd66531918fc961d2062d.jpg)  
05.B  

结点最少的情况如下图所示。除根结点层只有1个结点外，其他h-1层均有两个结点，结点总数 $=2(h-1)+1=2h-1$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/95a4c13d0ab9c34fb84df72c99b09f011ea9575976fd46e6202394347e746ca6.jpg)  

06.D  

除根结点外，在其余 $n-1$ 个结点中，每个结点要么是其父结点的左孩子，要么是其父结点的右孩子，每个结点都有两种可能， $n-1$ 个结点共有 $2^{n-1}$ 种不同的组合形态。  

07.C  

要求满足条件的树，分析可知当这50个结点构成一棵完全二叉树时高度最小， $h=\lfloor\log_{2}\!n\rfloor+1=$  $\left\lfloor\log_{2}\!50\right\rfloor\!+1\!=\!6\,.$  

【另解】第1层最多有1个结点，第2层最多有 $2^{1}$ 个结点，第3层最多有 $2^{2}$ 个结点，第4层最多有 $2^{3}$ 个结点，以此类推，可以得到 $h$ 最少为6。  

08.C  

由二叉树的性质1可知 $n_{0}\!=\!n_{2}+1$ ，结点总数 $\begin{array}{r}{{\bf\Pi}=2n\!=\!n_{0}\!+\!n_{1}\!+\!n_{2}\!=\!n_{1}\!+2n_{2}\!+1,}\end{array}$ 则 $n_{1}\!=\!2(n\!-\!n_{2})\!-\!1$ 所以 $n_{1}$ 为奇数，说明该二叉树中不可能有 $2m$ 个度为1的结点。  

09.C  

当二叉树为单支树时具有最大高度，即每层上只有一个结点，最大高度为1025。而当树为完全二叉树时，其高度最小，最小高度为 $\left\lfloor\log_{2}\!n\right\rfloor\!+1=11;$  

10.C  

建议画图，第一层有1个结点，其余 $h\!-\!1$ 层各有2个结点，总结点数 $=\!1+2(h-1)=15\,,\ h=8$  

11.C  

高度为 $h$ 的完全二叉树中，第1层～第 $h\!-\!1$ 层构成一个高度为 $h\!-\!1$ 的满二叉树，结点个数为 $2^{h-1}$ -1。第 $h$ 层至少有一个结点，所以最少的结点个数 $=(2^{h-1}-1)+1=2^{h-1}$  

12.A  

第6层有叶结点说明完全二叉树的高度可能为6或7，显然树高为6时结点最少。若第6层上有8个叶结点，则前5层为满二叉树，所以完全二叉树的结点个数最少为 $2^{5}\!-\!1+8=39$ 个结点。  

13.A  

深度为6的完全二叉树，第5层共有 $2^{4}\,=\,16$ 个结点。第6层最左边有3个叶结点，其对应的双亲结点为第5层最左边的两个结点，所以第5层剩余的结点均为叶结点，共有 $16\!-\!2=14$ 个，加上第6层的3个叶结点，共有17个叶结点。  

14.D  

由完全二叉树的性质，最后一个分支结点的序号为 $\lfloor1001/2\rfloor\!=\!500$ ，所以叶结点个数为501。  

【另解】 $n=n_{0}+n_{1}+n_{2}=n_{0}+n_{1}+(n_{0}-1)=2n_{0}+n_{1}-1$ ，因为 $n=1001$ ，而在完全二叉树中， $n_{1}$ 只能取0或1。当 $n_{1}=1$ 时， $n_{0}$ 为小数，不符合题意。所以 $n_{1}\!=\!0$ ，于是有 $n_{0}\!=\!501$ 8  

15.C  

要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有127个结点，126仅比127少1个结点，只能少在第7层，所以第7层最多有 $2^{6}\!-\!1=63$ 个结点。  
16.B  

在非空的二叉树当中，由度为0和2的结点数的关系 $n_{0}\!=\!n_{2}+1$ 可知 $n_{2}=123$ ：总结点数 $n=$  $n_{0}+n_{1}+n_{2}=247+n_{1}$ ，其最大值为248（ $n_{1}$ 的取值为1或 $0$ ，当 $n_{1}=1$ 时结点最多）。注意，由完全二叉树总结点数的奇偶性可以确定 $n_{1}$ 的值，但不能根据 $n_{0}$ 来确定 $n_{1}$ 的值。  

【另解】 $124<2^{7}=128$ ，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1个左孩子（不改变叶结点数），因此结点总数 $=2^{7}-1+120+1=248$  

17.B  

非空指针数 $=$ 总分支数 $=n-1$ ，空指针数 $=2\times$ 结点总数-非空指针数 $=2n\!-\!(n\!-\!1)=n+1$  

【另解】在树中，1个指针对应1个分支， $n$ 个结点的树共有 $n-1$ 个分支，即 $n-1$ 个非空指针，每个结点都有2个指针域，所以空指针数 $=2n\!-\!(n\!-\!1)=n+1$  

18.A  

二叉链表表示的二叉树中空指针的数量为 $n+1$ ，三叉链表表示的二叉树多了一个根结点指向双亲的空指针，所以树中空指针的数量为 $n+2$ ，1正确。若根结点的度为2，则只有左、右两个孩子指向它，ⅡI错误。若整棵树只有一个根结点，则没有指针指向它，Ⅲ错误。  

19.A  

由完全二叉树的性质，编号为 $i$  $,i\!\geqslant\!1$ ）的结点所在的层次为 $\log_{2}\!i\!\left\lfloor+1\right\rfloor$ ，若两个结点位于同一层，则一定有 $\scriptstyle\lfloor\log_{2}\!p\rfloor+1\;=\;\lfloor\log_{2}\!q\rfloor+1$ ，因此有 $\scriptstyle\lfloor\log_{2}\!p\rfloor=\lfloor\log_{2}\!q\rfloor$ 成立。  

20.C  

当根结点下标为1时，下标为 $i$ 的结点的父结点下标为 $i/2J$ ，那么下标为17的祖先的下标有8,4,2，1，下标为19的祖先的下标有9,4,2，1，因此两者最近的公共祖先的下标是4。  

21.C  

分析可知，满足条件的三叉树可以是完全三叉树，这棵树的第 $i\;\;(i\geqslant1$ ）层最多有 $3^{i-1}$ 个结点。设高度为  $h$  ，则  $3^{0}+3^{1}\!+\!\dots+3^{h-1}\!=\!(3^{h}\!-1)/2$  是结点数的上限，问题是求解  $50{\leqslant}(3^{h}-1)/2$  的最小  $h$  值 即 $h{\geq}\log_{3}\!101$ ，有 $h=\lceil\log_{3}\!101\rceil\!=\!5$  

22.B  

三叉树采用三叉链表表示，每个结点均有3个指针域指向3个孩子，共有 $3n$ 个指针域，但 $n$ 个结点构成的一棵树中只需要 $n-1$ 个指针（对于 $n-1$ 条边），因此空指针域有 $2n+1$ 个。  

23.D 对于高度为 $h$ 的满二叉树， $n=2^{0}+2^{1}+\cdots+2^{h-1}=2^{h}-1,\,m=2^{h-1}.$  

24. C  

第6层有叶结点，完全二叉树的高度可能为6或7，显然树高为7时结点最多。完全二叉树与满二叉树相比，只是在最下一层的右边缺少部分叶结点，而最后一层之上是个满二叉树，且只有最后两层上有叶结点。若第6层上有8个叶结点，则前6层为满二叉树，而第7层缺失 $8{\times}2=16$ 个叶结点，所以完全二叉树的结点个数最多为 $2^{7}\!-\!1-\!16=111$  

25.C 最后一个分支结点的编号为 $\lfloor768/2\rfloor\!=\!384$ ，所以叶结点的个数为 $768-384=384$ 。  

【另解】 $n=n_{0}+n_{1}+n_{2}=n_{0}+n_{1}+(n_{0}-1)=2n_{0}+n_{1}-1$ ，其中 $n=768$ ，而在完全二叉树中， $n_{1}$ 只能取0或1，当 $n_{1}\!=\!0$ 时， $n_{0}$ 为小数，不符合题意。因此 $n_{1}=1$ ，所以 $n_{0}=384$ 。  

26.A  
非叶结点的度均为2，且所有叶结点都位于同一层的完全二叉树就是满二叉树。对于一棵高度为 $h$ 的满二叉树（空树 $h=0$ )，其最后一层全部是叶结点，数目为 $2^{h-1}$ ；总结点数为 $2^{h}$ -1。因此当 $2^{h-1}=k$ 时，可以得到 $2^{h}\!-1=2k-1$ 8  

27. A  

二叉树采用顺序存储时，用数组下标来表示结点之间的父子关系。对于一棵高度为5的二叉树，为了满足任意性，其  $1\!\sim\!5$  层的所有结点都要被存储起来，即考虑为一棵高度为5的满二叉 树，共需要存储单元的数量为 $1+2+4+8+16=31$  

28.C  

高度一定的三叉树中结点数最多的情况是满三叉树。高度为5的满三叉树的结点数 $=3^{0}+3^{1}+$  $3^{2}+3^{3}+3^{4}=121,$ ，高度为6的满三叉树的结点数 $=3^{0}+3^{1}+3^{2}+3^{3}+3^{4}+3^{5}\!=\!364.$ 。由于三叉树 $T$ 的结点数为244， $121<244<364$ ，因此 $T$ 的高度至少为6。  

# 二、综合应用题  

01.【解答】  

在非空的二叉树中，由度为0和度为2的结点之间的关系 $n_{0}\!=\!n_{2}+1$ ，可知 $n_{2}\!=\!n_{0}\!-\!1$ 。因此总结点数 $n=n_{0}+n_{1}+n_{2}=2n_{0}+n_{1}-1$  

$\textcircled{\scriptsize{1}}$ 当 $n_{1}=1$ 时， $n\!=\!2n_{0},\,\,\,h\!=\!\!\lceil\log_{2}(n+1)\rceil\!=\!\!\lceil\log_{2}(2n_{0}+1)\rceil.$  $\circledcirc$ 当 $n_{1}=0$ 时， $n=2n_{0}-1$ ， $h=\lceil\log_{2}(n+1)\rceil=\lceil\log_{2}(2n_{0})\rceil=\lceil\log_{2}(n_{0})\rceil+1\,\circ$  

02.【解答】  

满二叉树中 $n_{1}=0$ ，由二叉树的性质1可知 $n_{0}\!=\!n_{2}+1$ ，即 $n_{2}\!=\!n_{0}\!-\!1$ ， $n=n_{0}+n_{1}+n_{2}=2n_{0}-1$ 则 $n_{0}\,{=}\,(n+1)/2$ 。分支结点个数 $n_{2}\,{=}\,n\,{-}\,(n+1)/2=(n-1)/2$ 。高度为 $h$ 的满二叉树的结点数 $n=1+$  $2^{1}+2^{2}+\dots+2^{h-1}=2^{h}-1$ ，即高度 $h=\log_{2}(n+1)$  

# 03.【解答】  

在完全二叉树中，若第9层是满的，则结点数 $=2^{9-1}=256$ ，而现在第9层只有240个结点，说明第9层未满，是最后一层。 $1\!\sim\!8$ 层是满的，所以总结点数 $=2^{8}-1+240=495$ 因为第9层是最后一层，所以第9层的结点都是叶结点。且第9层的240个结点的双亲在第8层中，其双亲个数为120，即第8层有120个分支结点，其余为叶结点，所以第8层的叶结点个数为 $2^{8-1}-120=8$ 。因此，总的叶结点个数 $=8+240=248$  

【另解】总结点数  $n=n_{0}+n_{1}+n_{2}$  ，  $=n_{0}-1\,,\,\,\,n=n_{0}+n_{1}+n_{2}=2n_{0}+n_{1}-1\,.$  。若  $n_{1}=1$  ，则  $2n_{0}+n_{1}-1=2n_{0}=495$ ，不符合；若 $n_{1}=0$ ，则 $2n_{0}+n_{1}-1=2n_{0}-1=495$ ，则 $n_{0}=248$ 。  

# 注意  

对于本题，应理解完全二叉树中只有最底层的结点是不满的，其他各层的结点是满的（即第 $i$ 层有 $2^{i-1}$ 个结点）。  

04.【解答】  

1）第1层有 $m^{0}=1$ 个结点，第2层有 $m^{1}$ 个结点，第3层有 $m^{2}$ 个结点····一般地，第 $i$ 层有 $m^{i-1}$ 个结点 $(1\!\leqslant\!i\!\leqslant\!h)$ 。2）在 $m$ 叉树的情形下，结点 $i$ 的第1个子女编号为 $j=(i-1)m+2$ ，反过来，结点 $i$ 的双亲的编号是 $(i\!-\!2)/m\!\perp\!+1$ ，根结点没有双亲，所以要求 $i>1$ 。3）因为结点 $i$ 的第1个子女编号为 $(i-1)m+2$ ，若设该结点子女的序号为 $k\,{=}\,1,2,\cdots,m$ ，则第 $k$ 个子女结点的编号为 $(i-1)m+k+1$ ( $1\!\leqslant\!k\!\leqslant\!m)$  
4）结点 $i$ 不是其双亲的第 $m$ 个子女时才有右兄弟。设其双亲编号为 $j$ ，可得 $j\!=\!\lfloor(i+m\!-\!2)/m\rfloor,$ 结点 $j$ 的第 $m$ 个子女的编号为 $(j-1)m+m+1=j m+1=\lfloor(i+m-2)/m\rfloor m+1$ ，所以当结点的编号 $i{\leqslant}\lfloor(i+m-2)/m\rfloor m$ 时才有右兄弟，右兄弟的编号为 $i+1$ 。或者，对于任意一个双亲结点i，其第  $m$  个子女结点的编号是  $j m+1$  ，所以若不为第  $m$  的子女结点，则  $(i-1)\%m!=0$  

05.【解答】  

首先，必须明确二叉树中任意两个结点必然存在最近的公共祖先结点，最坏的情况下是根结点（两个结点分别在根结点的左石分支中），而且从最近的公共祖先结点到根结点的全部祖先结点都是公共的。由二叉树顺序存储的性质可知，任意一个结点 $i$ 的双亲结点的编号为 $i/2$ 。求解 $i$ 和 $j$ 最近公共祖先结点的算法步骤如下（设从数组下标1开始存储）：  

1）若 $i>j$ ，则结点 $i$ 所在层次大于或等于结点 $j$ 所在层次。结点 $i$ 的双亲结点为结点 $i/2$ 若  $i/2=j$  ，则结点  $i/2$  是原结点  $i$  和结点  $j$  的最近公共祖先结点，若  $i/2\!\neq\!j$  ，则令  $i=i/2$  即以该结点 $i$ 的双亲结点为起点，采用递归的方法继续查找。2）若 $j>i$ ，则结点 $j$ 所在层次大于或等于结点 $i$ 所在层次。结点 $j$ 的双亲结点为结点 $j/2$ 若  $j/2=i$  ，则结点  $j/2$  是原结点  $i$  和结点  $j$  的最近公共祖先结点，若  $j/2\!\neq\!i$  ，则令  $j\!=\!j/2$  。 重复上述过程，直到找到它们最近的公共祖先结点为止。  

本题代码如下：  

ElemType Comm Ancestor（SqTree T,int i,int j){ //本算法在二叉树中查找结点i和结点j的最近公共祖先结点if(T[i] $!=$ #'&&T[j]!='#'){//结点存在while $(\dot{\bot}:=\dot{\bar{\jmath}}$ ){/两个编号不同时循环if(  $\scriptstyle{\dot{\mathrm{~i}}}>{\dot{\mathrm{~j~}}}$   $\scriptstyle{\dot{\boldsymbol{\mathtt{1}}}}={\dot{\boldsymbol{\mathtt{1}}}}/2$  //向上找i的祖先 else j=j/2; /向上找的祖先 return T[i];  

由解题中算法的步骤描述可知，本题也很容易地联想到采用递归的方法求解。  

06.【解答】  

1）正则 $k$ 叉树中仅含有两类结点；叶结点（个数记为 $n_{0}$ ）和度为 $k$ 的分支结点（个数记为 $n_{k}$ )。树 $T$ 中的结点总数 $n=n_{0}+n_{k}=n_{0}+m$ 。树中所含的边数 $e=n-1$ ，这些边均是从 $m$ 个度为 $k$ 的结点发出的，即 $e\,{=}\,m k$ 。整理得 $n_{0}+m\!=\!m k+1$ ，所以 $n_{0}\!=\!(k\!-\!1)m+1$ 。  

2）高度为 $h$ 的正则 $k$ 叉树 $T$ 中，含最多结点的树形为：除第 $h$ 层外，第1到第 $h-1$ 层的结点都是度为 $k$ 的分支结点；而第 $h$ 层均为叶结点，即树是“满”树。此时第 $j$  $\scriptstyle\cdot1\leqslant j\leqslant h\rangle$ 层的结点数为 $k^{j-1}$ ，结点总数 $M_{1}$ 为  

$$
M_{1}=\sum_{j=1}^{h}k^{j-1}=\frac{k^{h}-1}{k-1}
$$  

含最少结点的正则 $k$ 叉树的树形为：第1层只有根结点，第2到第h-1层仅含1个分支结点和 $k\!-\!1$ 个叶结点，第 $h$ 层有 $k$ 个叶结点。也就是说，除根外，第2到第 $h$ 层中每层的结点数均为 $k$ ，所以 $T$ 中所含结点总数 $M_{2}$ 为  

$$
M_{2}=1+(h-1)k
$$  
# 5.3 二叉树的遍历和线索二叉树  

# 5.3.1二叉树的遍历  

三义树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因此需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。  

命题追踪二叉树遍历方式的分析（2009、2011、2012）命题追踪（算法题）二叉树遍历的相关应用（2014、2017、2022）  

由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点在何时被访问。  

# 1.先序遍历（PreOrder）  

若二叉树为空，则什么也不做：否则  

1）访问根结点；2）先序遍历左子树：3）先序遍历右子树。  

图5.7中的虚线表示对该二叉树进行先序遍历的路径，得到先序遍历序列为124635。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb476333d53f3ddbbf63ed5dee671597c8d51d49b039178da94fd12e16d3cb6c.jpg)  
图5.7二叉树的先序遍历  

对应的递归算法如下：  

void PreOrder（BiTree T){ if（T!=NULL){ visit(T);//访问根结点PreOrder(T->lchild); /递归遍历左子树 PreOrder（T->rchild); //递归遍历右子树  

# 2.中序遍历（InOrder）  

若二叉树为空，则什么也不做；否则，  

1）中序遍历左子树：  
2）访问根结点：3）中序遍历右子树。  

命题追踪中序序列中结点关系的分析（2017）图5.8中的虚线表示对该二叉树进行中序遍历的路径，得到中序遍历序列为264135。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5a7a1e8979699afa63f476d125c173136bfd388f5b6d78a36bb8bedfd9462925.jpg)  
图5.8二叉树的中序遍历  

对应的递归算法如下：  

void InOrder（BiTree T）{ if（T!=NULL){ InOrder（T->lchild); //递归遍历左子树 visit(T);/访问根结点InOrder(T->rchild); //递归遍历右子树  

3.后序遍历（PostOrder）  

若二叉树为空，则什么也不做；否则  

1）后序遍历左子树：2）后序遍历右子树：3）访问根结点。  

图5.9中的虚线表示对该二叉树进行后序遍历的路径，得到后序遍历序列为642531。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83d65a43ce1d35fa50d330ff9b10a6426b21fdcc73aff5dc92b3166bd085a05b.jpg)  
图5.9二叉树的后序遍历  

对应的递归算法如下：  

void PostOrder（BiTree T) if（T!=NULL){  
PostOrder(T->lchild); /递归遍历左子树 PostOrder(T->rchild); /递归遍历右子树 visit(T);//访问根结点  

上述三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度都是 $O(n)$ 。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$  

# 4.递归算法和非递归算法的转换  

在上节介绍的三种遍历算法中，暂时抹去和递归无关的visitO语句，则3个遍历算法完全相同，因此，从递归执行过程的角度看先序、中序和后序遍历也是完全相同的。  

# 注意  

非递归遍历算法的难度较大，统考对非递归遍历算法的要求通常不高。  

图5.10用带箭头的虚线表示了这三种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历的过程中访问根结点时输出的信息。例如，由于中序遍历中访问结点是在遍历左子树之后、遍历右子树之前进行的，则带圆形的字符标在向左递归返回和向右递归调用之间。由此，只要沿虚线从1出发到2结束，将沿途所见的三角形（或圆形或方形）内的字符记下，便得到遍历二叉树的先序（或中序或后序）序列。例如，在图5.10中，沿虚线游走可以分别得到先序序列为ABDEC、中序序列为DBEAC、后序序列为DEBCA。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7a51d5bf37d72f50eb146aea747131d612db4759b8ba5278104c5bcb2f119547.jpg)  

借助栈的思路，我们来分析中序遍历的访问过程：  

$\textcircled{\scriptsize{1}}$ 沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点，此时栈内元素依次为 $A B D$ 。 $\textcircled{2}$ 栈顶元素出栈并访问：若其右孩子为空，继续执行 $\circledcirc$ ；若其右孩子不空，将右子树转执行 $^{\astrosun}$ 。栈顶 $D$ 出栈并访问，它是中序序列的第一个结点： $D$ 右孩子为空，栈顶 $B$ 出栈并访问； $B$ 右孩子不空，将其右孩子 $E$ 入栈， $E$ 左孩子为空，栈顶 $E$ 出栈并访问； $E$ 右孩子为空，栈顶 $A$ 出栈并访问； $A$ 右孩子不空，将其右孩子 $C$ 入栈， $C$ 左孩子为空，栈顶 $C$ 出栈并访问。由此得到中序序列DBEAC。读者可根据上述分析画出遍历过程的出入栈示意图。  
根据分析可以写出中序遍历的非递归算法如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bea97dfd359f4fa23e37774cbc37c392186c7ec83025a3781c4431d1c371b0ee.jpg)  

先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面，读者可以参考中序遍历的过程说明自行模拟出入栈示意图。先序遍历的非递归算法如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/551c0911a426ccd11fb7cd94140b7a15d86c77102cd7c3edad266c7d8f1fd06c.jpg)  

后序遍历的非递归实现是三种遍历方法中最难的。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。  

后序非递归遍历算法的思路分析：从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为若其有右子树，则还需按相同的规则对其右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈被访问，要么右子树 为空，要么右子树刚被访问完（此时左子树早已访问完），这样就保证了正确的访问顺序。  

后序遍历的非递归算法见本节综合应用题03的解析部分（不重要）。  

按后序非递归算法遍历图5.10(a)中的二叉树，当访问到 $E$ 时，A, $B,\,D$ 都已入过栈，对于后序非递归遍历，当一个结点的左右子树都被访问后才会出栈，图中 $D$ 已出栈，此时栈内还有 $A$ 和 $B$ 这是 $E$ 的全部祖先。实际上，访问一个结点 $p$ 时，栈中结点恰好是结点 $p$ 的所有祖先，从栈底到栈顶结点再加上结点 $p$ ，刚好构成从根结点到结点 $p$ 的一条路径。在很多算法设计中都可以利用这一思路来求解，如求根到某结点的路径、求两个结点的最近公共祖先等。  

# 5.层次遍历  

图5.11所示为二叉树的层次遍历，即按照箭头所指方向，按照 $1,2,3,4$ 的层次顺序，自上而下，从左至右，对二叉树中的各个结点进行逐层访问。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fcc01cff756f99920e69dd2b2480873979105c906664f3b0bf11376b861896dd.jpg)  
图5.11二叉树的层次遍历  

进行层次遍历，需要借助一个队列。层次遍历的思想如下： $\textcircled{\scriptsize{1}}$ 首先将二义树的根结点入队。 $\circledcirc$ 若队列非空，则队头结点出队，访问该结点，若它有左孩子，则将其左孩子入队：若它有右孩子，则将其右孩子入队。 $\textcircled{3}$ 重复 $\circledcirc$ 步，直至队列为空。  

二叉树的层次遍历算法如下：  

void LevelOrder（BiTree T) InitQueue（Q);//初始化辅助队列BiTree p; EnQueue（Q,T）;//将根结点入队while(!IsEmpty(Q)){ /队列不空则循环 DeQueue（Q,p）;/队头结点出队visit(p);/访问出队结点if(p->lchild！  $=$  NULL) EnQueue(Q,p->lchild);/若左孩子不空，则左孩子入队if(p->rchild!  $=$  NULL) EnQueue(Q,p->rchild);川若右孩子不空，则右孩子入队  

上述二叉树层次遍历的算法，读者在复习过程中应将其作为一个模板，在熟练掌握其执行过程的基础上来记忆，并达到熟练手写的程度。这样才能将该模板应用于各种题目之中。  

# 注意  

遍历是二叉树各种操作的基础，例如对于一棵给定二叉树求结点的双亲、求结点的孩子、求二叉树的深度、求叶结点个数、判断两棵二叉树是否相同等。所有这些操作都是在遍历的过程中进行的，因此必须掌握二叉树的各种遍历过程，并能灵活运用以解决各种问题。  

# 6.由遍历序列构造二叉树  

# 命题追踪先序序列对应的不同二叉树的分析（2015）  

对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是确定的。然而，只给出四种遍历序列中的任意一种，却无法唯一地确定一棵二叉树。若已知中序序列，再给出其他三种遍历序列中的任意一种，就可以唯一地确定一棵二叉树。  

（1）由先序序列和中序序列构造二叉树  

命题追踪先序序列和中序序列相同时确定的二叉树（2017）  

命题追踪由先序序列和中序序列构造一棵二叉树（2020、2021）  

在先序序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根的左子树的中序序列，后一个子序列是根的右子树的中序序列。左子树的中序序列和先序序列的长度是相等的，右子树的中序序列和先序序列的长度是相等的。根据这两个子序列，可以在先序序列中找到左子树的先序序列和右子树的先序序列，如图5.12所示。如此递归地分解下去，便能唯一地确定这棵二叉树。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f95f56d393b614bbe625168363fd791b2fa3b99d431538422cdb0c9dfce8aee8.jpg)  
图5.12由先序序列和中序序列构造二叉树  

例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。首先，由先序序列可知  $A$  为二叉树的根结点。中序序列中  $A$  之前的  $B C$  为左子树的中序序列，EDGHFI为 右子树的中序序列。然后，由先序序列可知 $B$ 是左子树的根结点， $D$ 是右子树的根结点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如图5.13(c)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bdfc32800eb0bdcdf69f66b04372af5f987fca29874a7edb3170bdcc7281785.jpg)  
图5.13一棵二叉树的构造过程  

（2）由后序序列和中序序列构造二叉树  

命题追踪由后序序列和树形构造一棵二叉树（2017、2023）  

同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，如图5.14所示，然后采用类似的方法递归地进行分解，进而唯一地确定这棵二叉树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7ff525d65d5eecf2e799de58498c82c5cc855212f4dedd5b861b42917822ce2.jpg)  
图5.14由后序序列和中序序列构造二叉树  

请读者分析后序序列（CBEHGIFDA）和中序序列（BCAEDGHFI）所确定的二叉树。  

（3）由层序序列和中序序列构造二叉树  

在层序遍历中，第一个结点一定是二叉树的根结点，这样就将中序序列分割成了左子树的中序序列和石子树的中序序列。若存在左子树，则层序序列的第二个结点一定是左子树的根，可进一步划分左子树；若存在右子树，则中序序列中紧接着的下一个结点一定是右子树的根，可进一步划分右子树，如图5.15所示。采用这种方法继续分解，就能唯一确定这棵二叉树。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfeb791360f3d1b1e847316927966170a32c8f5faecc10370d6de9816a2ae6c1.jpg)  
图5.15由层序序列和中序序列构造二叉树  

请读者分析后序序列（ABDCEFGIH）和中序序列（BCAEDGHFI）所确定的二叉树。  

需要注意的是，先序序列、后序序列和层序序列的两两组合，无法唯一确定一棵二叉树。例如，图5.16所示的两棵二义树的先序序列都为 $A B$ ，后序序列都为BA，层序序列都为 $A B_{c}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a85e2de2af6b7d96b93dbde3997116acee9adafbb64aa34b17139eaf5456102.jpg)  
图5.16两棵不同的二叉树  

# 5.3.2 线索二叉树  

# 1.线索二叉树的基本概念  

遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。  

# 命题追踪后序线索二叉树的定义（2010）  

传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针。这是因为每个叶结点都有2个空指针，每个度为1的结点都有1个空指针，空指针总数为 $2n_{0}+n_{1}$ ，又 $n_{0}\!=\!n_{2}\!+1$ ，所以空指针总数为 $n_{0}+n_{1}+n_{2}+1=n+1.$ 由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。  

规定：若无左子树，令lchild指向其前驱结点：若无右子树，令rchild指向其后继结点。 如图5.17所示，还需增加两个标志域，以标识指针域指向左（右）孩子或前驱（后继）。）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a9348224b92a82715ff985f8c31844579514448dbf87208d26fb3b1653501d4d.jpg)  

其中，标志域的含义如下：  

线索二叉树的存储结构描述如下：  

typedef struct ThreadNode{ El em Type data;struct Thread Node \*lchild,\*rchild; intltag,rtag;  

//数据元素

//左、右孩子指针I/左、右线索标志)ThreadNode,\*ThreadTree;  
以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱和后继的指针称为线索。加上线索的二叉树称为线索二叉树。  

# 2.中序线索二叉树的构造  

二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。  

# 命题追踪中序线索二叉树中线索的指向（2014）  

以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针P指向正在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，如图5.18所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76585adca20c3587f88d89587e71edca8e1fc50e3353660a5d0938cbebc7c9fa.jpg)  
图5.18中序线索二叉树及其二叉链表示  

通过中序遍历对二叉树线索化的递归算法如下：  

void InThread(ThreadTree &p,ThreadTree&pre){ if（p!=NULL）{ InThread(p->lchild,pre); //递归，线索化左子树 if(p->lchild $==$ NULL){/当前结点的左子树为空p->lchild=pre;I/建立当前结点的前驱线索p->ltag  $^{=1}$  if(pre! $=$ NULL&&pre->rchild= $:=$ NULL）（/前驱结点非空且其右子树为空pre->rchild=p;/建立前驱结点的后继线索pre->rtag  $\scriptstyle{\varphi=1}$  pre=p; /标记当前结点成为刚刚访问过的结点 InThread(p->rchild,pre); /递归，线索化右子树  

通过中序遍历建立中序线索二叉树的主过程算法如下：  

void Create In Thread(ThreadTree T){ ThreadTree pre  $=$  NULL; //非空二叉树，线索化if（T!=NULL){ InThread（T,pre); 线索化二叉树 pre->rchild $\scriptstyle=$ NULL;//处理遍历的最后一个结点pre->rtag  $^{=1}$  

为了方便，可以在二叉树的线索链表上也添加一个头结点，令其1chi1a域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点：令二叉树中序序列中的第一个结点的1child域指针和最后一个结点的rchild域指针均指向头结点。这好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如图5.19所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b88560b15260cda3cfd0b4e2229bfad1694c1d19f2b50c0d4c2b47f5c35b88e.jpg)  
图5.19带头结点的中序线索二叉树  

# 3.中序线索二叉树的遍历  

中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下。  

1）求中序线索二叉树的中序序列下的第一个结点：  

ThreadNode \*Firstnode(ThreadNode  $\star_{\mathbb{P}}$  while(p->ltag $==0$ ）p=p->lchild；/最左下结点（不一定是叶结点）returnp;  

2）求中序线索二叉树中结点p在中序序列下的后继：  

ThreadNode \*Nextnode(ThreadNode  ${}^{\star}\mathtt{p}.$  if(p->rtag $==0$ ）return First node（p->rchild）；l/右子树中最左下结点else return p->rchild;l/若rtag $==1$ 则直接返回后继线索  

请读者自行分析并完成求中序线索二叉树的最后一个结点和结点p前驱的运算?。3）利用上面两个算法，可写出不含头结点的中序线索二叉树的中序遍历的算法  

void Inorder(ThreadNode  $\star_{\mathrm{T}}$  for(ThreadNode ${}^{\star}\!\mathtt{p}^{=}$ Firstnode（T);p！ $=$ NULL; ${\tt p}{=}$ Nextnode(p))visit(p);  

# 4.先序线索二叉树和后序线索二叉树  

上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和建立后序线索二叉树的代码类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。  

以图5.20（a）的二叉树为例给出手动求先序线索二叉树的过程：先序序列为ABCDF，然后依次判断每个结点的左右链域，若为空，则将其改造为线索。结点 $A,B$ 均有左右孩子：结点 $C$ 无左孩子，将左链域指向前驱 $B$ ，无右孩子，将右链域指向后继 $D$ ：结点 $D$ 无左孩子，将左链域指尚前驱 $C$ ，无右孩子，将右链域指向后继 $F$ ：结点 $F$ 无左孩子，将左链域指向前驱 $D$ ，无右孩子，也无后继，所以置空，得到的先序线索二叉树如图5.20(b)所示。求后序线索二叉树的过程：后序序列为CDBFA，结点 $C$ 无左孩子，也无前驱，所以置空，无右孩子，将右链域指向后继 $D$ ：结点 $D$ 无左孩子，将左链域指向前驱 $C$ ，无右孩子，将右链域指向后继 $B$ ：结点 $F$ 无左孩子，将左链域指向前驱 $B$ ，无右孩子，将右链域指向后继 $A$ ，得到的后序线索二叉树如图5.20（c）所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fd60e6474663a6b6e5925b13b2ab71bcb51d855371fd982a306b9a0b94e3169.jpg)  
图5.20先序线索二叉树和后序线索二叉树  

如何在先序线索二叉树中找结点的后继？若有左孩子，则左孩子就是其后继；若无左孩子但有右孩子，则右孩子就是其后继；若为叶结点，则右链域直接指示了结点的后继。  

# 命题追踪后序线索二叉树中线索的指向（2013）  

在后序线索二叉树中找结点的后继较为复杂，可分三种情况： $\textcircled{\scriptsize{1}}$ 若结点 $x$ 是二叉树的根，则其后继为空： $\circledcirc$ 若结点 $x$ 是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲： $\textcircled{3}$ 若结点 $x$ 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。图5.20（c）中找结点 $B$ 的后继无法通过链域找到，可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。  

# 5.3.3 本节试题精选  

# 一、单项选择题  

01.在下列关于二叉树遍历的说法中，正确的是（）  

A.若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点B.若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点C.若有一个叶结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点D.若有一个叶结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点  

02.在任何一棵二叉树中，若结点a有左孩子 $^b$ 、右孩子 $c$ ，则在结点的先序序列、中序序列、后序序列中，（）。  

A.结点 $b$ 一定在结点 $a$ 的前面B.结点 $a$ 一定在结点 $c$ 的前面C.结点 $^b$ 一定在结点 $c$ 的前面D.结点 $a$ 一定在结点 $^b$ 的前面  

03.设 $n,m$ 为一棵二叉树上的两个结点，在中序遍历时， $n$ 在 $m$ 前的条件是（）A.  $n$  在  $m$  右方 B.n是  $m$  祖先 C.  $n$  在  $m$  左方 D.  $n$  是  $m$  子孙 04.设 $n,m$ 为一棵二叉树上的两个结点，在后序遍历时， $n$ 在 $m$ 前的充分条件是（）A.  $n$  在  $m$  右方 B.  $n$  是  $m$  祖先 C.  $n$  在  $m$  左方 D.  $n$  是  $m$  子孙  
05.在二叉树中有两个结点 $m$ 和 $n$ ，若 $m$ 是 $n$ 的祖先，则使用（）可以找到从 $m$ 到 $n$ 的路径。A.先序遍历B.中序遍历C.后序遍历D.层次遍历  

06.某非空二叉树采用顺序存储结构，树中的结点信息按完全二叉树的层次序列依次存放在如下所示的一维数组中，则该二叉树的后序遍历序列为（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/136fba974fb2bb808324a2bad69624da517f6f246dc80280816b49400eda802a.jpg)  

A. ghbefhca B. g, bdehcfa C. gdbhefca D. bgdehcfa  

07.在二叉树的前序序列、中序序列和后序序列中，所有叶结点的先后顺序（）。  

A.都不相同B.完全相同C.前序和中序相同，而与后序不同D.中序和后序相同，而与前序不同  

08.对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用（）次序的遍历实现编号。  

A.先序遍历B.中序遍历C.后序遍历D.层次遍历  

09.按某种顺序对二叉树的结点进行编号，编号为  $1,2,\cdots,n$  ，规定：树中任一结点V，其编 号等于 $v$ 的左子树上的最小编号减1，而 $\nu$ 的右子树中的最小编号等于 $v$ 的左子树上的最大编号加1，则说明该二叉树是按（）次序编号的。  

A.中序遍历B.先序遍历C.后序遍历D.层次遍历

10.前序序列为 $A,B,C$ ，后序序列为 $C,B,A$ 的二叉树共有（）A.1棵 B.2棵 C.3棵 D.4棵

 11.一棵完全二叉树的后序遍历序列为CDBFGEA，则其先序遍历序列是（）。A.CBDAFEG B.ABECDFG C. ABCDEFG D.无法确定  

12.设结点 $X$ 和 $Y$ 是二叉树中任意的两个结点。在该二叉树的先序遍历序列中 $X$ 在 $Y$ 之前，而在其后序遍历序列中 $X$ 在 $Y$ 之后，则 $X$ 和Y的关系是（）。  

A. $X$ 是Y的左兄弟B. $X$ 是Y的右兄弟C.  $X$  是  $Y$  的祖先 D.  $X$  是  $Y$  的后裔  

13.若二叉树中结点的先序序列是.… $a\cdots b\cdots$ ，中序序列是 $\cdots b\!\cdots a\!\cdots$ ，则（）。  

A.结点a和结点 $^b$ 分别在某结点的左子树和右子树中B.结点 $^b$ 在结点 $a$ 的右子树中C.结点 $^b$ 在结点 $a$ 的左子树中D.结点 $a$ 和结点 $^b$ 分别在某结点的两棵非空子树中  

14.一棵二叉树的先序遍历序列为1234567，它的中序遍历序列可能是（）A.3124567 B.1234567 C.4135627 D.1463572

 15.下列序列中，不能唯一地确定一棵二叉树的是（）。  

A.层次序列和中序序列 B.先序序列和中序序列 C.后序序列和中序序列D.先序序列和后序序列  

16.若一棵二叉树的中序序列和后序序列相同，则（）  

A.二叉树为空树或二叉树任一结点没有左子树B.二叉树为空树或二叉树任一结点没有右子树C.二叉树为空树或二叉树中每个结点的度为1 D.二叉树为空树或二叉树为满二叉树  
17.已知一棵二叉树的后序序列为DABEC，中序序列为DEBAC，则先序序列为（）。A.ACBED B.DECAB C.DEABC D. CEDBA  

18.已知一棵二叉树的先序遍历结果为 $A B C D E F$ ，中序遍历结果为CBAEDF，则后序遍历的结果为（）。  

A.CBEFDAB. FEDCBAC.CBEDFAD.不确定

19.已知一棵二叉树的层次序列为ABCDEF，中序序列为BADCFE，则先序序列为（）A.ACBEDF B.ABCDEF C.BDFECA D.FCEDBA  

20.某二叉树中的结点x，它在先序、中序、后序遍历序列中的编号分别为pre（x)、in（x）、post（x）（假设都是从1开始依次编号），a和b是树中任意两个结点，下列选项中错误的是（)。  

A.a是b的后代且pre（a)<pre(b）B.a b post（a)>post(b）C.a是b的后代且  $\mathtt{i n}\left(\mathtt{a}\right)\mathtt{<i n}\left(\mathtt{b}\right.$  D.a在b的左边且in(a)<in(b)  

21.某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用（）遍历方法最合适。  

A.中序 B.层次 C.后序 D.先序  

22.引入线索二叉树的目的是（）  

A.加快查找结点的前驱或后继的速度B.为了能在二叉树中方便插入和删除C.为了能方便找到双亲D.使二叉树的遍历结果唯一  

23.线索二叉树是一种（）结构。  

A.逻辑B.逻辑和存储C.物理D.线性  

24. $n$ 个结点的线索二叉树上含有的线索数为（）。  

A.  $2n$  B.n-1 C.  $n+1$  D.n  

25.判断线索二叉树中 ${}^{\star}\mathtt{p}$ 结点有右孩子结点的条件是（）  

A.P!  $=$  NULL B.p->rchild！  $=$  NULL C.p->rtag  $==0$  D.p->rtag  $==1$  

26.一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是（）A.不确定 B.0个 C.1个 D.2个

 27.在线索二叉树中，下列说法不正确的是（）  

A.在中序线索树中，若某结点有右孩子，则其后继结点是它的右子树的最左下结点B.在中序线索树中，若某结点有左孩子，则其前驱结点是它的左子树的最右下结点C.线索二叉树是利用二叉树的 $n+1$ 个空指针来存放结点的前驱和后继信息的D.每个结点通过线索都可以直接找到它的前驱和后继  

28.二叉树在线索化后，仍不能有效求解的问题是（）。  

A.先序线索二叉树中求先序后继 B.中序线索二叉树中求中序后继 C.中序线索二叉树中求中序前驱 D.后序线索二叉树中求后序后继  

29.若 $X$ 是二叉中序线索树中一个有左孩子的结点，且 $X$ 不为根，则 $X$ 的前驱为（）  

A. $X$ 的双亲B. $X$ 的右子树中最左的结点C.  $X$  的左子树中最右的结点 D.  $X$  的左子树中最右的叶结点  

30.若 $X$ 是后序线索二叉树中的叶结点，且 $X$ 存在左兄弟Y，则 $X$ 的右线索指向的是（）  

A. $X$ 的双亲B.以Y为根的子树的最左下结点C. $X$ 的左兄弟 $Y$ D.以Y为根的子树的最右下结点  
31.（）的遍历仍需要栈的支持。  

A.前序线索树 B.中序线索树 C.后序线索树 D.所有线索树  

32.某二叉树的先序序列和后序序列正好相反，则该二叉树一定是（）。  

A.空或只有一个结点B.高度等于其结点数C.任意一个结点无左孩子D.任意一个结点无右孩子  

33.【2009统考真题】给定二叉树如下图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是3175624，则其遍历方式是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bece79f4438b9825efc8c0878a6ba539d4dd913bd68de23452cce44779d2535b.jpg)  

A.LRN B.NRL C.RLN D.RNL

 34.【2010统考真题】下列线索二叉树中（用虚线表示线索），符合后序线索树定义的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7be87a3354ad6ec8c5e33e77d5988c5be2ae0b34f54f1614afe838f24c54a3b.jpg)  

35.【2011统考真题】一棵二叉树的前序遍历序列和后序遍历序列分别为 $1,2,3,4$ 和4,3,2,1，该二叉树的中序遍历序列不会是（）。  

A.1,2,3,4 B.2,3,4,1 C.3,2,4,1 D.4,3,2,1  

36.【2012统考真题】若一棵二叉树的前序遍历序列为  $a,e,b,d,c$  后序遍历序列为b，c,d，e  $a$ 则根结点的孩子结点（）。  

A.只有eB.有e、bC.有e、cD.无法确定  

37.【2013统考真题】若 $X$ 是后序线索二叉树中的叶结点，且 $X$ 存在左兄弟结点 $Y$ 则 $X$ 的右线索指向的是（）。  

A. $X$ 的父结点B.以Y为根的子树的最左下结点C. $X$ 的左兄弟结点YD.以Y为根的子树的最右下结点  

38.【2014统考真题】若对下图所示的二叉树进行中序线索化，则结点  $X$  的左、右线索指向 的结点分别是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/932cfacc1d3802532c7212113d9f98599ad8ddc9fd674ca46a29543e5aa460f2.jpg)  

A.e,c B.e,a C.d, c D.b,a  

39.【2015统考真题】先序序列为 $a,b,c,d$ 的不同二叉树的个数是（）A.13 B.14 C.15 D.16  
40.【2017统考真题】某二叉树的树形如下图所示，其后序序列为 $e,a,c,b,d,g,f,$ 树中与结点 $a$ 同层的结点是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a4358325318e7dee92e53f0394413b93ececa2a038e260f8b65e89d0bdd4f75a.jpg)  

A. B.d C.  $f$  D.g  

41.【2017统考真题】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是（）。  

A.只有左子树B.只有右子树C.结点的度均为1 D.结点的度均为2  

42.【2022统考真题】若结点  $p$  与  $q$  在二叉树  $T$  的中序遍历序列中相邻，且  $p$  在  $q$  之前，则 下列 $p$ 与 $q$ 的关系中，不可能的是（）。  

I. $q$ 是 $p$ 的双亲I1. $q$ 是 $p$ 的右孩子II. $q$ 是 $p$ 的右兄弟IV.q是 $p$ 的双亲的双亲A.仅1B.仅IⅢIC.仅Ⅱ、ⅢD.仅II、IV  

43.【2023统考真题】已知一棵二叉树的树形如下图所示，若其后序遍历序列为fdbeca，则其 先（前）序遍历序列是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8f5ff3e7b6822822a56725c58d78a69920e0e8c6f86dc46097b85c34cf1db90a.jpg)  

A.aedfbc B.acebdf C.cabefd D.dfebac  

# 二、综合应用题  

01.若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？

02.若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？

03.编写后序遍历二叉树的非递归算法。

04.试给出二叉树的自下而上、从右到左的层次遍历算法。

05.假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。

06.二叉树按二叉链表形式存储，试编写一个判别给定二叉树是否是完全二叉树的算法。

07.假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定二叉树的所有双分支结点个数。

08.设树 $B$ 是一棵采用链式结构存储的二叉树，编写一个把树 $B$ 中所有结点的左、右子树进行交换的函数。

09.假设二叉树采用二叉链存储结构存储，设计一个算法，求先序遍历序列中第k（ $1\!\leqslant\!\!k\!\leqslant$ 二叉树中结点个数）个结点的值。

10.已知二叉树以二叉链表存储，编写算法完成：对于树中每个元素值为 $x$ 的结点，删除以它为根的子树，并释放相应的空间。

11.在二叉树中查找值为 $x$ 的结点，试编写算法（用C语言）打印值为 $x$ 的结点的所有祖先，假设值为  $x$  的结点不多于一个。  
12.设一棵二叉树的结点结构为（LLINK，INFO，RLINK），ROOT为指向该二叉树根结点的指针，P和g分别为指向该二叉树中任意两个结点的指针，试编写算法ANCESTOR（ROOT，P，a，r），找到p和g的最近公共祖先结点r。  

13.假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树 $^b$ 的宽度（即具有结点数最多的那一层的结点个数）。  

14.设有一棵满二叉树（所有结点值均不同），已知其先序序列为pre，设计一个算法求其后序序列pOst。  

15.设计一个算法将二叉树的叶结点按从左到右的顺序连成一个单链表，表头指针为head。二叉树按二叉链表方式存储，链接时用叶结点的右指针域来存放单链表指针。  

16.试设计判断两棵二叉树是否相似的算法。所谓二叉树 $T_{1}$ 和 $T_{2}$ 相似，指的是 $T_{1}$ 和 $T_{2}$ 都是空的二叉树或都只有一个根结点；或者 $T_{1}$ 的左子树和 $T_{2}$ 的左子树是相似的，且 $T_{1}$ 的右子树和 $T_{2}$ 的右子树是相似的。  

17.【2014统考真题】二叉树的带权路径长度（WPL）是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1abffb1bbbfdf5aa692855e413abc5e091b70c4f64f35bea5ca9b4b3789062d8.jpg)  

其中叶结点的weight域保存该结点的非负权值。设root为指向 $T$ 的根结点的指针，请设计求 $T$ 的WPL的算法，要求：  

1）给出算法的基本设计思想。2）使用C或 $C^{++}$ 语言，给出二叉树结点的数据类型定义。3）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。  

18.【2017统考真题】请设计一个算法，将给定的表达式树（二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两棵表达式树作为算法的输入时：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f03f61a6ffa34247aa6b4efc657973874ddffd14f75ee1bc6d3b2727fe5f48d0.jpg)  

输出的等价中缀表达式分别为（a+b）\*（c\*（-d））和（a\*b）+（-（c-d））。二叉树结点定义如下：  

typedef struct no del char data[10];//存储操作数或操作符structnode\*left，\*right; }BTree; 要求：1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。  

19.【2022统考真题】已知非空二叉树 $T$ 的结点值均为正整数，采用顺序存储方式保存，数据结构定义如下：  
typedef struct//MAXSIZE为已定义常量int SqBiTNode[MAX SIZE];//保存二叉树结点值的数组int ElemNum;//实际占用的数组元素个数)SqBiTree;  

$T$ 中不存在的结点在数组SqBiTNode中用-1表示。例如，对于下图所示的两棵非空二叉树 $T_{1}$ 和 $T_{2}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28aace2e58407ef6096b69962cd09ee0025410cb450f18470028929419f46d33.jpg)  
二叉树T  

$T_{1}$ 的存储结果如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ae73bdd31b0d69a98ae92d4e057bba58ce2f951c0ecb54b996fad61108b231ef.jpg)  

T1.ElemNum=10  

$T_{2}$ 的存储结果如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/43f530c82c81f0af79fe1affaaddfd10367b069e6dcb65c4a8ed8dcb1c6afd87.jpg)  

请设计一个尽可能高效的算法，判定一棵采用这种方式存储的二叉树是否为二叉搜索树，若是，则返回true，否则，返回false。要求：  

1）给出算法的基本设计思想。  

2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。  

# 5.3.4 答案与解析  

# 一、单项选择题  

01.C  

二叉树中序遍历的最后一个结点一定是从根开始沿若子女指针链走到底的结点，设用 $p$ 指示。若结点 $p$ 不是叶结点（其左子树非空），则前序遍历的最后一个结点在它的左子树中，A、B错误若结点 $p$ 是叶结点，则前序与中序遍历的最后一个结点就是它，C正确。若中序遍历的最后一个结点 $p$ 不是叶结点，它还有一个左子女 $q$ ，结点 $q$ 是叶结点，那么结点 $q$ 是前序遍历的最后一个结点，但不是中序遍历的最后一个结点，D错误。  

02.C  

三种遍历方式中，都先遍历左子树，再遍历右子树，因此 $^b$ 一定在 $c$ 的前面访问。  

03.C  

中序遍历时，先访问左子树，再访问根结点，后访问右子树。 $n$ 在 $m$ 前的3种可能性如下图所示，从中看出 $n$ 总是在 $m$ 的左方。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c8dfbbbff6ae56c3a36e875776bcce647d64015dd0dfcf999e8fb6318c9484c.jpg)  
【另解】设 $n$ 和 $m$ 的最近公共祖先 $p$ ，则有以下可能：  

情形1， $m$ 和 $n$ 分别在 $p$ 的左、右（右、左）分支上；情形2， $m$ 或 $n$ 为 $p$ 结点，另一结点在 $p$ 的分支上。只有 $n$ 和 $m$ 分别处于 $p$ 的左、右分支上， $m$ 为祖先结点且 $n$ 位于 $m$ 的左分支， $n$ 为祖先结点且 $m$ 位于 $n$ 的右分支，符合题意。  

04.D  

后序遍历的顺序是LRN，若 $n$ 在N的左子树， $m$ 在N的右子树，则在后序遍历的过程中 $n$ 在 $m$ 之前访问：若 $n$ 是 $m$ 的子孙，设 $m$ 在 $_\mathrm{N}$ 的位置，则 $n$ 无论是在 $m$ 的左子树还是在右子树，在后序遍历的过程中 $n$ 都在 $m$ 之前访问。其他都不可以。选项C要成立，就需加上两个结点位于同一层这个条件。  

05.C  

在后序遍历退回时访问根结点，就可以从下向上把从 $n$ 到 $m$ 的路径上的结点输出，若采用非递归的算法，则当后序遍历访问到 $n$ 时，栈中把从根到 $n$ 的父指针的路径上的结点都记忆下来，也可以找到从 $m$ 到 $n$ 的路径。  

06.C  

在二叉树的数组存储结构中，下标为 $i$ 的结点的左、右孩子的下标分别为 $2i+1$ 和 $2i+2$ （若存在），画出二叉树的形态如下图所示，则后序遍历序列为gdbhefca。  

07.B  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa6d8f24cab5aa92b27438714e0ea552714791a720fe2eaeba68cc0233a247df.jpg)  

三种遍历方式中，访问左、右子树的先后顺序是不变的，只是访问根结点的顺序不同，因此叶结点的先后顺序完全相同。此外，读者可以采用特殊值法，画一个结点数为3的满二叉树，采用三种遍历方式来验证答案的正确性。  

08.C  

对每个顶点从1开始按序编号，要求结点编号大于其左、右孩子编号，并且左孩子编号小于右孩子编号。编号越大说明遍历顺序越靠后，因此，三者遍历顺序为先左子树、再右子树、后根结点。4个选项中仅后序遍历满足要求。  

09.B  

结点v的编号比其左子树上的最小编号还小，而 $\nu$ 的右子树中的最小编号大于v的左子树中的最大编号，因此 $\nu$ 的编号比其左、右子树上的所有编号都小，显然是按先序遍历次序。  

10.D  

前序为A、B、 $C$ 的不同二叉树共有5种，其中后序为C、B、A的有4种（前4种），都是单支树，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/34221acdbf2a5f9f21856b9d382d537e9e3cd45d327be8acda64e2f8ee90de74.jpg)  

11.C  

7个结点的完全二叉树是一棵3层的满二叉树，画出相应二叉树的树形，根据后序遍历序列填入相应的结点，得到相应的完全二叉树，求得其先序遍历序列为ABCDEFG。  
12.C  

二义树的前序遍历为NLR，后序遍历为LRN。根据题意，在前序序列中 $X$ 在 $Y$ 之前，在后序序列中 $X$ 在 $Y$ 之后，若设 $X$ 在根的位置，Y在其左子树或右子树中，即满足要求。  

13.C  

先序序列是 $\cdots a\cdots b\cdots$ ，因此a和 $^b$ 结点的3种情况如下图（a) $\sim$ （c）所示。中序序列是

 $\cdots b\!\cdots a\!\cdots$ ，因此 $^a$ 和 $b$ 结点的3种情况如下图（d）～（f所示，相同部分是 $^b$ 在 $a$ 的左子树中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/642d1f563463bd5539d46487993763c0b724a04aebd2be9103fc251eb80649bb.jpg)  

14.B  

解法1：由题可知，1为根结点，2为1的孩子。对于A，3应为1的左孩子，前序序列应为

13.，不符题意。类似的，C也错误。对于B，2为1的右孩子，3为2的右孩子...满足题意。对于D，463572应为1的右子树，2为1的右孩子，46357为2的左子树，3为2的左孩子，46为3的左子树，57为3的右子树，前序序列4、6应相连，5、7应相连，不符题意。  

解法2：前序遍历时需要借助栈。二义树的前序序列和中序序列的关系相当于以前序序列作为入栈次序，以中序序列作为出栈次序。题中以1234567入栈：对于A，第一个出栈的是3，所以1不可能在2之前出栈，错误。对于C，1不可能在3之前出栈，错误。对于D，6第三个出栈，此时栈顶元素是5，不是3，错误。B正确。  

解法3：因前序序列和中序序列可以确定一棵二叉树，所以可试着用题目中的序列构造出相应的二义树，即可得知，只有选项B的序列可以构造出二叉树。  

15.D  

先序序列为NLR，后序序列为LRN，虽然可以唯一确定树的根结点，但无法划分左、右子树。例如，先序序列为 $A B$ ，后序序列为BA，则其对应的二叉树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e27b68d581f4fb471640e3280e713e72c68fa75cf61242e5f7209e4566ed3e8.jpg)  

16.B  

中序遍历是“左根右”，后序遍历是“左右根”，当任一结点没有右子树时，两种遍历都是“左根”。显然，当二叉树为空树或只有根结点时，其中序序列和后序序列也相同。  

17.D  

根据后序序列与中序序列可构造出二叉树，如下图所示。由图可知先序序列为CEDBA。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4cefbbc82ac6fc9969c3dc3c587dee80b1f5fed7de8b40713c50310eb0bf5f3a.jpg)  
(a）确定根结点  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e8e141edfda28a636a0ce51573db02149bc3834aba03d4804069d134cff26df.jpg)  
(b）确定左子树根结点  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e109474afccc6679b8deb8740d93ca9e330ffc6dbe8718246d392440feb056a.jpg)  
（c）确定剩下的子树  
18.A  

对于这种遍历序列问题，先根据遍历的性质排除若干项，若还无法确定答案，则再根据遍历结果得到二义树，找到对应遍历序列。例如，在本题中，已知先序和中序遍历结果，可知本树的根结点为 $A$ ，左子树有 $C$ 和 $B$ ，其余为右子树，则后序遍历结果中， $A$ 一定在最后，并且 $C$ 和 $B$ 一定在前面，排除答案B和D。又因先序中有DEF，中序中有EDF，则 $D$ 为这个子树的根，所以 $D$ 在后序中排在 $E F$ 之后。  

根据二叉树的递归定义，要确定二叉树，就要分别我到根结点和左、右子树。因此，根据遍历结果，必定要确定根结点位置和如何划分左、右子树，才可以确定最终的二叉树。因此，仅有先序和后序遍历不能唯一确定一棵二叉树，而二者之一加上中序遍历都可以唯一确定一棵二叉树。如在本题中，根据先序和中序遍历的结果确定二叉树的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1aead16498b6de7d7cbdaa3c6d01338f073d72817739dd6eedbd644395296825.jpg)  

19.B  

可构造出二叉树如下图所示。因此，先序序列为ABCDEF。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/27df33368b083839eedf3b0514ca7af88ed07bfe2a1949644c0aaa80fab81cc6.jpg)  

20.B  

若a是b的祖先，则后序遍历时一定先遍历b后遍历a，所以B错误。  

21.C  

删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。  

22.A  

线索是前驱结点和后继结点的指针，引入线索的目的是加快对二叉树的遍历。  

23.C  

二义树是一种逻辑结构，但线索二叉树是加上线索后的链表结构，即它是二叉树在计算机内部的一种存储结构，所以是一种物理结构。  

24.C  

$n$ 个结点共有链域指针 $2n$ 个，其中，除根结点外，每个结点都被一个指针指向。剩余的链域建立线索，共 $2n\!-\!(n\!-\!1)\!=\!n+1$ 个线索。  

25.C  

线索二叉树中用1tag/rtag标识结点的左/右指针域是否为线索，其值为1时，对应指针域为线索，其值为0时，对应指针域为左/右孩子。  

26.D  
对左子树为空的二叉树进行先序线索化，根结点的左子树为空并且也没有前驱结点（先遍历根结点），先序遍历的最后一个元素为叶结点，左、右子树均为空且有前驱无后继结点，所以线索化后，树中空链域有2个。  

27.D  

不是每个结点通过线索都可以直接找到它的前驱和后继。在先序线索二叉树中查找一个结点的先序后继很简单，而查找先序前驱必须知道该结点的双亲结点。同样，在后序线索二叉树中查找一个结点的后序前驱也很简单，而查找后序后继也必须知道该结点的双亲结点，二叉链表中没有存放双亲的指针。  

28.D  

后序线索二叉树不能有效解决求后序后继的问题。如下图所示，结点 $E$ 的右指针指向右孩子，而在后序序列中 $E$ 的后继结点为 $B$ ，在查找 $E$ 的后继时仍然只能按常规方法来查找。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9318f19145a8c0b4a573067e58e6f8d3647d9167959521a6ffd703d20ded8ee3.jpg)  

29.C  

在二叉中序线索树中，某结点若有左孩子，则按照中序“左根右”的顺序，该结点的前驱结点为左子树中最右的一个结点（注意，并不一定是最右叶结点）。  

30.A  

在二义树的后序遍历中，叶结点 $X$ 的后继是其双亲，因此 $X$ 的右线索应指向该结点。  

31.C  

后序线索树遍历时，最后访问根结点，若从右孩子 $x$ 返回访问父结点，则由于结点 $x$ 的右孩子不一定为空（右指针无法指向其后继），因此通过指针可能无法遍历整棵树。如下图所示，结点中的数字表示遍历的顺序，图（c）中结点6的右指针指向其右孩子5，而不指向其后序后继结点 7，因此后序遍历还需要栈的支持，而图（a）和图（b）均可遍历。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f01e1f5c6bfa0ab8bd3496477988e32b56646f62f9a9f0dfb01b87aa9c670ced.jpg)  

32.B  

非空二叉树的先序序列和后序序列相反，即“根左右”与“左右根”顺序相反，因此树只有根结点，或根结点只有左子树或右子树，其子树也有同样的性质，任意结点只有一个孩子，才能满足先序序列和后序序列正好相反。此时树形应为一个长链，树中仅有一个叶结点。  

33.D  

分析遍历后的结点序列，可以看出根结点是在中间被访问的，而且右子树结点在左子树之前，则遍历的方法是RNL。本题考查的遍历方法并不是二叉树遍历的3种基本遍历方法，对于考生而言，重要的是掌握遍历的思想。  

34.D  
题中所给二叉树的后序序列为dbca。结点  $d$  无前驱和左子树，左链域空，无右子树，右链域 指向其后继结点  $^b$  ：结点  $^b$  无左子树，左链域指向其前驱结点d：结点c无左子树，左链域指向其 前驱结点 $b$ ，无右子树，右链域指向其后继结点a。  

35.C  

前序序列为NLR，后序序列为LRN，由于前序序列和后序序列刚好相反，所以不可能存在一个结点同时有左右孩子，即二叉树的高度为4。1为根结点，由于根结点只能有左孩子（或右孩子），因此在中序序列中，1或在序列首或在序列尾，选项A、B、C、D皆满足要求。仅考虑以1的孩子结点2为根结点的子树，它也只能有左孩子（或右孩子），因此在中序序列中，2或在序列首或在序列尾，选项A、B、D皆满足要求。  

【另解】画出各选项与题干信息所对应的二叉树如下，所以A、B、D均满足。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d099fc600e15293c0170714c6edf949b02c8780239cab62e97f4a5e96d748617.jpg)  

36.A  

前序序列和后序序列不能唯一确定一棵二叉树，但可以确定二叉树中结点的祖先关系：当两个结点的前序序列为  $X Y$  与后序序列为  $Y X$  时，则  $X$  为Y的祖先。考虑前序序列  $a,e,b,d,c.$  、后序 序列 $b,c,d,e,a$ ，可知 $a$ 为根结点， $e$ 为 $a$ 的孩子结点：此外，由 $^a$ 的孩子结点的前序序列 $e,b,d,$  $c$ 、后序序列 $b,c,d,e$ ，可知 $e$ 是bcd的祖先，所以根结点的孩子结点只有 $e$ 。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e13cc912f00d28b8c5a3bec288939e86c8cb0b0754b83808c75780f6542f39f.jpg)  

排除法：显然 $a$ 为根结点，且确定 $e$ 为 $a$ 的孩子结点，排除D。各种遍历算法中左右子树的遍历次序是固定的，若 $^b$ 也为 $a$ 的孩子结点，则在前序序列和后序序列中e、 $^b$ 的相对次序应是不变的，所以排除B，同理排除C。  

特殊法：前序序列和后序序列对应多棵不同的二叉树树形，我们只需画出满足该条件的任意一棵二叉树即可，任意一棵二叉树必定满足正确选项的要求。  

显然选择A，最终得到的二叉树满足题设中前序序列和后序序列的要求。  

37.A。  

根据后序线索二叉树的定义， $X$ 结点为叶结点且有左兄弟，因此这个结点为右孩子结点，利用后序遍历的方式可知 $X$ 结点的后序后继是其父结点，即其右线索指向的是父结点。为了更加形象，在解题的过程中可以画出如下所示的草图。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fbb372f30cb32518e9b3df19e5081a39269c66488b4aed85f920e92b2381459.jpg)  
38.D  

线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写 出二叉树的中序遍历序列debxac，中序遍历中在 $x$ 左边和右边的字符，就是它在中序线索化的左、右线索，即 $b,a$  

39.B  

根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列 $a$ b,C, $d$ 为入栈次序，则出栈序列的个数为？”，对于 $n$ 个不同元素进栈，出栈序列的个数为 $\frac{1}{n+1}C_{2n}^{n}=14$  

40.B  

后序序列先访问左子树，接着访问右子树，最后访问父结点，递归进行。根结点左子树的叶结点首先被访问，它是e。接下来是它的父结点  $a$  ，然后是  $a$  的父结点  $c$  。接着访问根结点的右子树。它 的叶结点 $^b$ 首先被访问，然后是 $b$ 的父结点 $d$ ，再后是 $d$ 的父结点 $g$ ，最后是根结点f，如下图所示。因此 $d$ 与 $a$ 同层，B正确。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/310cd850ebe2a0f810b9d0c1fede865efc5ef4c10f8c6920b4d153dd4a92a79c.jpg)  

41.B  

先序序列先访问父结点，接着访问左子树，然后访问右子树。中序序列先访问左子树，接着 访问父结点，然后访问右子树，递归进行。若所有非叶结点只有右子树，则先序序列和中序序列都先访问父结点，后访问右子树，递归进行。  

42.B  

对于此类题，每种情况只需举出一个反例即可。如图1所示， $q$ 是 $p$ 的双亲，中序遍历序列为 $\{p,\,q\}$ ，选项1可能。如图2所示， $q$ 是 $p$ 的右孩子，中序遍历序列为 $\{p,\,q\}$ ，选项ⅡI可能。如图4所示， $q$ 是 $p$ 的双亲的双亲，中序遍历序列为 $\{x,\,p,\,q\}$ ，选项IV可能。如图3所示， $q$ 是 $p$ 的右兄弟， $F$ 是 $q$ 和 $p$ 的父结点，中序遍历要求先遍历左子树，再访问根结点，最后遍历右子树，因此一定先访问 $p$ ，再访问 $F$ ，最后访问 $q$ ， $p$ 和 $q$ 不可能相邻出现，选项IⅢI不可能。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c591f62273d2efdf988f7bd9a8243e35fdfd2e0d1d0a44899a8560f7f7e740ab.jpg)  

43.A  

根据二叉树的树形和后序遍历序列，可以轻松地将各字母填入结点中，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0629617052231773263820303ba41813a70ec33b531926ab0f20663456bbcf6.jpg)  

然后对该二叉树进行先序遍历，得到序列aedfbc。  

# 二、综合应用题  

01.【解答】  

二义树的先序序列是NLR，后序序列是LRN。要使 $\mathrm{NLR}=\mathrm{NRL}$ （后序序列反序）成立，L或R应为空，这样的二叉树每层只有一个结点，即二叉树的形态是其高度等于结点个数。以3个结点 $a,b,c$ 为例，其形态如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/15e666d30bf5cb8d01e1ef955c018597ec9fe12c9f7ec6b39d30b712a5cb21cc.jpg)  

02.【解答】  

二叉树的先序序列是NLR，后序序列是LRN。要使NLR $=$ LRN成立，L和R应均为空，所以满足条件的二叉树只有一个根结点。  

# 03.【解答】  

算法思想如下：后序非递归遍历二叉树先访问左子树，再访问右子树，最后访问根结点。结合图5.10来分析： $\textcircled{\scriptsize{1}}$ 沿着根的左孩子，依次入栈，直到左孩子为空。此时栈内元素依次为 $A B D$  $\circledcirc$ 读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行 $\circledcirc$ ；否则，栈顶元素出栈并访问。栈顶 $D$ 的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶 $B$ 的右孩子不空且未被访问过， $E$ 入栈，栈顶 $E$ 的左右孩子均为空，出栈并访问：栈顶 $B$ 的右孩子不空但已被访问， $B$ 出栈并访问：栈顶 $A$ 的右孩子不空且未被访问过， $C$ 入栈，栈顶 $C$ 的左右孩子均为空，出栈并访问：栈顶 $A$ 的右孩子不空但已被访问，A出栈并访问。由此得到后序序列DEBCA。  

在上述思想的第 $\mathcal{Q}$ 步中，必须分清返回时是从左子树返回的还是从右子树返回的，因此设定一个辅助指针r，用于指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问。  

void PostOrder（BiTree T){ InitStack(S);BiTNode  $\scriptstyle{^{\star}\!\mathrm{p}=\mathrm{T}}$  BiTNode \*r=NULL; while(pll!IsEmpty(S))( if（p）{ //走到最左边 push(S,p);p=p->lchild; elsef /向右 GetTop(S,p);//读栈顶结点（非出栈）if(p->rchild&&p->rchild $!\!=\!\!\tau$ ）//若右子树存在，且未被访问过p=p->rchild; /转向右  
elsel //否则，弹出结点并访问 pop(s,p);/将结点弹出visit(p->data);/访问该结点 $\scriptstyle{\mathfrak{T}}={\mathfrak{P}}$  //记录最近访问过的结点  ${\mathfrak{p}}{=}$ NULL;l/结点访问完后，重置p指针}//else j//while  

# 注意  

每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将P置NULL  

04.【解答】  

一般的二叉树层次遍历是自上而下、从左到右，这里的遍历顺序恰好相反。算法思想：利用原有的层次遍历算法，出队的同时将各结点指针入栈，在所有结点入栈后再从栈顶开始依次访问即为所求的算法。具体实现如下：  

1）把根结点入队列。  

2）把一个元素出队列，遍历这个元素。3）依次把这个元素的左孩子、右孩子入队列。4）若队列不空，则跳到2），否则结束。  

算法实现如下：  

void Invert Level(BiTree bt){Stack s; QueueQ; if(bt  $!=$  NULL)( InitStack(s);/栈初始化，栈中存放二叉树结点的指针InitQueue（Q);//队列初始化，队列中存放二叉树结点的指针EnQueue（Q,bt);while(IsEmpty(Q)  $==$  false)( 川从上而下层次遍历 DeQueue（Q,p）;Push(s,p); /出队，入栈 if（p->lchild) EnQueue（Q，p->lchild）；//若左子女不空，则入队列if（p->rchild) EnQueue（Q，p->rchild）；//若右子女不空，则入队列while(IsEmpty(s)  $==$  false){ Pop(s,p); visit(p->data); /自下而上、从右到左的层次遍历}//if结束  

05.【解答】  

采用层次遍历的算法，设置变量1evel记录当前结点所在的层数，设置变量1ast指向当前层的最右结点，每次层次遍历出队时与1ast指针比较，若两者相等，则层数加1，并让1ast 指向下一层的最右结点，直到遍历完成。1eve1的值即为二叉树的高度。  

算法实现如下：  
int Btdepth（BiTree T)( 1/采用层次遍历的非递归方法求解二叉树的高度  

if（!T) return 0;//树空，高度为0int front  $\scriptstyle{\c=-1}$  ,rear  ${\scriptstyle{\ =-1}}$  int last  $=\!0$  ,leve  $_{1=0}$  //1ast指向当前层的最右结点 BiTree Q[MaxSize]; //设置队列Q，元素是二叉树结点指针且容量足够 Q[++rear] $\mathbf{\mu=}\mathbb{T}$ /将根结点入队BiTree p; while(front<rear)( //队不空，则循环 p=Q[++front];/队列元素出队，即正在访问的结点if(p->lchild) Q[++rear]=p->lchild;//左孩子入队if(p->rchild) Q[++rear]=p->rchild；//右孩子入队if（front $==$ last){//处理该层的最右结点level++; /层数增1 last=rear; //last指向下层 } return level;  

求某层的结点个数、每层的结点个数、树的最大宽度等，都可采用与此题类似的思想。当然此题可编写为递归算法，其实现如下：  

int Btdepth2（BiTree T){ if  $\scriptstyle{\mathrm{T}}=$  NULL) return0;/空树，高度为0ldep $\scriptstyle{\mathrm{~\textemdash~}}$ Btdepth2(T->lchild);/左子树高度rdep $\scriptstyle{\mathrm{~\!~\!~\!~\!~}}=$ Btdepth2(T->rchild);//右子树高度if(ldep>rdep) return ldep $^{+1}$ 八//树的高度为子树最大高度加根结点else return rdep  $^{+1}$  

06.【解答】  

根据完全二叉树的定义，具有 $n$ 个结点的完全二叉树与满二叉树中编号从 $1\!\sim\!n$ 的结点一一对应。算法思想：采用层次遍历算法，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。  

算法实现如下：  

bool IsComplete（BiTree T){1/本算法判断给定二叉树是否为完全二叉树InitQueue(Q）; if(!T) return true; /空树为满二叉树 EnQueue（Q,T）;while(!IsEmpty(Q)){ DeQueue(Q,p）; if(p）{ 结点非空，将其左、右子树入队列 EnQueue(Q,p->lchild);  
EnQueue(Q,p->rchild); else/结点为空，检查其后是否有非空结点while(!IsEmpty(Q)){ DeQueue（Q,p);if(p)/结点非空，则二叉树为非完全二叉树return false; return true;  

07.【解答】  

计算一棵二叉树b中所有双分支结点个数的递归模型f（b）如下：  

$\pounds_{\mathbf{\alpha}}(\mathfrak{b})=\!0$ 若 $_\mathrm{b}=$ NULLf(b) $\scriptstyle{={\frac{\epsilon}{2}}}$ (b->1child)+f(b->rchild)+1若 $\star_{\mathrm{b}}$ 为双分支结点f(b） $\scriptstyle{={\underline{{\boldsymbol{\mathsf{F}}}}}}$ (b->lchild) $+\mathbb{E}$ (b->rchild)其他情况（ $\star_{\mathrm{b}}$ 为单分支结点或叶结点）  

具体算法实现如下：  

in tD son Nodes(BiTree b)if  $\scriptstyle{\mathrm{b}}=$  NULL) return0; elseif(b->lchild!  $=$  NULL&&b->rchild!  $=$  NULL）/双分支结点 return DSonNodes(b->lchild)+DsonNodes(b->rchild)  $^{+1}$  else return DSonNodes（b->lchild)+DsonNodes(b->rchild);  

当然，本题也可以设置一个全局变量Num，每遍历到一个结点时，判断每个结点是否为分支结点（左、右结点都不为空，注意是双分支），若是则 $\mathtt{N u m++}$  

08.【解答】  

采用递归算法实现交换二义树的左、右子树，首先交换b结点的左孩子的左、右子树，然后交换b结点的右孩子的左、右子树，最后交换b结点的左、右孩子，当结点为空时递归结束（后序遍历的思想）。算法实现如下：  

void swap(BiTreeb){ 川本算法递归地交换二叉树的左、右子树if(b){ swap(b->lchild); /递归地交换左子树 swap(b->rchild); /递归地交换右子树 temp=b->lchild;I/交换左、右孩子结点b->lchild=b->rchild; b->rchild=temp;  

09.【解答】  

设置一个全局变量1（初值为1）来表示进行先序遍历时，当前访问的是第几个结点。然后可以借用先序遍历的代码模型，先序遍历二叉树。当二叉树b为空时，返回特殊字符#：当 $\tt k\mathrm{=}\mathrm{i}$ 时，该结点即为要找的结点，返回b->data；当 $\ k\not=1$ 时，递归地在左子树中查找，若找到则返回该值，否则继续递归地在右子树中查找，并返回其结果。对应的递归模型如下：  
f $(\mathtt{b}\,,\mathtt{k})="\,\#$ 当 $\mathbf{b}=$ NULL时f(b,k)=b->data当 $\scriptstyle{\dot{\Sigma}}={\dot{K}}$ 时f $({\mathfrak{b}},{\mathfrak{k}})=($  $\scriptstyle{\mathrm{ch}}=\mathbb{E}$ (b->lchild,k)） $,==$ '#'?f（b->rchild,k):ch)其他情况  

算法的实现如下：  

ElemType PreNode（BiTree b,int k){1/本算法查找二叉树先序遍历序列中第  $\kappa$  个结点的值 if  $\scriptstyle(\mathbf{b}=\mathbf{\alpha}$  NULL) /空结点，则返回特殊字符 return '# if（ $\scriptstyle{\dot{x}}=={\dot{\kappa}}$ 1/相等，则当前结点即为第 $\kappa$ 个结点return b->data;  $\ \ \dot{\mathbf{i}}_{++}$ //下一个结点ch  $\scriptstyle=$  PreNode(b->lchild,k); 左子树中递归寻找 if（ch!='#') /在左子树中，则返回该值 return ch; ch  $\scriptstyle\cdot^{=}$  PreNode(b->rchild,k); //在右子树中递归寻找 return ch;  

本题实质上就是一个遍历算法的实现，只不过用一个全局变量来记录访问的序号，求其他遍历序列的第 $\mathtt{k}$ 个结点也采用相似的方法。二叉树的遍历算法可以引申出大量的算法题，因此考生务必要熟练掌握二叉树的遍历算法。  

10.【解答】  

删除以元素值 $_\mathrm{x}$ 为根的子树，只要能删除其左、右子树，就可以释放值为 $_\mathrm{x}$ 的根结点，因此宜采用后序遍历。算法思想：删除值为x的结点，意味着应将其父结点的左（右）子女指针置空，用层次遍历易于找到某结点的父结点。本题要求删除树中每个元素值为 $_\mathrm{x}$ 的结点的子树，因此要遍历完整棵二叉树。算法实现如下：  

void Delete X Tree（BiTree&bt)(//删除以bt为根的子树if(bt）Delete x Tree(bt->lchild); Delete X Tree(bt->rchild); //删除bt的左子树、右子树 free(bt); //释放被删结点所占的存储空间 /在二叉树上查找所有以 $_\mathrm{x}$ 为元素值的结点，并删除以其为根的子树void Search（BiTree bt,ElemType x){ BiTree Q[];IIQ是存放二叉树结点指针的队列，容量足够大if(bt){ if(bt->data  $==$  /若根结点值为x，则删除整棵树 Delete x Tree(bt); exit(0); InitQueue（Q);EnQueue(Q,bt); while(!IsEmpty(Q)){ DeQueue(Q,p); if（p->lchild）/若左子女非空  
if(p->lchild->data  $==$  川左子树符合则删除左子树 Delete X Tree(p->lchild); p->lchild=NULL; //父结点的左子女置空else EnQueue(Q,p->lchild);川左子树入队列if(p->rchild)/若右子女非空if(p->rchild->data  $==$  II右子女符合则删除右子树 Delete X Tree(p->rchild); p->rchild  $\bar{-}$  NULL; II父结点的右子女置空else EnQueue(Q,p->rchild);川右子女入队列  

11.【解答】  

算法思想：采用非递归后序遍历，最后访问根结点，访问到值为 $_\mathrm{x}$ 的结点时，栈中所有元素均为该结点的祖先，依次出栈打印即可。算法实现如下：  

typedef struct{ BiTreet; int tag; )stack;//tag $=\!0$ 表示左子女被访问，tag $^{=1}$ 表示右子女被访问void Search（BiTree bt,ElemTypex){ /在二叉树bt中，查找值为 $\mathbf{x}$ 的结点，并打印其所有祖先stack s[];//栈容量足够大top  $_{i=0}$  while(bt!  $=$  NULLIItop  ${>}0$  while(bt  $:=$  NULL&&bt->data  $|=\times$  结点入栈 sD  $^{++}$  top].t=bt; s[top].tag  $=\!0$  bt=bt->lchild;/沿左分支向下if(bt!  $=$  NULL&&bt->data  $==$  printf（"所查结点的所有祖先结点的值为：\n"）；//找到xfor(  $\scriptstyle{\dot{\boldsymbol{\perp}}}={\boldsymbol{\perp}}$   $\scriptstyle{\dot{\mathbf{1}}}\,<=$  top;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  printf("od",s[i].t->data); //输出祖先值后结束 exit(1); while(top!=0&&s[top].tag  $==1$  top--;/退栈（空遍历）if(top  $!\!=\!\!0$  s[top].tag  $^{=1}$  bt=s[top].t->rchild; /沿右分支向下遍历 )//while(bt!  $=$  NULLIItop>0)  

因为查找的过程就是后序遍历的过程，所以使用的栈的深度不超过树的深度  

12.【解答】  

后序遍历最后访问根结点，即在递归算法中，根是压在栈底的。本题要找p和g的最近公共祖先结点r，不失一般性，设p在g的左边。算法思想：采用后序非递归算法，栈中存放二叉树结点的指针，当访问到某结点时，栈中所有元素均为该结点的祖先。后序遍历必然先遍历到结点p，栈中元素均为p的祖先。先将栈复制到另一辅助栈中。继续遍历到结点g时，将栈中元素从栈顶开始逐个到辅助栈中去匹配，第一个匹配（即相等）的元素就是结点p和g的最近公共祖先。算法实现如下：  
typedef struct BiTree t; int tag; //tag $:=0$ 表示左子女已被访问，tag $\scriptstyle{\mathfrak{z}}$ 表示右子女已被访问)stack; stack s[],sl[];//栈，容量足够大BiTree Ancestor(BiTree ROoT,BiTNode  $\star_{\mathbb{P}}$  ,BiTNode \*q）[ l/本算法求二叉树中p和g指向结点的最近公共结点top  $\scriptstyle{i=0}$  ;bt  $=$  ROOT; while(bt!  $=$  NULLl|top>0)( while(bt!  $=$  NULL){ s[  ${++}$  top].t=bt; s[top].tag  $=\!0$  bt=bt->lchild; //沿左分支向下while(top  $!\!=\!\!0$  &&s[top].tag  $==1$  //假定p在g的左侧，遇到p时，栈中元素均为p的祖先 if(s[top].  $\scriptstyle{\mathrm{tree=p}}$  for(  $_\mathrm{i}\!=\!\!1$   $\scriptstyle{\dot{\mathbf{1}}}\,<=$  top;  $\ \ \ \mathrm{i++}$  sl[i]  $=s$  [i]; topl  $=$  top; //将栈s的元素转入辅助栈s1保存 if(s[top]. $\scriptstyle{\mathrm{t==q}}$ //找到g结点for(  $\dot{\ }^{\dot{\ }\dot{\ }}$  top;  $\scriptstyle\dot{\Sigma}\,>\,0$  ；i--）（//将栈中元素的树结点到s1中去匹配 for(  ${\dot{\jmath}}=$  topl;j>0;j--) if(sl[j]. $\scriptstyle{\mathrm{t}}=={\mathrm{s}}$ [i].t)returns[i].t；//p和g的最近公共祖先已找到top--;/退栈}l/while if(top  $!\!=\!\!0$  s[top].tag  $^{=1}$  bt  $=_{S}$  [top].t->rchild; /沿右分支向下遍历 )//while return NULL; //p和g无公共祖先  

13.【解答】  

采用层次遍历的方法求出所有结点的层次，并将所有结点和对应的层次放在一个队列中。然后通过扫描队列求出各层的结点总数，最大的层结点总数即为二叉树的宽度。算法实现如下：  

typedef struct{ BiTree data[MaxSize];//保存队列中的结点指针int level[MaxSize];//保存data中相同下标结点的层次int front,rear;  
intBTWidth（BiTree b){ BiTree p; int k,max,i,n; Qu.front  $=$  Qu.rear  $\scriptstyle{\cdots}=-1$  /队列为空 Qu.rear++; Qu.data[Qu.rear] $\mathbf{\Sigma}=\mathbf{b}$ /根结点指针入队Qu.level[Qu.rear]  $^{=1}$  7根结点层次为1 while(Qu.front<Qu.rear){ Qu.front++;//出队 $\scriptstyle{\mathfrak{p}}=\mathtt{Q u}$ .data[Qu.front];//出队结点 $\kappa=$ Qu.level[Qu.front];//出队结点的层次if(p->lchild! $=$ NULL){1左孩子进队列Qu.rear++; Qu.data[Qu.rear]=p->lchild; Qu.level[Qu.rear]  $\mathbf{\lambda=}\mathbf{k}\mathbf{+}\mathbf{1}$  if(p->rchild! $=$ NULL){/右孩子进队列Qu.rear++; Qu.data[Qu.rear]=p->rchild; Qu.level[Qu.rear]  $=\!\kappa\!+\!1$  )//while max $=\!0$  $\scriptstyle{\dot{\mathbf{z}}}=0$ //max保存同一层最多的结点个数 $\kappa{=}1$  $//\kappa$ 表示从第一层开始查找while( $\scriptstyle{\dot{\mathbf{\rho}}}_{\dot{\mathbf{\rho}}}<=\left|\mathsf{Q u}\right|$ .rear){l/i扫描队中所有元素 $_{\mathrm{n}=0}$ 八 $/\mathrm{n}$ 统计第 $\kappa$ 层的结点个数while(  $\scriptstyle{\dot{\mathbf{1}}}<=\left|Q{\boldsymbol{\mathsf{u}}}\right|$  .rear&&Qu.level[i]  $\scriptstyle{==}k$   $\mathrm{n++}$   $\ \ \dot{\Sigma}^{++}$  k=Qu.level[i]; if(n>max)max $\tt=m$ //保存最大的nreturn max;  

# 注意  

本题队列中的结点，在出队后仍需要保留在队列中，以便求二叉树的宽度，所以设置的队列采用非环形队列，否则在出队后可能被其他结点覆盖，无法再求二叉树的宽度。  

14.【解答】  

对一般二叉树，仅根据先序或后序序列，不能确定另一个遍历序列。但对满二叉树，任意一个结点的左、右子树均含有相等的结点数，同时，先序序列的第一个结点作为后序序列的最后一个结点，由此得到将先序序列pre[l1..h1]转换为后序序列post[l2..h2]的递归模型如下：  

f（pre,11,h1,post,12,h2） $=$ 不做任何事情h1<11时f（pre,11,h1,post,12，h2） $=$ post[h2] $=$ pre[l1]其他情况  

取中间位置half $=$ (h1-11)/2;将pre[11+1，11+half]左子树转换为post[12，l2+half-1]，即f（pre)  $^{11+1}$   $^{11+}$  half,post,l2,12+half-1);  
将pre[11+half+1，h1]右子树转换为post[l2+half，h2-1]，即f（pre,11+half+1,h1,post,12+half,h2-1)。  

其中，post[h2] $=$ pre[11]表示后序序列的最后一个结点（根结点）等于先序序列的第一个结点（根结点）。相应的算法实现如下：  

void PreToPost（ElemType pre[],int11,inth1,ElemType post[],int12,inth2）{int half; if  $\stackrel{_{,\mathrm{h}1>=11}}{_{,\mathrm{h}2>=11}}$  post[h2]  $=$  pre[l1]; half  $=$  (h1-11)/2; PreToPost(pre,11+1,11+half,post,12,12+half-1); /转换左子树 PreToPost(pre,l1+half+l,h1,post,l2+half,h2-1); /转换右子树  

例如，有以下代码：  

ElemType \*pre $=$ "ABCDEFG";ElemType post[MaxSize]; PreToPost（pre,0,6,post,0,6）; printf（"后序序列："）；for(int  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\mathrm{i}}<=6$   $\ \ \mathrm{i++}$  printf（"c",post[i]）; printf（"\n");  

执行结果如下：  

后序序列：CDBFGEA  

15.【解答】  

通常使用的先序、中序和后序遍历对于叶结点的访问顺序都是从左到右，这里选择中序递归遍历。算法思想：设置前驱结点指针pre，初始为空。第一个叶结点由指针head指向，遍历到叶结点时，就将它前驱的rchild指针指向它，最后一个叶结点的rchild为空。算法实现如下：  

LinkedList head,pre $=$ NULL;//全局变量LinkedList InOrder(BiTree bt）{if（bt){ InOrder(bt->lchild); //中序遍历左子树 if(bt->lchild= $:=$ NULL&&bt->rchild $==$ NULL)//叶结点if(pre  $==$  NULL){ head=bt; pre  $=$  bt; 1/处理第一个叶结点elser pre->rchild=bt; pre  $=$  bt; //将叶结点链入链表InOrder(bt->rchild); /中序遍历右子树 pre->rchild=NULL; /设置链表尾 return head;  

上述算法的时间复杂度为 $O(n)$ ，辅助变量使用head和pre，栈空间复杂度为 $O(n)$  

16.【解答】  

本题采用递归的思想求解，若 $T_{1}$ 和 $T_{2}$ 都是空树，则相似；若有一个为空另一个不空，则必然不相似；否则递归地比较它们的左、右子树是否相似。递归函数的定义如下：  
1)f（T1, $\mathbb{T}2)=\mathbb{1}$ ；若 $\scriptstyle\mathrm{T}1==\mathrm{T}2=$ NULL。  

2）f（T1, $\mathbb{T}2)=\!0$ ：若T1和T2之一为NULL，另一个不为NULL。  

3)f（T1，  $\mathtt{T2)=f}$  (T1->1child,T2->lchild)&&f（T1->rchi1d,T2->rchild);若T1 和T2均不为NULL。  

因此，算法实现如下  

intsimilar（BiTree T1,BiTreeT2）/采用递归的算法判断两棵二叉树是否相似int lefts,rights; if（ $\scriptstyle\mathbb{T}\,\mathbb{I}\;=\;$ NULL&&T2 $==$ NULL)//两棵树皆空return 1; elseif（ $\scriptstyle{\mathrm{T}}\,\perp\,=$ NULL|IT2 $==$ NULL)/只有一棵树为空returno; elsef //递归判断 lefts  $=$  similar(T1->lchild,T2->lchild); rights  $=$  similar（T1->rchild,T2->rchild); return leftS&&rights;  

17.【解答】  

二义树的带权路径长度有两种常见的计算方法： $\textcircled{\scriptsize{1}}$ 根据二义树的带权路径长度的定义，二叉树的WPL值  $=$  树中全部叶结点的带权路径长度之和。  $\circledcirc$  根据带权二叉树的性质，二义树的WPL 值 $=$ 树中所有非叶结点的权值之和（记住该结论即可，不要求证明）。根据两种常见的计算方法，本题不难写出下列两种解法。  

1）算法的基本设计思想。  

$\textcircled{\scriptsize{1}}$ 本问题可采用递归算法实现。根据定义：  

二叉树的WPL值 $=$ 树中全部叶结点的带权路径长度之和 $=$ 根结点左子树中全部叶结点的带权路径长度之和 $^+$ 根结点右子树中全部叶结点的带权路径长度之和  

叶结点的带权路径长度  $=$  该结点的weight域的值  $\times$  该结点的深度  

设根结点的深度为0，若某结点的深度为 $d$ 时，则其孩子结点的深度为 $d+1$ 在递归遍历二叉树结点的过程中，若遍历到叶结点，则返回该结点的带权路径长度，否则返回其左右子树的带权路径长度之和。  

$\circledcirc$ 若借用非叶结点的weight域保存其孩子结点中weight域值的和，则树的WPL等于树中所有非叶结点weight域值之和。  

采用后序遍历策略，在遍历二叉树 $T$ 时递归计算每个非叶结点的weight域的值，则树 $T$ 的WPL等于根结点左子树的WPL加上右子树的WPL，再加上根结点中weight域的值。在递归遍历二叉树结点的过程中，若遍历到叶结点，则return0并且退出递归，否则递归计算其左右子树的WPL和自身结点的权值。  

2）二叉树结点的数据类型定义如下。  

typedef structnode{ int weight; struct node \*left,\*right; )BTree;  
3）算法的代码如下。  

$\textcircled{\scriptsize{1}}$ 基于方法1的算法实现  

intWPL（BTree\*root） //根据WPL的定义采用递归算法实现 returnWPL1（root,0); int WPLl（BTree \*root,int d)lla为结点深度if(root->left  $==$  NULL&&root->right  $==$  NULL) return(root->weight\*d);else return（WPL1(root->left,d+1)+WPL1（root->right,d+1));  

$\circledcirc$ 基于方法2的算法实现：  

intWPL（BTree\*root） //基于递归的后序遍历算法实现 intwl,wr; if（root->left==NULL&&root->right==NULL) return0; else w_l=WPL（root->left);/计算左子树的WPLw r=WPL（root->right）;/计算右子树的WPLroot->weight  $=$  root->left->weight+root->right->weight; //填写非叶结点的weight域return（w1+wr+root->weight）;/返回WPL值  

# 注意  

上述两种算法为官方标准答案，当遍历到度为1的结点时，会传入空指针，导致空指针异常。但是，作为408考试的算法题，不要求考虑特殊的边界条件，只要算法思想正确，代码逻辑正确，即可得满分。因此，在复习过程中，无须花过多的时间抠代码的各种边界条件。列  

# 18.【解答】  

1）算法的基本设计思想。  

表达式树的中序序列加上必要的括号即为等价的中缀表达式。可以基于二叉树的中序遍历策略得到所需的表达式。  

表达式树中分支结点所对应的子表达式的计算次序，由该分支结点所处的位置决定。为得到正确的中缀表达式，需要在生成遍历序列的同时，在适当位置增加必要的括号。显然，表达式的最外层（对应根结点）和操作数（对应叶结点）不需要添加括号。  

2）算法实现。  

将二叉树的中序遍历递归算法稍加改造即可得本题的答案。除根结点和叶结点外，遍历到其他结点时在遍历其左子树之前加上左括号，遍历完右子树后加上右括号。  

void BtreeToE(BTree \*root){ BtreeToExp（root,l); //根的高度为1 void BtreeToExp（BTree \*root,int deep）{ if(root $==$ NULL) return;/空结点返回elseif(root->left $==$ NULL&&root->right= $:=$ NULL)//若为叶结点  
printf("%s",root->data);//输出操作数，不加括号elser if（deep>l）printf("(");川若有子表达式则加一层括号BtreeToExp(root->left,deep  $^{+1}$  ); printf("os",root->data); /输出操作符 BtreeToExp(root->right,deep+1); if(deep>l)printf(")");若有子表达式则加一层括号  

19.【解答1】  

1）算法的基本设计思想。  

对于采用顺序存储方式保存的二叉树，根结点保存在SgBiTNode[O]中；当某结点保存在SqBiTNode[i]中时，若有左孩子，则其值保存在SqBiTNode[2i+1]中；若有右孩子，则其值保存在SqBiTNode[2i+2]中；若有双亲结点，则其值保存在SqBiTNode[（i-1）/2]中。  

二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。中序遍历二义搜索树得到一个升序序列。  

使用整型变量va1记录中序遍历过程中已遍历结点的最大值，初值为一个负整数。若当前遍历的结点值小于或等于val，则算法返回false，否则，将val的值更新为当前结点的值。  

2）算法实现。  

#define false0 #define true1 typedef int bool; bool judge In Order BST（SgBiTree bt，intk，int\*val）{//初始调用时  $\kappa$  的值是0 if(k<bt.ElemNum&&bt.SqBiTNode[k]  $!=-1$  if(!judge In Order BsT(bt,  $2^{\star}\kappa+1$  ,val)) return false; if(bt.SqBiTNode[k]  $<=\star$  val) return false; \*val  $=$  bt.SqBiTNode[k]; if(!judge In Order BsT(bt,  $2^{\star}\kappa+2$  ,val))return false; return true;  

【解答2】  

1）算法的基本设计思想。  

对于采用顺序存储方式保存的二叉树，根结点保存在SqBiTNode[O]中：当某结点保存在SqBiTNode[i]中时，若有左孩子，则其值保存在SqBiTNode[2i+1]中：若有右孩子，则其值Sq BiT Node $[2\,\dot{\Sigma}\!+\!2\,]$ 中；若有双亲结点，则其值保存在SqBiTNode[（i-1）/2]中。  

二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。设置两个数组pmax和pmin。根据二叉搜索树的定义，SgBiTNode[i]中的值应该大于以SqBiTNode[2i+1]为根的子树中的最大值（保存在pmax[2i+1]中），小于以SqBiTNode[2i+2]为根的子树中的最小值（保存在pmin[2i+1]中）。初始时，用数组Sq BiT Node El em Num p max pm in。  

在数组SqBiTNode中从后向前扫描，扫描过程中逐一验证结点与子树之间是否满足上述的大小关系。  

2）算法实现。  

#define false0 #define true 1  
typedef int bool; bool judgeBsT(SqBiTree bt){ int k,m,\*pmin,\*pmax; pmin $\scriptstyle=$ （int \*)malloc（sizeof（int) $\star$ (bt.ElemNum));pmax  $=$  （int\*)malloc（sizeof（int)\*（bt.ElemNum)); for( $k{=}0$ ;k<bt.ElemNum; $k++$ /辅助数组初始化pmin[k]=pmax[k]  $=$  bt.SqBiTNode[k]; for(  $\kappa=$  bt.ElemNum-1;  $_{k>0}$  ;k--）{ 1/从最后一个叶结点向根遍历 if(bt.SqBiTNode[k]  $!=-1$   $\mathsf{m}\!=\!\left(\mathbb{k}\!-\!\mathbb{1}\right)/2$  //双亲 if $(k82\!=\!\!1$ &&bt.SqBiTNode[m]>pmax[k])/其为左孩子pmin[m]  $=$  pmin[k]; else if（ $k\!\leqslant\!2\!=\!0\,\mathrm{i}$ &bt.SqBiTNode[m]<pmin[k])/其为右孩子pmax[m]  $=$  pmax[k]; else return false; return true;  

# 5.4树、森林  

# 5.4.1树的存储结构  

树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。  

# 1.双亲表示法  

这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。如图5.21所示，根结点下标为0，其伪指针域为-1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2e6b516fbf68e36a6730aff3150c9226473ea4cf4cbe0b6ac46cd04bc5e31e9.jpg)  
图5.21树的双亲表示法  

双亲表示法的存储结构描述如下：  

#define MAX TREE SIZE 100 typedef struct{ ElemType data;  

/树中最多结点数

/树的结点定义

//数据元素  
intparent;I/双亲位置域)PTNode; typedef structr /树的类型定义 PTNode nodes[MAX TREE SIZE];双亲表示intn;/结点数)PTree;  

双亲表示法利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时则需要遍历整个结构。  

# 注意  

区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。  

# 2.孩子表示法  

孩子表示法是将每个结点的孩子结点视为一个线性表，且以单链表作为存储结构，则 $n$ 个结点就有 $n$ 个孩子链表（叶结点的孩子链表为空表）。而 $n$ 个头指针又组成一个线性表，为便于查找，可采用顺序存储结构。图5.22（a）是图5.21（a）中的树的孩子表示法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60e641d5bf1b6a3367c0a715896ea6200c65d1d47f135dad05b2de7cc643bbac.jpg)  
图5.22树的孩子表示法和孩子兄弟表示法  

与双亲表示法相反，孩子表示法寻找孩子的操作非常方便，而寻找双亲的操作则需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。  

3.孩子兄弟表示法  

孩子兄弟表示法又称三叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄第结点的指针（沿此域可以找到结点的所有兄弟结点），如图5.22（b）所示。  

孩子兄弟表示法的存储结构描述如下：  

typedef struct CsNode{ El em Type data;struct CsNode \*firstchild,\*next sibling;  

/数据域川第一个孩子和右兄弟指针)CSNode,\*CSTree;  
孩子兄弟表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。  

# 5.4.2 树、森林与二叉树的转换  

二义树和树都可以用二义链表作为存储结构。从物理结构上看，树的孩子兄第表示法与二义树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。  

# 1.树转换为二叉树  

# 命题追踪树和二叉树的转换及相关性质的推理（2009、2011）  

树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，因此树转换得到的二叉树没有右子树，如图5.23所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c83cdc39d25f3e1591f8d9edaa5c910296cb1e468eeeba38ac072864a44455f.jpg)  
图5.23树与二叉树的对应关系  

树转换为二叉树的画法：  

1）在兄弟结点之间加一连线：2）对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；3）以树根为轴心，顺时针旋转  $45^{\circ}$  

# 2.森林转换为二叉树  

# 命题追踪森林和二叉树的转换及相关性质的推理（2014）  

将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树，以此类推，就可以将森林转换为二叉树。广  

森林转换为二叉树的画法：1）将森林中的每棵树转换成相应的二叉树：  
2）每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线：3）以第一棵树的根为轴心顺时针旋转 $45^{\circ}$  

# 3.二叉树转换为森林  

# 命题追踪  

由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）  

二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，所以将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树依次转换成树，就得到了原森林，如图5.24所示。二叉树转换为树或森林是唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/247436d1c407e375d4ea4ae286dd335ae4bf8469ec4ad1b3014b562aced6dfaa.jpg)  
图5.24森林与二叉树的对应关系  

# 5.4.3树和森林的遍历  

# 1.树的遍历  

# 命题追踪树与二叉树遍历方法的对应关系（2019）  

树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式  

1）先根遍历。若树非空，则按如下规则遍历  

先访问根结点。  

再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。  

其遍历序列与这棵树相应二叉树的先序序列相同  

2）后根遍历。若树非空，则按如下规则遍历：  

先依次遍历根结点的每棵子树，遍历子树时仍遵循先子树后根的规则  

再访问根结点。  

其遍历序列与这棵树相应二叉树的中序序列相同。  

图5.23的树的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。  

# 2.森林的遍历  

按照森林和树相互递归的定义，可得到森林的两种遍历方法。  

1）先序遍历森林。若森林为非空，则按如下规则遍历：访问森林中第一棵树的根结点。先序遍历第一棵树中根结点的子树森林  
先序遍历除去第一棵树之后剩余的树构成的森林。2）中序遍历森林。森林为非空时，按如下规则遍历：中序遍历森林中第一棵树的根结点的子树森林。访问第一棵树的根结点。中序遍历除去第一棵树之后剩余的树构成的森林。图5.24的森林的先序遍历序列为ABCDEFGHI，中序遍历序列为BCDAFEHIG。  

命题追踪森林与二叉树遍历方法的对应关系（2020）  

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为其对应二叉树的先序和中序遍历。  

树和森林的遍历与二叉树的遍历关系见表5.1。  

表5.1树和森林的遍历与二叉树遍历的对应关系
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e09d57af01729d539d610a7b2227fbf31fc318099d9e73cd036ab8262b4e34b.jpg)  

# 注意  

部分教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问的，若遇到这两种称谓，则可理解为同一种遍历方法。  

# 5.4.4 本节试题精选  

# 一、单项选择题  

01.下列关于树的说法中，正确的是（）  

I.对于有 $n$ 个结点的二叉树，其高度为 $\log_{2}\!n$ II.完全二叉树中，若一个结点没有左孩子，则它必是叶结点IⅢl.高度为 h( $h>0$ ）的完全二叉树对应的森林所含的树的个数一定是 $h$ IV.一棵树中的叶子数一定等于与其对应的二叉树的叶子数  

A.I和III B.IV C.I和II D.II 02.利用二叉链表存储森林时，根结点的右指针是（）A.指向最左兄弟B.指向最右兄弟C.一定为空D.不一定为空  

03.设森林 $F$ 中有3棵树，第1、2、3棵树的结点个数分别为 $M_{1},M_{2}$ 和 $M_{3}$ ，与森林 $F$ 对应的二叉树根结点的右子树上的结点个数是（）。  

A.  $M_{1}$  B.  $M_{1}+M_{2}$  C.  $M_{3}$  D.  $M_{2}+M_{3}$  

04.设森林 $F$ 中有4棵树，第1、2、3、4棵树的结点数分别为 $a$  $b$ 、 $c$ 和 $d$ 与森林 $F$ 对应的二叉树的根结点的左子树上的结点数是（）。  

A.a B.  $b+c+d$  C.a-1 D.  $a+b+c$  

05.设森林 $F$ 对应的二叉树为 $B$ ，它有 $m$ 个结点， $B$ 的根为 $p,\ p$ 的右子树结点数为 $n$ ，森林 $F$ 中第一棵树的结点数是（）。  

A. $m\!-\!n$ B. $m\!-\!n\!-\!1$ C. $n+1$ D.条件不足，无法确定  

06.设森林 $F$ 对应的二叉树是一棵具有16个结点的完全二叉树，则森林 $F$ 中树的数目和结点最多的树的结点数分别是（）。  
A.2和8 B.2和9 C.4和8 D.4和9  

07.森林  $T\!=\!(T_{1},\,T_{2},\cdots,\,T_{m}\,)$  转化为二叉树BT的过程为：若  $m=0$  ，则BT为空，若  $m\neq0$  则（）。  

A.将中间子树  $T_{\mathrm{mid}}$  C  $\mathsf{m i d}=(1+m)/2$  ）的根作为BT的根；将  $(T_{1},\,T_{2},\cdots,\,T_{\mathrm{mid-1}})$  转换为BT 的左子树；将 $(T_{\mathrm{mid+1}},\cdots,T_{m})$ 转换为BT的右子树B.将子树  $T_{1}$  的根作为BT的根；将  $T_{1}$  的子树森林转换成BT的左子树；将  $(T_{2},T_{3},\cdots,T_{m})$  转换成BT的右子树 C.将子树 $T_{1}$ 的根作为BT的根；将 $T_{1}$ 的左子树森林转换成BT的左子树；将 $T_{1}$ 的右子树森林转换为BT的右子树；其他以此类推D.将森林 $T$ 的根作为BT的根；将 $(T_{1},\;T_{2},\cdots,\;T_{m})$ 转化为该根下的结点，得到一棵树，然后将这棵树再转化为二叉树BT  

08.设 $F$ 是一个森林， $B$ 是由 $F$ 变换来的二叉树。若 $F$ 中有 $n$ 个非终端结点，则 $B$ 中右指针域为空的结点有（）个。  

A.  $n-1$  B.n C.  $n+1$  D.  $n+2$  

09.设某树的孩子兄弟链表示中共有6个空的左指针域、7个空的右指针域，包括5个结点的左、右指针域都为空，则该树中叶结点的个数是（）。  

A.7B.6C.5D.不能确定

10.若 $T_{\parallel}$ 是由有序树 $T$ 转换而来的二叉树，则 $T$ 中结点的后根序列就是 $T_{1}$ 中结点的（）序列。A.先序 B.中序 C.后序 D.层序  

11.某二叉树结点的中序序列为BDAECF，后序序列为DBEFCA，则该二叉树对应的森林包 括（）棵树。  

A.1 B.2 C.3 D.4  

12.设 $X$ 是树 $T$ 中的一个非根结点， $B$ 是 $T$ 所对应的二叉树。在 $B$ 中， $X$ 是其双亲结点的右孩子，下列结论中正确的是 $(\mathrm{~\,~})_{\circ}$  

A.在树 $T$ 中， $X$ 是其双亲结点的第一个孩子B.在树 $T$ 中， $X$ 一定无右边兄弟C.在树 $T$ 中， $X$ 一定是叶结点D.在树 $T$ 中， $X$ 一定有左边兄弟  

13.在森林的二叉树表示中，结点 $M$ 和结点 $N$ 是同一父结点的左儿子和右儿子，则在该森林中（）。  

A. $M$ 和 $N$ 有同一双亲B. $M$ 和 $N$ 可能无公共祖先C. $M$ 是 $N$ 的儿子D. $M$ 是 $N$ 的左兄弟  

14.【2009统考真题】将森林转换为对应的二叉树，若在二叉树中，结点 $u$ 是结点V的父结点的父结点，则在原来的森林中， $u$ 和V可能具有的关系是（）。  

I.父子关系II.兄弟关系I11. $u$ 的父结点与V的父结点是兄弟关系A.只有ⅡIB.I和IIC.I和IIID.I、ⅡI和ⅢI  

15.【2011统考真题】已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉 树中无右孩子的结点个数是（）。  

A.115 B.116 校C.1895 D.1896

 16.【2014统考真题】将森林 $F$ 转换为对应的二叉树T， $F$ 中叶结点的个数等于（）  

A. $T$ 中叶结点的个数B. $T$ 中度为1的结点个数C. $T$ 中左孩子指针为空的结点个数D.T中右孩子指针为空的结点个数  
17.【2019统考真题】若将一棵树 $T$ 转化为对应的二叉树BT，则下列对BT的遍历中，其遍历序列与 $T$ 的后根遍历序列相同的是（）  

A.先序遍历B.中序遍历C.后序遍历D.按层遍历  

18.【2020统考真题】已知森林  $F$  及与之对应的二叉树T，若  $F$  的先根遍历序列是  $a,b,c,d,e,$   $f,$ 后根遍历序列是 $b,a,d,f,e,c,$ 则 $T$ 的后序遍历序列是（）。  

A.  $b,a,d,f,e,c$  B.  $b,d,f,e,c,a$  C.b,f,e,d,c,a D  $\cdot\ \ f,e,d,c,b,a$  

19.【2021统考真题】某森林  $F$  对应的二叉树为  $T$  ，若  $T$  的先序遍历序列是  $a,b,d,c,e,g,f,$  中序遍历序列是 $b,d,a,e,g,c,f,$ 则 $F$ 中树的棵数是（）。  

A.1 B.2 C.3 D.4  

# 二、综合应用题  

01.给定一棵树的先根遍历序列和后根遍历序列，能否唯一确定一棵树？若能，请举例说明：若不能，请给出反例。  

02.将下面一个由3棵树组成的森林转换为二叉树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/142da67aee6899ce0fbb4e84f46d76715d912ef83261d4a0a5f7e7eddbf32e66.jpg)  

03.ABD EHC FIM GJ KL DB HE A IMF CG KL J， 请画出这棵二叉树，并画出二叉树对应的森林。  

04.编程求以孩子兄弟表示法存储的森林的叶结点数。05.以孩子兄弟链表为存储结构，请设计递归算法求树的深度。  

# 5.4.5 答案与解析  

# 一、单项选择题  

01.D  

若 $n$ 个结点的二叉树是一棵单支树，则其高度为 $n$ 。完全二叉树中最多存在一个度为1的结点且只有左孩子，若不存在左孩子，则一定也不存在右孩子，因此必是叶结点，选项ⅡI正确。只有满二义树才具有性质ⅢI，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e9ab7440fb0ba7ae2568a4d0cb457da7b029a76dee8eaa8d58dd29604f83da53.jpg)  

在树转换为二叉树时，若有几个叶结点具有共同的双亲，则转换成二叉树后只有一个叶结点（最右边的叶结点），如下图所示，选项IV错误。注意，若树中的任意两个叶结点都不存在相同的双亲，则树中的叶子数才有可能与其对应的二叉树中的叶子数相等。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/51b1988df9efa1bd0cfab2790e6a2fbc54938f6a60981ee51d79f38d299ef055.jpg)  

# 02.D  

森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。  

03.D  

与树转换为二叉树不同，森林中的每棵树是独立的，因此先要将每棵树的根结点全部视为兄弟结点的关系。森林转换为二叉树后，树2作为树1的根结点的右子树，树3作为树2的根结点的右子树，因此森林 $F$ 对应的二叉树根结点的右子树上的结点个数是 $M_{2}+M_{3\circ}$  

04.C  

森林转换为二叉树后，二叉树的根结点为第1棵树的根结点，二叉树的根结点的左子树包含第1棵树的所有孩子，因此森林 $F$ 对应的二叉树的根结点的左子树上的结点数是 $a-1$  

05.A  

森林转换成二叉树时采用孩子兄弟表示法，根结点及其左子树为森林中的第一棵树。右子树为其他剩余的树。所以，第一棵树的结点个数为 $m\!-\!n$  

06.D  

森林转换为二叉树后，二叉树的根结点及其左子树由第1棵树转换得到，二叉树的根结点的右子树由剩余的森林转换得到，以此类推，可以划分出第2，3，·棵树的结点。具有16个结点的完全二叉树的形态如下图所示，沿二叉树的根结点往右下遍历，共有4个结点，可知森林中有4棵树，其中第1棵树的结点数最多，有9个。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/038c61a6869824bb604ace6584a47963b2e2b68445265598b34b18b7a4f3b057.jpg)  

07.B  

将森林中每颗树的根结点视为兄弟结点的关系，再按照“左孩子右兄弟”的规则来进行转化。  

08.C  

根据森林与二叉树转换规则“左孩子右兄弟”。二叉树 $B$ 中右指针域为空代表该结点没有兄弟结点。森林中每棵树的根结点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根结点的右指针为空。另外，每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空，所以树  $B$  中右指针域为空的结点有  $n+1$  个。  

09.B  

在树的孩子兄弟表示法中，若一个结点没有孩子（即叶结点），则表现为该结点的左指针域为空，因此本题答案为“6”。至于“5个结点的左、右指针域都为空”，表示树中有5个结点既没有孩子又没有兄弟，约束条件比题中的“求叶结点的个数”要求更严格。  
10.B  

有序树  $T$  转换成二叉树  $T_{1}$  时，  $T$  的后根序列是对应  $T_{1}$  的中序序列还是后序序列呢（显然树 的后根序列不可能对应二叉树的先序序列和层序序列）？看下图所示的例子，在树 $T$ 中，叶结点 $B$ 应最先访问，在 $T_{\parallel}$ 中， $B$ 的右兄弟 $C$ 转换为它的右孩子，若对应 $T_{1}$ 的后序序列，则 $C$ 应在 $B$ 的前面访问，所以 $T$ 的后根序列不可能对应 $T_{1}$ 的后序序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/811d0fe939354b3af51877b3369a3f9485bf59a8f5df68c786751a521cec7be5.jpg)  

11.C  

根据二叉树的前序序列和中序序列可以确定一棵二叉树。根据后序序列， $A$ 是二叉树的根结点。根据中序序列，二叉树的形态如下图（a）所示。对于 $A$ 的左子树，根据后序序列， $B$ 比 $D$ 后被访问，因此 $B$ 必为 $D$ 的父结点，又根据中序序列， $D$ 是 $B$ 的右儿子。对于 $A$ 的右子树，同理可确定结点 $E$ 、 $C$ 、 $F$ 的关系。此二叉树的形态如下图（b）所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/68a02feaff287cc06c72c4994635bd4477104f0c03c73f4070947c9784d370e7.jpg)  

再根据二叉树与森林的对应关系，森林中树的棵数即为其对应二叉树（向右上旋转 $45^{\circ}$ 后）的根结点 $A$ 及其右兄弟数，或解释为：对应二叉树从根结点 $A$ 开始不断往右孩子访问，所访问到的结点数。可知此森林中有3棵树，根结点分别为 $A,C$ 和 $F$  

12.D  

在二叉树 $B$ 中， $X$ 是其双亲的右孩子，因此在树 $T$ 中， $X$ 必是其双亲结点的右兄弟，换句话说， $X$ 在树中必有左兄弟。  

13.B  

在森林的二叉树表示中，当 $M$ 和 $N$ 的父结点是二叉树根结点时， $M$ 和 $N$ 在不同的树上。因此 $M$ 和 $N$ 可能无公共祖先。  

14.B  

森林与二义树的转换规则为“左孩子右兄弟”。在最后生成的二义树中，父子关系在对应森林关系中可能是兄弟关系或者原本就是父子关系。  

情形I：若结点 $v$ 是结点 $u$ 的第二个孩子结点，转换时，结点 $\nu$ 就变成结点 $u$ 第一个孩子的右孩子，符合要求。情形ⅡI：结点 $u$ 和 $v$ 是兄弟结点的关系，但二者之中还有一个兄弟结点 $k$ 则转换后结点 $v$ 就变为结点 $k$ 的右孩子，而结点 $k$ 则是结点 $u$ 的右孩子，符合要求。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/23849acb7f1ad192690272d6eb62d837f5b522b5006188847d23c5a905fe3a8e.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/88e9d8be6c24673678554b626be8d4c64b38ada7141a9eb7d694b3392bfcc18c.jpg)  
图ⅡI  
情形ⅢI：若结点 $u$ 的父结点与 $v$ 的父结点是兄弟关系，则转换后，结点 $u$ 和 $v$ 分别在两者最左父结点的两颗子树中，不可能出现在同一条路径中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bce7723f12689d6f9f179618b6607eb9e0bff9a08fdb9fbfdb37547c7fdf2773.jpg)  
图Ⅲ  

【另解】由题意可知 $u$ 是，的父结点的父结点，如下图所示，有四种情况：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b54bde337c355968b9e84921ef0a04014bff4ff4dfe57b3415c41729abd0277b.jpg)  

根据树与二叉树的转换规则，将这四种情况转换成树中结点的关系。（1）在原来的树中 $u$ 是v的父结点的父结点：（2）在树中 $u$ 是 $\nu$ 的父结点；（3）在树中 $u$ 是 $v$ 的父结点的兄弟；（4）在树中 $u$ 与 $v$ 是兄弟关系。由此可知I和Ⅱ正确。  

15.D  

树转换为二叉树时，树的每个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉树中无右孩子的结点个数 $=$ 分支结点数 ${}+1=2011-116+1=1896.$  

通常本题应采用特殊法求解，设题意中的树是如下图所示的结构，则对应的二叉树中仅有前115个叶结点有右孩子，所以无右孩子的结点个数 $=2011-115=1896$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4a2a09690896ee7a1659e90819cb5a5265875656585a73a5949cce5a22350e9d.jpg)  

16.C  

将森林转化为二义树相当于用孩子兄第表示法来表示森林。在变化过程中，原森林某结点的第一个孩子结点作为它的左子树，它的兄弟作为它的右子树。森林中的叶结点由于没有孩子结点，转化为二叉树时，该结点就没有左结点，因此 $F$ 中叶结点的个数等于 $T$ 中左孩子指针为空的结点个数，。此题还可通过一些特例来排除A、B和 $\mathrm{D}$  

# 17.B  

后根遍历树可分为两步： $\textcircled{\scriptsize{1}}$ 从左到右访问双亲结点的每个孩子（转化为二叉树后，先访问根结点，再访问右子树）； $\circledcirc$ 访问完所有孩子后再访问它们的双亲结点（转化为二叉树后，先访问左子树，再访向根结点），因此树的后根遍历序列与其相应二义树的中序遍历序列相同。对于此类题，采用特殊值法求解通常会更便捷，左下图树 $T$ 转换为二叉树BT的过程如下图所示，树的后序遍历序列显然和其相应二叉树的中序遍历序列相同，均为5.6，7，2，3，4，1。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7259d4cc4818fc1babba24630a5e11bdb2228c4e397ab621f3110ecf2e0b78d.jpg)  

18.C  

森林  $F$  的先根遍历序列对应于其二叉树  $T$  的先序遍历序列，森林  $F$  的后根遍历序列对应于其 二叉树 $T$ 的中序遍历序列。即 $T$ 的先序遍历序列为 $a,b,c,d,e,f,$ 中序遍历序列为b,a,d,fe,c。根据二叉树 $T$ 的先序序列和中序序列可以唯一确定它的结构，构造过程如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7a007c3660bceaf1cbc9774ddce74fc8ec45142d05e7ef96da09fcc94934f9b8.jpg)  

可以得到二叉树 $T$ 的后序序列为 $b,f,e,d,c,a$  

19.C  

由二叉树 $T$ 的先序序列和中序序列可以构造出 $T$ ，如下图所示。由森林转化成二叉树的规则可知，森林中每棵树的根结点以右子树的方式相连，所以 $T$ 中的结点 $a$ 、C、 $f$ 为 $F$ 中树的根结点，森林 $F$ 中有3棵树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8ed6dd003c7f43d5f358dcca7ee0b04e888f8d9087591e61878e8d9c73e2df5e.jpg)  

# 二、综合应用题  

01.【解答】  

一棵树的先根遍历结果与其对应二叉树的先序遍历结果相同，树的后根遍历结果与其对应二叉树表示的中序遍历结果相同。由于二叉树的先序序列和中序序列能够唯一地确定这颗二叉树，因此，根据题自给出的条件，利用树的先根遍历序列和后根遍历序列能够唯一地确定这颗树。例如，对于下图所示的树，对应二叉树的先序序列为 $1,2,3,4,5,6,8,7$ ，中序序列为 $3,4,8,6,7,5,2$ 1。原树的先根遍历序列为 $1,2,3,4,5,6,8,7$ 后根遍历序列为 $3,4,8,6,7,5,2,1.$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/085440873967ec7e8b0b8007f732cdbe14e22837c2beac68619ef756532352cc.jpg)  
# 注意  

树的先根遍历、后根遍历与对应二叉树的前序遍历、中序遍历对应。  

02.【解答】  

根据树与二叉树“左孩子右兄弟”的转换规则，将森林转换为二叉树的过程如下： $\textcircled{\scriptsize{1}}$ 将每棵树的根结点也视为兄弟关系，在兄弟结点之间加一连线。 $\circledcirc$ 对每个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉。 $\textcircled{3}$ 以树根为轴心，顺时针旋转 $45^{\circ}$ 。结果如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8f4237f2bad0581db1b41bc5a56b06d5e6ed1cd4af1cd24fbbd0f3bccb027bb.jpg)  

03.【解答】  

知道二叉树的先序和中序遍历后，可以唯一确定这棵树的结构。然后把二叉树转换到树和森林的方式是，若结点 $x$ 是双亲 $y$ 的左孩子，则把 $x$ 的右孩子、右孩子的右孩子·…··都与 $y$ 用连线连起来，最后去掉所有双亲到右孩子的连线。  

最后得到的二叉树及对应的森林如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bba7755a3db5d37961b23c0e266b087e86f30eadccea04d52b6debd6dac35031.jpg)  

04.【解答】  

当森林（树）以孩子兄弟表示法存储时，若结点没有孩子（fch $\risingdotseq$ NULL），则它必是叶子，总的叶结点个数是孩子子树（fch）上的叶子数和兄弟子树（nsib）上的叶结点个数之和。  

算法代码如下：  

type def struct node ElemTypedata;struct node \*fch,\*nsib; )\*Tree;  

/数据域孩子与兄弟域  
intLeaves（Treet){//计算以孩子兄弟表示法存储的森林的叶子数if(  $\scriptstyle\mathrm{t}==$  NULL) return0; /树空返回0 if(t->fch $==$ NULL)/若结点无孩子，则该结点必是叶子return1+Leaves（t->nsib）；//返回叶结点和其兄弟子树中的叶结点数else/孩子子树和兄弟子树中叶子数之和return Leaves(t->fch)+Leaves（t->nsib);  

# 05.【解答】  

由孩子兄弟链表表示的树，求高度的算法思想如下：采用递归算法，若树为空，高度为零：否则，高度为第一子女树高度加1和兄弟子树高度的大者。其非递归算法使用队列，遂层遍历树，取得树的高度。算法代码如下：  

intHeight（CsTree bt){ 1/递归求以孩子兄弟链表表示的树的深度int hc,hs; if(bt  $==$  NULL) returno; else{//否则，高度取子女高度 $^{+1}$ 和兄弟子树高度的大者hc=Height(bt->firstchild); //第一子女树高 hs  $=$  Height(bt->next sibling); //兄弟树高 if（hc+1>hs) return hc+l; else return hs;  

# 5.5树与二叉树的应用  

# 5.5.1哈夫曼树和哈夫曼编码  

# 1.哈夫曼树的定义  

在介绍哈夫曼树之前，先介绍几个相关的概念：  

从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。路径上的分支数目称为路径长度。  

在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为  

$$
\mathrm{WPL}=\sum_{i=1}^{n}w_{i}l_{i}
$$  

式中， $w_{i}$ 是第 $i$ 个叶结点所带的权值， $l_{i}$ 是该叶结点到根结点的路径长度。  

在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树。例如，图5.25中的3棵二叉树都有4个叶结点 $a,b,c,d,$ 分别带权7，5.2.4，它们的带权路径长度分别为  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2d32313c261c37c12b5a28af99468dcb1c7b5e3580b6b57a99efff0cd38d3e9.jpg)  
图5.25具有不同带权长度的二叉树  

(a)  $\mathrm{WPL}=7\times2+5\times2+2\times2+4\times2=36\,\circ$  (b)  $\mathrm{WPL}=4{\times}2+7{\times}3+5{\times}3+2{\times}1=46{\circ}$  (C)  $\mathrm{WPL}=7\times1+5\times2+2\times3+4\times3=35\,\mathrm{s}$  

其中，图5.25（c）树的WPL最小。可以验证，它恰好为哈夫曼树。  

# 2.哈夫曼树的构造  

给定 $n$ 个权值分别为 $w_{1},w_{2},\cdots,w_{n}$ 的结点，构造哈夫曼树的算法描述如下：1）将这 $n$ 个结点分别作为 $n$ 棵仅含一个结点的二叉树，构成森林 $F$  

# 命题追踪分析哈夫曼树的路径上权值序列的合法性（2010）  

2）构造一个新结点，从 $F$ 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。3从 $F$ 中删除刚才选出的两棵树，同时将新得到的树加入 $F$ 中。4）重复步骤2）和3），直至 $F$ 中只剩下一棵树为止。  

# 命题追踪哈夫曼树的性质（2010、2019）  

从上述构造过程中可以看出哈夫曼树具有如下特点：  

1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。2）构造过程中共新建了 $n\!-\!1$ 个结点（双分支结点），因此哈夫曼树的结点总数为2n-1。3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。例如，权值7.5.2.41的哈夫曼树的构造过程如图5.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9a695e33dd97c1c5ed46237ca55e6881724f902b983ec04e5940d6658f255e.jpg)  
图5.26哈夫曼树的构造过程  

# 3.哈夫曼编码  

在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。若充许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。  
# 命题追踪根据哈夫曼编码对编码序列进行译码（2017）  

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B和C对应的编码0.10和110是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原字符，再对剩余的码串执行同样的解码操作。例如，码串0010110可被唯一地翻译为A，A，B和C。另举反例：若再将字符D的编码设计为11，此时11是110的前缀，则上述码串的后三位就无法唯一翻译。  

# 命题追踪哈夫曼树的构造及相关的分析（2012、2018、2021、2023）  

# 命题追踪前缀编码的分析及应用（2014、2020）  

可以利用二叉树来设计二进制前缀编码。假设为A，B，C，D四个字符设计前缀编码，可以用图5.27所示的二叉树来表示，4个叶结点分别表示4个字符，且约定左分支表示0，右分支表示1，从根到叶结点的路径上用分支标记组成的序列作为该叶结点字符的编码，可以证明如此得到的必为前缀编码。由图5.27得到字符A，B，C，D的前缀编码分别为0,10,110，111。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/530f7170ceac82b45e179b32785be7d95fda0363a9e6cd3d08e5994f85b9d240.jpg)  
图5.27前缀编码示例  

# 命题追踪哈夫曼编码和定长编码的差异（2022）  

哈夫曼编码是一种非常有效的数据压缩编码。由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。然后，将从根到叶结点的路径上分支标记的字符串作为该字符的编码。图5.28所示为一个由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/72a3cdbcb2f74e6a103772e7474ffec4f31c43dfd93f72e47a7066a5d3c31e44.jpg)  
图5.28由哈夫曼树构造哈夫曼编码  

这棵哈夫曼树的WPL为  

$$
\mathrm{WPL}=1\times45+3\times(13+12+16)+4\times(5+9)=224
$$  

此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位，因此哈夫曼编码共压缩了 $25\%$ 的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。  
# 注意  

左分支和右分支究竞是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。  

# 5.5.2并查集  

# 1.并查集的概念  

并查集是一种简单的集合表示，它支持以下3种操作：  

1）Initial（S）：将集合s中的每个元素都初始化为只有一个单元素的子集合。2）Union（S，Rootl，Root2）：s Root 2 Root l。要求Root1和Root2互不相交，否则不执行合并。3）Find $(\mathbf{S},\mathbf{x})$ ：查找集合S中单元素 $_\mathrm{x}$ 所在的子集合，并返回该子集合的根结点。  

# 2.并查集的存储结构  

通常用树的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。  

例如，若设有一个全集合为 $S=\{0,1,2,3,4,5,6,7,8,9\}$ ，初始化时每个元素自成一个单元素子集合，每个子集合的数组值为-1，如图5.29所示。  

$$
s(\odot\odot\odot)\odot(\odot)\odot(\odot)\odot(\odot)\odot(\odot)
$$  

$$
\begin{array}{c c c c c c}{{0}}&{{1}}&{{2}}&{{3}}&{{4}}&{{5}}&{{6}}&{{7}}&{{8}}&{{9}}\\ {{\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid}}\end{array}
$$  

经过一段时间的计算后，这些子集合合并为3个更大的子集合，即 $S_{1}=\{0,6,7,8\},\ S_{2}=\{1,4,9\}$  $S_{3}=\{2,3,5\}$ ，此时并查集的树形和存储结构如图5.30所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/976fcd63eca493385976fd301e1a61e3edcd3c536650dac7f9a30aab44ed41e1.jpg)  
图5.30用树表示并查集  

为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结点。因此， $S_{1}\cup S_{2}$ 可以具有如图5.31所示的表示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aac5c13895f1d4c8124a715052fb3f5ae623c11d1fa4e7e3de6ae02a965ce4c.jpg)  
图5.31 $S_{1}\cup S_{2}$ 可能的表示方法  
在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。其中SIZE是最大元素的个数。  

# 3.并查集的基本实现  

并查集的结构定义如下：  

下面是并查集主要运算的实现  

（1）并查集的初始化操作  

void Initial(int S[l){I/s即为并查集for(int $\scriptstyle{\dot{\mathbf{1}}}=0$ ;i<SIZE; $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ /每个自成单元素集合S  $:[\dot{\mathbf{\Delta}}]=-1$  

（2）并查集的Find操作  

在并查集S中查找并返回包含元素 $_\mathrm{x}$ 的树的根  

int Find（int S[l,int x）{ while( $\mathrm{~S~}[\mathrm{x}]\!>=\!0$ /循环寻找 $_\mathrm{x}$ 的根 $\scriptstyle{\mathrm{z=S}}\,[\mathrm{x}]$  return x; /根的S[]小于0  

判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。  

（3）并查集的Union操作  

求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个元素的根，再令一棵子集树的根指向另一棵子集树的根。  

void Union（int S[],int Rootl，int Root2）{ if（Root1 $==$ Root2)return;//要求Root1与Root2是不同的集合S[Root2] $=$ Rootl;/将根Root2连接到另一根Root1下面  

Find操作和Union操作的时间复杂度分别为 $O(d)$ 和 $O(1)$ ，其中 $d$ 为树的深度。  

# 4.并查集实现的优化  

在极端情况下， $n$ 个元素构成的集合树的深度为 $n$ ，则Find操作的最坏时间复杂度为 $O(n)$ 改进的办法是：在做Union操作之前，首先判别子集中的成员数量，然后令成员少的根指向成员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。  

（1）改进的Union操作  

void Union（int S[],int Rootl,int Root2）{ if(Rootl  $==$  Root2)return; if(S[Root2]>S[Root1]){//Root2结点数更少S[Rootl] $+{=}\mathbb{S}$ [Root2];/累加集合树的结点总数S[Root2] $=$ Rootl;1/小树合并到大树elsel //Root1结点数更少 S[Root2] $\scriptstyle{+=S}$ [Rootl];/累加结点总数S[Root1] $=$ Root2;1小树合并到大树  

$\log_{2}\!n\!\left\rfloor+1$  随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还可进一步对上述Find操作进行优化，当所查元素 $_\mathrm{x}$ 不在树的第二层时，在算法中增加一个“压缩路径”的功能，即将从根到元素 $_\mathrm{x}$ 路径上的所有元素都变成根的孩子。  
（2）改进的Find操作  

int Find（int s[l,int x）int root  $=\times$  while(s[root] $>=0$ //循环找到根root  $=$  s[root]; while（x!=root){//压缩路径int $\scriptstyle{\mathrm{t}}=\mathrm{S}\,[\mathrm{x}\,]$ /指向 $_\mathrm{x}$ 的父结点S[x] $=$ root; $//\mathrm{x}$ 直接挂到根结点下面 $\scriptstyle{\mathrm{x}=\mathrm{t}}$  return root;/返回根结点编号  

通过Find操作的“压缩路径”优化后，可使集合树的深度不超过 $O(\alpha(n))$ ，其中 $\alpha(n)$ 是一个增长极其缓慢的函数，对于常见的正整数 $n$ ，通常 $\alpha(n){\leqslant}4$  

# 5.5.3 本节试题精选  

# 一、单项选择题  

01.在有 $n$ 个叶结点的哈夫曼树中，非叶结点的总数是（）。A.n-1 B.n C.2n-1 D.2n 02.给定整数集合13，5，6，9，121，与之对应的哈夫曼树是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7fb8a0a8ef146e34f1cf1d5819eb82be2c02c844ae91169af4e61d562f7f1132.jpg)  

03.下列编码中，（）不是前缀码。  

A.{00,01,10,11} B.{0, 1,00, 11} C.{0,10,110,111} D.{10,110,1110,1111}  

04.设哈夫曼编码的长度不超过4，若已对两个字符编码为1和01，则还最多可对（）个字符编码。  

A. 2 B.3 C.4 D.5 05.一棵哈夫曼树共有215个结点，对其进行哈夫曼编码，共能得到（）个不同的码字。A.107 B.108 C.214 D.215 06.设某哈夫曼树有5个叶结点，则该哈夫曼树的高度最高可以是（）。A.3 B.4 C.5 D.6 07.以下对于哈夫曼树的说法中，错误的是（）  

A.对应一组权值构造出来的哈夫曼树一般不是唯一的B.哈夫曼树具有最小的带权路径长度C.哈夫曼树中没有度为1的结点D.哈夫曼树中除了度为1的结点，还有度为2的结点和叶结点  

08.下列关于哈夫曼树的说法中，错误的是（）  
1.哈夫曼树的结点总数不能是偶数II.哈夫曼树中度为1的结点数等于度为2和0的结点数之差 II.哈夫曼树的带权路径长度等于其所有分支结点的权值之和  

A.仅IⅢIB.I和IIC.仅ⅡID.I、Ⅱ和Ⅲ

09.若度为 $m$ 的哈夫曼树中，叶结点个数为 $n$ ，则非叶结点的个数为（））  

A.  $n-1$  B.[n/m]-1 C.  $\lceil(n-1)/(m-1)\rceil$  D.  $\lceil n/(m-1)\rceil-1$  

10.并查集的结构是一种（）  

A.二叉链表存储的二叉树B.双亲表示法存储的树C.顺序存储的二叉树D.孩子表示法存储的树  

11.并查集中最核心的两个操作是： $\textcircled{\scriptsize{1}}$ 查找，查找两个元素是否属于同一个集合； $\textcircled{2}$ 合并若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为10（0\~9）的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9的顺序进行查找和合并操作，最终并查集共有（）个集合。  

A.1 B.2 C.3 D.4

 12.下列关于并查集的说法中，正确的是（）（注，本题涉及图的考点）  

A.并查集不能检测图中是否存在环路的问题B.通过路径优化后的并查集在最坏情况下的高度仍是 $O(n)$ C.Find操作返回集合中元素个数的相反数，它用来作为某个集合的标志D.并查集基于树的双亲表示法  

13.下列关于并查集的叙述中，（）是错误的（注，本题涉及图的考点）。  

A.并查集是用双亲表示法存储的树B.并查集可用于实现克鲁斯卡尔算法C.并查集可用于判断无向图的连通性D.在长度为 $n$ 的并查集中进行查找操作的时间复杂度为 $O(\log_{2}n)$  

14.【2010统考真题】n（ $n{\geqslant}2$ ）个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是（）。  

A.该树一定是一棵完全二叉树B.树中一定没有度为1的结点C.树中两个权值最小的结点一定是兄弟结点D.树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值  

15.【2014统考真题】5个字符有如下4种编码方案，不是前缀编码的是（）  

A. 01,0000,0001,001,1 B.011,000,001,010,1 C.000001,010,011,100 D.0,100110,11101100  

16.【2015统考真题】下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是（）。  

A.24.10.5和24,10.7 B.24,10,5和24,12,7 C.24,10,10和24,14,11 D.24,10,5和24,14，6  

17.【2017统考真题】已知字符集{a,b,c,d,e,f,g,h}，若各字符的哈夫曼编码依次是0100,10 0000，0101，001，011，11，0001，则编码序列0100011001001011110101的译码结果是（）。  

A.acgabfh B.adbagbb C.afbeagd D.afeefgd  
18.【2018统考真题】已知字符集{a,b,c,d,e,f}，若各字符出现的次数分别为  $6,3,8,2,10,4$  则对应字符集中各字符的哈夫曼编码可能是（）。  

A.00,1011,01,1010,11,100 B.00,100,110,000,0010,01 C.10,1011,11,0011,00,010 D.0011,10,11,0010,01,000  

19.【2019统考真题】对  $n$  个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115 个结点，则 $n$ 的值是（）。  

A.56 B.57 C.58 D.60  

20.【2021统考真题】若某二叉树有5个叶结点，其权值分别为10,12,16,21,30，则其最小 的带权路径长度（WPL）是（）。  

A.89B.200C.208D.289  

21.【2022统考真题】对任意给定的含 $n$ ( $n>2$ ）个字符的有限集 $S$ ，用二叉树表示 $S$ 的哈夫曼编码集和定长编码集，分别得到二叉树 $T_{1}$ 和 $T_{2\circ}$ 下列叙述中，正确的是（）。  

A. $T_{1}$ 与 $T_{2}$ 的结点数相同B. $T_{1}$ 的高度大于 $T_{2}$ 的高度C.出现频次不同的字符在 $T_{1}$ 中处于不同的层D.出现频次不同的字符在 $T_{2}$ 中处于相同的层  

22.【2023统考真题】在由6个字符组成的字符集  $S$  中，各字符出现的频次分别为3,4,5,6, 8.10，为 $S$ 构造的哈夫曼编码的加权平均长度为（）。  

A. 2.4 B.2.5 C. 2.67 D.2.75  

# 二、综合应用题  

01.设给定权集 $w=\{5,\,7,\,2,\,3,\,6,\,8,\,9\}$ ，试构造关于 $w$ 的一棵哈夫曼树，并求其加权路径长度WPL。  

02.【2012统考真题】设有6个有序表A,B,C，D,E,F，分别含有10,35,40,50,60和200个 数据元素，各表中的元素按升序排列。要求通过5次两两合并，将6个表最终合并为1个升序表，并使最坏情况下比较的总次数达到最小。请回答下列问题：1）给出完整的合并过程，并求出最坏情况下比较的总次数。2）根据你的合并过程，描述 $n$  $n{\geqslant}2$ ）个不等长升序表的合并策略，并说明理由。  

03.【2020统考真题】若任意一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集（字符个数 $_{\geqslant2}$ ）的不等长编码，每个字符的编码均为二进制的0、1序列，最长为 $L$ 位，且具有前缀特性。请回答下列问题：  

1）哪种数据结构适宜保存上述具有前缀特性的不等长编码？2）基于你所设计的数据结构，简述从 $0/1$ 串到字符串的译码过程3）简述判定某字符集的不等长编码是否具有前缀特性的过程  

# 5.5.4 答案与解析  

一、单项选择题  

01.A  

由哈夫曼树的构造过程可知，哈夫曼树中只有度为 $0$ 和2的结点。在非空二叉树中，有 $n_{0}=$  $n_{2}+1$ ，所以 $n_{2}\!=\!n\!-\!1$  

【另解】 $n$ 个结点构造哈夫曼树需要 $n\!-\!1$ 次合并过程，每次合并新建一个分支结点，所以选择选项A。  
02.C  

首先，3和5构造为一棵子树，其根权值为8，然后该子树与6构造为一棵新子树，根权值为14，再后9与12构造为一棵子树，最后两棵子树共同构造为一棵哈夫曼树。  

03.B  

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。在选项B中，0是00的前缀，1是11的前缀。  

04.C  

在哈夫曼编码中，一个编码不能是任何其他编码的前缀。3位编码可能是001，对应的4位编码只能是0000和0001。3位编码也可能是000，对应的4位编码只能是0010和0011。若全采用4位编码，则可以为0000，0001，0010和0011。题中问的是最多，所以选择选项C。  

【另解】若哈夫曼编码的长度只允许小于或等于4，则哈夫曼树的高度最高是5，已知一个字符编码为1，另一个字符编码是01，这说明第二层和第三层各有一个叶结点，为使得该树从第3层起能够对尽可能多的字符编码，余下的二叉树应该是满二叉树，如下图所示，底层可以有4个叶结点，最多可以再对4个字符编码。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9ff6aad7dd82f7a971bba44de0654ac095b92a8281d8f8b32cf08495abc724f8.jpg)  

05.B  

根据上题的结论，叶结点数为 $(215+1)/2=108$ ，所以共有108个不同的码字。  

【另解】在哈夫曼树中只有度为0和2的结点，结点总数 $n=n_{0}+n_{2}$ ，且 $n_{0}\!=\!n_{2}+1$ ，由题知 $n=215,\,\,\,n_{0}=108.$  

06.C  

在哈夫曼树的构造中，每个初始结点最终都成为叶结点，5个初始结点构造的哈夫曼树共新建4个双分支结点，4个双分支结点所构成的高度最高的哈夫曼树如下图所示，其高度是5。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42ca9973d8f18ebba36f6d07629e0d69db90a553d9e4104ad358480307c93f99.jpg)  

07.D  

哈夫曼树通常是指带权路径长度达到最小的扩充二叉树，在其构造过程中每次选根的权值最小的两棵树，一棵作为左子树，一棵作为右子树，生成新的二叉树，新的二叉树根的权值应为其左右两棵子树根结点权值的和。至于谁做左子树，谁做右子树，没有限制，所以构造的哈夫曼树是不唯一的。哈夫曼树只有度为0和2的结点，度为0的结点是外结点，带有权值，没有度为1的结点。  
08.C  

$n$ 个初始结点构造的哈夫曼树共新建 $n-1$ 个双分支结点，因此哈夫曼树的结点总数是 $2n-1$ 是个奇数，1错误。哈夫曼树中没有度为1的结点，ⅡI错误。哈夫曼的带权路径长度有两种计算方法： $\textcircled{\scriptsize{1}}$ 所有叶结点的带权路径长度之和； $\circledcirc$ 所有分支结点的权值之和，ⅢI正确。  

09.C  

一棵度为 $m$ 的哈夫曼树应只有度为 $0$ 和 $m$ 的结点，设度为 $m$ 的结点有 $n_{m}$ 个，度为0的结点有 $n_{0}$ 个，又设结点总数为 $N_{i}$  $N\!=\!n_{0}+n_{m^{\circ}}$ ，因有 $N$ 个结点的哈夫曼树有 $N\!-\!1$ 条分支，则 $m n_{m}\!=\!N\!-\!1\!=$  $n_{m}+n_{0}-1$ ，整理得 $(m\!-\!1)n_{m}\!=\!n_{0}\!-\!1$ ， $n_{m}\!=\!(n_{0}\!-\!1)/(m\!-\!1)\circ$  

10.B  

并查集的存储结构是用双亲表示法存储的树，主要是为了方便两个重要的操作。  

11. C  

初始时， $_{0\sim9}$ 各自成一个集合。查找1-2时，合并{1}和{2}；查找3-4时，合并{3}和{4);查找5-6时，合并{5}和{6}；查找7-8时，合并{7}和{8}；查找8-9时，合并{7，8}和{9}；查找1-8时，合并{1,2}和{7,8,9}；查找0-5时，合并{0}和{5,6}；查找1-9时，它们属于同一个集合。最终的集合为0,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项℃。  

12.D  

依次探测图的各条边，用并查集检查该边依附的两个顶点是否已属于同一集合（两个顶点的根结点是否相同）。若是，则说明图中存在环路，A错误。经过路径优化后，并查集在最坏情况下的高度远小于 $O(n)$ ，B错误。Find操作总返回当前根结点作为集合的标志，C错误。  

13.D  

在用并查集实现Kruskal算法求图的最小生成树时：判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合（即判断加入这条边之后是否形成回路），若形成回路，则继续判断下一条边；若不形成回路，则将该边和边对应的顶点加入最小生成树T，并继续判断下一条边，直到所有顶点都已加入最小生成树 $T_{\circ}$ B正确。用并查集判断无向图连通性的方法：遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中，处理完所有边后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中。C正确。未做路径优化的并查集在最坏情况下的高度为 $n$ ，此时查找操作的时间复杂度为 $O(n)$ ，时间复杂度通常指最坏情况下的时间复杂度。D错误。  

14.A  

哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，选项B正确。构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，选项C正确。哈夫曼树中任意一个非叶结点的权值为其左、右子树根结点的权值之和，可知，哈夫曼树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值。  

15.D  

前缀编码的定义是在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。选项D中的编码110是编码1100的前缀，违反了前缀编码的规则，所以选项D不是前缀编码。  

16.D  

在哈夫曼树中，左右孩子权值之和为父结点权值。仅以分析选项A为例：若两个10分别属于两棵不同的子树，则根的权值不等于其孩子的权值和，不符；若两个10属同棵子树，则其权值不等于其两个孩子（叶结点）的权值和，不符。选项B、C选项的排除方法相同  
17.D  

哈夫曼编码是前缀编码，各个编码的前缀不同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为 $0100\,011\,001\,001\,011\,11\,0101$ ，译码结果是afeefgd。选项D正确。  

18.A  

根据各字符出现的次数构造的哈夫曼树如下图所示。由图可知，a、c和e的编码长度应该相同：a和c的第1个编码应该相同，且与e的第1个编码不同：b和d的前3个编码应该相同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/08e198998117d2d3790a9bc5f2d61fb413ce112cd731b071524be4f85aab49ea.jpg)  

19.C  

$n$ 个符号构造成哈夫曼树的过程中，共新建了 $_{n-1}$ 个结点（双分支结点），因此哈夫曼树的结点总数为 $2n\!-\!1\!=\!115$ ， $n$ 的值为58。  

20.B  

对于带权值的结点，构造出哈夫曼树的带权路径长度（WPL）最小，哈夫曼树的构造过程如 下图所示。求得其 $\mathrm{WPL}=(10+12)\times3+(30+16+21)\times2=200$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5ff281504ec4a9321197204f8297f883689249c454e3e6dccd555e03c6d3d0a.jpg)  

21.D  

可以画一个简单的特例来证明。图1是满足条件的二叉树  $T_{1}$  ，图2是满足条件的二叉树  $T_{2}$  结点中有值表示这个结点是编码字符。 $T_{1}$ 和 $T_{2}$ 的结点数不同，选项A错误。 $T_{1}$ 的高度等于 $T_{2}$ 的高度，选项B错误。出现频次不同的字符在 $T_{1}$ 中也可能处于相同的层，选项C错误。对于定长编码集，所有字符一定都在 $T_{2}$ 中处于相同的层，而且都是叶结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/10a86d2e849b5cca4dd47a358c1652320f8c46a9c7d2e40651769ea94d24c543.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/771c4823fc2fbe4fc51d66319b1fa0c108044a38391b95d0884d9d8ae1b4165e.jpg)  
图2  

22.B  

构建哈夫曼树的过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/149b825d15915e3ac02e787d001e0120d7f228d99a95e03573792a1ff45a0a36.jpg)  

对叶结点的哈夫曼编码，共有4个长度为3的叶结点、2个长度为2的叶结点，编码的加权 平均长度为 $[(3+4+5+6)\times3+(8+10)\times2]/(3+4+5+6+8+10)=2.5\,\mathrm{s}$  

# 二、综合应用题  

01.【解答】  

根据哈夫曼树的构造方法，每次从森林中选取两个根结点值最小的树合并成一棵树，将原先的两棵树作为左、右子树，且新根结点的值为左、右孩子关键字之和。构造过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/82f7046431340ab64837db08b393d12a65df83fad28acb985065875994652c70.jpg)  

由构造出的哈夫曼树可得 $\mathrm{WPL}=(2+3)\times4+(5+6+7)\times3+(8+9)\times2=108.$  

# 注意  

哈夫曼树并不唯一，但带权路径长度一定是相同的。  

02.【解答】  

1）由于最先合并的表中的元素在后续的每次合并中都会再次参与比较，因此求最小合并次数类似于求最小带权路径长度，此时可立即想到哈夫曼树。根据哈夫曼树的构造过程，每次选择表集合中长度最小的两个表进行合并。6个表的合并顺序如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/499ae6c6e4e94c0099ac2c3ffbf5e3e116f5b62142c0e24c0383a6e628cad01d.jpg)  

根据图中的哈夫曼树，6个序列的合并过程如下： $\textcircled{\scriptsize{1}}$ 在表集合{10,35,40,50,60,200}中，选择表A与表B合并，生成含45个元素的表AB。 $\textcircled{2}$ 在表集合{40,45,50,60,200}中，将表AB与表C合并，生成含85个元素的表ABC。 $\textcircled{3}$ 在表集合{50,60,85,200}中，表D与表E合并，生成含110个元素的表DE。 $\textcircled{4})$ 在表集合{85，110,200}中，表ABC与表DE合并，生成含195个元素的表ABCDE。 $\circledast$ 当前表集合为{195,200}，表ABCDE与表F合并，生成含395个元素的表ABCDEF。由于合并两个长度分别为 $m$ 和 $n$ 的有序表，最坏情况下需要比较 $m+n-1$ 次，所以最坏情况下比较的总次数计算如下：  

第1次合并：最多比较次数 $=10+35-1=44$ 第2次合并：最多比较次数 $=40+45-1=84\$ 第3次合并：最多比较次数 $=50+60-1=109$ 第4次合并：最多比较次数 $=85+110-1=194.$ 第5次合并：最多比较次数 $=195+200-1=394$ 比较的总次数最多为 $44+84+109+194+394=825$  

2）各表的合并策略是：对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较次数依赖于表的合并次序。可以借助于哈夫曼树的构造思想，依次选择最短的两个表进行合并，此时可以获得最坏情况下的最佳合并效率。  

# 03.【解答】  

1）使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符。2）从左至右依次扫描0/1串中的各位。从根开始，根据串中当前位沿当前结点的左子指针或 右子指针下移，直到移动到叶结点时为止。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到0/1串结束，译码完成。3）二叉树既可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的过程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。  

依次读入每个编码C，建立/寻找从根开始对应于该编码的一条路径，过程如下：  

对每个编码，从左至右扫描C的各位，根据C的当前位（0或1）沿结点的指针（左子指针或右子指针）向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿指针移动的过程中，可能遇到三种情况：  

$\textcircled{\scriptsize{1}}$ 若遇到了叶结点（非根），则表明不具有前缀特性，返回。 $\circledcirc$ 若在处理C的所有位的过程中，均没有创建新结点，则表明不具有前缀特性，返回。 $\textcircled{3}$ 若在处理C的最后一个编码位时创建了新结点，则继续验证下一个编码。若所有编码均通过验证，则编码具有前缀特性。  
# 归纳总结  

本章的内容较多，其中二叉树是极其重要的考查点。关于二叉树的有关操作，在2014年的统考中首次出现了线性表以外的算法设计题，需要引起读者的注意。  

遍历是二叉树的各种操作的基础，统考时会考查遍历过程中对结点的各种其他操作，而且容易结合递归算法和利用栈或队列的非递归算法。读者需重点掌握各种遍历方法的代码书写，并学会在遍历的基础上，进行一些其他的相关操作。其中递归算法短小精悍，出现的概率较大，请读者不要掉以轻心，要做到对几种遍历方式的程序模板烂熟于心，并结合一定数量的习题，才可以在考试中快速地写出漂亮的代码。  

二叉树遍历算法的递归程序：  

void Track（BiTree \*p）{ if(p!  $=$  NULL)I (1) Track(p->lchild); 1/(2）Track(p->rchild); 1(3)  

访问函数visit（）位于（1）、（2）、（3）的位置，分别对应于先序、中序、后序遍历。但对于具体题目来说，设计算法时要灵活应用。请读者认真练习下面的例题。  

例题：设二叉树的存储结构为二叉链表，编写有关二叉树的递归算法。  

1）统计二叉树中度为1的结点个数。2）统计二叉树中度为2的结点个数。3）统计二叉树中度为0的结点个数。4）统计二叉树的高度。5）统计二叉树的宽度。6）从二叉树中删去所有叶结点。7）计算指定结点 ${}^{\star}\mathtt{P}$ 所在的层次。8）计算二叉树中各结点中的最大元素的值。  

9）交换二叉树中每个结点的两个子女。  

10）以先序次序输出一颗二叉树中所有结点的数据值及结点所在的层次。  

# 思维拓展  

输入一个整数data和一棵二元树。从树的根结点开始往下访问一直到叶结点，所经过的所有结点形成一条路径。打印出路径及与data相等的所有路径。例如，输入整数22和下图所示的二元树，则打印出两条路径1012和10，5，7。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/941f06790d07c3ba3849267e4edafa0ff0976cce9578e4bd627251e1fa3c5cf8.jpg)  

提示：使用数组或栈保存访问的路径，并记录当前路径上所有元素的和Sum。若当前结点为叶结点，且当前结点值与sum的和等于data，则满足条件，打印当前路径。然后递归返回到父结点，注意在递归返回之前要先减去当前结点元素的值。使用前序遍历操作的递归算法模板可以简化程序。  
# 第6章图  

# 【考纲内容】  

图的基本概念  

（二）图的存储及基本操作邻接矩阵：邻接表：邻接多重表；十字链表  

（四）图的基本应用最小（代价）生成树：最短路径；拓扑排序：关键路径  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1736cc1858562584a3b9c75bce02bd73a9deed0a76bcc241d437fa01e41ebb56.jpg)  

【复习提示】  

图算法的难度较大，主要掌握深度优先搜索与广度优先搜索。掌握图的基木概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及特性、存储结构之间的转化、基于存储结构上的各种遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）等。图的相关算法较多，通常只需掌握其基本思想和实现步骤，而实现代码不是重点。  

# 6.1图的基本概念  

6.1.1图的定义  

图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,\,E)$ ，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集； $E(G)$ 表示图 $G$ 中顶点之间的关系（边）集合。若 $V=\{v_{1},\,v_{2},\cdots,\,v_{n}\}$ ，则用IV表示图 $G$ 中顶点的个数， $E=\{(u,v)\mid u{\in}V,v{\in}V\}$ ，用 $|E|$ 表示图 $G$ 中边的条数。  
# 注意  

线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。  

下面是图的一些基本概念及术语。  

1.有向图  

若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 为有向图。弧是顶点的有序对，记为y， $w^{>}$ 其中 $v,w$ 是顶点， $v$ 称为弧尾， $w$ 称为弧头，<v,W>称为从v到 $w$ 的弧，也称v邻接到 $w$ 。  

图6.1（a）所示的有向图 $G_{1}$ 可表示为  

$$
G_{1}\!=\!(V_{1},E_{1})
$$  

$$
E_{1}=\{<\!1,2\!>,<\!2,1\!>,<\!2,3\!>\}
$$  

2.无向图  

若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,\,w)$ 或 $(w,v)$  。可以说  $w$  和  $\nu$  互为邻接点。边  $(v,w)$  依附于  $w$  和  $v$  ，或称边  $(v,w)$  和  $v,w$  相关联。  

图6.1（b）所示的无向图 $G_{2}$ 可表示为  

$$
\begin{array}{c}{G_{2}=\left(V_{2},E_{2}\right)}\\ {V_{2}=\left\{1,2,3,4\right\}}\end{array}
$$  

$$
E_{2}=\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}
$$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5151560dfc0c00af5239183bc6f467e3c9e73df7d8ee3886d9de445058a96358.jpg)  
图6.1图的示例  

3.简单图、多重图  

一个图 $G$ 若满足： $\textcircled{\scriptsize{1}}$ 不存在重复边； $\circledcirc$ 不存在顶点到自身的边，则称图 $G$ 为简单图。图6.1中 $G_{1}$ 和 $G_{2}$ 均为简单图。若图 $G$ 中某两个顶点之间的边数大于1条，又充许顶点通过一条边和自身关联，则称图 $G$ 为多重图。多重图和简单图的定义是相对的。本书中仅讨论简单图。  

# 4.完全图（也称简单完全图）  

对于无向图， $|E|$ 的取值范围为0到 $n(n-1)/2$ ，有 $n(n-1)/2$ 条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。对于有向图， $|E|$ 的取值范围为0到 $n(n-1)$ ，有 $n(n-1)$ 条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图6.1中 $G_{2}$ 为无向完全图，而 $G_{3}$ 为有向完全图。  

5.子图  

设有两个图 $G=(V,E)$ 和 $G^{\prime}=(V,E^{\prime})$ ，若 $V$ 是 $V$ 的子集，且 $E^{\prime}$ 是 $E$ 的子集，则称 $G^{\prime}$ 是 $G$ 的子图。若有满足 $V(G^{\prime})=V(G)$ 的子图 $G^{\prime}$ ，则称其为 $G$ 的生成子图。图6.1中 $G_{3}$ 为 $G_{1}$ 的子图。  
# 注意  

并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。  

6.连通、连通图和连通分量  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/69224036bff123d02b308266e0d7f55e821273fdb4588553d671e49cea7a8c2f.jpg)  

图的连通性与边和顶点的关系（2010、2022）  

在无向图中，若从顶点 $\nu$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量，在图6.2（a)中，图 $G_{4}$ 有3个连通分量如图6.2（b）所示。假设一个图有 $n$ 个顶点，若边数小于 $_{n-1}$ ，则此图必是非连通图；思考，若图是非连通图，则最多可以有多少条边？  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d9d6a37be3c6ce09a5a0aa15355ead14bf7a5a3e352c73cf8d0cb852ebd9b30.jpg)  
图6.2无向图及其连通分量  

# 7.强连通图、强连通分量  

在有向图中，若有一对顶点 $v$ 和 $w$ ，从 $v$ 到 $w$ 和从 $w$ 到 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量，图 $G_{1}$ 的强连通分量如图6.3所示。思考，假设一个有向图有 $n$ 个顶点，若是强连通图，则最少需要有多少条边？?  

# 注意  

在无向图中讨论连通性，在有向图中讨论强连通性。  

8.生成树、生成森林  

连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n\!-\!1$ 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。图 $G_{2}$ 的一个生成树如图6.4所示。  
# 01e 3  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfa9e01aeec1a2c5a3b7b4d36a675036ff24683fc2cf93f63569eaa97879224d.jpg)  
图6.4图 $G_{2}$ 的一个生成树  

# 注意  

区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和边；极小连通子图是既要保持子图连通又要使得边数最少的子图。  

# 9.顶点的度、入度和出度  

无向图中顶点和边的关系（2009、2017）  

在无向图中，顶点 $v$ 的度是指依附于顶点 $v$ 的边的条数，记为 $\operatorname{TD}(\nu)$ 。在图6.1(b中，每个顶点的度均为3。无向图的全部顶点的度之和等于边数的2倍，因为每条边和两个顶点相关联。  

在有向图中，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为ID(v)：而出度是以顶点 $v$ 为起点的有向边的数目，记为 $\mathrm{{OD}}(v)$ 。在图6.1（a中，顶点2的出度为2、入度为1。顶点 $v$ 的度等于其入度与出度之和，即 $\mathrm{TD}(\nu)=\mathrm{ID}(\nu)+\mathrm{OD}(\nu)$ 。有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。  

# 10.边的权和网  

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。  

# 11.稠密图、稀疏图  

边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠 密图常常是相对而言的。一般当图 $G$ 满足 $|E|<|V|\mathrm{log}|V|$ 时，可以将 $G$ 视为稀疏图。  

# 12.路径、路径长度和回路  

顶点 $\boldsymbol{v}_{p}$ 到顶点 $\nu_{q}$ 之间的一条路径是指顶点序列 $v_{p},v_{i_{1}},v_{i_{2}},\cdots,v_{i_{m}},v_{q}$ ，当然关联的边也可理解为路径的构成要素。路径上的边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，且有大于 $n\!-\!1$ 条边，则此图一定有环。  

# 13.简单路径、简单回路  

命题追踪路径、回路、简单路径、简单回路的定义（2011）  

在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。  

14.距离  

从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离。若从 $u$ 到根本不存在路径，则记该距离为无穷（）。  

# 15.有向树  

一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。  
# 6.1.2 本节试题精选  

# 一、单项选择题  

01.图中有关路径的定义是（），  

A.由顶点和相邻顶点序偶构成的边所形成的序列B.由不同顶点所形成的序列C.由不同边所形成的序列D.上述定义都不是  

02.一个有 $n$ 个顶点和 $n$ 条边的无向图一定是（）A.连通的B.不连通的C.无环的D.有环的  

03.若从无向图的任意顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是()。  

A.强连通图 B.连通图 C.有回路 D.一棵树  

04.以下关于图的叙述中，正确的是（）  

A.图与树的区别在于图的边数大于或等于顶点数B.假设有图  $G=\{V,\{E\}\}$  ，顶点集  $V\subseteq V$   $E^{\prime}{\subseteq}E$  则V和  $\{E^{\prime}\}$  构成  $G$  的子图 C.无向图的连通分量是指无向图中的极大连通子图D.图的遍历就是从图中某一顶点出发访遍图中其余顶点  

05.以下关于图的叙述中，正确的是（）。  

A.强连通有向图的任何顶点到其他所有顶点都有弧B.图的任意顶点的入度等于出度C.有向完全图一定是强连通有向图D.有向图的边集的子集和顶点集的子集都构成原有向图的子图  

06.一个有28条边的非连通无向图至少有（）个顶点。A.7 B.8 C. 9 D.10  

07.对于一个有 $n$ 个顶点的图：若是连通无向图，其边的个数至少为（）；若是强连通有向图，则其边的个数至少为（）。  

A.  $n-1,n$  B.  $n-1,\,n(n-1)$  C.n,n D.  $n,n(n-1)$  

08.无向图  $G$  有23条边，度为4的顶点有5个，度为3的顶点有4个，其余都是度为2的 顶点，则图 $G$ 有（）个顶点。  

A.11 B.12 C.15 D.16

 09.在有 $n$ 个顶点的有向图中，顶点的度最大可达（），A.n B.n-1 C.2n D.2n-2

 10.具有6个顶点的无向图，当有（）条边时能确保是一个连通图。A.8 B.9 C.10 D.11

 11.设有无向图 $G=(V,E)$ 和 $G^{\prime}\!=\!(V,E^{\prime})$ ，若 $G^{\prime}$ 是 $G$ 的生成树，则下列不正确的是（）。  

I. $G^{\prime}$ 为 $G$ 的连通分量II. $G^{\prime}$ 为 $G$ 的无环子图m. $G^{\prime}$ 为 $G$ 的极小连通子图且 $V=V$  

A.I、IIB.只有IIC.ⅡI、ⅢID.只有I  

12.具有51个顶点和21条边的无向图的连通分量最多为（）A.33 B.34 C.45 D.32  
13.在如下图所示的有向图中，共有（）个强连通分量。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/737b44aaeaca8aaf610881d5bfd898e6ee3caf965b4027a2d513106de554c59c.jpg)  

A.1 B.2 C.3 D.4 14.若具有 $n$ 个顶点的图是一个环，则它有（）棵生成树。A.  $n^{2}$  B.  $n$  C.  $n-1$  D.1 15.若一个具有 $n$ 个顶点、 $e$ 条边的无向图是一个森林，则该森林中必有（）棵树。A.n B.e C.  $n\!-\!e$  D.1 16.【2009统考真题】下列关于无向连通图特性的叙述中，正确的是（）  

I.所有顶点的度之和为偶数IIL.边数大于顶点个数减1 I1I.至少有一个顶点的度为1  

A.只有IB.只有ⅡIC.I和IID.I和III  

17.【2010统考真题】若无向图  $G=(V,\,E)$  中含有7个顶点，要保证图  $G$  在任何情况下都是 连通的，则需要的边数最少是（）。  

A.6 B.15 C.16 D.21  

18.【2017统考真题】已知无向图 $G$ 含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图 $G$ 所含的顶点个数至少是（）  

A.10 B.11 C.13 D.15 19.【2022统考真题】对于无向图 $G\!=\!(V,E)$ ，下列选项中，正确的是（）  

A.当 $\vert V\vert>\vert E\vert$ 时， $G$ 一定是连通的B.当 $\left|V\right|\!<\!\left|E\right|$ 时， $G$ 一定是连通的C.当 $|V|\!=\!|E|\!-\!1$ 时， $G$ 一定是不连通的D.当 $\left|V\right|>\left|E\right|+1$ 时， $G$ 一定是不连通的  

# 二、综合应用题  

01.图 $G$ 是一个非连通无向图，共有28条边，该图至少有多少个顶点？  

# 6.1.3 答案与解析  

# 一、单项选择题  

01.A  

本题是北京交通大学考研真题，不同教材对路径的定义可能略有不同，顶点之间关联的边也可理解为路径的构成要素。对于B，路径的定义中并没有要求是不同顶点，比如简单回路的第一个顶点和最后一个顶点是可以相同的，此外B也没有说明这些顶点之间有边相联。  

02.D  

若一个无向图有 $n$ 个顶点和 $n\!-\!1$ 条边，可以使它连通但没有环（即生成树），但若再加一条边，在不考虑重边的情形下，则必然会构成环。  
03.B  

强连通图是有向图，与题意矛盾，A错误：对无向连通图做一次深度优先搜索，可以访问到该连通图的所有顶点，B正确；有回路的无向图不一定是连通图，因为回路不一定包含图的所有结点，C错误；连通图可能是树，也可能存在环，D错误。  

04.C  

图与树的区别是逻辑上的区别，而不是边数的区别，图的边数也可能小于树的边数，A错误；若 $E^{\prime}$ 中的边对应的顶点不是V的元素，V"和 $\{E^{\prime}\}$ 无法构成图，B错误；无向图的极大连通子图称为连通分量，C正确：图的遍历要求每个结点只能被访问一次，且若图非连通，则从某一顶点出发无法访问到其他全部顶点，D的说法不准确。  

05.C  

强连通有向图的任何顶点到其他所有顶点都有路径，但未必有弧；无向图任意顶点的入度等于出度，但有向图未必满足；若边集中的某条边对应的某个顶点不在对应的顶点集中，则有向图的边集的子集和顶点集的子集无法构成子图。  

06. C  

考查至少有多少个顶点的情形，我们考虑该非连通图最极端的情况，即它由一个完全图加一个独立的顶点构成，此时若再加一条边，则必然使图变成连通图。在 $28=n(\,n-1\,)/2=\,8{\times}7/2$ 条边的完全无向图中，总共有8个顶点，再加上1个不连通的顶点，共9个顶点。  

07. A  

对于连通无向图，边最少即构成一棵树的情形；对于强连通有向图，边最少即构成一个有向环的情形。  

08.D  

因为在具有 $n$ 个顶点、é条边的无向图中，有 ${\textstyle\sum}_{i=1}^{n}\operatorname{TD}(v_{i})=2e$ ，所以求得度为2的顶点数为7，从而共有16个顶点。  

09.D  

在有向图中，顶点的度等于入度与出度之和。 $n$ 个顶点的有向图中，任意一个顶点最多还可以与其他 $n-1$ 个顶点有一对指向相反的边相连。注意数据结构中仅讨论简单图。  

10.D  

5个顶点构成一个完全无向图，需要 $n(\,n-1\,)/2\,=\,10$ 条边；再加上1条边后，能保证第6个顶点必然与此完全无向图构成一个连通图，所以共需11条边。  

11.D  

一个连通图的生成树是一个极小连通子图，显然它是无环的，所以选项ⅡI、IⅢI正确。极大连通子图称为连通分量， $G^{\prime}$ 连通但非连通分量。这里再补充一下“极大连通子图”：若图本来就不是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。  

12.C  

初始考虑只有51个顶点的无向图 $G$ ，此时 $G$ 中每个顶点都是连通分量，问题转化为向 $G$ 中添加21条边，如何添加这21条边使得连通分量数目最多。若向两个不同的连通分量之间添加边，则连通分量数目会减1，所以应尽可能地将这21条边加入同一个连通分量且让其接近完全图，含有7个顶点的完全图有21条边，所以用7个顶点构成一个含有21条边的连通分量，剩下 $51-7=44$ 个顶点对应44个连通分量，共有45个连通分量。  

13.B  

强连通分量是极大强连通子图，任意两个顶点之间有方向相反的两条路径。由定义不难得出，若一个顶点只有出边或入边，则该顶点必定单独构成一个连通分量。图中，顶点B只有出边，其他所有顶点都不可能有到顶点B的路径，所以顶点B单独构成一个强连通分量。在顶点A、C、D、E中，任意两个顶点之间都有方向相反的两条路径，所以可构成一个强连通分量。  
14.B  

$n$ 个顶点的生成树是具有 $n-1$ 条边的极小连通子图，因为 $n$ 个顶点构成的环共有 $n$ 条边，去掉任意一条边就是一棵生成树，所以共有 $n$ 种情况，所以可以有 $n$ 棵不同的生成树。  

15.C  

$n$ 个结点的树有 $n\!-\!1$ 条边，假设森林中有 $x$ 棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是 $n+1$ ，边数是 $e+x$ ，从而可知 $x=n-e$ 。  

另解：设森林中有 $x$ 棵树，则再用 $x-1$ 条边就可将所有的树连接成一棵树，此时边数 $+1=$ 顶点数，即 $e+(x-1)+1=n,$ ，所以 $x=n-e$  

16.A  

每条边都连接了两个顶点，在计算顶点的度之和时每条边都被计算了两次，所以所有顶点的度之和偶数。无向连通图对应的生成树也是无向连通图，但此时边数等于顶点数减1，ⅡI错误。考虑2个或以上的顶点恰好构成一个环的情况，此时每个顶点的度都是2，1ⅢI错误。  

17. C  

题干要求无论如何分配边，都能使7个顶点连通，这不同于只要6条边两两相连就能构成一个连通图的情形。考虑最极端的情形，即图 $G$ 的某6个顶点构成一个完全无向图，此时若再添加一条边，则都将连通第7个顶点，使该图变成一个连通图。所以最少边数 $=6{\times}5/2+1=16$ 。若边数 $n$ 小于或等于15，可以使这 $n$ 条边仅连接图 $G$ 中的某6个顶点，从而导致第7个顶点无法与这6个顶点构成连通图（不满足“在任何情况下”）。  

为简单起见，以5个顶点为例，左边4个顶点和 $4{\times}3/2\,=\,6$ 条边构成一个完全图，此时若再添加一条边（可以是虚线中的任意一条），则能保证这5个顶点在任何情况下都是连通的，如下图所示。若边数小于7，则不能保证5个顶点在任何情况下都是连通的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6670f866390407030b20e85bbe75f66f8be31f83e401718042801845ef69e03a.jpg)  

18.B  

无向图边数的2倍等于各顶点度数的总和。要求至少的顶点数，应使每个顶点的度取最大，而由于其他顶点的度均小于3，因此可设它们的度都为2，并设它们的数量是 $x_{i}$ ，列出方程 $^{4\times3\ +}$  $3{\times}4+2x=16{\times}2$ ，解得 $x=4$ 。因此至少包含 $4+4+3=11$ 个顶点。  

19.D  

对于此类分析图的边数、顶点数与连通性问题，思路是寻找临界情况，在临界情况下任意增加或减少一条边，都会改变图的连通性。第一种临界情况如图1所示，此时若减少任意一条边，图就由连通变为不连通，即无向图连通的最小边数是 $\left|V\right|\!-\!1$ ，因此，当 $\left|E\right|\!<\!\left|V\right|$ -1时，图一定不连通，C错误，D正确。第二种临界情况如图2所示，此时若增加任意一条边，则图就由不连通变为连通，即无向图不连通的最大边数是 $(\left\lvert V\right\lvert-1)(\left\lvert V\right\lvert-2)/2$ （此时V-1个顶点构成一个完全图)，因此，只有当 $|E|\!\geqslant(\left|V\right|\!-\!1)(\left|V\right|\!-\!2)/2+1$ 时，才能保证无向图一定连通，A、B错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d365d6fe671746d8b7f4d6f9f66c1fb1b3efb171fab922c052fc4c36d4daeeb6.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bb495ae5fd497815ebccdaad25436bee6ad203a9575cfee392daa488c7fe946.jpg)  
图2  
# 二、综合应用题  

01.【解答】  

图 $G$ 是一个非连通无向图，当边数固定时，顶点数最少的情况是该图由两个连通子图构成，且其中之一只含一个顶点，另一个为完全图。其中只含一个顶点的子图没有边，另一个完全图的边数为 $n(\,n-1\,)/2=28$ ，得 $n=8$ 。所以该图至少有 $1+8=9$ 个顶点。  

# 6.2图的存储及基本操作  

图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于待求解的问题。  

# 6.2.1邻接矩阵法  

所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。  

顶点数为 $n$ 的图 $G\!=\!(V,E)$ 的邻接矩阵 $_A$ 是 $_{n\times n}$ 的，将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n},$ 则  

# 命题追踪图的邻接矩阵存储及相互转换（2011、2015、2018）  

对带权图而言，若顶点 $v_{i}$ 和 $\nu_{j}$ 之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点 $V_{i}$ 和 $V_{j}$ 不相连，则通常用0或 $\infty$ 来代表这两个顶点之间不存在边：  

有向图、无向图和网对应的邻接矩阵示例如图6.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/452c3b970dbd32b4453acaa0973977edccafa0e6e194da0812a21b6fe6148c9b.jpg)  
图6.5有向图、无向图及网的邻接矩阵  

# 命题追踪（算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）  

图的邻接矩阵存储结构定义如下：  

#define Max Vertex Num l00typedef char VertexType;  
typedef int EdgeType;//边对应的数据类型typedef struct{ Vertex Type vex[Max Vertex Num];/顶点表Edge Type edge[Max Vertex Num][Max Vertex Num]；//邻接矩阵，边表int vexnum,arcnum;/图的当前顶点数和边数)MGraph;  

# 注意  

$\textcircled{\scriptsize{1}}$ 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。 $\circledcirc$ 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可用值为0和1的枚举类型。 $\textcircled{3}$ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。 $\textcircled{4}$ 邻接矩阵表示法的空间复杂度为 $O(n^{2})$ ，其中 $n$ 为图的顶点数VI  

# 命题追踪邻接矩阵的遍历的时间复杂度（2021）  

图的邻接矩阵存储表示法具有以下特点：  

$\textcircled{\scriptsize{1}}$ 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。  

# 命题追踪基于邻接矩阵的顶点的度的计算（2013、2021、2023）  

$\textcircled{2}$ 对于无向图，邻接矩阵的第i行（或第 $i$ 列）非零元素（或非 $\infty$ 元素）的个数正好是顶点i的度 $\mathrm{TD}(\nu_{i})$  

$\textcircled{3}$ 对于有向图，邻接矩阵的第 $i$ 行非零元素（或非 $\infty$ 元素）的个数正好是顶点i的出度 $\mathrm{{OD}}(v_{i})$ ；第 $i$ 列非零元素（或非 $\infty$ 元素）的个数正好是顶点 $i$ 的入度 $\mathrm{ID}(v_{i})$  

$\textcircled{4}$ 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。  

$\circledast$ 稠密图（即边数较多的图）适合采用邻接矩阵的存储表示。  

# 命题追踪》计算 $A^{2}$ 并说明A"[][/]的含义（2015）  

$\circledcirc$ 设图 $G$ 的邻接矩阵为 $_A$ ， $A^{n}$ 的元素A"[等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。该结论了解即可，证明方法可参考离散数学教材。  

# 6.2.2邻接表法  

当一个图为稀疏图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。  

所谓邻接表，是指对图 $G$ 中的每个顶点 $\nu_{i}$ 建立一个单链表，第i个单链表中的结点表示依附于顶点 $\nu_{i}$ 的边（对于有向图则是以顶点 $v_{i}$ 为尾的弧），这个单链表就称为顶点 $\nu_{i}$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻接表中存在两种结点：顶点表结点和边表结点，如图6.6所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ad0c70c97181ad46888d00bf7d1e1937cfcb142dda79077f20ff660fa09fa94.jpg)  
图6.6顶点表和边表结点结构  
顶点表结点由两个域组成：顶点域（data）存储顶点 $v_{i}$ 的相关信息，边表头指针域（firstarc）指向第一条边的边表结点。边表结点至少由两个域组成：邻接点域（adjvex）存储与头结点顶点  $v_{i}$  邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。  

# 命题追踪图的邻接表存储的应用（2014）  

无向图和有向图的邻接表的实例分别如图6.7和图6.8所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3503c0ddc86c46b037cc84f917b3f4f690516b2cbec074113c67d50a2be472cf.jpg)  
图6.7无向图邻接表表示法实例  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99831cb9adda79d80ce0087a8c64203ed478c2696ff7c44eddc97b0e34c61786.jpg)  
图6.8有向图邻接表表示法实例  

图的邻接表存储结构定义如下：  

#define Max Vertex Num 100/图中顶点数目的最大值typedef struct ArcNode{/边表结点int adjvex;/该弧所指向的顶点的位置struct ArcNode \*nextarc;/指向下一条弧的指针l/InfoType info; //网的边权值  

)ArcNode;  

typedef struct VNode{//顶点表结点Vertex Type data;//顶点信息ArcNode \*firstarc;/指向第一条依附该顶点的弧的指针  

)VNode,AdjList[Max Vertex Num];  

AdiList vertices;川/邻接表int vexnum,arcnum;/图的顶点数和弧数)ALGraph;I/ALGraph是以邻接表存储的图类型  

图的邻接表存储方法具有以下特点：  

$\textcircled{\scriptsize{1}}$  若  $G$  为无向图，则所需的存储空间为  $O(|V|+2|E|)$  ；若  $G$  为有向图，则所需的存储空间为  $O(|V|+|E|)$ 。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。  

# 命题追踪邻接矩阵法和邻接表法的适用性差异（2011）  

$\circledcirc$ 对于稀疏图（即边数较少的图），采用邻接表表示将极大地节省存储空间。  
$\textcircled{3}$ 在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。  

$\textcircled{4}$ 在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点 $x$ 的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为 $x$ 的边表结点个数。  

$\circledast$ 图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。  

# 6.2.3十字链表  

十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧结点）来表示，每个顶点也用一个结点（顶点结点）来表示。两种结点的结构如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74266ee7e563c116de5fb9a491b7ab8fe3ff5c963390bb5cd61fc774107b00af.jpg)  

弧结点中有5个域：tailvex和headvex两个域分别指示弧尾和弧头这两个顶点的编号；头链域hlink指向弧头相同的下一个弧结点；尾链域tlink指向弧尾相同的下一个弧结点；info域存放该弧的相关信息。这样，弧头相同的弧在同一个链表上，弧尾相同的弧也在同一个链表上。  

顶点结点中有3个域：data域存放该顶点的数据信息，如顶点名称；firstin域指向以该顶点为弧头的第一个弧结点；firstout域指向以该顶点为弧尾的第一个弧结点。  

图6.9为有向图的十字链表表示法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22cd3b3c3edea93d459339c492f17aca8da4b3af583a22feddb788230535e18b.jpg)  
图6.9有向图的十字链表表示（弧结点省略info域）  

注意，顶点结点之间是顺序存储的，弧结点省略了info域。  

在十字链表中，既容易找到 $V_{i}$ 为尾的弧，也容易找到 $V_{i}$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。  

# 6.2.4邻接多重表  

邻接多重表是无向图的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca384d2315602e299aa8d39ceb099e8698afb0d7699ccc8d0753379c1c14fd9d.jpg)  

其中，ivex和jvex这两个域指示该边依附的两个顶点的编号；ilink域指向下一条依附于顶点ivex的边；jlink域指向下一条依附于顶点jvex的边，info域存放该边的相关信息。  

每个顶点也用一个结点表示，它由如下所示的两个域组成。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d2235b1c5b4ab153bc8da98b8ef339ac5118bd7a377aa55aa99addf45c45911.jpg)  

其中，data 域存放该顶点的相关信息，firstedge 域指向第一条依附于该顶点的边。  

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。  

图6.10为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/00d0a1988e38e61fac9ff788e80b20481d9c5be4523450b723ae3a32fba6dab2.jpg)  
图6.10无向图的邻接多重表表示（边结点省略info域）  

图的四种存储方式的总结如表6.1所示。  

表6.1图的四种存储方式的总结
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c4a4bbdb4cf810f3765a867f779a8771cbd4a4349fecb05e02ba697baa3b451.jpg)  

# 6.2.5图的基本操作  

图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。  

图的基本操作主要包括（仅抽象地考虑，所以忽略各变量的类型）：  

Adjacent $(G,\mathrm{x},\mathrm{y})$ ：判断图G是否存在边 ${\tt<x}$ y>或 $({\tt x},{\tt y})$ 。·Neighbors $(G,\mathrm{x})$ ：列出图G中与结点 $_\mathrm{x}$ 邻接的边。Insert Vertex  $(G,\mathrm{x})$  ：在图G中插入顶点  $_\mathrm{x}$  。 Delete Vertex  $(G,\mathrm{x})$  ：从图G中删除顶点  $_\mathrm{x}$  

·AddEdge $(\mathtt{G},\mathtt{x},\mathtt{y})$ ：若无向边 $(\mathtt{x},\mathtt{y})$ 或有向边 ${\tt<x}$ ,y>不存在，则向图G中添加该边。  
·RemoveEdge $(\mathtt{G},\mathtt{x},\mathtt{y})$ ：若无向边 $(\mathtt{x},\mathtt{y})$ 或有向边 ${\tt<x}$  $_\mathrm{y}{>}$ 存在，则从图G中册除该边。First Neighbor $(G,\mathrm{x})$ ：求图G中顶点 $_\mathrm{x}$ 的第一个邻接点，若有则返回顶点号。若 $_\mathrm{x}$ 没有邻接点或图中不存在 $_\mathrm{x}$ ，则返回-1。Next Neighbor $(G,\tt x,\tt y)$ ：假设图G中顶点是顶点 $\mathbf{\Deltar}$ 的一个邻接点，返回除外顶点x的下一个邻接点的顶点号，若y是 $_\mathrm{x}$ 的最后一个邻接点，则返回-1。  

Get edge value（G，x，y）：获取图G中边 $(\mathsf{x},\mathsf{y})$ 或 $\ll$  $_\mathrm{y}{>}$ 对应的权值Set edge value（G，x，y，v）：设置图G中边 $({\mathsf{x}}\,,{\mathsf{y}})$ 或 ${\tt C x}$ ，V>对应的权值为V。  

此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历，具体见下一节的内容。  

# 6.2.6 本节试题精选  

# 一、单项选择题  

01.下列关于图的存储结构的说法中，错误的是（）  

A.使用邻接矩阵存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中的顶点数有关，与边数无关B.邻接表只用于有向图的存储，邻接矩阵适用于有向图和无向图C.若一个有向图的邻接矩阵的对角线以下的元素为0，则该图的拓扑序列必定存在D.存储无向图的邻接矩阵是对称的，所以只需存储邻接矩阵的下（或上）三角部分  

02.若图的邻接矩阵中主对角线上的元素皆为0，其余元素全为1，则该图一定（）A.是无向图B.是有向图C.是完全图D.不是带权图03.在含有 $n$ 个顶点和 $e$ 条边的无向图的邻接矩阵中，零元素的个数为（）A. B.2e C.  $n^{2}\!-\!e$  D.  $n^{2}\!-\!2e$  04.带权有向图 $G$ 用邻接矩阵存储，则 $v_{i}$ 的入度等于邻接矩阵中（）  

A.第 $i$ 行非的元素个数B.第i列非o的元素个数C.第 $i$ 行非 $\infty$ 且非0的元素个数D.第 $i$ 列非 $\infty$ 且非0的元素个数  

05.一个有 $n$ 个顶点的图用邻接矩阵 $_A$ 表示，若图为有向图，顶点 $\boldsymbol{v}_{i}$ 的入度是（）；若图为无向图，顶点 $v_{i}$ 的度是（）。  

A. A[i]] B Z A[][] j=1 j=l C A[][] D. ∑A[或A] /=1 j=1  

06.从邻接矩阵 $A\,{=}\,{\left[\begin{array}{l l l}{0}&{1}&{0}\\ {1}&{0}&{1}\\ {0}&{1}&{0}\end{array}\right]}$ 可以看出，该图共有（ $\circledcirc$ ）个顶点；若是有向图，则该图共有 $\circledcirc$ ）条弧；若是无向图，则共有（ $\textcircled{3}$ ）条边。  

$\textcircled{\scriptsize{1}}$ A.9B.3C.6D.1E.以上答案均不正确 $\circledcirc$ A.5B.4C.3D.2E.以上答案均不正确 $\textcircled{3}$ A.5B.4C.3D.2E.以上答案均不正确  

07.以下关于图的存储结构的叙述中，正确的是（）  

A.一个图的邻接矩阵表示唯一，邻接表表示唯一B.一个图的邻接矩阵表示唯一，邻接表表示不唯一  
C.一个图的邻接矩阵表示不唯一，邻接表表示唯一D.一个图的邻接矩阵表示不唯一，邻接表表示不唯一  

08.矩阵 $_A$ 是有向图 $G$ 的邻接矩阵，若矩阵 $A^{2}$ 的某元素 $a_{i,j}^{2}=3$ ，则说明（）  

A.从顶点i到j存在3条长度为2的路径B.从顶点i到 $j$ 存在3条长度不超过2的路径C.从顶点i到 $j$ 存在2条长度为3的路径D.从顶点i到 $j$ 存在2条长度不超过3的路径  

09.用邻接表法存储图所用的空间大小（）  

A.与图的顶点数和边数有关 B.只与图的边数有关 C.只与图的顶点数有关D.与边数的平方有关  

10.若邻接表中有奇数个边表结点，则（）  

A.图中有奇数个结点B.图中有偶数个结点C.图为无向图D.图为有向图  

11.在有向图的邻接表存储结构中，顶点V在边表中出现的次数是（）。  

A.顶点 $v$ 的度B.顶点v的出度C.顶点 $v$ 的入度D.依附于顶点v的边数  

12. $n$ 个顶点的无向图的邻接表最多有（）个边表结点。  

A.  $n^{2}$  B.  $n(n-1)$  C.  $n(n+1)$  D.n(n-1)/2  

13.设某无向图中有 $n$ 个顶点和 $e$ 条边，则建立该图的邻接表的时间复杂度是（）  

A.  $O(n+e)$  B.  $O(n^{2})$  C.O(ne) D. 0(n)  

14.假设有 $n$ 个顶点、 $e$ 条边的有向图用邻接表表示，则删除与某个顶点 $v$ 相关的所有边的时间复杂度为（）。  

A.  $O(n)$  B.O（e) C.  $O(n+e)$  D.O(ne)  

15.对邻接表的叙述中，（）是正确的。  

A.无向图的邻接表中，第 $i$ 个顶点的度为第 $i$ 个链表中结点数的两倍B.邻接表比邻接矩阵的操作更简便 C.邻接矩阵比邻接表的操作更简便 D.求有向图结点的度，必须遍历整个邻接表  

16.邻接多重表是（）的存储结构。  

A.无向图B.有向图C.无向图和有向图D.都不是  

17.十字链表是（）的存储结构。  

A.无向图B.有向图C.无向图和有向图D.都不是  

18.【2013统考真题】设图的邻接矩阵 $_{A}$ 如下所示，各顶点的度依次是（）  

$$
\scriptstyle A\,=\left[{\begin{array}{l l l l}{0}&{1}&{0}&{1}\\ {0}&{0}&{1}&{1}\\ {0}&{1}&{0}&{0}\\ {1}&{0}&{0}&{0}\end{array}}\right]
$$  

A.1,2,1,2 B.2,2,1,1 C.3,4,2,3 D.4,4,2,2  
# 二、综合应用题  

01.已知带权有向图 $G$ 的邻接矩阵如下图所示，请画出该带权有向图 $G_{\circ}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e986200ebffb3e2e847574ec2d8cb2b16cc40309415c468504bedfc290037d2.jpg)  

02.设图 $G\!=\!(V,E)$ 以邻接表存储，如下图所示。画出其邻接矩阵存储及图 $G_{\circ}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d0304ae666b26ec9298d8630abc81094a4702bc792a790f18a2bcd1ef391e7bd.jpg)  

03.对 $n$ 个顶点的无向图和有向图，分别采用邻接矩阵和邻接表表示时，试问：  

1）如何判别图中有多少条边？2）如何判别任意两个顶点 $i$ 和j是否有边相连？3）任意一个顶点的度是多少？  

04.如何对无环有向图中的顶点重新编号，使得该图的邻接矩阵中所有的1都集中到对角线以上？  

05.写出从图的邻接表表示转换成邻接矩阵表示的算法。  

06.【2015统考真题】已知含有5个顶点的图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/871483a033da33ec98320eb30e60f4b8b6ac60df1748890aeea46c36082b2d47.jpg)  

请回答下列问题：  

1）写出图 $G$ 的邻接矩阵 $_A$ （行、列下标从0开始）2）求 $A^{2}$ ，矩阵 $A^{2}$ 中位于 $0$ 行3列元素值的含义是什么？3）若已知具有 $n$ C $n{\geqslant}2$ ）个顶点的图的邻接矩阵为 $\pmb{{\cal B}}$ ，则 $B^{m}$ C $2{\leqslant}m{\leqslant}n$ ）中非零元素的含义是什么？  

07.【2021统考真题】已知无向连通图  $G$  由顶点集V和边集  $E$  组成，  $|{\cal E}|>0$  ，当  $G$  中度为奇 数的顶点个数为不大于2的偶数时， $G$ 存在包含所有边且长度为 $|E|$ 的路径（称为EL路径）。设图 $G$ 采用邻接矩阵存储，类型定义如下：  

type def struct{ /图的定义 intnum Vertices,numEdges;/图中实际的顶点数和边数char Vertices List[MAxV];//顶点表。MAXV为已定义常量int Edge[MAXV][MAXV]: /邻接矩阵 }MGraph;  

请设计算法intIsExistEL（MGraphG），判断G是否存在EL路径，若存在，则返回1，否则返回0。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  
08.【2023统考真题】已知有向图 $G$ 采用邻接矩阵存储，类型定义如下：  

type def struct{ //图的类型定义 int num Vertices,numEdges;/图的顶点数和有向边数char Vertices List[MAxV];//顶点表，MAXV为已定义常量int Edge[MAXV][MAxV];/邻接矩阵MGraph;  

将图中出度大于入度的顶点称为K顶点。例如，在下图中，顶点a和b为K顶点  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c93096aa4fb4bcf746bc336579fe7ba38f5f060f75d0a73d3294bf96a5883907.jpg)  

in t print Vertices（MGraphG），G，输出G中所有的K顶点，并返回K顶点的个数。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。  

# 6.2.7 答案与解析  

# 一、单项选择题  

01.B  

$n$ 个顶点的图，若采用邻接矩阵表示，不考虑压缩存储，则存储空间大小为 $O(n^{2})$ ，A正确。邻接表可用于存储无向图，只是把每条边都视为两条方向相反的有向边，因此需要存储两次，B错误。因为邻接矩阵中对角线以下的元素全为0，所以若存在 ${\scriptscriptstyle<\!i},{\scriptscriptstyle>}$ ，则必有 $i<j$ 由传递性可知图中路径的顶点编号是依次递增的，假设存在环 $k\!\!\to\!\!\dots\!\!\to\!\!j\!\!\to\!\!k$ ，由题设可知 $k<j<k$ ，承盾，所以不存在环，拓扑序列必定存在，C正确。D显然正确。  

# 注意  

若邻接矩阵对角线以下（或以上）的元素全为0，则图中必然不存在环，即拓扑序列一定存在，但这并不能说明拓扑序列是唯一的。  

02.C  

除主对角线上的元素外，其余元素全为1，说明任意两个顶点之间都有边相连，因此该图一定是完全图。  

03.D  

在无向图的邻接矩阵中，矩阵大小为 $n^{2}$ ，非零元素的个数为 $_{2e}$ ，所以零元素的个数为 $n^{2}\!-\!2e$ 。读者应掌握此题的变体，即当无向图变为有向图时，能够求出零的个数和非零的个数。  

04.D  

带权有向图的邻接矩阵中，0和表示的都不是有向边，而入度是由邻接矩阵的列中元素计算出来的：出度是由邻接矩阵的行中元素计算出来的。  

05.B、D  
有向图的入度是其第 $i$ 列的非0元素之和，无向图的度是第 $i$ 行或第 $i$ 列的非 $0$ 元素之和。  

06.B、B、D  

邻接矩阵的顶点数等于矩阵的行（列）数，有向图的边数等于矩阵中非零元素的个数，无向图的边数等于矩阵中非零元素个数的一半。  

# 注意  

本题中所给的矩阵为对称矩阵，若不是对称矩阵，则必然不可能是无向图。  

07.B  

邻接矩阵表示唯一是因为图中边的信息在矩阵中有确定的位置，邻接表不唯一是因为邻接表的建立取决于读入边的顺序和边表中的插入算法。  

08. A  

设图 $G$ 的邻接矩阵为 $_A$ ， $A^{n}$ 的元素 ${a^{n}}_{i,j}$ 等于从顶点 $i$ 到 $j$ 的长度为 $n$ 的路径的数目，因此 $a_{i,j}^{2}=3$ 表示从顶点 $i$ 到 $j$ 存在3条长度为2的路径。该结论记住即可。  

09. A  

邻接表存储时，顶点数 $n$ 决定了顶点表的大小，边数 $e$ 决定了边表结点的个数，且无向图的每条边存储两次，总存储空间为 $O(n+2e)$ 。而邻接矩阵只与图的顶点数有关，为 $O(n^{2})$  

10.D  

无向图采用邻接表表示时，每条边存储两次，所以其边表结点的个数为偶数。题中边表结点为奇数个，所以必然是有向图，且有奇数条边。  

11.C  

题中的边表是不包括顶点表的。因为任何顶点 $u$ 对应的边表中存放的都是以 $u$ 为起点的边所对应的另一个顶点v。从而 $v$ 在边表中出现的次数也就是它的入度。  

12.B 最多有 $n(\,n\!-\!1\,)/2$ 条边，每条边在邻接表中存储两次，因此边表结点最多为 $n(\,n\!-\!1$ ）个。  

13.A  

建立图的邻接表需要遍历所有的顶点和边，每个顶点有一个顶点表结点，每条边需要创建一个边表结点并插入到相应的链表中。因此，共需 $n+2e$ 次操作，时间复杂度为 $O(n+e)$  

14.C  

与顶点 $\nu$ 相关的边包括出边和入边，对于出边，只需遍历 $v$ 的顶点表结点和其指向的边表：对于入边，则需遍历整个边表。先删除出边：删除 $v$ 的顶点表结点的单链表，出边数最多为 $n\!-\!1$ ，时间复杂度为 $O(n)$ ：再删除入边：扫描整个边表（即扫描剩余全部顶点表结点及其指向的边表），删除所有的顶点 $\nu$ 的入边，时间复杂度为 $O(n+e)$ 。所以总时间复杂度为 $O(n+e)$ 。  

15.D  

无向图的邻接表中，第 $i$ 个顶点的度为第 $i$ 个链表中的结点数，所以选项A错。邻接表和邻接矩阵对于不同的操作各有优势，选项B和C都不准确。有向图结点的度包括出度和入度，对于出度，需要遍历顶点表结点所对应的边表：对于入度，则需要遍历剩下的至部边表。  

16.A 邻接多重表是无向图的存储结构。  

17.B 十字链表是有向图的存储结构。  
18.C  

邻接矩阵A为非对称矩阵，说明图是有向图，度为入度与出度之和。各顶点的度是矩阵中此结点对应的行（对应出度）和列（对应入度）的非零元素之和。  

# 二、综合应用题  

01.【解答】  

带权有向图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/df6e89b4cefa3f7daaf65b0fe56116fb237590d91c96f58515fb459c056f2809.jpg)  

02.【解答】  

其邻接矩阵存储如下所示。  

在邻接表中，每条边存储了2次，在没有特殊说明时，通常默认其为无向图（当然，无向图也可视为具有对边的有向图）。该邻接表对应的图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e95de7c80d4299d3ee308bcfe57663e3fa6e77953b19f1d83e51f5bc4d4d4be.jpg)  

03.【解答】  

1）对于邻接矩阵表示的无向图，边数等于矩阵中1的个数除以2：对于邻接表表示的无向图，边数等于边结点的个数除以2。对于邻接矩阵表示的有向图，边数等于矩阵中1的个数；对于邻接表表示的有向图，边数等于边结点的个数。  

2）在邻接矩阵表示的无向图或有向图中，对于任意两个顶点 $i$ 和 $j$ ，邻接矩阵中arcs[i][j]或arcs[j][i]为1表示有边相连，否则表示无边相连。在邻接表表示的无向图或有向图中，对于任意两个顶点 $i$ 和 $j$ ，若从顶点表结点 $i$ 出发找到编号为 $j$ 的边表结点或从顶点表结点出发找到编号为 $i$ 的边表结点，表示有边相连；否则为无边相连。  

3）对于邻接矩阵表示的无向图，顶点 $i$ 的度等于第 $i$ 行中1的个数：对于邻接矩阵表示的有向图，顶点 $i$ 的出度等于第 $i$ 行中1的个数；入度等于第 $i$ 列中1的个数；度数等于它  
们的和。对于邻接表表示的无向图，顶点 $i$ 的度等于顶点表结点 $i$ 的单链表中边表结点的个数：对于邻接表表示的有向图，顶点 $i$ 的出度等于顶点表结点 $i$ 的单链表中边表结点的个数，顶点 $i$ 的入度等于邻接表中所有编号为i的边表结点数；度数等于入度与出度之和。  

04.【解答】  

按各顶点的出度进行排序。 $n$ 个顶点的有向图，其顶点的最大出度是 $_{n-1}$ ，最小出度为0。这样排序后，出度最大的顶点编号为1，出度最小的顶点编号为 $n$ 。之后，进行调整，即只要存在弧<i，>，就不管顶点 $j$ 的出度是否大于顶点 $i$ 的出度，都把 $i$ 编号在顶点 $j$ 的编号之前，因为只有 $i{\leqslant}j$ ，弧 $<\!i,j\!>$ 对应的1才能出现在邻接矩阵的上三角。  

通过后面小节的学习，会发现采用拓扑排序并依次编号是一种更为简便的方法。  

05.【解答】  

算法思想：设图的顶点分别存储在数组 $\upsigma[\mathrm{n}]$ 中。首先初始化邻接矩阵。遍历邻接表，在依次遍历顶点v[i]的边链表时，修改邻接矩阵的第i行的元素值。若链表边结点的值为j，则置arcs[i][j] $^{=1}$ 。遍历完邻接表时，整个转换过程结束。此算法对于无向图、有向图均适用。  

算法的实现如下：  

void Convert（ALGraph &G,int arcs[M][N])//此算法将邻接表方式表示的图G转换为邻接矩阵arcsfor $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$ ;i<n; $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ {//依次遍历各顶点表结点为头的边链表 $\mathsf{p}\mathrm{=\pi}\left(\mathsf{G}\mathrm{-}\mathrm{>}\mathsf{v}\left[\mathrm{i}\right]\right.$ ).firstarc;/取出顶点i的第一条出边while（p!=NULL){//遍历边链表arcs[i][p->adjvex]  $^{=1}$  p=p->nextarc; //取下一条出边 //while llfor  

06.【解答】  

考查图的邻接矩阵的性质。  

1）图 $G$ 的邻接矩阵 $\pmb{A}$ 如下  

$A={\left[\begin{array}{l l l l}{0}&{1}&{1}&{0}&{1}\\ {1}&{0}&{0}&{1}&{1}\\ {1}&{0}&{0}&{1}&{0}\\ {0}&{1}&{1}&{0}&{1}\\ {1}&{1}&{0}&{1}&{0}\end{array}\right]}$  

2) $A^{2}$ 如下：  

$$
A^{2}={\left[\begin{array}{l l l l}{3}&{1}&{0}&{3}&{1}\\ {1}&{3}&{2}&{1}&{2}\\ {0}&{2}&{2}&{0}&{2}\\ {3}&{1}&{0}&{3}&{1}\\ {1}&{2}&{2}&{1}&{3}\end{array}\right]}
$$  

0行3列的元素值3表示从顶点0到顶点3之间长度为2的路径共有3条。  
3) $B^{m}$  $2{\leqslant}m{\leqslant}n!$ ）中位于 $i$ 行 $j$ 列（ $\scriptstyle0\leqslant i,$  $j\!\leqslant\!n\!-\!1$ ）的非零元素的含义是，图中从顶点i到顶点 $j$ 的长度为 $m$ 的路径条数。  

07.【解答】  

1）算法的基本设计思想  

本算法题属于送分题，题干已经告诉我们算法的思想。对于采用邻接矩阵存储的无向图，在邻接矩阵的每一行（列）中，非零元素的个数为本行（列）对应顶点的度。可以依次计算连通图 $G$ 中各顶点的度，并记录度为奇数的顶点个数，若个数为0或2，则返回1，否则返回0。  

2）算法实现  

int IsExistEL(MGraph G){/采用邻接矩阵存储，判断图是否存在EL路径int degree,i,j,count  $=\!0$  for( $\scriptstyle{\dot{\boldsymbol{\perp}}}=0$  $_{\perp<G}$ .num Vertices; $\ \ \mathrm{i}_{++}$ ）degree  $=\!0$  for(  $\scriptstyle{\dot{\mathbf{\rho}}}=0$   $\gimel G$  .num Vertices;j++) degree $\scriptstyle+=G$ .Edge[i][j];/依次计算各个顶点的度if(degree%2  $!\!=\!\!0$  count++;/对度为奇数的顶点计数if(count  $==0$  lcount  $==2$  1 return1;//存在EL路径，返回1else return 0;/不存在EL路径，返回0  

3）时间复杂度和空间复杂度  

算法需要遍历整个邻接矩阵，所以时间复杂度是 $O(n^{2})$ ，空间复杂度是 $O(1)$  

08.【解答】  

1）算法的基本设计思想  

采用邻接矩阵表示有向图时，一行中1的个数为该行对应顶点的出度，一列中1的个数为该列对应顶点的入度。使用一个初值为零的计数器记录K顶点的个数。对图G的每个顶点，根out degree in degree。若outdegree-indegree>0，则输 出该顶点且计数器加1。最后返回计数器的值。  

2）用C语言描述的算法：  

int print Vertices(MGraph G){ /采用邻接矩阵存储，输出K顶点，返回个数int indegree,outdegree,k,m,count  $=\!0$  for $\kappa{=}0$  $\kappa{<}G$ .num Vertices; $\kappa++$ ）indegree  $=$  outdegree  $=\!0$  for $\scriptstyle{\mathrm{im}}=0$  $\mathtt{m c}_{\mathrm{G}}$ .num Vertices; $\mathtt{m}{\mathrel{+{+}}}$ /计算顶点的出度outdegreet  $\scriptstyle\cdot=G$  .Edge[k][m]; for $\scriptstyle{\mathrm{m}}=0$  $\mathtt{m c}_{\mathrm{G}}$ .num Vertices; $\mathrm{m++}$ //计算顶点的入度indegree  $\scriptstyle+=G$  .Edge[m][k]; if(outdegree>indegree){ printf("&c",G.Vertices List[k]); count  ${++}$  
# 6.3图的遍历  

图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次，且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。  

图的遍历比树的遍历要复杂得多，因为图的任意一个顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组visited[门]来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。  

# 6.3.1 广度优先搜索  

广度优先搜索（Breadth-First-Search，BFS）类似于二叉树的层序遍历算法。基本思想是：首 先访问起始顶点 $v$ ，接着由 $\nu$ 出发，依次访问v的各个未访问过的邻接顶点 $w_{1},\,w_{2},\cdots,\,w_{i}$ ，然后依次访问  $w_{1},$   $w_{2},\cdots$   $w_{i}$  的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所 有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra单源最短路径算法和 $\operatorname{Prim}$ 最小生成树算法也应用了类似的思想。  

换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和 $\nu$ 有路径相通且路径长度为12，的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。  

广度优先搜索算法的伪代码如下：  

bool visited[MAX VERTEX NUM];//访问标记数组void BF S Traverse（Graph G){//对图G进行广度优先遍历for(  $\scriptstyle{\mathrm{~i}}=0$  ;i<G.vexnum;  ${++}\,{\mathrm{i}}$  visited[i] $=$ FALSE;//访问标记数组初始化InitQueue(Q); //初始化辅助队列Q for( $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$ ;i<G.vexnum; ${++}\,{\mathrm{i}}$ //从0号顶点开始遍历if(!visited[i])//对每个连通分量调用一次BFS（）BFS(G,i);/诺 $v_{i}$ 未访问过，从v开始调用BFS（)  

用邻接表实现广度优先搜索的算法如下：  

void BFS（ALGraph G,int i){ //访问初始顶点ivisit（i); visited[i] $=$ TRUE;//对i做已访问标记EnQueue（Q,i);//顶点i入队while(!IsEmpty(Q)){ DeQueue(Q,v);/队首顶点v出队  
$w=\mathtt{p}->$  adjvex; if(visited  $[w]==$  FALSE){ visit（w); l/w为  $\triangledown$  的尚未访问的邻接点，访问w visited[w] $=$ TRUE;//对w做已访问标记EnQueue $(Q,w)$ ”//顶点 $\mathbf{w}$ 入队  

用邻接矩阵实现广度优先搜索的算法如下：  

void BFS（MGraph G,int i)(visit（i);//访问初始顶点ivisited[i]  $=$  TRUE; 对1做已访问标记 EnQueue（Q,i）;//顶点i入队while(!IsEmpty(Q)){ DeQueue(Q,v);/队首顶点v出队for $w\!=\!0$  $w\!<\!G$ .vexnum; $w++$ 1//检测 $\mathtt{v}$ 的所有邻接点if(visited  $[w]==$  FALSE&&G.edge[v][w]  $==1$  visit(w); /w为  $\mathbf{v}$  的尚未访问的邻接点，访问  $w$  visited[w]  $=$  TRUE; 1对  $w$  做已访问标记 EnQueue $(Q,w)$ //顶点 $\mathbf{w}$ 入队  

辅助数组visited[]标志顶点是否被访问过，其初始状态为FALSE。在图的遍历过程中，一旦某个顶点 $\nu_{i}$ 被访问，就立即置visited[i]为TRUE，防止它被多次访问。  

# 命题追踪广度优先遍历的过程（2013）  

下面通过实例演示广度优先搜索的过程，给定图 $G$ 如图6.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42543e3cbbf650ee51abdafe55648cf488f5a427608b8a1e32178060c28985aa.jpg)  
图6.11一个无向图 $G$  

假设从顶点 $a$ 开始访问， $a$ 先入队。此时队列非空，取出队头元素 $a$ ，因为 $^b$  $c$ 与 $a$ 邻接且未被访问过，于是依次访问 $b,\,c$ ，并将 $^b$  $c$ 依次入队。队列非空，取出队头元素 $^b$ ，依次访问与 $b$ 邻接且未被访问的顶点 $d,e$ ，并将 $d,e$ 入队（注意： $a$ 与 $^b$ 也邻接，但 $a$ 已置访问标记，所以不再重复访问）。此时队列非空，取出队头元素 $c$ ，访问与 $c$ 邻接且未被访问的顶点 $f,\,g$ ，并将 $f,g$ 入队。此时，取出队头元素 $d$ ，但与 $d$ 邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素 $e$ ，将 $h$ 入队列最终取出队头元素 $h$ 后，队列为空，从而循环自动跳出。遍历abcde f gh  

从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。  
# 1.BFS算法的性能分析  

无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列 $\mathcal{Q}$  $n$ 个顶点均需入队一次，在最坏的情况下，空间复杂度为 $O(|V|)$  

# 命题追踪基于邻接表存储的BFS的效率（2012）  

遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结 构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为 $O(|V|)$ ，在搜索每个顶点的邻接点时，每条边至少访问一次，时间复杂度为 $O(|E|)$ ，总的时间复杂度为 $O(|V|+|E|)$ 。采用邻接矩阵存储时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，总时间复杂度为 $O(|V|^{2})$  

# 2.BFS算法求解单源最短路径问题  

若图 $G=(V,\,E)$ 为非带权图，定义从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u,\,v)$ 为从 $u$ 到 $\nu$ 的任何路径中最少的边数；若从  $u$  到  $\nu$  没有通路，则  $d(u,v)=\infty$  6  

使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。  

BFS算法求解单源最短路径问题的算法如下：  

void BFS MIN Distance（Graph G,int u){ /ld[i]表示从u到i结点的最短路径 for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<G.vexnum;  ${++i}$   ${\sf d}\left[\dot{\Sigma}\right]\!=\!\infty$ //初始化路径长度visited[u]  $=$  TRUE;d[u]  $=\!0$  EnQueue（Q,u）;while(!isEmpty(Q)){/BFS算法主过程DeQueue(Q,u);/队头元素u出队for  $w=$  First Neighbor(G,u);  $w\!>\!=\!0$   $w=$  Next Neighbor（G,u,w)) if(!visited[w]){//为u的尚未访问的邻接顶点visited[w]  $=$  TRUE; //设已访问标记 d[w]  $\scriptstyle=\operatorname{d}$  [u]  $^{+1}$  /路径长度加1 EnQueue(Q,w);/顶点w入队  

# 3.广度优先生成树  

在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a558e1e1aab5256ec092199096715091d9fd2bed801b23092ca6ae4ea150bdf2.jpg)  
图6.12图的广度优先生成树  
# 6.3.2 深度优先搜索  

与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。  

它的基本思想如下：首先访问图中某一起始顶点 $v$ ，然后由 $v$ 出发，访问与 $v$ 邻接且未被访问的任意一个顶点 $w_{1}$ ，再访问与 $w_{1}$ 邻接且未被访问的任意一个顶点 $w_{2}$ …重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该 点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。  

一般情况下，其递归形式的算法十分简洁，算法过程如下：  

bool visited[MAX VERTEX NUM];/访问标记数组void DF S Traverse(Graph G){I/对图G进行深度优先遍历for  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\dot{\mathbf{z}}}<G$  .vexnum;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  visited[i] $=$ FALSE;//初始化已访问标记数组for $\scriptstyle{\dot{\mathbf{1}}}=0$  $\scriptstyle{\mathrm{~i}}<G$ .vexnum; $\dot{\mathbf{x}}_{++}$ 川本代码中是从 $v_{0}$ 开始遍历if(!visited[i])/对尚未访问的顶点调用DFS（）DFS(G,i);  

用邻接表实现深度优先搜索的算法如下：  

void DFS（ALGraph G,int i）{visit(i);/访问初始顶点ivisited[i]  $=$  TRUE; /对1做已访问标记 for $\scriptstyle{\mathfrak{p}}=G$ .vertices[i].firstarc;p; $\scriptstyle{\mathbb{P}}^{=}\mathbb{P}$ ->nextarc）（/检测i的所有邻接点j=p->adjvex; if（visited[j]  $==$  FALSE) DES(G,j）;为i的尚未访问的邻接点，递归访问  

用邻接矩阵实现深度优先搜索的算法如下：  

void DFS（MGraph G,int i）{visit（i);//访问初始顶点ivisited[i]  $=$  TRUE; /对1做已访问标记 for $(\stackrel{.}{\mathrm{j}}=\stackrel{0}{0}$ j<G.vexnum; $\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\$ //检测i的所有邻接点if(visited[j]  $==$  FALSE&&G.edge[i][j]  $==1$  DFS(G,j);j为i的尚未访问的邻接点，递归访问  

# 命题追踪深度优先遍历的过程（2015、2016）  

以图6.11的无向图为例，深度优先搜索的过程：首先访问 $a$ ，并置 $a$ 访问标记：然后访问与 $a$ 邻接且未被访问的顶点 $b$ ，置 $^b$ 访问标记：然后访问与 $^b$ 邻接且未被访问的顶点 $d$ ，置 $d$ 访问标记。此时 $d$ 已没有未被访问过的邻接点，所以返回上一个访问的顶点 $^b$ ，访问与其邻接且未被访问的顶点 $e$ ，置 $e$ 访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。  

# 注意  

图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得到的DFS序列和BFS序列是不唯一的。  
1.DFS算法的性能分析  

DFS算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为 $O(|V|)$  

遍历图的过程实质上是通过边查找邻接点的过程，因此两种遍历方式的时间复杂度都相同，不同之处仅在于对顶点访问顺序的不同。采用邻接矩阵存储时，总时间复杂度为 $O(|V|^{2})$ 采用邻接表存储时，总的时间复杂度为 $O(|V|+|E|)$  

# 2.深度优先的生成树和生成森林  

与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林，如图6.13所示。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80ef10fc4c40d90faf1f0f3f8503446a41b03c6ef2278ea05623bcbf8a932ea2.jpg)  
图6.13图的深度优先生成森林  

# 6.3.3图的遍历与图的连通性  

图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。  

因此，在BFSTraverse（)或DFSTraverse（）中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS(G，i)或DFS（G，i）的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS（G，i)或DFS（G，i)无法访问到该连通分量的所有顶点，如图6.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/823fee21850cd372fbc2f6401fff35ce59784df00323e94b4176edf7aeec0711.jpg)  
图6.14有向图的非强连通分量  

# 6.3.4 本节试题精选  

# 一、单项选择题  

01.下列关于广度优先算法的说法中，正确的是（）  

1.当各边的权值相等时，广度优先算法可以解决单源最短路径问题II.当各边的权值不等时，广度优先算法可用来解决单源最短路径问题I11.广度优先遍历算法类似于树中的后序遍历算法IV.实现图的广度优先算法时，使用的数据结构是队列  

A. 1、IVB.ⅡI、III、IVC. II、IVD.I、II、IV  

02.下列关于图的说法中，错误的是（）  
1.对一个无向图进行深度优先遍历时，得到的深度优先遍历序列是唯一的I1.若有向图不存在回路，即使不用访问标志位，同一结点也不会被访问两次I1I.采用深度优先遍历或拓扑排序算法可以判断一个有向图中是否有环（回路）IV.对任何非强连通图必须2次或以上调用广度优先遍历算法才可访问所有的顶点  

A.I、II、ⅢIB.II、ⅢIC.I、1ID.I、II、IV  

03.对于一个非连通无向图 $G$ ，采用深度优先遍历访问所有顶点，在DFSTraVerSe函数（见考点讲解DFS部分）中调用DFS的次数正好等于（）。  

A.顶点数B.边数C.连通分量数D.不确定  

04.对一个有 $n$ 个顶点、é条边的图采用邻接表表示时，进行DFS遍历的时间复杂度为（），空间复杂度为（）；进行BFS遍历的时间复杂度为（），空间复杂度为（）。  

A.O(n)N B.O(e) C.  $O(n+e)$  D. 0(1)  

05.图的广度优先遍历算法中使用队列作为其辅助数据结构，那么在算法执行过程中，每个顶点的入队次数最多为（）  

A.1 B.2 C.3 D.4  

06.对有 $n$ 个顶点、 $e$ 条边的图采用邻接矩阵表示时，进行DFS遍历的时间复杂度为（）进行BFS遍历的时间复杂度为（）  

A.  $O(n^{2})$  B.O(e) C.  $O(n+e)$  D. 0(e²)  

07.无向图 $G=(V,E)$ 其中 $V\!=\!\{a,b,c,d,e,f\},\ E\!=\!\{(a,b),(a,e),(a,c),(b,e),(c,f),(f,d),$  $(e,d)\}$ ，对该图从 $a$ 开始进行深度优先遍历，得到的顶点序列正确的是（）。  

A.  $a,b,e,c,d,f$  B.a,c,fe,b,d C.  $a,e,b,c,f,d\quad\mathrm{~\textbf~{~D.~}~}a,e,d,f,c,b$  

08.如下图所示，在下面的5个序列中，符合深度优先遍历的序列个数是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/44feda8b1aa3d8aab31277757357b31360ad290a2d8cb5d8cba5423222cc9546.jpg)  

1.aebfdc2.acfdeb3.aedfcb4.aefdbc5.aecfdb A.5 B.4 C.3 D.2  

09.用邻接表存储的图的深度优先遍历算法类似于树的（），而其广度优先遍历算法类似于树的（）。  

A.中序遍历B.先序遍历C.后序遍历D.按层次遍历  

10.一个有向图 $G$ 的邻接表存储如下图所示，从顶点1出发，对图 $G$ 调用深度优先遍历所得顶点序列是（）；按广度优先遍历所得顶点序列是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa54efd57e1847db85b66dd13f01c92df1fd836e2b6a4c7a561460758249fc82.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1378e07fd052f29e8d3a2e8502fcc2a602778972a3c472f13540ecc08e1ed28d.jpg)  

A.125436 B.124536 C.124563 D.362514 11.无向图 $G=(V,E)$ ，其中 $V\!=\{a,b,c,d,e,f\}\,,\,\,\,E\!=\{(a,b),(a,e),(a,c),(b,e),(c,f),(f,d\,),$  $(e,d)\}$ 。对该图进行深度优先遍历，不能得到的序列是（）。  
A.acfdeb B.aebdfc C.aedfcb D.abecdf

 12.判断有向图中是否存在回路，除拓扑排序外，还可以利用（）。（注：涉及下节内容）  

A.求关键路径的方法B.DijkstraC.深度优先遍历算法D.广度优先遍历算法  

13.设无向图 $G=(V,E)$ 和 $G^{\prime}\!=\!(V^{\prime},E^{\prime})$ ，若 $G$ 是 $G$ 的生成树，则下列说法错误的是（）。  

A. $G^{\prime}$ 为 $G$ 的子图B. $G$ 为 $G$ 的连通分量C. $G$ 为 $G$ 的极小连通子图且 $V=V^{\prime}$ D. $G$ 是 $G$ 的一个无环子图  

14.图的广度优先生成树的树高比深度优先生成树的树高（）A.小或相等B.小C.大或相等D.大  

15.【2012统考真题】对有 $n$ 个顶点、 $e$ 条边且使用邻接表存储的有向图进行广度优先遍历，其算法的时间复杂度是（）。  

A. O(n) B.O(e) C.  $O(n+e)$  D. O(ne)  

16.【2013统考真题】下列选项中，不是如下无向图的广度优先遍历序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6768e2608ce1d308810cf41988a3ce6d07c37df1af797f413dbf4552ed798a05.jpg)  

A.h,c,a,b,d,e,  $g,f$  B.  $e,a,f,g,b,h,c,d$  C.d,  $b,c,a,h,e,f,f$  8 D.  $a,b,c,d,h,e,f,g$  

17.【2015统考真题】设有向图 $G=(V,\,E)$ ，顶点集 $V=\{V_{0},V_{1},V_{2},V_{3}\}$ ，边集 $E=\{<\!v_{0},\!v_{1}\!>,$  $\scriptstyle<v_{0},v_{2}>$  $\scriptstyle<v_{0},v_{3}>$  $\scriptstyle<v_{1},v_{3}>\}$ 。若从顶点 $V_{0}$ 开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是（）。  

A.2B.3C.4D.5

18.【2016统考真题】下列选项中，不是下图深度优先搜索序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6600f6d8f778a8a8607d53cc3c724ca876a139f2bc76a586ee3dd95e1cc3947.jpg)  

A.  $V_{1},V_{5},V_{4},V_{3},V_{2}$  B.V,V3，V2,Vs,V4 C.  $V_{1},V_{2},V_{5},V_{4},V_{3}$  D.V,V2,V3,V4,Vs  

# 二、综合应用题  

01.图 $G=(V,E)\nu\lambda$ 邻接表存储，如下图所示，试画出图 $G$ 的深度优先生成树和广度优先生成树（假设从结点1开始遍历）  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9281127c00acc39cf80753b14f738dfdb37f868fc5af8189586b225d8aa842e.jpg)  

02.给定一个连通无向图，采用邻接表存储，将图的所有顶点分别染成红色或蓝色，若存在一种染色方法使图中每条边的两个顶点的颜色都不相同，则称这个图能被二分。人  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0256308912671fb20ed8ddf6ff060f059b41d84952ba77a570473f97f4b16870.jpg)  

1）判断上面两个无向图是否能被二分，若能被二分，则请标出每个顶点的颜色。2）请设计一种算法用来判断图是否能被二分，仅用语言描述算法的思想即可。3）给出你设计的算法的时间复杂度和空间复杂度。  

03.试设计一个算法，判断一个无向图 $G$ 是否为一棵树。若是一棵树，则算法返回true，否则返回false。  

04.分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表方式存储的有向图中是否存在由顶点 $v_{\mathrm{i}}$ 到顶点 $v_{j}$ 的路径( $i\neq j$ ）。注意，算法中涉及的图的基本操作必须在此存储结构上实现。  

05.假设图用邻接表表示，设计一个算法，输出从顶点 $V_{i}$ 到顶点 $V_{j}$ 的所有简单路径  

# 6.3.5 答案与解析  

# 一、单项选择题  

01.A  

广度优先搜索以起始结点为中心，一层一层地向外层扩展遍历图的顶点，因此无法考虑到边权值，只适合求边权值相等的图的单源最短路径。广度优先搜索相当于树的层序遍历，选项 mI错误。广度优先搜索需要用到队列，深度优先搜索需要用到栈，选项IV正确。  

02.D  

图的深度优先遍历序列通常是不唯一的，1错误。图1是一个不存在回路的有向图，从顶点1开始执行广度优先遍历，若不设置访问标志位，则会重复访问顶点3，Ⅱ错误。深度优先遍历（见本节后面习题的解析）或拓扑排序算法可以判断有向图中是否有环，ⅢI正确。图2是一个非强连通图，但从顶点1开始调用一次广度优先遍历算法就可访问所有顶点，IV错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f18c9a9794241285abda35d9f051dd1b73b91191764e70668e41b5b17d47e38d.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33905d8575f91778c1644bbae05c138467d530c5a20818bc8bdc73d29d996ee7.jpg)  
图2  

03.C  

DFS（或BFS）可用来计算无向图的连通分量数，因为一次遍历必然会将一个连通图中的所有顶点都访问到，所以计算图的连通分量数正好是DFSTraverSe（)中DFS被调用的次数。  
04.C、A、C、A  

深度优先遍历时，每个顶点表结点和每个边表结点均查找一次，每个顶点递归调用一次，需要借助一个递归工作栈：而广度优先遍历时，也是每个顶点表结点和每个边表结点均查找一次，需要借助一个辅助队列。因此，时间复杂度都是 $O(n+e)$ ，空间复杂度都是 $O(n)$  

05. A  

在图的广度优先遍历算法中，每个顶点被访问后立即做访问标记并入队。若队列不空，则队首顶点出队，若该顶点的邻接顶点未被访问，则访问之，做访问标记并入队：若被访问过，则跳过，如此反复，直至队空。因此，在厂度优先遍历过程中，每个顶点最多入队一次。  

06.A、A  

采用邻接矩阵表示时，查找一个顶点所有出边的时间复杂度为 $O(n)$ ，共有 $n$ 个顶点，所以时间复杂度均为 $O(n^{2})$  

07.D  

画出草图后，此类题可以根据边的邻接关系快速排除错误选项。以A为例，在遍历到é之后，应该访问与 $e$ 邻接但未被访问的结点， $(e,c)$ 显然不在边集中。  

08. D  

仅1和4正确。以2为例，遍历到 $c$ 之后，与 $c$ 邻接且未被访问的结点为空集，所以应为 $^a$ 的邻接点 $b$ 或 $e$ 入栈。以3为例，因为遍历要按栈退回，所以是先 $b$ 后 $c$ ，而不能先 $c$ 后 $b_{\circ}$  

09.B、D  

图的深度优先搜索类似于树的先根遍历，即先访问结点，再递归向外层结点遍历，都采用回浏算法。图的广度优先搜索类似于树的层序遍历，即一层一层向外层扩展遍历，都需要采用队列来辅助算法的实现。  

10.A、B  

DFS序列产生的路径为  ${\vartriangle}1$   $2^{>}$   $^{<2}$   $5\mathrm{>}$   ${<}5$   $4{>}$   $^{<3}$  ，  $6{>}$  ；BFS序列产生的路径为  $\leftrightharpoons$   $^{2>}$  <1,4>  $<2,5>,<3,6>_{\circ}$  

11.D  

画出 $V$ 和 $E$ 对应的图 $G$ ，然后根据搜索算法求解。  

这里应注意：为什么本题序列是不唯一的，而上题序列却是唯一的呢？  

因为上题给出了具体的存储结构，此时就必须按照算法的过程来执行，每个顶点的邻接点的顺序已固定，但本题中每个顶点的邻接点的顺序是非固定的。  

12. C  

利用深度优先遍历可以判断图 $G$ 中是否存在回路。  

对于无向图来说，若深度优先遍历过程中遇到了回边，则必定存在环：对于有向图来说，这条回边可能是指向深度优先森林中另一棵生成树上的顶点的弧；但是，从有向图的某个顶点v出发进行深度优先遍历时，若在DFS(v)结束之前出现一条从顶点 $u$ 到顶点 $v$ 的回边，且 $u$ 在生成树上是的子孙，则有向图必定存在包含顶点 $\nu$ 和顶点 $u$ 的环。  

13.B  

连通分量是无向图的极大连通子图，其中极大的含义是将依附于连通分量中顶点的所有边都加上，所以连通分量中可能存在回路，这样就不是生成树了。  
# 注意  

极大连通子图是无向图（不一定连通）的连通分量，极小连通子图是连通无向图的生成树。极小和极大是在满足连通的前提下，针对边的数目而言的。极大连通子图包含连通分量的全部边；极小连通子图（生成树）包含连通图的全部顶点，且使其连通的边数最少。  

14.A  

对于无向图的广度优先搜索生成树，起点到其他顶点的路径是图中对应的最短路径，即所有生成树中树高最小。此外，深度优先总是尽可能“深”地搜索图，因此其路径也尽可能长，所以深度优先生成树的树高总是大于或等于广度优先生成树的树高。  

15.C  

广度优先遍历需要借助队列实现。采用邻接表存储方式对图进行广度优先遍历时，每个顶点均需入队一次（顶点表遍历），所以时间复杂度为 $O(n)$ ，在搜索所有顶点的邻接点的过程中，每条边至少访问一次（出边表遍历），所以时间复杂度为 $O(e)$ ，算法总的时间复杂度为 $O(n+e)$  

16.D  

只要掌握DFS和BFS的遍历过程，便能轻易解决。逐个代入，手工模拟，选项D是深度优先遍历，而不是广度优先遍历。  

17.D  

画出该有向图，如下图所示。采用图的深度优先遍历，共有5种可能： $<\!\nu_{0},\,\nu_{1},\,\nu_{3},\,\nu_{2}\!>,\,<\!\nu_{0},\,\nu_{2},$ V3, $\nu_{1}{>}$ <Vo,V2,V1,V3>,<Vo,V3,V2, $\nu_{1}\!>$ <V0,V3,V1,V2>。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b9810bad37c4e0283dff2dff1d7d2f28cfc25a750e9d9a33849ff61e54acba7d.jpg)  

18.D  

按深度优先遍历的策略进行遍历。对于A：先访问  $V_{1}$  ，然后访问与  $V_{1}$  邻接且未被访问的任 意一个顶点（满足的有 $V_{2},$  $V_{3}$ 和 $V_{5}.$ ），此时访问 $V_{5}$ ，然后从 $V_{5}$ 出发，访问与 $V_{5}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{4}$ ），然后从 $V_{4}$ 出发，访问与 $V_{4}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{3}$ ），然后从！ $V_{3}$ 出发，访问与 $V_{3}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{2})$ ，结束遍历。B和C的分析方法与A相同。对于D，首先访问 $V_{1}$ ，然后从 $V_{1}$ 出发，访问与 $V_{1}$ 邻接且未被访问的任意一个顶点（满足的有 $V_{2},\,V_{3}$ 和 $V_{5}$ ），然后从 $V_{2}$ 出发，访问与 $V_{2}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{5}$ ），按规则本应该访问 $V_{5}$ ，但D却访问了 $V_{3}$ ，错误。  

# 二、综合应用题  

01.【解答】  

根据  $G$  的邻接表不难画出图（a)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0dacc0ce4ff245995248b13b690c879ad955fc670205a8e52e25d706a090489f.jpg)  
(a)图G  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/65f684d2ae2fb3fba8211e9c60166480082d9063630a5647c81376dbdf577b35.jpg)  
(b）深度优先生成树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2f2910ae8ec451afa1d4dc85b66487877920c98d80f03f76acf52c48c20e424b.jpg)  
（c）广度优先生成树  
1）采用深度优先遍历。深度优先搜索总是尽可能“深”地搜索图，根据存储结构可知深度优先搜索的路径次序为 $(1,2),(2,3),(3,4),(4,5)$ ，深度优先生成树如图（b）所示。需要注意的是，当存储结构固定时，生成树的树形也就固定了，比如不能先搜索（1，3)。2）采用广度优先遍历。广度优先搜索总是尽可能“广”地搜索图，一层一层地向外扩展，根据存储结构可知广度优先搜索的路径次序为（1，2)， $(1,3),$ (1，4)（2.5)，广度优先生成树如图（c）所示。  

# 02.【解答】  

1）右图不能被二分，左图能被二分，染色情况如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40f9e1b96b4abbe71caac80ffad2c2c25d33eeea6ebdb2e2a7ae6ddcbe75020c.jpg)  

2）从任意一个结点开始，将其染成红色，并从该结点开始对整个图进行遍历，在遍历过程中，若当前遍历的结点 $a$ 有一条边指向 $^b$ ，则可能出现三种情况： $@b$ 未被染色，将它染成与结点 $a$ 不同的颜色，并且继续遍历与 $b$ 相连的结点： $@a$ 与 $b$ 的颜色相同，说明该图不能被二分，直接返回： $^{(3)}\footnote{C o r r e s p o n d i n g a u t h o r.T e l:~+86-1088236256.E-m a i l a d d r e s s:g i v e n@i h e c.e d u.c r o s c.e d u.c r i l.a c.e d u.c r o s c u.a n t h e r e s s:g i v e n.e d u.c r i s c u.e d u.c r i l a u.c r.e d u.c r i l a u.c r.e d u.c r i l a u.c r.e d u.c r i l i n e v e n v e r:t h e v e n.c d i s c u.c r i l i n e v e n.c d i t i o n.a c u.c r i l i n e v e n.c d i f i r e n t h e s t:g i v e n.e d u.c r i l i n e v e n.c d i t i o n.a c u.c r i l i n e v e n.c d i f i r e n t:t h e v e n.c d i s c u.c r i l i n e v e n.c d i f i r e n t:t h e s t:g i v e n.c d i f i r e n t:t h e s t:g i v e n.c n a n t h i c u.c r i l i n g a u.c r i l i n g a u.c r.c h i l i n g a u.c r i l i n g a u.c h i l i n g a u.c h i f i r e n t:t h e v e n.c d i f i r e n t:t h e s t:g i v e n.c d i f i r e n t h e s t:h a n i c u.c r i l i n g a u.c r i l i n e v e n u.c d i n t h i c u.c o n t i n i c u.c o n t i n i n g a c u.c o m i n t i n i n i n e v e r.c d i n c u.c d i n t i n g a c u.c o m i n t i n t i n e v e r.c o m i n c u.c o m a n t i n i n i n i n t i n e v e r.c o m i n c u.c o m a n c u.c o m i n t i n i n t i n t i n t i n e v e r.c o m i n c u.c o m i n c u.c o m i n c u.c o m i n c c u.c o m i n t i n t i n t i n t i n t i n e r.c o m i n t i n t i n e r.c o m i n c$ 与 $b$ 的颜色不同，跳过 $b$ 点。3）上述遍历无论是使用深度优先还是使用广度优先，时间复杂度都为 $O(n+m)$ ，其中的 $n$ 和 $m$ 分别是顶点数和边数。需要一个数组来存储各结点的颜色及是否已访问，空间复杂度为 $O(n)$ 。  

03.【解答】  

一个无向图 $G$ 是一棵树的条件是， $G$ 必须是无回路的连通图或有 $_{n-1}$ 条边的连通图。这里采用后者作为判断条件。对连通的判定，可以用能否一次遍历全部顶点来实现。可以采用深度优先搜索算法在遍历图的过程中统计可能访问到的顶点个数和边的条数，若一次遍历就能访问到 $n$ 个顶点和 $n\!-\!1$ 条边，则可断定此图是一棵树。算法实现如下：  

boolisTree（Graph& G)(for  $\scriptstyle{\dot{\Sigma}}=1$   $\scriptstyle{\dot{\mathbf{1}}}<={\mathsf{G}}$  .vexnum;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  visited[i] $=$ FALSE;//访问标记visited[l初始化int Vnum $\scriptstyle{1=0}$ ,Enu $_{:=0}$ //记录顶点数和边数DFS（G,1,Vnum,Enum,visited);if（Vnum $\scriptstyle{|=G}$ .vexnum&&Enum $==Z^{\star}$ (G.vexnum-1))returntrue;/符合树的条件else return//不符合树的条件void DFS（Graph& G,int v,int& Vnum,int& Enum,int visited[]){//深度优先遍历图G，统计访问过的顶点数和边数，通过Vnum和Enum返回 visited[v] $=$ TRUE; $\mathrm{Vnum++}$ 八/作访问标记，顶点计数int $w=$ First Neighbor $(G,v)$ /取v的第一个邻接顶点while $(w:=-1$ //当邻接顶点存在Enum ${++}$ /边存在，边计数if(!visited[w]) /当该邻接顶点未访问过 DFS（G,w,Vnum,Enum,visited); $w=$  Next Neighbor（G,v,W);  
04.【解答】  

两个不同的遍历算法都采用从顶点 $\nu_{i}$ 出发，依次遍历图中每个顶点，直到搜索到顶点v，若能够搜索到 $v_{j}$ ，则说明存在由顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径。  

深度优先遍历算法的实现如下：  

intvisited[MAxsIzE] $\mathbf{\Gamma}=\left\{\,0\,\right\}$ /访问标记数组void DFS（ALGraph G,int i,int j,bool &can reach)//深度优先判断有向图G中顶点  $\boldsymbol{v}_{i}$  到顶点  $v_{j}$  是否有路径，用canreach来标识 if(  $\scriptstyle{\dot{\Sigma}}=={\dot{\bar{\jmath}}}$  can reach  $\bar{}$  true; return;lli就是jvisited[i] $^{=1}$ /置访问标记for(int  ${\tt p}^{=}$  First Neighbor(G,i);  $_{\mathrm{p}>=0}$   ${\tt p}^{=}$  Next Neighbor（G,i,p)) if(!visited[p]&&!can reach)//递归检测邻接点DFS（G，p，j，can_reach）;  

广度优先遍历算法的实现如下：  

int visited[MAxSIZE] $\mathbf{\Gamma}=\left\{\,0\,\right\}$ /访问标记数组int BFS（ALGraphG,inti,intj）{//广度优先判断有向图G中顶点 $v_{i}$ 到顶点v是否有路径，是则返回1，否则返回0InitQueue（Q）；EnQueue（Q，i）；I/顶点i入队while(!isEmpty(Q)){ /非空循环 DeQueue（Q,i）;/队头顶点出队visited $[\dot{\mathbf{x}}]\!=\!\!1$ 八//置访问标记if  $\scriptstyle{\dot{\mathbf{i}}}=={\dot{\mathbf{j}}}$  return1; for(int  ${\tt p}^{=}$  First Neighbor(G,i);p;  ${\tt p}^{=}$  Next Neighbor（G,i,p））（ //检查所有邻接点if  $\tt{p==j}$  川若  $\mathtt{p}{=}{\dot{\mathtt{j}}}$  ，则查找成功 return1; if(!visited[p]){l/否则，顶点p入队EnQueue(Q,p）; visited[p]  $^{=1}$  return 0;  

本题也可以这样解答：调用以 $i$ 为参数的DFS（G，i）或BFS（G，i），执行结束后判断visited[j]是否为TRUE，若是则说明 $v_{j}$ 已被遍历，图中必存在由 $\boldsymbol{v}_{i}$ 到 $v_{j}$ 的路径。但此种解法每次都耗费最坏时间复杂度对应的时间，需要遍历与 $\nu_{i}$ 连通的所有顶点。  

# 05.【解答】  

本题采用基于递归的深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。查找从顶点u到 $\mathtt{v}$ 的简单路径过程说明如下（假设查找Find Path（））：  
1)FindPath(G,u,V,path,d): ${\mathsf{d++}}$ ;path[d] $=\!\upalpha$ ；若找到u的未访问过的相邻结点ul，则继续下去，否则置visited[u] $=\!0$ 并返回。  

2)FindPath(G,ul,  $\mathtt{v}$  ,path,d):  $\mathrm{d++}$  ;path[d]  $\mathbf{\mu\sigma}=\mathbf{\mu\sigma}\mathbf{\bot}$  ：若找到ul的未访问过的相邻结 点u2，则继续下去，否则置visited[ul]  $=\!0$  

3）以此类推，继续上述递归过程，直到  $\scriptstyle{\mathrm{u}}\,{\mathrm{i}}={\mathrm{v}}$  ，输出path  

算法实现如下：  

void FindPath（AGraph \*G,int u,int v,int path[],int d）intw; ArcNode \*p;  $\mathrm{d++}$  /路径长度增1 path[d] $=\!\upalpha$ //将当前顶点添加到路径中visited[u]  $^{=1}$  //置已访问标记 if $\scriptstyle{\mathrm{==}}$ //找到一条路径则输出/输出路径上的结点print(path[]);  $\scriptstyle\mathtt{p}=\mathtt{G}->$ adjlist[u].firstarc;/p指向u的第一个相邻点while（p!=NULL){ w=p->adjvex;//若顶点w未访问，递归访问它if(visited[w] $==0$ 一FindPath(G,w,v,path,d);p=p->nextarc;/lp指向u的下一个相邻点visited[u] $=\!0$ //恢复环境，使该顶点可重新使用  

# 6.4图的应用  

本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性极小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。  

# 6.4.1 最小生成树  

一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。  

对于一个带权连通无向图 $G$ ，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。权值之和最小的那棵生成树称为 $G$ 的最小生成树（Minimum-Spanning-Tree,MST）。  

# 命题追踪最小生成树的性质（2012、2017）  

不难看出，最小生成树具有如下性质  

1）若图 $G$ 中存在权值相同的边，则 $G$ 的最小生成树可能不唯一，即最小生成树的树形不唯一。当图 $G$ 中的各边权值互不相等时， $G$ 的最小生成树是唯一的：若无向连通图G的边数比顶点数少1，即 $G$ 本身是一棵树时，则 $G$ 的最小生成树就是它本身。  

2）虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。  
3）最小生成树的边数为顶点数减1。  

命题追踪最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）  

# 注意  

最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。如下图所示，最小生成树中A到C的路径长度为5，但原图中C到D的最短路径长度为4。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/02e492777fdd70471f99a72a7ca8d6237b0cbdc152f003539de53616c1664f55.jpg)  

构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $G=(V,E)$ 是一个带权连通无向图， $U$ 是顶点集 $V$ 的一个非空子集。若 $(u,\,v)$ 是一条具有最小权值的边，其中 $u{\in}U$  $v{\in}V{-}\,U$ ，则必存在一棵包含边 $(u,v)$ 的最小生成树。  

基于该性质的最小生成树算法主要有 $\operatorname{Prim}$ 算法和Kruskal算法，它们都基于贪心算法的策略。对这两种算法应主要掌握算法的本质含义和基本思想，并能够手工模拟算法的实现步骤。  

下面介绍一个通用的最小生成树算法：  

GENERICMST(G)( $\scriptstyle{\mathrm{T}}=$  NULL; whileT未形成一棵生成树；do找到一条最小代价边 $(\boldsymbol{\mathrm{u}},\boldsymbol{\mathrm{v}})$ 并且加入T后不会产生回路 $\scriptstyle{\mathrm{T}=\mathrm{T}\cup\left(\mathrm{u},\,\mathrm{v}\right)}$  ”  

通用算法每次加入一条边以逐渐形成一棵生成树，下面介绍两种实现上述通用算法的途径。  

1.Prim算法  

Prim（普里姆）算法的执行非常类似于寻找图的最短路径的Dijkstra算法（见下一节）。  

命题追踪Prim算法构造最小生成树的实例（2015、2017、2018）  

Prim算法构造最小生成树的过程如图6.15所示。初始时从图中任取一顶点（如顶点1）加 入树 $T$ ，此时树中只含有一个顶点，之后选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点和相应的边加入 $T$ ，每次操作后 $T$ 中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入 $T$ ，得到的 $T$ 就是最小生成树。此时 $T$ 中必然有 $n\!-\!1$ 条边。  

Prim算法的步骤如下：  

假设 $G=\{V,E\}$ 是连通图，其最小生成树 $T\!=\!(U,E_{T})$ ， $E_{T}$ 是最小生成树中边的集合。  

初始化：向空树 $T\!=\!(U,E_{T})$ 中添加图 $G=(V,E)$ 的任意一个顶点 $u_{0}$ ，使 $U=\{u_{0}\}$ ， $E_{T}\!=\!\emptyset$  

循环（重复下列操作直至 $U=V)$ ：从图 $G$ 中选择满足 $\{(u,\,v)|u{\in}U,\,v{\in}V{-}\,U\}$ 且具有最小权值的边 $(u,v)$ ，加入树 $T$ 置 $U\!=\!U\!\cup\{\nu\},\:\:E_{T}\!=\!E_{T}\!\cup\{(u,\nu)\}$  

Prim算法的简单实现如下：  

void Prim（G,T） $\scriptstyle{\mathrm{T}}=\varnothing$  /初始化空树  $\scriptstyle{\mathrm{U}=\{w\}}$ /添加任意一个顶点 $w$ while((V-U) $!\!=\!\!\bigcirc\!,$ //若树中不含全部顶点  
设 $(\boldsymbol{\mathrm{u}},\boldsymbol{\mathrm{v}})$ 是使ueU与 $\forall{\in}\left(\mathrm{V}{-}\mathrm{U}\right)$ ，且权值最小的边； $\scriptstyle{\mathbb{T}=\mathbb{T}\cup\{\ (\mathfrak{u},\mathfrak{v})\ \}}$  /边归入树  $\scriptstyle{\mathrm{U}=\mathrm{U}\cup\{\mathrm{v}\}}$  //顶点归入树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/413704bf3253c2671855c3395ee5f1027e23761bf8da66bca7df35e4ef0ebc82.jpg)  
图6.15Prim算法构造最小生成树的过程  

Prim算法的时间复杂度为 $O(|V|^{2})$ ，不依赖于 $\cdot|E|$ ，因此它适用于求解边稠密的图的最小生成树。虽然采用其他方法能改进 $\operatorname{Prim}$ 算法的时间复杂度，但增加了实现的复杂性。  

# 2.Kruskal算法  

与 $\operatorname{Prim}$ 算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。  

# 命题追踪Kruskal算法构造最小生成树的实例（2015、2018、2020）  

Kruskal算法构造最小生成树的过程如图6.16所示。初始时为只有  $n$  个顶点而无边的非连 通图 $T=\{V,\,\{\}\}$ ，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在 $T$ 中不同的连通分量上（使用并查集判断这两个顶点是否属于同一棵集合树），则将此边加入T，杏则舍弃此边而选择下一条权值最小的边。以此类推，直至 $T$ 中所有顶点都在一个连通分量上。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfb9edf9b314446b65731e53e39a987ef76f3a653992a0d176bd51f77fe01337.jpg)  
图6.16Kruskal算法构造最小生成树的过程  
Kruskal算法的步骤如下：  

假设 $G=(V,E)$ 是连通图，其最小生成树 $T\!=\!(U,E_{T})$  

初始化： $\begin{array}{r}{U\!=\!V,E_{T}\!=\!\emptyset_{\circ}}\end{array}$ ，即每个顶点构成一棵独立的树， $T$ 此时是一个仅含IV个顶点的森林。  

循环（重复直至 $T$ 是一棵树)：按 $G$ 的边的权值递增顺序依次从 $E\!-\!E_{T}$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入 $E_{T}$ ，否则舍弃，直到 $E_{T}$ 中含有 $n-1$ 条边。  

Kruskal算法的简单实现如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2b5891ebe5b470c06be5813e03e210a476a10eb80e5ae811e0df366ecf210561.jpg)  

根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。  

在Kruskal算法中，最坏情况需要对 $|E|$ 条边各扫描一次。通常采用堆（见第7章）来存放边的集合，每次选择最小权值的边需要 $O(\log_{2}\lvert E\rvert)$ 的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为 $O(\alpha(|V|))$ ， $\alpha(V)$ 的增长极其缓慢，可视为常数。算法的总时间复杂度为 $O(|E|\log_{2}\lvert E\rvert)$ ，不依赖于 $|V|$ ，因此Kruskal算法适合于边稀疏而顶点较多的图。  

# 6.4.2最短路径  

# 命题追踪最短路径的分析与举例以及相关的算法（2009、2023）  

6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点 $v_{0}$ 到图中其余任意一个顶点 $\nu_{i}$ 的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。  

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。  

# 1.Dijkstra算法求单源最短路径问题  

Dijkstra $S$ 记录已求得的最短路径的顶点，初始时把源点 $\nu_{0}$ 放入 $S$ ，集合 $S$ 每并入一个新顶点 $\nu_{i}$ ，都要修改源点 $v_{0}$ 到集合 $V\!-\!S$ 中顶点当前的最短路径长度值（这里可能不太好理解？没关系，继续往下看，相信会逐步理解）。  

在构造的过程中还设置了三个辅助数组：  

·final[]：标记各顶点是否已找到最短路径，即是否归入集合 $S_{\circ}$ ·dist[]：记录从源点 $v_{0}$ 到其他各顶点当前的最短路径长度，它的初始值为：若从 $v_{0}$ 到 $v_{i}$ 有弧，则dist[i]为弧上的权值；否则置dist[i]为oo。path[]：path[i]表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 $\nu_{0}$ 到顶点 $v_{i}$ 的最短路径。  
假设从顶点0出发，即 $v_{0}\,{=}\,0$ ，集合 $S$ 最初只包含顶点O，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边 ${<\!i,j\!>}$ 的权值，若不存在有向边 $\mid<\!i,j>$ ，则arcs[i][j]为o。  

Dijkstra算法的步骤如下（不考虑对path[的操作）：  

1）初始化：集合 $S$ 初始为 $\{0\}$ ，dist[]的初始值dist[i] $=$ arcs[0][i],i=1,2,.,n-1。2）从顶点集合  $V{-}S$  中选出  $v_{j}$  ，满足dist[j]  $=$  Min(dist[i]l  $\scriptstyle v_{i}\in V-S\}$   $\nu_{j}$  就是当前求得 的一条从 $\nu_{0}$ 出发的最短路径的终点，令 $S\!=\!S\cup\{j\}$ 。3）修改从 $v_{0}$ 出发到集合 $V\!-\!S$ 上任意一个顶点 $v_{k}$ 可达的最短路径长度：若dist[j]+arcs[j][k]  $<$  dist[k]，则更新dist[k]  $=$  dist[j]  $^+$  arcs[j][k]。  

4）重复 $2)\sim\!3)$ 操作共 $_{n-1}$ 次，直到所有的顶点都包含在集合 $S$ 中  

步骤3）也就是开头留下的疑问，每当一个顶点加入集合 $S$ 后，可能需要修改源点 $\nu_{0}$ 到集合 $V{-}S$ 中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为 $v_{0}$ ，初始时 $S=\{v_{0}\}$ ，dist $[1]\!=\!3$ ,dist $[2]=7$ ，当将 $\nu_{1}$ 并入集合 $S$ 后，dist[2]需要更新为4。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8cd3f126d0f9f02af5404cbc8a5301d32f89543ad84684ca594dafd871d7647.jpg)  

思考：Dijkstra  $\operatorname{Prim}$  算法有何异同之处？ 命题追踪Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）  

例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如表6.2所示。算法执行过程的说明如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c7090950bb73763feef7e1ea4c3e3ea318d642815621a4657605a0e98585dbdc.jpg)  
图6.17应用Dijkstra算法图  

表6.2从 $\nu_{1}$ 到各终点的dist值和最短路径的求解过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f8939ca7029cd3a8d7e5c73314b7488664116e02a550898bfbcd99d295b6878.jpg)  
初始化：集合 $S$ 初始为 $\{v_{1}\}$ ， $v_{1}$ 可达 $v_{2}$ 和 $v_{5}$  $v_{1}$ 不可达 $\nu_{3}$ 和 $v_{4}$ ，因此dist[]数组各元素的初始值依次设置为dist  $[2]\!=\!10$  ，dist  $\left[\,3\,\right]\mathrm{=}\infty$  , dist  $\left[\,4\,\right]\mathrm{=}\infty$  ,dist  $[\,5\,]\!=\!5$  

第1轮：选出最小值dist[5]，将顶点 $v_{5}$ 并入集合 $S$ ，即此时已找到 $\nu_{1}$ 到 $v_{5}$ 的最短路径。当 $v_{5}$ 加入 $S$ 后，从 $\nu_{1}$ 到集合 $V\!-\!S$ 中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]数组。 $v_{5}$ 可达 $\nu_{2}$ ，因 $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{2}$ 的距离8比dist $[2]\!=\!10$ 小，更新 dist $[2]\!=\!8$  $v_{5}$ 可达 $v_{3}$ ， $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{3}$ 的距离14，更新dist $[3]\!=\!14$ .. $v_{5}$ 可达 $v_{4}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{4}$ 的距离7，更新dist $[\,4\,]\,{=}7$ 。  

第2轮：选出最小值dist[4]，将顶点 $v_{4}$ 并入集合 $S_{\circ}$ 继续更新dist[]数组。 $v_{4}$ 不可达 $v_{2}$ ，dist[2]不变； $v_{4}$ 可达 $v_{3}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{4}{\rightarrow}v_{3}$ 的距离13比dist[3]小，故更新dist[3]=13。  

第3轮：选出最小值dist[2]，将顶点 $v_{2}$ 并入集合 $S_{\circ}$ 继续更新 dist[]数组。 $v_{2}$ 可达 $\nu_{3}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{2}{\rightarrow}v_{3}$ 的距离9比dist[3]小，更新dist $\left[\,3\,\right]\,=\,9.$  

第4轮：选出唯一最小值dist[3]，将顶点 $v_{3}$ 并入集合 $S_{i}$ ，此时全部顶点都已包含在 $S$ 中。  

显然，Dijkstra算法也是基于贪心策略的。  

使用邻接矩阵表示时，时间复杂度为 $O(|V|^{2})$ 。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[中选择最小分量的时间不变，所以时间复杂度仍为 $O(|V|^{2})$  

人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为 $O(|V|^{2})$  

注意，边上带有负权值时，Dikstra算法并不适用。若充许边上带有负权值，则在与集合S（已求得最短路径的顶点集，归入 $S$ 内的顶点的最短路径不再变更）内某顶点（记为 $a$ ）以负边相连的顶点（记为6）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于 $a$ 原先确定的最短路径长度，而此时 $a$ 在Dijkstra算法下是无法更新的。例如，对于图6.18所示的带权有向图，利用Dijkstra算法不一定能得到正确的结果。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/354061dd6653c1cf7d28647835680430baf780d8a8c6da4925a50828c972315d.jpg)  
图6.18边上带有负权值的有向带权图  

# 2.Floyd算法求各顶点之间最短路径问题  

求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对任意两个顶点 $v_{i}\not=v_{j}$ ，要求求出 $\nu_{i}$ 与 $v_{j}$ 之间的最短路径和最短路径长度。  

Floyd算法的基本思想是：递推产生一个 $n$ 阶方阵序列 $A^{(-1)}$  $A^{(0)},\cdots,\,A^{(k)},\cdots,\,A^{(n-1)}$ ，其中 $A^{(k)}[i][j]$ 表示从顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径长度， $k$ 表示绕行第 $k$ 个顶点的运算步骤。初始时，对于任意两个顶点 $v_{j}$ 和 $v_{j}$ ，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k$  $\textit{k}(k=0,\,1,\cdots,n-1\,)$ 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法描述如下：  

定义一个 $n$ 阶方阵序列 $A^{(-1)},A^{(0)},\cdots,A^{(n-1)}$ ，其中，  

$$
A^{(-1)}[i][j]=\arcsin[i][j]
$$  

$$
\begin{array}{r}{A^{(k)}[i][j]=\operatorname{Min}\{A^{(k-1)}[i][j],\quad A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},\ k=0,1,\cdots,n-1}\end{array}
$$  

式中， $A^{(0)}[i][j]$ 是从顶点 $v_{i}$ 到 $\nu_{j\setminus}$ 中间顶点是 $\nu_{0}$ 的最短路径的长度， $A^{(k)}[i][j]$ 是从顶点 $\nu_{i}$ 到 $v_{j\setminus}$ 中间顶点的序号不大于 $k$ 的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从 $\nu_{i}$ 到 $\nu_{j}$ 的最短路径上就多考虑了一个顶点；经过 $n$ 次迭代后，所得到的 $A^{(n-1)}[i][j]$ 就是 $v_{i}$ 到 $\nu_{j}$ 的最短路径长度，即方阵 $A^{(n-1)}$ 中就保存了任意一对顶点之间的最短路径长度。  
图6.19所示为带权有向图 $G$ 及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长度的过程如表6.3所示。算法执行过程的说明如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9563eb9adc4d1c1bbd123557953338f0013fcf037d3a58a2bb15403ac38ae2a2.jpg)  
图6.19带权有向图 $G$ 及其邻接矩阵  

初始化：方阵 $A^{(-1)}[i][j]=$ arcs[][]  

第1轮：将 $v_{0}$ 作为中间顶点，对于所有顶点对 $\{i,j\}$ ，若有 $\boldsymbol{A}^{-1}[i][j]>\boldsymbol{A}^{-1}[i][0]+\boldsymbol{A}^{-1}[0][j]$ ，则将 $A^{-1}[i][j]$  更新为  $\begin{array}{r}{\boldsymbol{A}^{-1}[i][0]+\boldsymbol{A}^{-1}[0][j].}\end{array}$  有  $\begin{array}{r}{\boldsymbol{A}^{-1}[2][1]>\boldsymbol{A}^{-1}[2][0]+\boldsymbol{A}^{-1}[0][1]=11}\end{array}$  ，更新  $A^{-1}[2][1]=11$  ，更 新后的方阵标记为 $A^{0}$  

第2轮：将 $\nu_{1}$ 作为中间顶点，继续检测全部顶点对 $\{i,j\}$ 。有 $A^{0}[0][2]>A^{0}[0][1]+A^{0}[1][2]=$ 10，更新 $A^{0}[0][2]=10$ ，更新后的方阵标记为 $A^{1}$  

第3轮：将 $\nu_{2}$ 作为中间顶点，继续检测全部顶点对i,}。有 $\begin{array}{r}{\boldsymbol{A}^{1}[1][0]>\boldsymbol{A}^{1}[1][2]+\boldsymbol{A}^{1}[2][0]=\boldsymbol{9},}\end{array}$ 更新 $A^{1}[1][0]=9$ ，更新后的方阵标记为 $A^{2}$ 。此时 $A^{2}$ 中保存的就是任意顶点对的最短路径长度。  

表6.3Floyd算法的执行过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91b9d670ed390741ce41fa7fada27f7a43fe887b80c64666880ba9353d11e80f.jpg)  

Floyd算法的时间复杂度为 $O(|V|^{3})$ 。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。  

Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。  

也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为 $O(|V|^{2}){\cdot}|V|\!=\!O(|V|^{3})$  

BFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。  

表6.4BFS算法、Dijkstra算法和Floyd算法求最短路径的总结 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7c367d52e0336cc1a989ce844941cf5beff18d63452f540edc3163d0104266fc.jpg)  
6.4.3有向无环图描述表达式  

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。  

命题追踪构建表达式的有向无环图（2019）  

有向无环图是描述含有公共子式的表达式的有效工具。例如表达式 $((a+b)^{*}(b^{*}(c+d))+(c+d)^{*}e)^{*}((c+d)^{*}e)$  

可以用上一章描述的二义树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的子表达式 $(c+d$ )和 $(c+d)^{*}e$ ，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e1ae982871a34fb5119dda6581088409768da4bd88e8d177af012108a5f7ae4.jpg)  
图6.20二叉树描述表达式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e4c2332ba4acd478e43e4a2865dff8a8e7911989ffb9daa949ca81a074232194.jpg)  
图6.21有向无环图描述表达式  

# 注意  

在表达式的有向无环图表示中，不可能出现重复的操作数顶点。  

# 6.4.4 拓扑排序  

AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边 $\begin{array}{r}{{<}V_{i},}\end{array}$  $V_{j}>$ 表示活动 $V_{i}$ 必须先于活动 $V_{j}$ 进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网。在AOV网中，活动 $V_{i}$ 是活动 $V_{j}$ 的直接前驱， $V_{j}$ 是 $V_{i}$ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 $V_{i}$ 不能以它自己作为自己的前驱或后继。  

拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：  

1）每个顶点出现且只出现一次。  

2）若顶点A在序列中排在顶点 $B$ 的前面，则在图中不存在从 $B$ 到 $A$ 的路径。  

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点 $B$ 的路径，则在排序中 $B$ 出现在 $A$ 的后面。每个AOV网都有一个或多个拓扑排序序列。  

# 命题追踪拓扑排序和回路的关系（2011）  

对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤 $\textcircled{\scriptsize{1}}$ 从AOV网中选择一个没有前驱（入度为0）的顶点并输出。 $\circledcirc$ 从网中删除该顶点和所有以它为起点的有向边。  

$\textcircled{3}$ 重复 $\circledcirc$ 和 $^{(\mathcal{Q})}$ 直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。  
命题追踪拓扑排序的实例（2010、2014、2018、2021）  

图6.22所示为拓扑排序过程的示例。每轮选择一个入度为0的顶点并输出，然后删除该顶点和所有以它为起点的有向边，最后得到拓扑排序的结果为 $\{1,2,4,3,5\}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8810ace9ff20c9670d0e1272ddf371bd248455d387e1a48022dfcfc7f025d42a.jpg)  
图6.22有向无环图的拓扑排序过程  

拓扑排序算法的实现如下：  

o ol Topological Sort(Graph G){ InitStack(S);/初始化栈，存储入度为0的顶点int i; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<G.vexnum;  $\ \ \dot{\mathbf{1}}_{++}$  if（indegree[i] $==0$ 一Push(S,i); //将所有入度为0的顶点进栈 int count $=\!0$ //计数，记录当前已经输出的顶点数while(!IsEmpty(S)){//栈不空，则存在入度为0的顶点Pop(S,i); /栈顶元素出栈 print[count ${\bf++}]\!=\!\mathrm{i}$ /输出顶点for  $\scriptstyle{\mathrm{sp}}=G$  .vertices[i].firstarc;p;p=p->nextarc)( //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S $\scriptstyle{\mathrm{~v=p~}}$  ->adjvex; if(!(--indegree[v]))Push(S,v); 11入度为0，则入栈 if（count<G.vexnum)returnfalse;/排序失败，有向图中有回路else return true; /拓扑排序成功  
# 命题追踪不同存储方式下的拓扑排序的效率（2016）  

因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时间复杂度为 $O(|V|+|E|)$ ，采用邻接矩阵存储时拓扑排序的时间复杂度为 $O(|V|^{2})$  

# 命题追踪》DFS实现拓扑排序的思想（2020）  

此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码见本节后的习题。对于有向无环图 $G$ 中的任意结点 $u,v$ ，它们之间的关系必然是下列三种之一：  

1）若  $u$  是  $\nu$  的祖先，则在调用DFS访问  $u$  之前，必然已对  $v$  进行了DFS访问，即v的DFS 结束时间先于 $u$ 的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。  

2）若 $u$ 是 $v$ 的子孙，则v为 $u$ 的祖先，按上述思路，v的结束时间大于 $u$ 的结束时间。  

3）若 $u$ 和 $v$ 没有路径关系，则 $u$ 和 $\nu$ 在拓扑序列的关系任意。  

于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。  

对一个AOV网，若采用下列步骤进行排序，则称之为逆拓扑排序：  

$\textcircled{\scriptsize{1}}$ 从AOV网中选择一个没有后继（出度为0）的顶点并输出。  

$\textcircled{2}$ 从网中删除该顶点和所有以它为终点的有向边。  

$\textcircled{3}$ 重复 $\textcircled{\scriptsize{1}}$ 和 $\textcircled{2}$ 直到当前的AOV网为空。  

用拓扑排序算法处理AOV网时，应注意以下问题：  

1）入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。  

# 命题追踪分析给定图的拓扑序列的存在性和唯一性（2011）  

2）若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。  

3）由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。  

# 6.4.5关键路径  

在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。  

AOE网具有以下两个性质：  

$\textcircled{\scriptsize{1}}$ 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始； $\circledcirc$ 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。  

在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。  

# 命题追踪关键路径的性质（2020）  

在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。  
完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。  

下面给出在寻找关键活动时所用到的几个参量的定义。  

# 1．事件 $\nu_{k}$ 的最早发生时间 $\nu_{e}(k)$  

它是指从源点 $\nu_{1}$ 到顶点 $v_{k}$ 的最长路径长度。事件 $v_{k}$ 的最早发生时间决定了所有从 $v_{k}$ 开始的活动能够并工的最早时间。可用下面的递推公式来计算：  

v.(源点)  $=0$  

$\nu_{e}(k)=\operatorname{Max}\{\nu_{e}(j)+\operatorname{Weibht}(\nu_{j},\nu_{k})\},\nu_{k}$ 为 $v_{j}$ 的任意后继，Weight $(v_{j},v_{k})$ 表示 $\begin{array}{r}{\negthickspace\negthickspace\negthickspace<\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\neg\negthickspace\neg\!\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!$ v>上的权值  

# 注意  

计算 $\nu_{e}()$ 值时，按从前往后的顺序进行，可以在拓扑排序的基础上计算：  

$\textcircled{\scriptsize{1}}$ 初始时，令 $\nu_{e}[1...n]=0$  

$\circledcirc$ 输出一个入度为 $0$ 的顶点 $\nu_{j}$ 时，计算它所有直接后继顶点 $\nu_{k}$ 的最早发生时间，若ve[] $\mathrm{Weibt}(\nu_{j},\nu_{k})>\nu_{e}[k],$ 则 $\nu_{e}[k]=\nu_{e}[j]+\mathrm{Weibt}(\nu_{j},\nu_{k})$ 。以此类推，直至输出全部顶点。  

# 2.事件 $\nu_{k}$ 的最迟发生时间 $\nu_{l}(k)$  

它是指在不推迟整个工程完成的前提下，即保证它的后继事件 $v_{j}$ 在其最迟发生时间 $v(j)$ 能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：  

$v_{I}($  汇点)  $=$  v(汇点)  

$\nu_{l}(k)=\mathrm{Min}\{\nu_{l}(j)-\mathrm{Weibh}(\nu_{k},\nu_{j})\},\nu_{k}$  为  $\nu_{j}$  的任意前驱  

# 注意  

计算 $v_{l}(k)$ 值时，按从后往前的顺序进行，可以在逆拓扑排序的基础上计算。增设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：  

$\textcircled{\scriptsize{1}}$ 初始时，令 $\nu_{l}[1...n]=\nu_{e}[n].$  

$\circledcirc$ 栈顶顶点 $v_{j}$ 出栈，计算其所有直接前驱顶点 $v_{k}$ 的最迟发生时间，若 $v_{l}[j]-\mathsf{W e i g h t}(v_{k},\,v_{j})<$  $\displaystyle{\nu_{l}[k]}$ ，则 $\nu_{l}[k]=\nu_{l}[j]-\mathrm{Weigint}(\nu_{k},\nu_{j}).$ ，以此类推，直至输出全部栈中顶点。  

# 3.活动 $\pmb{a}_{i}$ 的最早开始时间 $e(i)$  

它是指该活动弧的起点所表示的事件的最早发生时间。若边 $\begin{array}{r}{\sqrt{\!\!\mathrm{\Sigma}_{k}^{\mathrm{}}\!\!},}\end{array}$ v>表示活动 $a_{i}$ ，则有 $e(i)=$  $\nu_{e}(k)$  

# 4.活动 $\mathbf{\delta}_{\mathbf{\alpha}_{i}}$ 的最迟开始时间I(i)  

它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边 $\begin{array}{r}{{\mathbf{\mu}}^{<\nu_{k},}}\end{array}$ V>表示活动 $a_{i}$ ，则有 $l(i)=\nu_{i}(j)-\mathrm{Weibull}(\nu_{k},\nu_{j})\,.$  

# 5.一个活动 $\mathbf{\delta}a_{i}$ 的最迟开始时间 $\iota(i)$ 和其最早开始时间 $e(i)$ 的差额 $\begin{array}{r}{d(i)=l(i)-e(i)}\end{array}$  

它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动 $a_{i}$ 可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工程的进度，所以称 $l\!(i)\!-\!e(i)\!=\!0$ 即 $l(i)=e(i)$ 的活动 $a_{i}$ 是关键活动。  
# 命题追踪求关键路径的实例（2019、2022）  

求关键路径的算法步骤如下：  

$\textcircled{\scriptsize{1}}$ 从源点出发，令v(源点) $=0$ ，按拓扑有序求其余顶点的最早发生时间 $\nu_{e}(0)_{\circ}$  

$\textcircled{2}$ 从汇点出发，令 $v_{l}($ 汇点） $=v_{e}$ (汇点)，按逆拓扑有序求其余顶点的最迟发生时间 $\nu(0)$  

$\textcircled{3}$ 根据各顶点的 $\nu_{e}()$ 值求所有弧的最早开始时间 $e()$  

$\textcircled{4}$ 根据各顶点的 $v_{I}()$ 值求所有弧的最迟开始时间 $l().$  

$\circledast$ 求AOE网中所有活动的差额 $d()$ ，找出所有 $d()=0$ 的活动构成关键路径。  

图6.23所示为求解关键路径的过程，简单说明如下：  

$\textcircled{\scriptsize{1}}$ 求 $\nu_{e}()$ ：初始 $\nu_{e}(1)=0$ ，在拓扑排序输出顶点过程中，求得 $\nu_{e}(2)=3\,,\,\,\nu_{e}(3)=2\,,\,\,\nu_{e}(4)=$  $\operatorname*{max}\left\{\nu_{e}(2)+2,\nu_{e}(3)+4\right\}=\operatorname*{max}\left\{5,6\right\}=6,\;\;\nu_{e}(5)=6,\;\;\nu_{e}(6)=\operatorname*{max}\left\{\nu_{e}(5)+1,\nu_{e}(4)+2,\nu_{e}(3)+4\right\}=2.$   $3\}=\operatorname*{max}\{7,8,5\}=8.$  

若这是一道选择题，根据上述求 $\nu_{e}()$ 的过程就已经能知道关键路径。  

$\circledcirc$ 求 $v()$ ：初始 $\nu(6)\!=\!8$ ，在逆拓扑排序出栈过程中，求得 $\nu(5)\!=\!7$ ， $v(4)\!=\!6$ ， $\begin{array}{r}{v_{i}(3)\!=\!\operatorname*{min}\{v_{i}(4)\!-\!4,}\end{array}$  $\nu_{\ell}(6)-3\}=\operatorname*{min}\{2,\,5\}=2,\,\,\,\nu_{\ell}(2)=\operatorname*{min}\{\nu_{\ell}(5)-3,\,\nu_{\ell}(4)-2\}=\operatorname*{min}\{4,\,4\}=4,$   $v_{l}(1)$  必然为  $0$  而无 须再求。  

$\textcircled{3}$ 弧的最早开始时间e(等于该弧的起点的顶点的 $\nu_{e}(\r)$ ，结果如下表。  

$\textcircled{4}$ 弧的最迟开始时间 $l(i)$ 等于该弧的终点的顶点的 $v_{\Lambda}()$ 减去该弧持续的时间，结果如下表。 $\circledast$ 根据 $l(i)\,-\,e(i)=0$ 的关键活动，得到的关键路径为 $(v_{1},v_{3},v_{4},v_{6}).$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3c83283a75649b4d8c5c2d0548388cadf2a7ab0f11784d1e7fa5d35976e5c5b2.jpg)  
图6.23求解关键路径的过程  

# 命题追踪缩短工期的相关分析（2013）  

对于关键路径，需要注意以下几点：  

1）关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。  

2）网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。  

各种图算法在采用邻接矩阵或邻接表存储时的时间复杂度如表6.5所示。  
表6.5采用不同存储结构时各种图算法的时间复杂度
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0cd28f07c2726861bd6847070ff8c2ca1109e478a5a69b4406f36d63f04ed47e.jpg)  

# 6.4.6 本节试题精选  

# 一、单项选择题  

01.任何一个无向连通图的最小生成树（）  

A.有一棵或多棵B.只有一棵C.一定有多棵D.可能不存在  

02.用Prim算法和Kruskal算法构造图的最小生成树，所得到的最小生成树（）。  

A.相同 B.不相同 C.可能相同，可能不同D.无法比较  

03.以下叙述中，正确的是（）。  

A.只要无向连通图中没有权值相同的边，则其最小生成树唯一B.只要无向图中有权值相同的边，则其最小生成树一定不唯一 C.从 $n$ 个顶点的连通图中选取 $n^{-1}$ 条权值最小的边，即可构成最小生成树D.设连通图  $G$  含有  $n$  个顶点，则含有  $n$  个顶点、  $n^{-1}$  条边的子图一定是  $G$  的生成树  

04.设有 $n$ 个顶点的无向连通图的最小生成树不唯一，则下列说法中正确的是（）  

A.图的边数一定大于  $n-1$  B.图的权值最小的边一定有多条 C.图的最小生成树的代价不一定相等D.图的各条边的权值不相等  

05.用Prim算法求一个带权连通图的最小生成树，在算法执行的某个时刻，已选取的顶点集合 $U=\{1,2,3\}$ ，已选取的边集合 $\mathrm{TE}=\{(1,2),(2,3)\}$ ，要选取下一条权值最小的边，应当从（）组中选取。  

A.  $\{(1,4),(3,4),(3,5),(2,5)\}$  B.  $\{(3,4),(3,5),(4,5),(1,4)\}$  C.  $\{(1,2),(2,3),(3,5)\}$  D. {(4, 5), (1, 3), (3, 5)}  

06.用Kruskal算法求一个带权连通图的最小生成树，在算法执行的某个时刻，已选取的边集合 $\mathrm{TE}=\{(1,2),(2,3),(3,5)\}$ ，要选取下一条权值最小的边，不可能选取的边是（）。  

A. (3,6) B. (2,4) C. (1,3) D. (1,4)  

07．下列关于图的最短路径的相关叙述中，正确的是（）。  

A.最短路径一定是简单路径B.Dikstra算法不适合求有回路的带权图的最短路径C.Dijkstra算法不适合求任意两个顶点的最短路径 D.Floyd算法求两个顶点的最短路径时， $\mathrm{\Delta}\mathrm{path}_{k-1}$ 一定是pathk的子集  

08.下列关于图的最短路径的相关叙述中，正确的是（）  

I.Dijkstra算法求单源最短路径不允许边的权为负 II.Dijkstra算法求每对顶点间的最短路径的时间复杂度是  $O(n^{2})$  Ill.Floyd算法求每对顶点间的最短路径允许边的权为负，但不允许含有负边的回路  

A.I、ⅡI和IⅢIB.仅IC.I和ⅢID.ⅡI和IⅢI  

09.已知带权连通无向图 $G\!=\!(V,E)$ ，其中 $\scriptstyle V=\{v_{1},\,v_{2},\,v_{3},\,v_{4},\,v_{5},\,v_{6},\,v_{7}\},\ E=\{(v_{1},\,v_{2})10,\,(v_{1},\,v_{3})2,$  $(v_{3},v_{4})2$ (v3,v)11, $(v_{2},\,v_{5})1$  $(v_{4},\,v_{5})4$  $(v_{4},\,v_{6})6$  $(v_{5},\,v_{7})7,$  $(v_{6},\,v_{7})3\}$ （注：顶点偶对括号外的数据表示边上的权值），从源点 $\nu_{1}$ 到顶点 $v_{7}$ 的最短路径上经过的顶点序列是（）  
A.  $v_{1},v_{2},v_{5},v_{7}$  B.  $v_{1},v_{3},v_{4},v_{6},v_{7}\quad\mathrm{~\textit~{~C~}~}$   $v_{1},v_{3},v_{4},v_{5},v_{7}$  D.  $v_{1},v_{2},v_{5},v_{4},v_{6},v_{7}$  

10.用Dijkstra算法求一个带权有向图的从顶点0出发的最短路径，在算法执行的某个时刻，已求得的最短路径的顶点集合 $S=\{0,2,3,4\}$ ，下一个选取的目标顶点是顶点1，则可能修改的最短路径是（）。  

A.从顶点0到顶点3的最短路径B.从顶点0到顶点2的最短路径C.从顶点2到顶点4的最短路径D.从顶点0到顶点1的最短路径  

11.下面的（）方法可以判断出一个有向图是否有环（回路）I.深度优先遍历II.拓扑排序III.求最短路径IV.求关键路径 A.I、II、IVB.I、III、IVC.I、II、IIID.全部可以

12.在有向图 $G$ 的拓扑序列中，若顶点 $\boldsymbol{v}_{i}$ 在顶点 $\boldsymbol{v}_{j}$ 之前，则不可能出现的情形是（）  

A.G中有弧<v,V>B. $G$ 中有一条从 $\boldsymbol{v}_{i}$ 到V的路径C. $G$ 中没有弧<v,V>D. $G$ 中有一条从v到 $\nu_{i}$ 的路径  

13.下列关于拓扑排序的说法中，错误的是（）  

I.若某有向图存在环路，则该有向图一定不存在拓扑排序 I1.在拓扑排序算法中为暂存入度为零的顶点，可以使用栈，也可以使用队列III.若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为1 IV.若有向图的拓扑有序序列唯一，则图中入度为0和出度为0的顶点都仅有1个  

A.I、III、IVB.III、IVC. II、IVD.III

14.下列关于拓扑排序的说法中，正确的是（）。  

1.强连通图不能进行拓扑排序 IL.在一个有向图的拓扑序列中，若顶点 $^a$ 在顶点 $^b$ 之前，则图中必有一条弧<a， $b\!\!>$  

A.仅I B.仅ⅡI C.I和ⅡI D.都不正确

 15.若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图（）。  

A.含有多个出度为0的顶点B.是个强连通图C.含有多个入度为0的顶点 D.含有顶点数大于1的强连通分量  

16.下图所示有向图的所有拓扑序列共有（）个。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9ca3103c401d528df9d58fe2474167e5ea629c2b87da7e543bc79bed3e790bd.jpg)  

A.4 B.6 C.5 D.7  

17.已知有向图 $G\!=\!(V,E)$ ，其中 $V=\{\nu_{1},\,\nu_{2},\,\nu_{3},\,\nu_{4},\,\nu_{5},\,\nu_{6},\,\nu_{7}\},\;\;E=\{<\nu_{1},\,\nu_{2}>,\,<\nu_{1},\,\nu_{3}>,\,<\nu_{1},\,\nu_{4}>,$  $\scriptstyle<\nu_{2},\,\nu_{5}>,\,<\nu_{3},\,\nu_{5}>,\,<\nu_{3},\,\nu_{6}>,\,<\nu_{5},\,\nu_{7}>,\,<\nu_{6},\,\nu_{7}>,\,<\nu_{4},\,\nu_{6}>\}\,.$  $G$ 的拓扑序列是（）。  

A.  $\{v_{1},v_{3},v_{4},v_{6},v_{2},v_{5},v_{7}\}$  B.{V1,V3,V2,V6,V4,V5,V7} C.  $\{v_{1},v_{3},v_{4},v_{5},v_{2},v_{6},v_{7}\}$   $\begin{array}{r l}{\mathrm{D}.}&{{}\{v_{1},v_{2},v_{5},v_{3},v_{4},v_{6},v_{7}\}}\end{array}$  

18.下列哪种图的邻接矩阵是对称矩阵？（  

A.有向网B.无向图C.AOV网D.AOE网  

19.若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为（）。  

A.对称B.稀疏C.三角D.一般  
20.用DFS算法遍历一个无环有向图，并在DFS算法退栈返回时输出相应的顶点，则输出的顶点序列是（）。  

A.逆拓扑有序B.拓扑有序C.无序的D.无法确定  

21.下列关于图的说法中，正确的是（）。  

I.有向图中顶点 $V$ 的度等于其邻接矩阵中第V行中1的个数I1.无向图的邻接矩阵一定是对称矩阵，有向图的邻接矩阵一定是非对称矩阵 IⅢI.在带权图 $G$ 的最小生成树 $G_{1}$ 中，某条边的权值可能会超过未选边的权值IV.若有向无环图的拓扑序列唯一，则可以唯一确定该图  

A.I、ⅡI和ⅢIB.II和IVC.IID.IV

22.下图所示的AOE网中，关键路径长度为（）A.16N B.17 C.18 D.19  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d099e858da2fc2199eba6cb56222df8890c62095826023f01ddf3db438acac17.jpg)  

23.若某带权图为 $G\!=\!(V,E)$ ，其中 $V=\{\nu_{1},\,\nu_{2},\,\nu_{3},\,\nu_{4},\,\nu_{5},\,\nu_{6},\,\nu_{7},\,\nu_{8},\,\nu_{9},\,\nu_{10}\}\,,\,\,\,E=\{<\nu_{1},\,\nu_{2}>5,\,<\nu_{1},\,\nu_{3}>5,\,\}\,\,,$  $\nu_{3}{>}6,\,\lnot v_{2},\,\nu_{5}{>}3,$   $\begin{array}{r}{<\!v_{3},}\end{array}$   $v_{5}{>}6,$   $\begin{array}{r}{<\!v_{3},}\end{array}$   $v_{4}{>}3$   ${\mathfrak{c}}v_{4},$   $v_{5}{>}3$   ${\mathfrak{c}}v_{4}$   $\scriptstyle{\nu_{7}>1}$   ${\mathfrak{c}}v_{4},$   $v_{8}{>}4$  <V5,V6>4,<V5,  $_{v_{7}>2}$   ${\displaystyle<}v_{6},$   $\scriptstyle{v_{10}>4}$  $\scriptstyle<v_{7}$  $v{>}5$  ${\mathfrak{c}}v_{8}$  $v_{9}{>}2$  ${<}v_{9}$  $_{v_{10}>2\}$ （注：边括号外的数据表示边上的权值），则 $G$ 的关键路径的长度为（）。  

A.19 B.20 C.21 D.22

 24.下面关于求关键路径的说法中，不正确的是（）  

A.求关键路径是以拓扑排序为基础的 B.一个事件的最早发生时间与以该事件为始的弧的活动的最早开始时间相同C.一个事件的最迟发生时间是以该事件为尾的弧的活动的最迟开始时间与该活动的持续时间的差D.任何一个活动的持续时间的改变可能会影响关键路径的改变  

25.下列关于关键路径的说法中，正确的是（）  

I.改变网上某一关键路径上的任意一个关键活动后，必将产生不同的关键路径II1.在AOE图中，关键路径上活动的时间延长多少，整个工期也就随之延长多少I1I.缩短关键路径上任意一个关键活动的持续时间可缩短关键路径长度IV.缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度V.缩短多条关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度  

A.II和V B.I、II和IV C.ⅡI和IV D.I和IV

 26.在求AOE网的关键路径时，若该有向图用邻接矩阵表示且第 $i$ 列值全为0，则（）  

A.若关键路径存在，第i个顶点一定是起点B.若关键路径存在，第 $i$ 个顶点一定是终点C.关键路径不存在D.该有向图对应的无向图存在多个连通分量  
27.【2010统考真题】对下图进行拓扑排序，可得不同拓扑序列的个数是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74c4f116ee4b445eea68d6bb91cfd68b14e3d92e15c718388000e6ca4abd5260.jpg)  

A.4 B.3 C.2 D.1

 28.【2012统考真题】下列关于最小生成树的叙述中，正确的是（）  

I.最小生成树的代价唯一II.所有权值最小的边一定会出现在所有的最小生成树中IIl.使用Prim算法从不同顶点开始得到的最小生成树一定相同IV.使用Prim算法和Kruskal算法得到的最小生成树总不相同  

A.仅IB.仅ⅡIC.仅I、IIID.仅II、IV  

29.【2012统考真题】对下图所示的有向带权图，若采用Dijkstra算法求从源点a到其他各 顶点的最短路径，则得到的第一条最短路径的目标顶点是b，第二条最短路径的目标顶点是C，后续得到的其余各最短路径的目标顶点依次是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e51b0ff7037ed9c7341eccbe53ac22573729b78d30574754bf1ae9be5c2f50bc.jpg)  

A.d,e,f B.e,d,f C. f,d,e D.f,e,d  

30.【2012统考真题】若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关 于该图拓扑序列的结论是（）。  

A.存在，且唯一B.存在，且不唯一C.存在，可能不唯一D.无法确定是否存在  

31.【2013统考真题】下列A0E网表示一项包含8个活动的工程。通过同时加快若千活动的进度可缩短整个工程的工期。在下列选项中，加快其进度就可缩短工程工期的是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/555327f861e1f54543ce1a6eddf5f448b59f5b56af36c10f09fe15de38c6f841.jpg)  

A.c和e B.d和c C.f和d D.f和h  

32.【2014统考真题】对下图所示的有向图进行拓扑排序，得到的拓扑序列可能是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc9f75c48ff3399db23e602c80e2ed08a2ff8e1c23e8c20f5931aea0296c4b5e.jpg)  
A.3,1,2,4,5,6 B.3,1,2,4,6,5 C.3,1,4,2,5,6 D.3,1,4,2,6,5  

33.【2015统考真题】求下面的带权图的最小（代价）生成树时，可能是Kruskal算法第2次选中但不是Prim算法（从 $V_{4}$ 开始）第2次选中的边是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7bc1c643c392a258847895435132bb49539f365b46fddce96625366a41807a9a.jpg)  

A.  $(V_{1},V_{3})$  A2KXB.  $(V_{1},V_{4})$  C.  $(V_{2},V_{3})$  D.  $(V_{3},V_{4})$  34.【2011统考真题】下列关于图的叙述中，正确的是（）  

I.回路是简单路径II.存储稀疏图：用邻接矩阵比邻接表更省空间III.若有向图中存在拓扑序列，则该图不存在回路  

A.仅ⅡIB.仅I、ⅡC.仅IⅢID.仅I、ⅢII  

35.【2016统考真题】使用Dijkstra算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/be32bd20b2f8a905e67b9417f3d50ad3a849d4b8be5ee730c9bf81ebc5c4fcda.jpg)  

A.5,2,3,4,6 B.5,2,3,6,4 C.5,2,4,3,6 D.5,2,6,3,4  

36.【2016统考真题】若对  $n$  个顶点、  $e$  条弧的有向图采用邻接表存储，则拓扑排序算法的 时间复杂度是（）。  

A.O(n) B.  $O(n+e)$  C. 0(n²) D. O(ne)  

37.【2018统考真题】下列选项中，不是如下有向图的拓扑序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c29e48fc49d17b97665df356416a9a2f574ad441bc2385a9fed6b304d5f02429.jpg)  

A.1,5,2,3,6,4 B.5,1,2,6,3,4 C.5,1,2,3,6,4 D.5,2,1,6,3,4  

38.【2019统考真题】下图所示的A0E网表示一项包含8个活动的工程。活动 $d$ 的最早开始时间和最迟开始时间分别是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/11525bea64034c7313bb695917c15b81c8eae73290a43e17219c71fdcbcfb633.jpg)  

A.3和7 B.12和12 C.12和14 D.15和15  
39.【2019统考真题】用有向无环图描述表达式  $(x+y)((x+y)/x)$  ，需要的顶点个数至少是 ()。  

A.5 B.6 C.8 D.9  

40.【2020统考真题】已知无向图 $G$ 如下所示，使用Kruskal算法求图 $G$ 的最小生成树，加到最小生成树中的边依次是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ef0855a857307e59286bd4bdc96983ef25e4bc8c68087d83c43acdde61f391ad.jpg)  

A.  $(b,f),(b,d),(a,e),(c,e),(b,e)$  B.  $(b,f),(b,d),(b,e),(a,e),(c,e)$  C. (a, e)  $,(b,e),(c,e),(b,d),(b,f)$  D.  $(a,e),(c,e),(b,e),(b,f),(b,d)$  

41.【2020统考真题】修改递归方式实现的图的深度优先搜索（DFS）算法，将输出（访 问）顶点信息的语句移到退出递归前（即执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图 $G$ 若输出结果中包含 $G$ 中的全部顶点，则输出的顶点序列是 $G$ 的()。  

A.拓扑有序序列 B.逆拓扑有序序列 C.广度优先搜索序列D.深度优先搜索序列  

42.【2020统考真题】若使用AOE网估算工程进度，则下列叙述中正确的是（）  

A.关键路径是从源点到汇点边数最多的一条路径B.关键路径是从源点到汇点路径长度最长的路径 C.增加任意一个关键活动的时间不会延长工程的工期D.缩短任意一个关键活动的时间将会缩短工程的工期  

43.【2021统考真题】给定如下有向图，该图的拓扑有序序列的个数是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2d50b3307056ac82a041fda9f7d3985b66158930285467f3081961d8fd931032.jpg)  

A. 1 B.2 C.3 D.4  

44.【2021统考真题】使用Dijkstra算法求下图中从顶点1到其余各顶点的最短路径，将当前找到的从顶点1到顶点2，3，4，5的最短路径长度保存在数组dist中，求出第二条最短路径后，dist中的内容更新为（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/996ae4f1f0c45c43bc5dded69c4a7b24e5f827a8491d273831a39cc129358279.jpg)  
A.26,3,14,6 B.25,3,14,6 C.21,3,14,6 D.15,3,14,6

 45.【2022统考真题】下图是一个有10个活动的AOE网，时间余量最大的活动是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/37ab5adcd9e888f760e755ef5d2f8f04b20b24796ffb38dbf9bc2d0f2ade3d36.jpg)  

A. B. g C.h D.j  

46.【2023统考真题】已知无向连通图 $G$ 中各边的权值均为1。在下列算法中，一定能够求出图 $G$ 中从某顶点到其余各顶点最短路径的是（）。I.Prim算法ⅡI.Kruskal算法IⅢl.图的广度优先搜索算法  

A.仅1B.仅IⅢIC.仅I、ⅡID.I、ⅡⅢ  

# 二、综合应用题  

01.下面是一种称为“破圈法”的求解最小生成树的方法：所谓“破圈法”，是指“任取一圈，去掉圈上权最大的边”，反复执行这一步骤，直到没有圈为止。试判断这种方法是否正确。若正确，说明理由；若不正确，举出反例（注：圈就是回路）。  

02.已知有向图如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ef70ec28a49b39c3070800aac78b1636854ebd3eeefab3623c019d84e3a61c74.jpg)  

1）写出该图的邻接矩阵表示并据此给出从顶点1出发的深度优先遍历序列2）求该有向图的强连通分量的数目。3）给出该图的任意两个拓扑序列。4）若将该图视为无向图，分别用  $\operatorname{Prim}$  算法和Kruskal算法求最小生成树。  

03.对下图所示的无向图，按照Dijkstra算法，写出从顶点1到其他各个顶点的最短路径和 最短路径长度（顺序不能颠倒）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8b2b7b88251e8ace2fda8f31679349033203f4be1d534cff7bcbf088cd6deb8.jpg)  

04.下图所示为一个用AOE网表示的工程。1）画出此图的邻接表表示。2）完成此工程至少需要多少时间？3）指出关键路径。4）哪些活动加速可以缩短完成工程所需的时间？  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/448a57f09817d564fd9e4ec59ab42c92ff4b5902d6d3b6bad19391a42a80076c.jpg)  

05.下表给出了某工程各工序之间的优先关系和各工序所需的时间（其中“一”表示无先驱工序）请完成以下各题：  

1）画出相应的AOE网。 2）列出各事件的最早发生时间和最迟发生时间。3）求出关键路径并指明完成该工程所需的最短时间  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea11a7dacb5c1a689e0bdc974ba7fe6ee8736332d0eecd50fc2447ee5981a831.jpg)  

06.一连通无向图，边非负权值，问用Dikstra最短路径算法能否给出一棵生成树，该树是 否一定是最小生成树？说明理由。  

07.试编写利用DFS实现有向无环图拓扑排序的算法  

08.【2009统考真题】带权图（权值非负，表示边连接的两顶点间的距离）的最短路径问题是找出从初始顶点到自标顶点之间的一条最短路径。假设从初始顶点到自标顶点之间存在路径，现有一种解决该问题的方法：  

$\textcircled{\scriptsize{1}}$ 设最短路径初始时仅包含初始顶点，令当前顶点 $u$ 为初始顶点。 $\circledcirc$ 选择离 $u$ 最近且尚未在最短路径中的一个顶点V，加入最短路径，修改当前顶点 $u=v_{\circ}$   $\textcircled{3}$ 重复步骤 $\circledcirc$ ，直到 $u$ 是目标顶点时为止。请问上述方法能否求得最短路径？若该方法可行，请证明：否则，请举例说明。  

09.【2011统考真题】已知有6个顶点（顶点编号为0\~5）的有向带权图 $G$ ，其邻接矩阵 $_A$ 为上三角矩阵，按行为主序（行优先）保存在如下的一维数组中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a899324565b460c6402ce1bdfc632930ad352b09f4536c9ed4b61e30794e10d8.jpg)  

要求：  

1）写出图 $G$ 的邻接矩阵A。2）画出有向带权图 $G_{c}$ 3）求图 $G$ 的关键路径，并计算该关键路径的长度。  

10.【2014统考真题】某网络中的路由器运行OSPF路由协议，下表是路由器R1维护的主要链路状态信息（LSI），RI构造的网络拓扑图（见下图）是根据题下表及RI的接口名构造出来的网络拓扑。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c610e648dc04ce4bd0e6f700e12ab6689bea0e516bbc618f11a3b14271b1baa.jpg)  

请回答下列问题。  

1）本题中的网络可抽象为数据结构中的哪种逻辑结构？2）针对表中的内容，设计合理的链式存储结构，以保存表中的链路状态信息（LSI）要求给出链式存储结构的数据类型定义，并画出对应表的链式存储结构示意图（示意图中可仅以ID标识结点）。3）按照Dijkstra算法的策略，依次给出R1到达子网 $192.1._{\mathrm{X.X}}$ 的最短路径及费用。  

11.【2017统考真题】使用Prim算法求带权连通图的最小（代价）生成树（MST）。请回答下列问题：  

1）对下列图 $G$ 从顶点 $A$ 开始求 $G$ 的MST，依次给出按算法选出的边2）图 $G$ 的MST是唯一的吗？3）对任意的带权连通图，满足什么条件时，其MST是唯一的？  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5866f5cef4574297162726e3c74198cfa8f0e74f09e67cfe3ae4861a78db497a.jpg)  

12.【2018统考真题】拟建设一个光通信骨干网络连通BJ、CS、XA、QD、JN、NJ、TL和WH等8个城市，下图中无向边上的权值表示两个城市之间备选光缆的铺设费用。请回答下列问题：  

1）仅从铺设费用角度出发，给出所有可能的最经济的光缆铺设方案（用带权图表示），并计算相应方案的总费用。2）该图可采用图的哪种存储结构？给出求解问题1）所用的算法名称。3）假设每个城市采用一个路由器按1）中得到的最经济方案组网，主机H1直接连接TL的路由器，主机H2直接连接BJ的路由器。若H1向H2发送一个 $\mathrm{TTL}=5$ 的 IP分组，则H2是否可以收到该IP分组？  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/988db1d95e7e87273cd82c0b6880528e120fddd6e4b66b528fb9dca3d4037c2d.jpg)  

# 6.4.7 答案与解析  

# 一、单项选择题  

01. A  

当无向连通图存在权值相同的多条边时，最小生成树可能是不唯一的；另外，由于这是一个无向连通图，因此最小生成树必定存在，从而选A。  

02.C  

因为无向连通图的最小生成树不一定唯一，所以用不同算法生成的最小生成树可能不同，但当无向连通图的最小生成树唯一时，不同算法生成的最小生成树必定是相同的。  

03.A  

最小生成树算法是基于贪心策略的，每次总是选取权值最小且满足条件的边，若各边权值不同，则每次选择的新顶点也是唯一的，因此最小生成树唯一，A正确。对于B，若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。对于C，选取的 $n\!-\!1$ 条边可能构成回路。对于D，含有 $n$ 个顶点、 $n\!-\!1$ 条边的子图可能构成回路，也可能不连通。  

04.A  

若图的边数小于 $n-1$ ，则图不存在最小生成树：若无向连通图的边数等于 $n-1$ ，则最小生成树唯一，即为图本身，所以图的边数一定大于 $n-1$ ，A正确。若最小生成树不唯一，则一定存在权值相等的边，但未必是权值最小的边，如下图所示，B错误。最小生成树可能不唯一，但代价一定相同，C错误。当图的各边的权值互不相等时，图的最小生成树是唯一的，D错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f966785a56f7219b92bd3159fa9a6fdbd71ca4e605ed551f492e5391121c04e6.jpg)  

05.A  

$U{=}\left\{1,2,3\right\}$ ， $V-U=\{4,5,\cdots\}$ ，候选边只能是这两个顶点集之间的边，只有A符合题意。  

06.C  

若选取边（1，3）则会构成回路。  

07.A  

A正确，见严蔚敏撰写的教材《数据结构》。Dijkstra算法适合求解有回路的带权图的最短 路径，也可以求任意两个顶点的最短路径，不适合求带负权值的最短路径问题。在用Floyd算法求两个顶点的最短路径时，当最短路径发生更改时， $\mathrm{\Delta}\mathrm{\mathfrak{h}}_{k-1}$ 就不是path的子集。  

08.C  

在负权图中，Dijkstra算法既不能保证每次选出的顶点都是真正的最近顶点，又不能保证已确定的最短路径不再被改变，因此Dikstra算法不允许边的权为负，I正确。求每对顶点间的最短路径需要调用Dijkstra算法 $n$ 次，时间复杂度为 $O(n^{3})$ ，ⅡI错误。Floyd算法求每对顶点间的最短路径充许有负边存在，但不充许有包含负边组成的回路，Ⅲ正确。  
09.B  

题目所描述的图 $G$ 如下图所示。A,B,C，D对应的路径长度分别为18，13，15,24。应用Dijkstra算法不难求出最短路径为  $\nu_{1}{\rightarrow}\nu_{3}{\rightarrow}\nu_{4}{\rightarrow}\nu_{6}{\rightarrow}\nu_{7}{\circ}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a12b8ef9ce0cdc2861a92c1c431f04efa89d5bbf617e04da0ef1c4278817060.jpg)  

10.D  

在Dijkstra算法的执行过程中，只可能修改从源点O到集合 $V\!-\!S$ 中某个顶点的最短路径  

11.A  

使用深度优先遍历，若从有向图上的某个顶点 $u$ 出发，在DFS $(u)$ 结束之前出现一条从顶点v到 $u$ 的边，由于 $v$ 在生成树上是 $u$ 的子孙，图中必定存在包含 $u$ 和 $v$ 的环，因此深度优先遍历可以检测一个有向图是否有环。拓扑排序时，当某顶点不为任何边的头时才能加入序列，存在环时环中的顶点一直是某条边的头，不能加入拓扑序列。也就是说，还存在无法找到下一个可以加入拓扑序列的顶点，则说明此图存在回路。求最短路径是充许图有环的。至于关键路径能否判断一个图有环，则存在一些争议。关键路径本身虽然不充许有环，但求关键路径的算法本身无法判断是否有环，判断是否有环是求关键路径的第一步一一拓扑排序。  

12.D  

若图 $G$ 中存在一条从v到 $v_{i}$ 的路径，说明 $V_{j}$ 是 $V_{i}$ 的前驱，则要把 $V_{j}$ 消去以后才能消去 $V_{i},$ 从而拓扑序列中必然先输出 $v_{j}$ ，再输出 $v_{i}$ ，这显然与题意矛盾。  

13.D  

对于I，若有向图中存在环，运行拓扑排序算法后，肯定会剩下有环的子图，在此环中无法再找到入度为0的顶点，拓扑排序也就无法再运行。对于ⅡI，若两个顶点之间不存在祖先或子孙关系，则它们在拓扑序列中的前后关系是任意的，因此使用栈和队列都可以，因为进栈或队列的都是入度为0的顶点。IⅢI是难点，若拓扑序列唯一，则很自然联想到一个线性的有向图，下图的拓扑序列也唯一，但却不满足该条件。对于IV，若入度为0的顶点不唯一，则这些顶点均可作为拓扑序列的起点：若出度为0的顶点不唯一，则这些顶点均可作为拓扑序列的终点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ff4dc41e511401c95eac50d846e8847e107fe68c249b561958cb51d3e3b7d84.jpg)  

14.A  

强连通图是指有向图中任意顶点对之间都存在两条相反的路径，这意味着强连通图中一定存在环，因此不能进行拓扑排序，1正确。假设顶点 $a$ 和 $^b$ 的入度均为0，且分别有两条孤从 $a$ 和 $b$ 指向同一顶点 $c$ ，则产生的拓扑序列可以是abc，但是此时并无一条弧<a, $b\!>$ ，Ⅱ错误。  

15.D  

一个有向图中的顶点不能排成一个拓扑序列，表明其中存在一个顶点数目大于1的回路（环），该回路构成一个强连通分量，从而答案选D。  
16. C  

A BCF DEG，ABCDFEG，ABCDEFG，ABD CF EG ABD CEF G。读者应能把这一类经典习题的拓扑序列全部写出来。  

17.A  

拓扑序列的过程：找到入度为0的顶点，删除该顶点及其所有出边，并将顶点加入拓扑序列，重复直至所有顶点都加入拓扑序列。选择入度为0的顶点 $\nu_{1}$ ，删除与 $\nu_{1}$ 有关的边；此时顶点 $v_{3}$ 的入度为0，选择 $v_{3}$ ，删除与 $v_{3}$ 有关的边；以此类推，得出 $G$ 的拓扑序列。  

18.B  

无向图的邻接矩阵存储中，每条边存储两次，且 $A[i][j]=A[j][i]$  

19.C  

此题一直以来争议较大，因为有些书中漏掉了“有序”二字。可以证明，对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元素全为零的充分必要条件是，该有向图可以进行拓扑排序。若这个题目把“有序”二字去掉，显然应选D。但此题题干中已经指出是“有序的拓扑序列”，因此应选C。需要注意的是，若一个有向图的邻接矩阵为三角矩阵（对角线以上或以下的元素为0），则图中必不存在环，因此其拓扑序列必然存在。  

20. A  

设图中有顶点 $v_{i}$ ，它有后继顶点 $v_{j}$ ，即存在边 $\begin{array}{r}{{\mathbf{\rho}}^{<}\mathbf{v}_{i},}\end{array}$  $v_{f}$ 。根据DFS 的规则， $v_{i}$ 入栈后，必先遍历完其后继顶点后 $\boldsymbol{v}_{i}$ 才会出栈，也就是说 $v_{i}$ 会在 $v_{j}$ 之后出栈，在如题所指的过程中， $v_{i}$ 在 $v_{j}$ 后打印。由于 $v_{i}$ 和 $v_{j}$ 具有任意性，因此由上面的规律看出，输出顶点的序列是逆拓扑有序序列。  

对有向无环图利用深度优先搜索进行拓扑排序的例子如下：如下图所示，退出DFS栈的顺序为efgdcahb，此图的一个拓扑序列为bhacdgfe。该方法的每一步均是先输出当前无后继的结点，即对每个结点 $v$ ，先递归地求出 $v$ 的每个后继的拓扑序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/95e2e823926f924b2589d0b7dfdd674f5f69af8575edf6919732ef5b2aebcfa4.jpg)  

21.C  

有向图邻接矩阵的第 $V$ 行中1的个数是顶点 $V$ 的出度，而有向图中顶点的度为入度与出度之和，1错。无向图的邻接矩阵一定是对称矩阵，但当有向图中任意两个顶点之间有边相连，且是两条方向相反的有向边时，有向图的邻接矩阵也是一个对称矩阵，Ⅱ错。最小生成树中的 $n\!-\!1$ 条边不能保证是图中权值最小的 $n\!-\!1$ 条边，因为权值最小的 $n\!-\!1$ 条边并不一定能使图连通。在下图中，左图的最小生成树如下图所示，权值为3的边不在其最小生成树中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b6edd2859df37c19f7a2db2bcc1addfd745b18f3c239b4dbcb5403f6e13b2b2.jpg)  

有向无环图的拓扑序列唯一并不能唯一确定该图。在下图所示的两个有向无环图中，拓扑序列都为 $V_{1},V_{2},V_{3},V_{4}$ ，IV错。注意，很多辅导书对该命题的判断是错误的。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba51729bd44321dd54583c4635c03ee9d8f3f509ea27ba9fa4af6069b7a12074.jpg)  

22.C  

观察题图，从 $V_{0}$ 到 $V_{8}$ 的最长路径为 $V_{0}{\rightarrow}V_{1}{\rightarrow}V_{4}{\rightarrow}V_{6}{\rightarrow}V_{8}$ ，长度为 $6+1+9+2=18$  

23.C  

题目描述的图如下，得到关键路径的长度为21，图中画出的两条路径都是关键路径。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0339099fc2887d3db0ba13f94595ebdf8256da86fabd6b3f2a3fbddd434a4046.jpg)  

24.C  

一个事件的最迟发生时间 $=$ min{以该事件为尾的弧的活动的最迟开始时间}），或min{以该事件为尾的弧所指事件的最迟发生时间与该弧的活动的持续时间之差）。改变AOE网中任何一个活动的持续时间，需要重新计算关键活动，可能导致关键路径的改变。  

25.C  

若改变的是所有关键路径上的公共活动，则不一定会产生不同的关键路径（延长必然不会导致，只有缩短才有可能导致）。根据关键路径的定义，可知选项ⅡI正确。关键路径是源点到终点的最长路径，只有所有关键路径的长度都缩短时，整个图的关键路径才能有效缩短，但也不能任意缩短，一旦缩短到一定程度，该关键活动就可能变成非关键活动。  

26.A  

邻接矩阵第i列值全为o，说明顶点 $i$ 没有入边，为整个工程的开始，若关键路径存在，则该顶点一定是起点。不能确定关键路径是否存在，也不能确定其对应的无向图的连通分量个数。  

27.B  

拓扑排序的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2fd17cb74237decb87b55ddb35fbe175806e2fdd5c49585e7e01c1047e081f09.jpg)  

可以得到3种不同的拓扑序列，即abced，abecd和aebcd。  
28.A  

最小生成树的树形可能不唯一（因为可能存在权值相同的边），但代价一定是唯一的，选项I正确。若权值最小的边有多条并且构成环状，则总有权值最小的边将不出现在某棵最小生成树 中，选项Ⅱ错误。设 $N$ 个结点构成环， $N-1$ 条边权值相等，另一条边权值较小，则从不同的顶点开始 $\operatorname{Prim}$ 算法会得到 $N-1$ 种不同的最小生成树，选项Ⅲ错误。当最小生成树唯一时（各边的权值不同）， $\operatorname{Prim}$ 算法和Kruskal算法得到的最小生成树相同，选项IV错误。  

29.C  

从 $a$ 到各顶点的最短路径的求解过程下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e1d083369e54075c281c4d4de6652df149becbf1ef0a3e632872be29db82818.jpg)  

后续目标顶点依次为f.d, $e$  

本题也可用排除法：对于A，若下一个顶点为 $d$ ，路径 $a_{i}$  $^b$  $d$ 的长度为5，而a,b,c,f的长度仅为4，显然错误。同理可排除选项B。将 $f$ 加入集合 $S$ 后，采用上述方法也可排除选项D。  

# 30. C  

对角线以下元素均为零，表明只有顶点 $i$ 到 $j$ C $i<j)$ 可能有边，而顶点 $j$ 到i一定没有边，即有向图是一个无环图，因此一定存在拓扑序列。对于拓扑序列是否唯一，试举一例：设有向图的邻接矩阵 $\left[\begin{array}{l l l}{0}&{1}&{1}\\ {0}&{0}&{0}\\ {0}&{0}&{0}\end{array}\right]$ 存在两个拓扑序列，因此该图存在可能不唯一的拓扑序列。  

结论：对于任一有向图，若它的邻接矩阵中对角线以下（或以上）的元素均为零，则存在拓扑序列（可能不唯一）。反止，若图存在拓扑序列，却不一定能满足邻接矩阵中主对角线以下的元素均为零，但是可以通过适当地调整结点编号，使其邻接矩阵满足前述性质。  

31.C  

找出AOE网的全部关键路径为bdcg、bdeh和bfh。根据性质，只有当所有关键路径的活动时间同时减少时，才能缩短工期。即正确选项中的路径必须能涵盖所有的关键路径。选项A和B不能涵盖bfh这条路径，选项C不能涵盖bdcg和bdeh这两条路径，只有选项C能涵盖所有关键路径，因此只有加快 $f$ 和 $d$ 的进度才能缩短工期（建议在图中检验）。  

# 32. D  

按照拓扑排序的算法，每次都选择入度为0的结点从图中删除，此图中一开始只有结点3的入度为0；删除结点3后，只有结点1的入度为0；删除结点1后，只有结点4的入度为0；删除结点4后，结点2和结点6的入度都为0，此时选择删除不同的结点，会得出不同的拓扑序列，分别处理完毕后可知可能的拓扑序列为 $3,1,4,2,6,5$ 和 $3,1,4,6,2,5$ ，选 D。  

# 33.C  

从 $V_{4}$ 开始，Kruskal算法选中的第一条边一定是权值最小的( $(V_{1},\,V_{4})$ ，选项B错误。由于 $V_{1}$ 和 $V_{4}$ 已经可达，因此含有 $V_{1}$ 和 $V_{4}$ 的权值为8的第二条边一定符合 $\operatorname{Prim}$ 算法，排除A、D。  

34.C  
第一个顶点和最后一个顶点相同的路径称为回路：序列中顶点不重复出现的路径称为简单路径；回路显然不是简单路径，I错误。稀疏图是边比较少的情况，邻接矩阵存储的空间复杂度为 $O(n^{2})$ ，必将浪费大量的空间，而邻接表存储的空间复杂度为 $O(\,n+e\,)$ ，所以应选用邻接表，ⅡI错误。存在回路的有向图不存在拓扑序列，若拓扑排序输出结束后所余下的顶点都有前驱，则说明只得到了部分顶点的拓扑有序序列，图中存在回路，Ⅲ正确。  

35.B  

根据Dijkstra算法，从顶点1到其余各顶点的最短路径如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b1ee570975fd06919866d013d958d6995eba2e2c6d77d5c3c78ac13ff8afc28.jpg)  

快速解法。依次观察从顶点1到其他顶点的最短路径长度：顶点1到顶点2的最短路径长度为5；顶点1到顶点3的最短路径长度为 $5+2=7$ ：顶点1到顶点4的最短路径长度为11：顶点1到顶点5的最短路径长度为4；顶点1到顶点6的最短路径长度为 $4\,+\,5\,=\,9$ ；最终dist  $[\mathbf{\Lambda}]\!=\!\!\{0,5,7,11,4,9\}$  ，根据dist数组值从小到大选择顶点顺序为  $1,5,2,3,6,4$  

# 36.B  

采用邻接表作为AOV网的存储结构进行拓扑排序，需要对 $n$ 个顶点做进栈、出栈、输出各一次，当处理 $e$ 条边时，需要检测这 $n$ 个顶点的边链表结点，共需要的时间为 $O(n+e)$ 。若采用邻接矩阵作为AOV网的存储结构进行拓扑排序，在处理 $e$ 条边时需对每个顶点检测相应矩阵中的某一行，寻找与它相关联的边，以便对这些边的入度减1，需要的时间代价为 $O(n^{2})$  

【补充】有两种常用的拓扑排序算法：基于BFS的算法和基于DFS的算法。本题未指明采用哪种算法，因此只需验证一种算法即可（说明两种算法在对应条件下的时间复杂度相同）。  

基于BFS的算法的思想：首先找到所有入度为0的结点，将它们加入一个队列，并将它们作为拓扑序列的起始部分：然后依次从队列中取出结点，并删除它们与后继结点的所有边。若某个后继结点的入度变为0，则将它也加入队列，并将它加入拓扑序列，重复这个过程。  

基于DFS的算法的思想：在DFS调用过程中设定一个时间标记，当DFS调用结束时，对各结点计时，进而按结束时间从大到小排序，可以得到一个拓扑序列。  

# 37.D  

拓扑排序每次选取入度为0的结点输出，经观察不难发现拓扑序列前两位一定是1，5或5，1（因为只有1和5的入度均为0，且其他结点都不满足仅有1或仅有5作为前驱）。  

# 38.C  

活动 $d$ 的最早开始时间等于该活动弧的起点所表示的事件的最早发生时间，活动 $d$ 的最早开始时间等于事件2的最早发生时间 $\operatorname*{max}\{a,b+c\}=\operatorname*{max}\{3,12\}=12$ 。活动 $d$ 的最迟开始时间等于该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差，先算出图中关键路径长度为27（对于不复杂的选择题，找出所有路径计算长度），那么事件4的最退发生时间为 $\operatorname*{min}\{27-g\}=\operatorname*{min}\{27-6\}=21$ ，活动 $d$ 的最迟开始时间为 $21\!-\!d=21\!-\!7=\!14$ 一。  
常规方法：按照关键路径算法算得到下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56bcc4f1f6756aaa5f9bd67269099b3a7f259e69c3a75559927b7d70f954a8c3.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f199d1399a50e953a7cf84fb0ada7c0eaf51aac09de82269325351cdd811b855.jpg)  

从表中可知，活动 $d$ 的最早开始时间和最迟开始时间分别为12和14，所以选C。  

# 39.A  

先将该表达式转换成有向二叉树，该二叉树中有些顶点是重复的，为了节省存储空间，去除重复的顶点，将有向二义树去重转换成有向无环图，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/212b218462bd3c21cb929472cb9866503e42aa62e53ef58d89185e96da6a061f.jpg)  

40.A  

Kruskal算法：按权值递增顺序依次选取 $_{n-1}$ 条边，并保证这 $_{n-1}$ 条边不构成回路。初始构造一个仅含 $n$ 个顶点的森林；第一步，选取权值最小的边 $(b,f$ ）加入最小生成树；第二步，剩余边中权值最小的边为 $(b,d$ ），加入最小生成树，第二步操作后权值最小的边 $(d,f$ ）不能选，因为会与之前已选取的边形成回路：接下来依次选取权值9、10、11对应的边加入最小生成树，此时6个顶点形成了一棵树，最小生成树构造完成。按照上述过程，加到最小生成树的边依次为 $(b,f$  $(b,d),(a,e),(c,e),(b,e)$ 。其生成过程如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d92c0bb4e1010180cfab5498139f19295844da3cfdbe11ea5bae0493f511335d.jpg)  
41.B  

根据题干所提供的信息可知：  

$\textcircled{\scriptsize{1}}$ 图 $G$ 为有向无环图，因此一定存在拓扑序列和逆拓扑序列。  

$\circledcirc$ DFS的性质是顶点 $v_{i}$ 的所有后继顶点 $\nu_{j}$ 出栈后， $\nu_{i}$ 才会出栈。  

$\textcircled{3}$ 本题要求执行输出语句后立刻退出递归，即执行完输出语句后立即出栈，因此后进栈的顶点先输出，结合 $\circledcirc$ 不难得出只有输出顶点 $v_{i}$ 的所有后继顶点 $v_{j}$ 后， $v_{i}$ 才会输出。  

综合上述分析，输出的顶点序列是逆拓扑有序序列。  

42.B  

关键路径是指权值之和最大而非边数最多的路径，A错误。选项B是关键路径的概念。无 论是存在一条还是存在多条关键路径，增加任意一个关键活动的时间都会延长工程的工期，因为关键路径始终是权值之和最大的那条路径，C错误。仅有一条关键路径时，减少关键活动的时间会缩短工程的工期；存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径，D错误。  

43. A  

求拓扑序列的过程：从图中选择无入边的结点，输出该结点并删除该结点的所有出边，重复上述过程，直至全部结点都已输出，这样求得的拓扑序列为ABCDEF。每次输出一个结点并删除该结点的所有出边后，都发现有且仅有一个结点无入边，因此该拓扑序列唯一。  

44.C  

在执行Dijkstra算法时，首先初始化dist』，若顶点1到顶点 $i\ (i=2,\,3,\,4,\,5)$ ）有边，就初始化为边的权值；若无边，就初始化为；初始化顶点集  $S$  只含顶点1。Dijkstra算法每次选择一个 到顶点1距离最近的顶点 $j$ 加入顶点集 $S$ ，并判断由顶点1绕行顶点 $j$ 后到任意一个顶点 $k$ 是否距离更短，若距离更短（即 $\mathrm{dist}[j]+\arcs[j][k]<\mathrm{dist}[k]\,)$ ，则将 dist[x]更新为 dist[] $^+$ arcs[][k]；重复该过程，直至所有顶点都加入顶点集 $S_{\circ}$ 数组dist的变化过程如下图所示，可知将第二个顶点5加入顶点集S后，数组dist更新为21,3,14,6。  

45.B  

在AOE网中，活动的时间余量 $=$ 结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的持续时间。根据关键路径算法得到下表：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cf2196f56af2eb2bcc141ea6e9394b99733c7f9d6e445cc9dad0be542fd517b0.jpg)  

c的时间余量 $=\!\nu(3)\!-\!\nu_{e}(2)-1\!=\!5-2-1\!=\!2$ ，g的时间余量 $=\!\nu(6)-\nu_{e}(3)-1=12-5-1=6$ ，h的时间余量 $=\!\nu(5)-\nu_{e}(4)-1=11-8-1=2$ ，j的时间余量 $=\!\nu(6)-\nu_{e}(5)-1=12\!-9-1=2$ 8  

46.B  

$\operatorname{Prim}$ 算法和Kruskal算法用于求解最小生成树，最小生成树中某顶点到其余各顶点的路径不一定具有最短路径的性质。例如，在下图所求得的最小生成树中，a到c的路径长度为2，但原图中a到c的最短路径长度为1。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/45e267869ed4acc552bd57cfb251c668895d9d327d24bba63cf807414b310f12.jpg)  

图的广度优先搜索算法总按距离由近到远来遍历图中的每个顶点，因此可用来求解非带权图（或各边权值均相同）的单源最短路径问题。  

# 二、综合应用题  

01.【解答】  

这种方法是正确的。  

由于经过“破圈法”之后，最终没有回路，因此一定可以构造出一棵生成树。下面证明这棵生成树是最小生成树。记“破圈法”生成的树为T，假设 $T$ 不是最小生成树，则必然存在最小生成树 $T_{0}$ ，使得它与 $T$ 的公共边尽可能多，则将 $T_{0}$ 与 $T$ 取并集，得到一个图，此图中必然存在回路，由于“破圈法”的定义就是从回路中去除权最大的边，因此此时生成的 $T$ 的权必然是最小的，这与原假设矛盾，从而 $T$ 是最小生成树。下图说明了“破圈法”的过程：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28e65480b50c412183861db54ef5344d3a80d792ce5d605b2212227b797687b2.jpg)  

# 02.【解答】  

1）该图的邻接矩阵为  

$$
A={\frac{3}{4}}{\left[\begin{array}{l l l l l l}{1}&{2}&{3}&{4}&{5}&{6}&{7}\\ {0}&{3}&{3}&{6}&{\infty}&{\infty}&{\infty}\\ {\infty}&{0}&{4}&{\infty}&{5}&{\infty}&{\infty}\\ {\infty}&{\infty}&{0}&{\infty}&{4}&{\infty}&{\infty}\\ {\infty}&{\infty}&{\infty}&{0}&{\infty}&{5}&{\infty}\\ {5}&{\infty}&{\infty}&{\infty}&{0}&{\infty}&{3}\\ {6}&{\infty}&{3}&{\infty}&{\infty}&{0}&{7}\\ {7}&{\infty}&{\infty}&{\infty}&{\infty}&{\infty}&{0}\end{array}\right]}
$$  

得到的深度优先遍历序列为 $1,2,3,5,7,4,6,$  

2）解题思路：当某个顶点只有出弧而没有入弧时，其他顶点无法到达这个顶点，不可能与其他顶点和边构成强连通分量（这个单独的顶点构成一个强连通分量）。  

$\textcircled{\scriptsize{1}}$ 顶点1无入弧构成第一个强连通分量。删除顶点1及所有以之为尾的弧。 $\circledcirc$ 顶点2无入弧构成一个强连通分量。删除顶点2及所有以之为尾的弧。  
$\textcircled{3}$  

以此类推，最后得到每个顶点都是一个强连通分量，所以强连通分量数目为7。  

3）该图的两个拓扑序列如下：  

$\textcircled{\scriptsize{1}}$  1,2,4,6,3,5,7 ②1,4,2,6,3,5,7  

4）若视该图为无向图：  

用 $\operatorname{Prim}$ 算法生成最小生成树的过程如下：1—2，1-3，3-6，3-5，5-7，6-4（图略）。用Kruskal算法生成最小生成树的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a88b5f3b18dfebf298354e38e440539a4b0bf43f1d0de9271086610afad2432.jpg)  

# 03.【解答】  

根据Dikstra算法，求从顶点1到其余各顶点的最短路径如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cc7c36b9797f2479b1cb2e54568d40f440bd2bedaca99c55c0b29d9983a46ed.jpg)  

# 04.【解答】  

1）该图的邻接表表示如下图所示  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6d98cfa9ca142c73dc51d838d72012d3fb06dd226c39d7db95fbc1573275f36.jpg)  

求关键路径的算法如下：  

$\textcircled{\scriptsize{1}}$ 输入 $e$ 条弧<i $k^{>}$ ，建立AOE网的存储结构。 $\textcircled{2}$ 从源点 $v_{1}$ 出发，令 $v_{e}(1)\,{=}\,0$ ，求 $v_{e}(j)$ ， $2{\leqslant}j{\leqslant}n$  $\textcircled{3}$ 从汇点 $v_{n}$ 出发，令 $v_{1}(n)=v_{e}(n)$ ，求 $\nu_{\mathrm{l}}(i)$ ， $1\!\leqslant\!i\!\leqslant n\!-\!1$ 。 $\textcircled{4}$ 根据各顶点的 $\nu_{e}$ 和 $v_{1}$ 值，求每条弧 $s$ （活动）的最早开始时间 $e(s)$ 和最晚开始时间I(s)，其中 $e(s)=l(s)$ 为关键活动。  

2）根据以上算法可以得到至少需要时间16。  

3）关键路径为  $(V_{1},V_{3},V_{5},V_{7},V_{9})_{\circ}$  

4）活动 $a_{2},a_{6},a_{9},a_{12}$ 加速，可以缩短工程所需的时间。  

# 05.【解答】  

1）根据题表可以画出AOE网如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/53237128e29e41fb7ef6db32656b88abe417f5a32bf28f732f659e4dbb6cf861.jpg)  

求解各事件和活动的最早发生时间与最迟发生时间公式分别如下：  

$\textcircled{\scriptsize{1}}$ V（源点） $=0$ ，ve（k)=Max{v(）+Weight（y,v)）}，Weight $(v_{j},v_{k})$ 表示从 $v_{j}$ 指向 $v_{k}$ 的弧的权值。  

$\circledcirc$   $\nu_{1}$   $={\nu_{e}}($   $v_{1}(j)=\mathrm{Min}\{v_{1}(k)-\mathrm{Weibt}(v_{j},\,v_{k})\}$   $(v_{j},v_{k})$   $v_{j}$   $v_{k}$  弧的权值。 $\textcircled{3}$ 若边 $\begin{array}{r l}{\lefteqn{<\!\nu_{k},}}&{{}}\end{array}$ v>表示活动 $a_{i}$ ，则有 $e(i)=v_{e}(k)$ 0 $\textcircled{4}$ 若边 $\begin{array}{r}{\mathrm{\Sigma}^{<\nu_{k},~}}\end{array}$ v>表示活动 $a_{i}$ ，则有 $l(i)=v_{1}(j)-\mathrm{Weibull}(v_{k},v_{j})$  $\circledast$   $)~d(i)=l(i)-e(i)\circ$  关键路径即由 $\boldsymbol d(i)=0$ 的 $i$ 构成。  

2）根据上述公式，各事件的最早发生时间 $\boldsymbol{v}_{e}$ 和最迟发生时间 $v_{l}$ 如下表所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/da5c6d62cde32e87b40744b1f6b1a2ec0688fc76c844bc7aedc0fc23cee86a35.jpg)  

3）根据上述公式，各活动最早发生时间e、最迟发生时间 $l$ 和时间余量 $d(i)=l(i)\,{-}\,e(i)$ 如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3a3ea7bca2ef34fc4c5ad1c4d740fe8dd33a2f795ea6fe1d1e0ee828ba4cc8d6.jpg)  

所以关键路径为 $B$ 、 $E$ 、 $G$ ，完成该工程最少需要8（单位依题意而定）。  

06.【解答】  

Diikstra算法每一步都会贪婪地选择与源点 $\nu_{0}$ 最近的下一条边，直到 $v_{0}$ 连接到图中所有顶点。 $\operatorname{Prim}$ 算法（已知是最小生成树算法）与Diikstra算法高度相似，但是在每个阶段，它贪婪地选择与该阶段已加入MST中任意一个顶点最近的下一条边。显然，Dikstra算法可以产生一棵生成树，但该树不一定是最小生成树，只需举出一个反例即可，以下图 $G$ 为例（将a作为源点）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d05a1566d1c8da4ef8df224254808eba76adf3d3deb612f894419835c7831327.jpg)  
(a）图G  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/64f33a9fef4a712f10af18ec2c7de356f42cb82d00698f14af96048d200fa482.jpg)  
(b）两种算法产生的生成树  

Dijkstra算法得到的路径集合为{（a,b).（a,c)，（a,d)}，该生成树的总权值为 $5+5+5=15$  $\operatorname{Prim}$ 算法得到的边集合为{（ad)），（b，d)，（c，d）}，该最小生成树的总权值为 $5+1+1=7.$ 显然，Dijkstra算法得到的生成树不一定是最小生成树。  

# 07.【解答】  

本节前面给出了DFS实现拓扑排序的思想，下面是利用DFS求各顶点结束时间的代码（在DFS的基础上加入了time变量）。将结束时间从大到小排序，即可得到拓扑序列。  

bool visited[MAX VERTEX NUM];/访问标记数组void DF S Traverse(Graph G){ for  $|\mathrm{v}{=}0\rrangle$   $\scriptstyle{\mathrm{~v}}<G$  .vexnum;  $++\mathbf{v}$  1 visited[v] $=$ FALSE;//初始化访问标记数组time  $_{;=0}$  for $\scriptstyle{\sqrt{=}0}$  $\mathrm{w}{<}G$ .vexnum; $++\uptau$ 川/本代码从 $\scriptstyle{\mathrm{~v=0~}}$ 开始遍历if(!visited[v]） DFS(G,v）;void DFS（Graph G,int v)  

visited[v]  $=$  TRUE; visit $(\upnu)$ ；for  $w=$  First Neighbor(G,v);  $w\!>\!=\!0$   $w=$  Next Neighbor（G,V,w))  
if(!visited[w]){ J/w为  $\triangledown$  的尚未访问的邻接点 DFS(G,W);  

time  $=$  time+l;finishTime[v]  $=$  time;  

08.【解答】  

该方法不一定能（或不能）求得最短路径。  

例如，对于下图所示的带权图，若按照题中的原则，从 $A$ 到 $C$ 的最短路径是 $A{\rightarrow}B{\rightarrow}C,$ 事实上其最短路径是  $A{\rightarrow}D{\rightarrow}C$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5b9bdc22e89cd4a2703d5bc77424463c6ccdebc588048a0ec21ea6108cdbda72.jpg)  

09.【解答】  

1）在上三角矩阵A[6][6]中，第1行至第5行主对角线上方的元素个数分别为5，4，3，2,1，由此可以画出压缩存储数组中的元素所属行的情况，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc242faacbd5ff2a4bbb0b3163909ea560bb24dc7d59e94a53c316898cec1c7c.jpg)  

可以用“平移”的思想，将前5个、后4个、后3个、后2个、后1个元素，分别移动到矩阵对角线（“0"）右边的行上。图 $G$ 的邻接矩阵 $_A$ 为  

$$
A\,{=}\,{\left[\begin{array}{l l l l l l}{0}&{4}&{6}&{\infty}&{\infty}&{\infty}\\ {\infty}&{0}&{5}&{\infty}&{\infty}&{\infty}\\ {\infty}&{\infty}&{0}&{4}&{3}&{\infty}\\ {\infty}&{\infty}&{\infty}&{0}&{\infty}&{3}\\ {\infty}&{\infty}&{\infty}&{\infty}&{0}&{3}\\ {\infty}&{\infty}&{\infty}&{\infty}&{\infty}&{0}\end{array}\right]}
$$  

2）有向带权图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f246a1a9ffa3bac2b4e025337a668ae5b8bb0813a2554b1107fa9fe436c02729.jpg)  

3）先计算各个事件的最早发生时间，得到 $\nu_{e}()$ 和 $v_{I}()$ 数组如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71c45a3721ff64c0c43703c8a63f9a52859a3f6e0ed933bad6dc2f29ddff5454.jpg)  

接下来计算所有活动的最早和最迟发生时间 $e()$ 和70，如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4706f54e80dcf9cfb473b8312eaac94ee44d65b57604d08ac7a8e1aef5852690.jpg)  
满足 $l()\!-\!e()=0$ 的路径就是关键路径，所以关键路径为 $a_{0^{-}1},\,a_{1^{-}2},\,a_{2^{-}3},\,a_{3^{-}5}$ ，如下图所示（双线箭头表示），长度为 $4+5+4+3=16$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d2937832e7c5f605c93a412e766a82ebc26ac38bfd25625b580d09da03b76fa.jpg)  

按求关键路径的公式计算较为复杂，建议考生面临此类题时直接穷举各条路径即可，  

10.【解答】  

本题初看起来感觉难度较大，但仔细分析就可发现考查的其实是邻接表的数据结构  

1）图题中给出的是一个简单的网络拓扑图，可以抽象为无向图。  

2）图的常用存储结构有邻接矩阵法和邻接表法，其中邻接表法属于链式存储结构，因此本题的基本思路就是写出邻接表的数据类型定义，并根据题意调整相应的边表结点和顶点表结点的成员变量。具体分析如下：邻接表由表头顶点和弧顶点组成。根据题目给出的图和表，可将顶点分为三类：路由器、网络和链路。路由器是连接网络和链路的载体，因此可将它作为表头顶点。网络和链路则是连接路由器的边，因此可将它们作为弧顶点。为了简化代码，可将网络和链路的结构合并为一个，用一个标志位来区分它们，这样就可用邻接表来实现图的存储。链式存储结构的如下图所示。  

弧结点的两种基本形态
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7dbfc41c69dca1bf179b1e180bb9e86403e3bda1ff588de297ff127505faa9b7.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bde19f77b71d686ba2f71be0c25d9ec98bd668550d671d4f6d77b054380aac90.jpg)  

其数据类型定义如下：  

typedef struct{ unsigned int ID, IP; )LinkNode;/Link的结构typedef struct{ unsigned int Prefix, Mask; )NetNode;//Net的结构typedef struct Node{ int Flag; //Flag  $^{=1}$  为Link;Flag  $_{=2}$  为Net unionl LinkNode Lnode; NetNode Nnode )LinkORNet; Unsigned int Metric; struct Node \*next; )ArcNode;//弧结点typedef struct hNode unsigned int RouterID; ArcNode \*LN link; Struct hNode \*next; )HNODE; //表头结点  

对应表的链式存储结构示意图如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0011931a93d019337cf4a954057bb753baf0694837d72912f8f90dbba5458bca.jpg)  

3）计算结果如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d329691b5cbd2906f23e4dfc9f6de81c302a8208ade214142e41f4c8799511e.jpg)  

# 11.【解答】  

1）Prim算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中的所有顶点为止。算法的每一步在连接树集合 $S$ 的顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合 $S_{\circ}$ 当算法终止时， $S$ 就是最小生成树。  

$\circledcirc S$ 中顶点为 $A$ ，候选边为 $(A,D),(A,B),(A,E)$ ，选择 ${\mathcal{\mathbf{\ell}}}(A,D)$ 加入 $S$  $({\small\mathscr{Q}})\,S$ 中顶点为 $A,D$ ，候选边为 $(A,B)$  $(A,E),(D,E)$  $(C,D)$ ，选择 $(D,E)$ ，加入 $S$  $\circledcirc S$ 中顶点为 $A,D,E$ ，候选边 $\mathfrak{g}(A,B),(C,D),(C,E)$ ，选择 $(C,E)$ 加入S。 $(\!4\!)\,S$ 中顶点为 $A,D,E,C$ ，候选边为 $(A,B),(B,C)$ ，选择 $(B,C)$ 加入 $S_{\circ}$  $({\mathfrak{S}})\,S$ 就是最小生成树。  

依次选出的边为  

$$
(A,D),(D,E),(C,E),(B,C)
$$  

2）图 $G$ 的MST是唯一的。第一小题的最小生成树包括了图中权值最小的4条边，其他边除 $(A,E)$ 外都比这4条边大，但若用 $(A,E)$ 替换同权值的 $(C,E)$  $A,D,E$ 三个顶点构成了回路，因此不能替换，所以此图的MST唯一。  

3）当带权连通图的任意一个环中所包含的边的权值均不相同时，其MST是唯一的。此题不要求回答充分必要条件，所以回答一个限制边权值的充分条件即可。  

12.【解答】  

1）为了求解最经济的方案，可把问题抽象为求无向带权图的最小生成树。可以采用手动Prim算法或Kruskal算法作图。注意本题的最小生成树有两种构造，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f49f52813183cca54fe6fb810601191af11c959eb18194de436e554832930a1a.jpg)  

方案的总费用为16。  

2）存储题中的图可采用邻接矩阵（或邻接表）。构造最小生成树采用 $\operatorname{Prim}$ 算法（或Kruskal算法）。  

3） $\mathrm{TTL}=5$ ，即IP分组的生存时间（最大传递距离）为5，方案1中TL和BJ的距离过远 $\mathrm{TTL}=5$ 不足以让IP分组从H1传送到H2，因此H2不能收到IP分组。而方案2中TL和BJ邻近，H2可以收到IP分组。  

# 归纳总结  

1.关于图的基本操作  

本章中的很多程序对采用邻接表或邻接矩阵的存储结构都适用，主要原因是在图的基本操作函数中保持了相同的参数和返回值，而封闭了内部实现细节。  

例如，取 $_\mathrm{x}$ 邻接顶点y的下一个邻接顶点的函数NextNeighbor（G，x,y）。  

1）用邻接矩阵作为存储结构  

int Next Neighbor（MGraph& G,int x,int y）{ if  $(\mathbf{x}!=-1$  &&  $\mathsf{y}!\!=\!\!-1$  for(int col=y+l;col<G.vexnum;col++) if（G.Edge[x][col]  ${>}0$  &&G.Edge[x][col]<maxWeight) return col; /max Weight oo return-1;  

2）用邻接表作为存储结构  

int Next Neighbor（ALGraph& G，int x,int y){ if $(\mathbf{x}!=-1)$ /顶点 $_\mathrm{x}$ 存在ArcNode $\star_{\mathsf{P}=\mathsf{G}}$ .vertices[x].first;//对应边链表第一个边结点while（p!=NULL&& p->data!=y)/寻找邻接顶点y $\mathtt{p}^{=}\mathtt{p}^{->}$  next; if（p!=NULL&& p->next！  $=$  NULL) return p->next->data;1/返回下一个邻接顶点return-l;  

2.关于图的遍历、连通性、生成树、关键路径的几个要点  

1）在执行图的遍历时，因为图中可能存在回路，且图的任意一个顶点都可能与其他顶点相连，所以在访问完某个顶点后可能会沿某些边又回到了曾经访问过的顶点。因此，需要设置一个辅助数组visited[]标记顶点是否已被访问过，避免重复访问。  
2）深度优先搜索时利用回溯法对图遍历，一般利用递归方法实现，每当向前递归查找某一邻接结点之前，必须判断该结点是否访问过。另外，递归算法均可借助栈来实现非递归算法，深度优先搜索也不例外，具体程序见6.3.4节的综合应用题03。3）广度优先搜索是一种分层的遍历过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。因此，它不是一个递归的过程。4）一个给定的图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入先后次序不同，则生成的邻接表表示也不同。5）图的最小生成树首先必须是带权连通图，其次要在 $n$ 个顶点的图中选择 $n\!-\!1$ 条边将其连通，使得其权值总和达到最小，且不出现回路。6）加速某一关键活动不一定能缩短整个工程的工期，因为AOE网中可能存在多条关键路径。可能存在称为“桥”的一种特殊关键活动，它位于所有的关键路径上，只有它加速才会缩短整个工期。  

# 思维拓展  

【网易有道笔试题】求一个无向连通图的割点。割点的定义是，若除去此结点和与其相关的边，无向图不再连通，描述算法。  

提示：要判断一个点是否为割点，最简单直接的方法是，先把这个点和所有与它相关的边从图中去掉，再用深搜或广搜来判断剩下的图的连通性，这种方法适合判断给定结点是否为割点；还有一种比较复杂的方法可以快速找出所有割点，有兴趣的读者可自行搜索相关资料。  
# 第7章查找  

# 【考纲内容】  

（一）查找的基本概念（二）顺序查找法（三）分块查找法（四）折半查找法（五）树形查找二叉搜索树：平衡二叉树：红黑树（六）B树及其基本操作、 $^{\mathrm{B+}}$ 树的基本概念（七）散列（Hash）表（八）查找算法的分析及应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/04bba28557f8de0f60708124edff3cf56401157743f882b68284dea1f7097c04.jpg)  

【复习提示】  

本章是考研命题的重点。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找长度等。对于二叉排序树、二叉平衡树和红黑树，要了解它们的概念、性质和相关操作等。B树 和 $^{\mathrm{B+}}$ 树是本章的难点。对于B树，考研大纲要求掌握插入、删除和查找的操作过程；对于 $^{\mathrm{B+}}$ 树仅要求了解其基本概念和性质。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。  

# 7.1查找的基本概念  

1）查我。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分  
为两种：一是查我成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。  

2）查找表。用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。对查找表的常见操作有： $\textcircled{\scriptsize{1}}$ 查询符合条件的数据元素： $\circledcirc$ 插入、删除数据元素。  

3）静态查找表。若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地插入或删除的查找表称为动态查找表。适合静态查我表的查我方法有顺序查找、折半查找、散列查我等：适合动态查找表的查我方法有二叉排序树的查找、散列查找等。  

4）关键字。数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。  

5）平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查我长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为  

$$
\mathrm{ASL}=\sum_{i=1}^{n}P_{i}C_{i}
$$  

式中， $n$ 是查找表的长度； $P_{j}$ 是查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_{i}=1/n$ ； $C_{i}$ 是找到第 $i$ 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。  

# 7.2 顺序查找和折半查找  

# 7.2.1 顺序查找  

顺序查找又称线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素：对于链表，可通过指针next来依次扫描每个元素。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。下面分别进行讨论。  

# 1.一般线性表的顺序查找  

作为一种最直观的查找方法，其基本思想： $\textcircled{\scriptsize{1}}$ 从线性表的一端开始，逐个检查关键字是否满足给定的条件； $\circledcirc$ 若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置； $\textcircled{3}$ 若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。下面给出其算法，后面说明了算法中引入的“哨兵”的作用。  

typedef struct{//查找表的数据结构（顺序表）ElemType \*elem;/动态数组基址int TableLen;/表的长度)SSTable; int Search_Seq(SSTable ST,ElemType key){ ST.elem[0]=key; Ⅱ“哨兵” for(int  $\scriptstyle{\mathrm{i}}={\mathrm{ST}}$  .TableLen;ST.elem[i]  $!=\!\kappa$  ey;--i); //从后往前找 returni；//若查找成功，则返回元素下标；若查找失败，则返回0  

上述算法中，将ST.elem[O]称为哨兵，引入它的目的是使得Search_Seq内的循环不必判断数组是否会越界。算法从尾部开始查找，若找到ST.elem[i] $==$ key则返回i值，查找成功。否则一定在查找到sT.elem $\left[\,0\,\right]=$ key时跳出循环，此时返回的是0，查找失败。在程序中引入“哨兵”，可以避免很多不必要的判断语句，从而提高程序效率。  
对于有 $n$ 个元素的表，给定值key与表中第 $i$ 个元素相等，即定位第 $i$ 个元素时，需进行 $n\!-\!i\!+\!1$ 次关键字的比较，即 $C_{i}\!=\!n\!-\!i\!+\!1$ 。查找成功时，顺序查找的平均长度为  

$$
\operatorname{ASL}_{\mathfrak{h}(n;i)}=\sum_{i=1}^{n}P_{i}(n-i+1)
$$  

当每个元素的查找概率相等，即 $P_{i}=1/n$ 时，有  

$$
\operatorname{PSL}_{n|k\rangle n|}{=}{\sum_{i=1}^{n}P_{i}(n-i+1)}={\frac{n+1}{2}}
$$  

查找不成功时，与表中各关键字的比较次数显然是 $n+1$ 次，即ASL $\kappa_{\hat{\imath}\hat{\imath}\hat{\jmath}}=n+1$  

通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由大至小重新排列。  

综上所述，顺序查找的缺点是当 $n$ 较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对链表只能进行顺序查找。  

# 2.有序线性表的顺序查找  

若在查找之前就已知表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低查找失败的平均查找长度。假设表 $L$ 是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key，当查找到第 $i$ 个元素时，发现第 $i$ 个元素的关键字小于key，但第 $i+1$ 个元素的关键字大于key，这时就可返回查找失败的信息，因为第 $i$ 个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。  

# 命题追踪有序线性表的顺序查找的应用（2013）  

可以用如图7.1所示的判定树来描述有序线性表的查找过程。树中的圆形结点表示有序线性表中存在的元素；矩形结点称为失败结点（若有 $n$ 个结点，则相应地有 $n+1$ 个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到矩形结点，则说明查找失败。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b9a556e5c788039f2fe0a08be26af8476e380c1fcd30a762adcbe9951bfa13c7.jpg)  
图7.1有序顺序表上的顺序查找判定树  

在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为  

$$
\operatorname{ASL}_{\mathcal{K}:n\times l}=\!\!\sum_{j=1}^{n}q_{j}(l_{j}-1)\!=\!\frac{1\!+2\!+\!\cdots\!+n\!+\!n}{n\!+\!1}\!=\!\frac{n}{2}\!+\!\frac{n}{n\!+\!1}
$$  
式中， $q_{j}$ 是到达第 $j$ 个失败结点的概率，在相等查找概率的情形下，它为 $1/(n+1)$  $l_{j}$ 是第 $j$ 个失败结点所在的层数。当 $n=6$ 时，ASL $\kappa_{i i k x h}=6/2+6/7=3.86$ ，比一般的顺序查找好一些。  

注意，有序线性表的顺序查找和后面的折半查找的思想是不一样的，且有序线性表的顺序查找中的线性表可以是链式存储结构，而折半查找中的线性表只能是顺序存储结构。  

# 7.2.2 折半查找  

折半查找又称二分查找，它仅适用于有序的顺序表。  

# 分析对比给定查找算法与折半查找的效率（2016）  

折半查找的基本思想： $\textcircled{\scriptsize{1}}$ 首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置； $\circledcirc$ 若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若key大于中间元素，则所查找的元素只可能在后半部分），然后在缩小的范围内继续进行同样的查找。重复上述步骤，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。算法如下：  

int Binary Search(SSTable L,ElemType key){ int low  $=\!0$  ,high  $\mathbf{\mu=}\mathbb{L}$  .TableLen-l,mid; while(low  $<=$  high){ mid=（low+high)/2;/取中间位置if(L.elem[mid]  $\scriptstyle==\mathrm{kg}$  return mid;//查找成功则返回所在位置elseif(L.elem[mid]>key) high=mid-1;I/从前半部分继续查找else low=mid+1;//从后半部分继续查找return //查找失败，返回-1  

当折半查找算法选取中间结点时，既可以采用向下取整，又可以采用向上取整。但每次查找的取整方式必须相同，这部分内容请读者结合本题部分习题来理解。  

# 命题追踪折半查找的查找路径的判断（2015）  

例如，已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}，要查找值为11和32的元素，指针1ow和high分别指向表的下界和上界，mid则指向表的中间位置L（low+high）/2」。  

下面来说明查找11的过程（查找32的过程请读者自行分析）  

710 13 16 19 2932 3337 41 43 ↑low ↑mid ↑high  

第一次查找时，将中间位置元素与key比较。因为 $11<29$ ，说明待查元素若存在，则必在范围[low,mid-1]内，high mid-1，high=mid- $\cdot{}^{1}{=}5$ ，mid=(1+5)/ $^{\prime}2{=}3$ ，第二次查找范围为[1,5] 。  

7 10 13 16 1929 32 33 3741 43 ↑low ↑mid ↑high  

第二次查找时，将中间位置元素与key比较。因为 $11<13$ ，说明待查元素若存在，则必在范围[low,mid-1]内，high mid-1，high=mid- $^{\cdot1=2}$ ，mid $\scriptstyle=$ (1+2) $^{\prime}2{=}1$ ，第三次查找范围为[1,2]。  

7 10 13 16 19 29 32 33 3741 43 low↑ ↑high mid↑  
第三次查找时，将中间位置元素与key比较。因为 $11>7$ ，说明待查元素若存在，则必在范围[mid $^{+1}$ ,high]内。令low=mid $_{+1=2}$ ,mid $=\left(2\!+\!2\right)/2\!=\!2$ ，第四次查找范围为[2，2]。  

第四次查找，此时子表只含有一个元素，且 $10\neq11$ ，所以表中不存在待查元素。  

# 命题追踪分析给定二叉树树形能否构成折半查找判定树（2017）  

折半查找的过程可用图7.2所示的二叉树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值：树中最下面的叶结点都是方形的，它表示查找失败的区间。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查我失败时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左子结点值，且均小于其右子结点值。若有序序列有 $n$ 个元素，则对应的判定树有 $n$ 个圆形的非叶结点和 $n+1$ 个方形的叶结点。显然，判定树是一棵平衡二叉树（见7.3.2节）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a3c13d8b6e09e2161cf91b26befcb36e69ca849ba58fb230483c6eaa214215f5.jpg)  
图7.2描述折半查找过程的判定树  

# 命题追踪折半查找的最多比较次数的分析（2010、2023）  

由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为  

$$
\mathrm{ASL}={\frac{1}{n}}\sum_{i=1}^{n}l_{i}={\frac{1}{n}}(1\times1+2\times2+\cdots+h\times2^{h-1})={\frac{n+1}{n}}\log_{2}(n+1)-1\approx\log_{2}(n+1)-1
$$  

式中， $h$ 是树的高度，并且元素个数为 $n$ 时树高 $h=\lceil\log_{2}(n+1)\rceil,$ 。所以，折半查找的时间复杂度为 $O(\log_{2}n)$ ，平均情况下比顺序查找的效率高。  

在图7.2所示的判定树中，在等概率情况下，查找成功（圆形结点）的 $\mathrm{ASL}=(1{\times}1+2{\times}2+3{\times}4+$  $4{\times}4)/11=3$ ，查找失败（方形结点）的 $\mathrm{ASL}=(3{\times}4+4{\times}8)/12=11/3.$  

因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。  

# 7.2.3 分块查找  

分块查我又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。  

分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找。 例如，关键码集合为88,24,72,61,21,6,32,11，8,31,22,83,78,54}，按照关键码值24,54,7888，分为4个块和索引表，如图7.3所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76ded7a7f7a5d8bfa95e7e4f016ef281090b1deb3b0fa15e348952f286083f80.jpg)  
图7.3分块查找示意图  

分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为 $L_{1}$ 和 $L_{S}$ ，则分块查找的平均查找长度为  

$$
\mathrm{ASL}=L_{1}+L_{S}
$$  

将长度为 $n$ 的查找表均匀地分为 $^b$ 块，每块有 $s$ 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为  

$$
{\mathrm{ASL}}=L_{1}+L_{s}={\frac{b+1}{2}}+{\frac{s+1}{2}}={\frac{s^{2}+2s+n}{2s}}
$$  

此时，若  $s={\sqrt{n}}$  ，则平均查找长度取最小值  ${\sqrt{n}}+1$  

虽然索引表占用了额外的存储空间，索引查找也增加了一定的系统开销，但由于其分块结构，使得在块内查找时的范围较小，因此与顺序查找相比，分块查找的总体效率提升了不少。  

# 7.2.4 本节试题精选  

# 一、单项选择题  

01.顺序查找适合于存储结构为（）的线性表。  

A.顺序存储结构或链式存储结构B.散列存储结构C.索引存储结构D.压缩存储结构  

02.由 $n$ 个数据元素组成的两个表：一个递增有序，一个无序。采用顺序查找算法，对有序表从头开始查找，发现当前元素已不小于待查元素时，停止查找，确定查找不成功，已知查找任意一个元素的概率是相同的，则在两种表中成功查找（）  

A.平均时间后者小B.平均时间两者相同C.平均时间前者小D.无法确定  

03.对长度为 $n$ 的有序单链表，若查找每个元素的概率相等，则顺序查找表中任意一个元素的查找成功的平均查找长度为（）  

A.n/2 B.  $(n+1)/2$  C.  $(n-1)/2$  D.n/4  

04.对长度为3的顺序表进行查找，若查找第一个元素的概率为1/2，查找第二个元素的概率为1/3，查找第三个元素的概率为1/6，则查找任意一个元素的平均查找长度为（）。  

A.5/3 B.2 C.7/3 D.4/3 05.下列关于二分查找的叙述中，正确的是（）  
A.表必须有序，表可以顺序方式存储，也可以链表方式存储B.表必须有序且表中数据必须是整型、实型或字符型C.表必须有序，而且只能从小到大排列D.表必须有序，且表只能以顺序方式存储  

06.在一个顺序存储的有序线性表上查找一个数据时，既可以采用折半查找，也可以采用顺序查找，但前者比后者的查找速度（）。  

A.必然快 B.取决于表是递增还是递减 C.在大部分情况下要快D.必然不快  

07.折半查找过程所对应的判定树是一棵（）  

A.最小生成树 B.平衡二叉树 C.完全二叉树 D.满二叉树  

08.折半查找和二叉排序树的时间性能（）  

A.相同B.有时不相同C.完全不同D.无法比较  

09.在有11个元素的有序表 $\mathbb{A}\left[1,2,\cdots,11\right]$ 中进行折半查找（L（low+high）/2），查找元素A[11]时，被比较的元素下标依次是（）。  

A.6,8,10,11 B.6,9,10,11 C.6,7,9,11 D.6,8,9,11  

10.已知有序表（13,18,24,35，47,50,62，83,90,115，134），当二分查找值为90的元素时，查找成功的元素比较次数为（）。  

A.1 B.2 C.4T D.6  

11.若有序表的关键字序列为 $\{b,c,d,e,f,g,q,r,s,t\}$ ，则在二分查找关键字 $b$ 的过程中，进行比较的关键字依次为（）。  

A.  $f,c,b$  B.  $f,d,b$  C.  $g,c,b$  D. g,d, b

 12.对表长为 $n$ 的有序表进行折半查找，其判定树的高度为（）A.  $\lceil\log_{2}(n+1)\rceil$  B.  $\lfloor\log_{2}(n+1)\rfloor-1$  C.[log2n] D.[log2n]-1  

13.已知一个长度为16的顺序表，其元素按关键字有序排列，若采用折半查找算法查找一个不存在的元素，则比较的次数至少是（），至多是（）  

A.4 B.5 C.6 D.7  

14.具有12个关键字的有序表中，对每个关键字的查找概率相同，折半查找算法查找成功的平均查找长度为（），折半查找查找失败的平均查找长度为（）。  

A.37/12 B.35/12 C.39/13 D.49/13

 15.下列关于查找的说法中，正确的是（）。（注，涉及下节内容）  

A.若数据元素保持有序，则查找时就可以采用折半查找法B.折半查找与二叉查找树的时间性能在最坏情况下是相同的C.折半查找法的平均查找长度一定小于顺序查找法D.折半查找法查找一个元素大约需要 $O(\log_{2}\!n)$ 次关键字比较  

16.采用分块查找时，数据的组织方式为（）  

A.数据分成若干块，每块内数据有序B.数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块C.数据分成若干块，每块内数据有序，每块内最大（或最小）的数据组成索引块D.数据分成若干块，每块（除最后一块外）中数据个数需相同  
17.对有2500个记录的索引顺序表（分块表）进行查找，最理想的块长为（）  

A.50 B.125 C.500 D.  $\lceil\log_{2}2500\rceil$  

18.设顺序存储的某线性表共有123个元素，按分块查找的要求等分为3块。若对索引表采 用顺序查找法来确定子块，且在确定的子块中也采用顺序查找法，则在等概率情况下，分块查找成功的平均查找长度为（）  

A.21 B.23 C.41 D.62  

19.为提高查找效率，对有65025个元素的有序顺序表建立索引顺序结构，在最好情况下查找到表中已有元素最多需要执行（）次关键字比较。  

A.10 B.14 C.16 D.21  

20.【2010统考真题】已知一个长度为16的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个 $L$ 中不存在的元素，则关键字的比较次数最多是（）。  

A.4 B.5 C. 6 D.7

 21.【2015统考真题】下列选项中，不能构成折半查找中关键字比较序列的是（）  

A.500,200,450,180 B.500,450,200,180 C.180,500,200,450 D.180,200,500,450  

22.【2016统考真题】在有 $n$  $n>1000$ ）个元素的升序数组A中查找关键字X。查找算法的伪代码如下所示。  

$\kappa{=}0$  while  $(\kappa{<}\mathrm{n}$  且  $\mathbb{A}\left[\mathbb{k}\right]\!<\!\mathrm{x}$   $\scriptstyle{k=k+3}$  if $\mathrm{/}\kappa\mathrm{<}\mathrm{n}$ 且 $\mathtt{A}\left[\mathtt{k}\right]==\mathtt{x},$ ）查找成功；elseif $\uparrow\downarrow\!\!k\!-\!\!1\!<\!\!\mathrm n$ 且 $\mathbb{A}\left[k{-}1\right]==$ ）查找成功：elseif $\gamma_{\kappa-2<n}$ 且 $\mathtt{A}\left[\mathtt{k}\!-\!2\right]\mathrm{==}\mathtt{x}$ ）查找成功；else查找失败；  

本算法与折半查找算法相比，有可能具有更少比较次数的情形是（）。  

A.当x不在数组中 B.当  $_\mathrm{x}$  接近数组开头处 C.当 $_\mathrm{x}$ 接近数组结尾处D.当 $_\mathrm{x}$ 位于数组中间位置  

23.【2017统考真题】下列二叉树中，可能成为折半查找判定树（不含外部结点）的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c13950ab9fd4df6cf068579f50b852ff0a022f97e4be3f907048e120b0626ebc.jpg)  

24.【2023统考真题】对含600个元素的有序顺序表进行折半查找，关键字间的比较次数最 多是（）。  

A.9 B.10 C.30 D.300  

# 二、综合应用题  

01.若对有 $n$ 个元素的有序顺序表和无序顺序表进行顺序查找，试就下列三种情况分别讨论两者在相等查找概率时的平均查找长度是否相同。  

1）查找失败。2）查找成功，且表中只有一个关键字等于给定值k的元素。3）查找成功，且表中有若干关键字等于给定值 $\boldsymbol{\mathrm{k}}$ 的元素，要求一次查找能找出所有元素。  
02.有序顺序表中的元素依次为017,094,154,170,275,503,509,512,553,612,677,765,897,908。1）试画出对其进行折半查找的判定树。2）若查找275或684的元素，将依次与表中的哪些元素比较？3）计算查找成功的平均查找长度和查找不成功的平均查找长度。  

03.已知一个有序顺序表A[0...8n-1]的表长为8n，并且表中没有关键字相同的数据元素。假设按下述方法查找一个关键字值等于给定值X的数据元素：首先在 $\mathtt{A}\left[\,7\,\right],\mathtt{A}\left[\,15\,\right],\mathtt{A}\left[\,23\,\right],\cdots,\mathtt{A}\left[\,8\,\mathtt{k}{-1}\,\right],\cdots,\mathtt{A}\left[\,8\,\mathtt{n}{-1}\,\right]$ 中进行顺序查找，若查找成功，则算法报告成功位置并返回；若不成功，则当 $\mathbb{A}\left[8\,\mathsf{k}\!-\!\mathbb{1}\right]\!<\!\!\mathsf{X}\!\!<\!\!\mathbb{A}\left[8\times\left(\mathsf{k}\!+\!\mathbb{1}\right)-\!\mathbb{1}\right]$ 时，可确定一个缩小的查找范围 $\mathbb{A}\left[8\,\mathtt{k}\right]{\sim}\mathbb{A}\left[8\times\left(\mathtt{k}\!+\!1\right)\!-\!2\right]$ ，然后可在这个范围内执行折半查找。特殊情况：若 $\mathrm{X}{>}\mathtt{A}\left[\,8\mathrm{n}{-}1\,\right]$ 的关键字，则查找失败。1）画出描述上述查找过程的判定树。2）计算相等查找概率下查找成功的平均查找长度。  

04.写出折半查找的递归算法。初始调用时，1ow为1，high为ST.length  

05.线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱结点（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。  

06.已知一个 $n$ 阶矩阵 $_A$ 和一个目标值 $k_{\circ}$ 该矩阵无重复元素，每行从左到右升序排列，每列从上到下升序排列。请设计一个在时间上尽可能高效的算法，判断矩阵中是否存在目标值 $k_{\circ}$ 例如，矩阵为 $\begin{array}{r}{\left[\begin{array}{l l l}{1}&{4}&{7}\\ {2}&{5}&{8}\\ {3}&{6}&{9}\end{array}\right]}\end{array}$ ，目标值为8，判断存在。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你的算法的时间复杂度和空间复杂度。  

07.【2013统考真题】设包含4个数据元素的集合 $S=\{\mathrm{d}\mathrm{o}^{\prime}$ ,'for','repeat'，'while'}，各元素的查找概率依次为 $p_{1}=0.35,p_{2}=0.15,p_{3}=0.15,p_{4}=0.35.$ 将 $S$ 保存在一个长度为4的顺序表中，采用折半查找法，查找成功时的平均查找长度为2.2。  

1）若采用顺序存储结构保存 $S$ ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？  

2）若采用链式存储结构保存 $S$ ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？  

# 7.2.5 答案与解析  

# 一、单项选择题  

01.A  

顺序查找是指从表的一端开始向另一端查找。它不要求查找表具有随机存取的特性，可以是顺序存储结构或链式存储结构。  

02.B 对于顺序查找，不管线性表是有序的还是无序的，成功查找第一个元素的比较次数为1，成功查找第二个元素的比较次数为2，以此类推，即每个元素查找成功的比较次数只与其位置有关（与是否有序无关），因此查找成功的平均时间两者相同。  
03.B  

在有序单链表上做顺序查找，查找成功的平均查找长度与在无序顺序表或有序顺序表上做顺序查找的平均查找长度相同，都是 $(n+1)/2$  

04.A  

在长度为3的顺序表中，查找第一个元素的查找长度为1，查找第二个元素的查找长度为2，查找第三个元素的查找长度为3，所以有  

$$
\operatorname{PSL}_{\vec{n}\times\vec{n}}{=}\frac{1}{2}{\times}1{+}\frac{1}{3}{\times}2{+}\frac{1}{6}{\times}3=\frac{5}{3}
$$  

05.D  

二分查找通过下标来定位中间位置元素，所以应采用顺序存储，且二分查找能够进行的前提是查找表是有序的，但具体是从大到小还是从小到大的顺序则不做要求。  

06. C  

折半查找的快体现在一般情况下，在大部分情况下要快，但是对于某些特殊情况，顺序查找可能会快于折半查找。例如，查找一个含1000个元素的有序表中的第一个元素时，顺序查找的比较次数为1次，而折半查找的比较次数却将近10次。  

07.B  

A显然排除。对于选项C，考点精析示例中的判定树就不是完全二叉树。由选项C也可排除选项D，且满二叉树对结点数有要求。只可能选B。事实上，由折半查找的定义不难看出，每次把一个数组从中间结点分割时，总是把数组分为结点数相差最多不超过1的两个子数组，从而使得对应的判定树的两棵子树高度差的绝对值不超过1，所以应是平衡二义树。  

08.B  

折半查找的性能分析可以用二叉判定树来衡量，平均查找长度和最大查找长度都是 $O(\log_{2}n)$ 二叉排序树的查找性能与数据的输入顺序有关，最好情况下的平均查找长度与折半查找相同，但最坏情况即形成单支树时，其查找长度为 $O(n)$  

09.B  

依据折半查找算法的思想，第一次mid=L（ $_{1+11}$ )/2 ${\it\Delta\phi}=6{\it\Delta\Psi}$ ，第二次 $\begin{array}{r}{\mathrm{mid}\;\mathrm{mid}=\left\lfloor\left(6\!+\!1\right)\!+\!11\right\rfloor/2\right\rfloor=\!9}\end{array}$ 第三次 $\mathsf{m i d}\!=\!\!\big\lfloor\,\left(\,9\!+\!1\right)\!+\!11\,\big\rceil\,/2\,\big\big\rfloor\!\!=\!\!\!10$ ，第四次mid $=\mathbb{1}$  

10.B  

开始时1ow指向13，high指向134，mid指向50，比较第一次 $90>50$ ，所以将1ow指向62，high指向134，mid指向90，第二次比较找到90。  

11. A  

在折半查找算法中，mid取值的方式是确定的，要么采用向上取整，要么采用向下取整，而不能出现两种情况。对于A，第1次比较的元素是f，为向下取整；第2次比较的元素是 $c$ ，为向下取整；第3次比较的元素是 $b$ ，为向下取整，查找成功，符合二分查找。对于B，第1次比较的元素是f为向下取整；第2次比较的元素是 $d$ ，为向上取整，两次mid取值的方式不同，不符合二分查找。对于C，第1次比较的元素是 $g$ ，为向上取整；第2次比较的元素是 $^c$ ，为向下取整，不符合二分查找。对于D，第1次比较的元素是 $g$ ，为向上取整；第2次比较的元素是 $d$ 为正中间元素；第3次比较的元素为 $b$ ，为向下取整，不符合二分查找。  

12.A  

对  $n$  个结点的判定树，设结点总数  $n=2^{h}-1$  ，则  $h=\lceil\log_{2}(n+1)\rceil_{\circ}$  
另解：特殊值代入法。直接将 $n=1$ 和 $n=2$ 的情况代入，仅有A满足要求。  

13.A、B  

对于此类题，有两种做法：一种方法是，画出查找过程中构成的判定树，让最小的分支高度对应于最少的比较次数，让最大的分支高度对应于最多的比较次数，出现类似于长度为15的顺序表时，判定树刚好是一棵满树，此时最多比较次数与最少比较次数相等；另一种方法是，直接用公式求出最小的分支高度和最大分支高度，从前面的讲解不难看出最大分支高度为 $H\!=\!\!\lceil\log_{2}(n+1)\rceil\!\!=\!5$ ，这对应的就是最多比较次数，然后由于判定树不是一棵满树，所以至少应该是4（由判定树的各分支高度最多相差1得出）。  

注意，若是求查找成功或查找失败的平均查找长度，则需要画出判定树进行求解。此外，对长度为 $n$ 的有序表，采用折半查找时，查找成功和查找失败的最多比较次数相同，均为 $\lceil\log_{2}(n+1)\rceil,$  

14.A、D  

假设有序表中元素为A[0...11]，不难画出对它进行折半查找的判定树如下图所示，圆圈是查找成功结点，方形是虚构的查找失败结点。从而可以求出查找成功的 $\mathrm{ASL}=(1+2{\times}2+3{\times}4+4{\times}5)/12=$ 37/12，查找失败的 $\mathrm{ASL}=(3{\times}3+4{\times}10)/13$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d62638414a41c9d2f61f21d04880497f33ac6a96f5789b84f1a19767ff1dbd1.jpg)  

# 注意  

对于本类题目，应先根据所给 $n$ 的值，画出如上图所示的折半查找判定树。另外，查找失败结点的ASL不是到图中的方形结点，而是到方形结点上一层的圆形结点。  

15.D  

折半查找法不仅要求数据元素有序，而且要求必须为顺序存储，A错误。折半查找法在最坏情况下的时间性能为 $O(\log_{2}n)$ ，二叉查找树在最坏情况下的时间性能为 $O(n)$ ，B错误。在每个元素查找概率不同的情况下，折半查找法的平均查找长度可能大于顺序查找法， $\mathrm{^C}$ 错误。  

16.B  

通常情况下，在分块查找的结构中，不要求每个索引块中的元素个数都相等。  

17. A  

设块长为 $b$ ，索引表包含 $n/b$ 项，索引表的 $\mathrm{ASL}=(n/b+1)/2$ ，块内的 $\mathrm{ASL}\,{=}\,(b+1)/2$ ，总 $\mathrm{{SL}}=$ 索引表的ASL $^+$ 块内的 $\mathrm{ASL}=(b+n/b+2)/2$ ，其中对于 $b+n/b$ ，由均值不等式知 $b=n/b$ 时有最小值，此时 $b\!=\!\sqrt{n}$ 。则最理想块长为 $\sqrt{2500}=50$ 。  

18.B  

根据公式 ${\mathrm{ASL}}=L_{1}+L_{s}={\frac{b+1}{2}}+{\frac{s+1}{2}}={\frac{s^{2}+2s+n}{2s}}$ ，其中 $b=n/s,s=123/3,n=123$ ，代入不难得出ASL为23。所以选B。另一方面，可根据穷举法来一步步模拟。对于A块中的元素，查找过程的第一步是先找到A块，由于是顺序查找，找到A块只需一步，然后在A块中顺序查找。因此，A块内各元素查找长度分别为 $2,3,4,\cdots,42$ 。对于B块，采用类似的方法，但查找到B块要比查找到A块多一步，因此B块内各元素查找长度为 $3,4,5,\cdots,43$ 。同理，C块中各个元素查找长度为 $4,5,6,\cdots$ 44。所以平均查找长度为（2+3+4+...+42+3+4+5+..+43+4+5+6+..+44）/123=23。  
19.C  

为使查找效率最高，每个索引块的大小应是 $\sqrt{65025}{=}255$ ，为每个块建立索引，则索引表中索引项的个数为255。若对索引项和索引块内部都采用折半查找，则查找效率最高，为 $\left\lceil\log_{2}(255\!+\!1)\right\rceil+$  $\left\lceil\log_{2}(255\!+\!1)\right\rceil\!=\!16\,\mathrm{.}$  

20.B  

折半查找法在查找不成功时和给定值进行关键字的比较次数最多为树的高度，即 $\scriptstyle\log_{2}n\rfloor+1$ 或 $\mathrm{log}_{2}(n+1)\lceil,$ 在本题中， $n=16$ ，所以比较次数最多为5。  

# 注意  

在折半查找判定树中的方形结点是虚构的，它不计入比较的次数。  

21.A  

画出查找路径图，因为折半查找判定树是一棵二叉排序树，看其是否满足二叉排序树的要求。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/208fba8f531d9f042b4bb575f0d21b6def06133281f5bff8ae5b6d8e47a0c4e4.jpg)  

显然，选项A的查找路径不满足。  

22.B  

本题为送分题。该程序采用跳跃式的顺序查找法查找升序数组中的x。显然， $_\mathrm{x}$ 越靠前，比较次数越少。  

23.A  

对于给定的一个有序查找表，其对应的折半查找判定树是确定且唯一的。7.2.2节描述的折半查找算法中，mid $\bar{-}$ L（low+high）/2]，因此若表中初始有 $2n+1$ 个元素，则mid分割后，左右子树各有 $n$ 个元素；若表中初始有 $2n$ 个元素，则mid分割后，左子树有 $n-1$ 个元素，右子树有 $n$ 个元素。即左子树的元素个数或者与右子树的元素个数相等，或者比右子树少一个。若令mid $\bar{=}$ 1（low+high）/2|，不难理解，左子树的元素个数或者与右子树的元素个数相等，或者比右子树多一个。选项A，树中每个左子树都与右子树的结点个数相等，或者多一个结点，符合向上取整的规则。选项B、C、D，存在有的左子树比右子树多一个结点，有的左子树比右子树少一个结点，不符合折半查找的规则。  

24.B  

用折半查找法查找给定值的比较次数最多不超过折半查找判定树的高度。折半查找判定树 的树高 $h=\lceil\log_{2}(n+1)\rceil$ ，将 $n=600$ 代入，结果为10。  
# 二、综合应用题  

01.【解答】  

1）平均查找长度不同。因为有序顺序表查找到其关键字值比要查找值大的元素时就停止查找，并报告失败信息，不必查找到表尾：而无序顺序表必须查找到表尾才能确定查找失败。  

2）平均查找长度相同。两者查找到表中元素的关键字值等于给定值时就停止查找  

3）平均查找长度不同。有序顺序表中关键字相等的元素相继排列在一起，只要查找到第一个就可以连续查找到其他关键字相同的元素。而无序顺序表必须查找全部表中的元素才能找出相同关键字的元素，因此所需的时间不同。  

02.【解答】  

1）判定树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76e322a28944433e37007a894880a99a516312625dc2efc436b3c5c8f3b0d2f6.jpg)  

2）若查找275，依次与表中元素509.154.275进行比较，共比较3次。若查找684，依次与 表中元素509，677，897，765进行比较，共比较4次。  

3）在查找成功时，会找到图中的某个圆形结点，其平均查找长度为  

$$
\operatorname{PSL}_{n\!\!k\!\times\!\!j_{l}}=\frac{1}{14}\sum_{i=1}^{14}C_{i}=\frac{1}{14}(1+2\times2+3\times4+4\times7)=\frac{45}{14}
$$  

在查找失败时，会找到图中的某个方形结点，但这个结点是虚构的，最后一次的比较元素为其父结点（圆形结点），所以其平均查找长度为  

$$
\mathrm{ASL}_{\mathbb{K}^{n}\mathbb{K}^{n}}={\frac{1}{15}}\sum_{i=0}^{14}C_{i}^{\prime}={\frac{1}{15}}(3\times1+4\times14)={\frac{59}{15}}
$$  

03.【解答】  

1）先在A[7]，A[15]，"，A[8n-1]内顺序查找，再在区间内折半查找。相应的判定树如 下图所示。其中，每个关键字下的数字为其查找成功时的关键学比较次数。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31eafbd9a8e3949e9c8b697dc72a887a69869cf17a7452141a76ea81a84f6ceb.jpg)  

2）等查找概率下，平均每个关键字查找成功的概率为 $1/8n$ ； $_{0\sim7}$ 之间的关键字，顺序比较1次后，进行折半查找，查找成功的平均查找长度为 $2\mathrm{~+~}3{\times}2\mathrm{~+~}4{\times}4$  $8\!\sim\!15$ 之  
间的关键字，先顺序比较2次后，再进入折半查找：以此类推， $8(n-1){\sim}8n-1$ 之间的关键字，先顺序比较 $n$ 次，再进入折半查找，如上图所示。因此，查找成功的平均查找长度为  

$$
\begin{array}{l c l}{{\operatorname{PSL}_{\scriptscriptstyle{\tilde{n}}\scriptscriptstyle{\tilde{k}};\scriptscriptstyle{\tilde{n}}}=\displaystyle\frac{1}{8n}\sum_{i=0}^{8n-1}C_{i}=\displaystyle\frac{1}{8n}\biggl(\sum_{i=1}^{n}i+\sum_{i=2}^{n+1}i+2\sum_{i=3}^{n+2}i+4\sum_{i=4}^{n+3}i\biggr)}}\\ {{}}\\ {{}}&{{=\displaystyle\frac{1}{8n}\biggl(\sum_{i=1}^{n}(i+(i+1)+2(i+2)+4(i+3))\biggr)}}\\ {{}}&{{=\displaystyle\frac{1}{8n}\sum_{i=1}^{n}(8i+17)=\frac{1}{n}\sum_{i=1}^{n}i+\frac{17}{8}\!=\!\frac{n+1}{2}\!+\!\frac{17}{8}}}\end{array}
$$  

04.【解答】  

算法的基本思想：根据查找的起始位置和终止位置，将查找序列一分为二，判断所查找的关键字在哪一部分，然后用新的序列的起始位置和终止位置递归求解。  

算法代码如下：  

typedef struct{川查找表的数据结构ElemType\*elem;存储空间基址，建表时按实际长度分配，0号留空intlength;//表的长度}SSTable; int Bin Search Rec（SSTable ST,ElemType key,int low,int high){if(low>high) return0; mid $=$ (low+high)/2;//取中间位置if(key>ST.elem[mid])//向后半部分查找Bin Search Rec（ST,key,mid+l,high);elseif（key<ST.elem[mid]）//向前半部分查找Bin Search Rec(ST,key,low,mid-1); else //查找成功 returnmid;  

算法把规模为 $n$ 的复杂问题经过多次递归调用转化为规模减半的子问题求解。时间复杂度为 $O(\log_{2}\!n)$ ，算法中用到了一个递归工作栈，其规模与递归深度有关，也是 $O(\log_{2}n)$  

# 05.【解答】  

算法的基本思想：检索时可先从表头开始向后顺序扫描，若找到指定的结点，则将该结点和其前趋结点（若存在）交换。采用顺序表存储结构的算法实现如下：  

int SeqSrch（RcdType R[],ElemType k){ //顺序查找线性表，找到后和其前面的元素交换int  $\scriptstyle{\dot{\mathbf{1}}}=0$  while((R[i].key $!\!=\!\!k$ && $\mathrm{(\vec{\tau})}$ ） $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ 川/从前向后顺序查找指定结点if（i<n&&i>0){ I/若找到，则交换 temp  $\scriptstyle{\varepsilon=\mathbb{R}}$  [i];R[i]  $\scriptstyle=\mathbb{R}$  [i-1];R[i-1]=temp; return--i;交换成功，返回交换后的位置elsereturn -1; 交换失败  

链表的实现方式请读者自行思考。注意，链表方式实现的基本思想与上述思想相似，但要注意用链表实现时，在交换两个结点之前需要保存指向前一结点的指针。  
06.【解析】  

1）算法的基本设计思想：  

从矩阵 $_{A}$ 的右上角（最右列）开始比较，若当前元素小于自标值，则向下寻找下一个更大的元素：若当前元素大于自标值，则从右往左依次比较，若自标值存在，则只可能在该行中。  

2）算法的实现：  

bool findkey（int A[][],intn,int k){ int  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\frac{1}{1}}=\mathbf{n}-1$  while(  $\mathtt{i}\!<\!\mathtt{n}\!\;\delta\delta\,\mathtt{i}\!>=\!0$  //离开边界时查找结束 if(A[i][j]  $==k$  ）returntrue；l/查找成功 else if(A[i][j]>k)j--;/向左移动，在该行内寻找目标值else $\dot{\mathbf{1}}_{++}$ /向下移动，查我下一个更大的元素return false; //查找失败  

3）比较次数不超过 $2n$ 次，时间复杂度为 $O(n)$ ：空间复杂度为 $O(1)$  

07.【解答】  

1）折半查找要求元素有序顺序存储，字符串默认按字典序排序（字典序是一种比较两个字符串大小的方法，它按字母顺序从左到右逐个比较对应的字符，若某一位可比较出大小，则不再继续比较后面的字符，如abd<acd、abc<abcd等），对本题来说do<for<repeat<while。若各个元素的查找概率不同，折半查找的性能不一定优于顺序查找。采用顺序查找时，元素按其查找概率的降序排列时查找长度最小。采用顺序存储结构，数据元素按其查找概率降序排列。采用顺序查找方法。查找成功时的平均查找长度 $=\!0.35\!\times\!1+0.35\!\times\!2+0.15\!\times\!3+0.15\!\times\!4=2.1$ 此时，显然查找长度比折半查找的更短。  

2）答案1：采用链式存储结构时，只能采用顺序查找，其性能和顺序表一样，类似于上题。数据元素按其查找概率降序排列，构成单链表。采用顺序查找方法。查找成功时的平均查找长度 $=\!0.35\!\times\!1+0.35\!\times\!2+0.15\!\times\!3+0.15\!\times\!4=2.1.$ 答案2：还可以构造成二叉排序树的形式。采用二叉链表的存储结构，构造二叉排序树，元素的存储方式见下图。采用二叉排序树的查找方法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/afb63decb05cee9e2bed3e965980387378416316eb46074679f198ad328a9aa8.jpg)  

查找成功时的平均查找长度 $=0.15\times1+0.35\times2+0.35\times2+0.15\times3=2.0.6$  

# 7.3 树形查找  

# 7.3.1二叉排序树（BST）  

构造一棵二叉排序树的目的并不是排序，而是提高查找、插入和删除关键字的速度，二叉排序树这种非线性结构也有利于插入和删除的实现。  
# 1.二叉排序树的定义  

# 命题追踪二叉排序树的应用（2013）  

二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：  

1）若左子树非空，则左子树上所有结点的值均小于根结点的值。2）若右子树非空，则右子树上所有结点的值均大于根结点的值。3）左、右子树也分别是一棵二叉排序树。  

# 命题追踪二叉排序树中结点值之间的关系（2015、2018）  

根据二叉排序树的定义，左子树结点值 $<$ 根结点值 $<$ 右子树结点值，因此对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，图7.4所示二叉排序树的中序遍历序列为123468。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ce5699f8e763d0cb3b6dbd0974980ca0913f135c1e27622016155408d0e469aa.jpg)  
图7.4一棵二叉排序树  

# 2.二叉排序树的查找  

二义排序树的查找是从根结点开始，沿某个分支遂层向下比较的过程。若二义排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，若小于根结点的关键字，则 在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。  

二叉排序树的非递归查找算法：  

BSTNode \*BST Search(BiTree T,ElemType key)( while(T!=NULL&&key  $!=$  T->data){ I/若树空或等于根结点值，则结束循环 if（key<T->data）T=T->1child；//小于，则在左子树上查找 elseT=T->rchild; //大于，则在右子树上查找 returnT;  

例如，在图7.4中查找值为4的结点。首先4与根结点6比较。由于4小于6，所以在根结点6的左子树中继续查找。由于4大于2，所以在结点2的右子树中查找，查找成功。  

同样，二叉排序树的查找也可用递归算法实现，递归算法比较简单，但执行效率较低。具体的代码实现，留给读者思考。  

# 3.二叉排序树的插入  

二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。  

插入结点的过程如下：若原二义排序树为空，则直接插入：否则，若关键字 $\boldsymbol{\mathrm{k}}$ 小于根结点值则插入到左子树，若关键字k大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。如图7.5所示在一棵二叉排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e89e6ea7f4ada4a4c481bc8b1e0ce1cafabd2e67868cbf3cc6ccf9d77c30fc9c.jpg)  
图7.5向二叉排序树中插入结点  

二叉排序树插入操作的算法描述如下：  

int BST Insert（BiTree &T，KeyType k）( if（ $\scriptstyle\mathrm{T}==$ NULL)(//原树为空，新插入的记录为根结点 $\scriptstyle{\mathrm{T}}=$  (BiTree)malloc（sizeof（BSTNode)); T->data  $=\kappa$  T->lchild  $=$  T->rchild  $\equiv$  NULL; return1; /返回1，插入成功 elseif( $\scriptstyle{k=T^{*}}$ ->data)//树中存在相同关键字的结点，插入失败return 0; elseif(k<T->data) /插入T的左子树 return BST Insert(T->lchild,k); else /插入T的右子树 return BST Insert（T->rchild,k);  

# 4.二叉排序树的构造  

命题追踪 构造二叉排序树的过程（2020）  

从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设查找的关键字序列为{45，24，53，45，12.24}，则生成的二叉排序树如图7.6所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/359f08371aa754ac430fc9f29a85302372b2b4d9718c8e692c96b4d3a2472bf0.jpg)  
图7.6二叉排序树的构造过程  

构造二叉排序树的算法描述如下：  

void Creat BST（BiTree &T，KeyType str[],int n){  $\scriptstyle{\mathrm{T}}=$  NULL; //初始时T为空树 int  $_\mathrm{i}\!=\!0$  while $\mathrm{\ddot{z}}\mathrm{<}\mathrm{n}_{i}$ //依次将每个关键字插入二叉排序树BSTInsert(T,str[i]);  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  
# 5.二叉排序树的删除  

在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都册除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：  

$\textcircled{\scriptsize{1}}$ 若被删除结点：是叶结点，则直接删除，不会破坏二叉排序树的性质。 $\circledcirc$ 若结点z只有一棵左子树或右子树，则让：的子树成为z父结点的子树，替代z的位置。 $\textcircled{3}$ 若结点 $z$ 有左、右两棵子树，则令：的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。  

图7.7显示了在3种情况下分别删除结点45.78.78的过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/337a0835918349dc03e9c616897783190facdb482e06740c2ec450fd4cfe8a1b.jpg)  
图7.73种情况下的删除过程  

# 命题追踪二叉排序树中删除并插入某结点的分析（2013）  

思考：若在二叉排序树中删除并插入某结点，得到的二叉排序树是否和原来的相同？  

# 6.二叉排序树的查找效率分析  

二义排序树的查找效率，主要取决于树的高度。若二义排序树的左、右子树的高度之差的绝对值不超过1（平衡二叉树，下一节），它的平均查找长度为 $O(\log_{2}n)$ 。若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为 $O(n)$  

在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数 $n$ ，如图7.8（b）所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54dd73fa59f89a754e5fd4e7dce8cf7124f8fa9db15eeeafeb8140073840c7bf.jpg)  
图7.8相同关键字组成的不同二叉排序树  

在等概率情况下，图7.8（a）查找成功的平均查找长度为  

$$
\mathrm{ASL_{a}}\!=(1+2\!\times\!2+3\!\times\!4+4\!\times\!3)/10=2.9
$$  

而图7.8（b）查找成功的平均查找长度为  

$$
\mathrm{ASL}_{b}=(1+2+3+4+5+6+7+8+9+10)/10=5.5
$$  

从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，如图7.8所示。  

就维护表的有序性而言，二义排序树无须移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为 $O(\log_{2}n)$ 。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是 $O(n)$ 。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。  

# 7.3.2 平衡二叉树  

# 1.平衡二叉树的定义  

为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树（Balanced BinaryTree），也称AVL树。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。  

# 命题追踪平衡二叉树的定义（2009）  

因此，平衡二叉树可定义为或是一棵空树，或是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。图7.9（a）所示是平衡二叉树，图7.9（b）所示是不平衡的二叉树。结点中的数字为该结点的平衡因子。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42460a711e8a2a7bcbc0a975d83fd52c42972810cdf1ff0354c8c9d9ea7aa463.jpg)  
图7.9平衡二叉树和不平衡的二叉树  
# 2.平衡二叉树的插入  

二叉排序树保证平衡的基本思想如下：每当在二义排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以 $A$ 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。  

# 命题追踪平衡二叉树中插入操作的特点（2015）  

# 注意  

每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。图7.10中的虚线框内为最小不平衡子树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2209bb6cb24b8548ca118f9d5f40aa8899f7ed2e20e83c7fe0c0621ee7b842db.jpg)  
图7.10最小不平衡子树示意  

# 命题追踪平衡二叉树的插入及调整操作的实例（2010、2019、2021）  

平衡二义树的插人过程的前半部分与二义排序树相同，但在新结点插人后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：  

1）LL平衡旋转（右单旋转）。由于在结点 $A$ 的左孩子（L）的左子树（L）上插入了新结点， $A$ 的平衡因子由1增至2，导致以 $A$ 为根的子树失去平衡，需要一次向右的旋转操作。将 $A$ 的左孩子 $B$ 向右上旋转代替 $A$ 成为根结点，将 $A$ 向右下旋转成为 $B$ 的右孩子，而 $B$ 的原右子树则作为 $A$ 的左子树。如图7.11所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b95eff2c046b43bb6a18bc9a41beacc9de133dbf00206769ee68eb40f6d13e7.jpg)  
图7.11LL平衡旋转  

2）RR平衡旋转（左单旋转）。由于在结点 $A$ 的右孩子（R）的右子树（R）上插入了新结点 $A$ 的平衡因子由-1减至-2，导致以4为根的子树失去平衡，需要一次向左的旋转操作。  
将 $A$ 的右孩子 $B$ 向左上旋转代替 $A$ 成为根结点，将 $A$ 向左下旋转成为 $B$ 的左孩子，而 $B$ 的原左子树则作为 $A$ 的右子树，如图7.12所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5619c6d8436c1be38b63d259dcc65e0d4dfdd684c7e61b46edda1f39de83300f.jpg)  
图7.12RR平衡旋转  

3）LR平衡旋转（先左后右双旋转）。由于在 $A$ 的左孩子（L）的右子树（R）上插入新结点， $A$ 的平衡因子由1增至2，导致以 $A$ 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将 $A$ 的左孩子 $B$ 的右子树的根结点 $C$ 向左上旋转提升到 $B$ 的位置，然后把结点 $C$ 向右上旋转提升到 $A$ 的位置，如图7.13所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e7462a89cd7274f34abe2309c0d8eedb6ed3d046096c03916695558689e50a9f.jpg)  
图7.13LR平衡旋转  

4）RL平衡旋转（先右后左双旋转）。由于在 $A$ 的右孩子（R）的左子树（L）上插入新结点， $A$ 的平衡因子由-1减至-2，导致以 $A$ 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 $A$ 的右孩子 $B$ 的左子树的根结点 $C$ 向右上旋转提升到 $B$ 的位置然后把结点 $C$ 向左上旋转提升到 $A$ 的位置，如图7.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/044e9dac3e9118af06383caa4ab6770b19e9168a05e12eabac22b4702037505f.jpg)  
图7.14RL平衡旋转  

# 注意  

LR和RL旋转时，新结点究竟是插入 $C$ 的左子树还是插入 $C$ 的右子树不影响旋转过程，而图7.13和图7.14中以插入 $C$ 的左子树中为例。  
# 命题追踪构造平衡二叉树的过程（2013）  

以关键字序列：15，3，7，10，9，8）构造一棵平衡二叉树的过程为例，图7.15（d插入7后导致不平衡，最小不平衡子树的根为15，插入位置为其左孩子的右子树，所以执行LR旋转，先左后右双旋转，调整后的结果如图7.15（e）所示。图7.15（g）插入9后导致不平衡，最小不平衡子树的根为15，插入位置为其左孩子的左子树，所以执行LL旋转，右单旋转，调整后的结果如图7.15（h）所示。图7.15（1插入8后导致不平衡，最小不平衡子树的根为7，插入位置为其右孩子的左子树，所以执行RL旋转，先右后左双旋转，调整后的结果如图7.15（所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/093f0bfc9d39ea0cacad9cfef59f6edf59790e2ed7a6692f2ea8792f99c3b8bf.jpg)  
图7.15平衡二叉树的生成过程  

3.平衡二叉树的删除  

与平衡二叉树的插入操作类似，以删除结点w为例来说明平衡二叉树删除操作的步骤：  

1）用二叉排序树的方法对结点w执行删除操作。2）若导致了不平衡，则从结点w开始向上回溯，找到第一个不平衡的结点 $\mathrm{_{z}}$ （即最小不平衡子树）；y为结点z的高度最高的孩子结点；x是结点y的高度最高的孩子结点。3）然后对以z为根的子树进行平衡调整，其中x、y和 $\mathrm{_{Z}}$ 可能的位置有4种情况：y是z的左孩子，x是y的左孩子（LL，右单旋转）；y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）；y是z的右孩子，x是y的右孩子（RR，左单旋转）；V是z的右孩子，x是V的左孩子（RL，先右后左双旋转）。  

这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以z为根的子树进行平衡调整；而删除操作就不一样，先对以z为根的子树进行平衡调整，若调整后子树的高度减1，则可能需要对z的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）。  

以删除图7.16（a）的结点32为例，由于32为叶结点，直接删除即可，向上回溯找到第一个不平衡结点44（即z），z的高度最高的孩子结点为78（y），y的高度最高的孩子结点为 $50\ \mathrm{\Omega}(\mathbf{x})$ ，满足RL情况，先右后左双旋转，调整后的结果如图7.16（c）所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7583531b4059bdd4839026ef84e33d80a0e80d188229f9a181a9205146f44d1b.jpg)  
图7.16平衡二叉树的删除  

# 4.平衡二叉树的查找  

命题追踪指定条件下平衡二叉树的结点数的分析（2012）  

在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，进行关键字的比较次数不超过树的深度。假设以 $n_{h}$ 表示深度为 $h$ 的平衡二叉树中含有的最少结点数。显然，有 $n_{0}\!=\!0,n_{1}\!=\!1,n_{2}\!=\!2,$ ，并且有 $n_{h}\,{=}\,n_{h-2}+n_{h-1}+1\,,$ ，如图7.17所示，依次推出 $n_{3}\,{=}\,4$  $n_{4}\,{=}\,7$  $n_{5}=12,\cdots$ 含有 $n$ 个结点的平衡二叉树的最大深度为 $O(\log_{2}\!n)$ ，因此平均查找效率为 $O(\log_{2}n)$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05527187cb555c4a8c169a1c9bb747cea9d526708b08d8e44da08c7188104059.jpg)  
图7.17结点个数  $n$  最少的平衡二叉树  

# 注意  

该结论可用于求解给定结点数的平衡二叉树的查找所需的最多比较次数（或树的最大高度）。如在含有12个结点的平衡二叉树中查找某个结点的最多比较次数？  

深度为 $h$ 的平衡二叉树中含有的最多结点数显然是满二叉树的情况。  

# 7.3.3 红黑树  

1.红黑树的定义  

为了保持AVL树的平衡性，在插入和删除操作后，会非常频繁地调整全树整体拓扑结构代价较大。为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构。  

一棵红黑树是满足如下红黑性质的二叉排序树： $\textcircled{\scriptsize{1}}$ 每个结点或是红色，或是黑色的。  

$\textcircled{2}$ 根结点是黑色的。  

$\textcircled{3}$ 叶结点（虚构的外部结点、NULL结点）都是黑色的。  

$\circledast$ 不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。  

$\circledast$ 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。与折半查找树和B树类似，为了便于对红黑树的实现和理解，引入了 $n+1$ 个外部叶结点，  
以保证红黑树中每个结点（内部结点）的左、右孩子均非空。图7.18所示是一棵红黑树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6302ead6b67560702595dc181ea237d148fcc79e5f41102d878fe7c0d83723be.jpg)  
图7.18一棵红黑树  

从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh），黑高的概念是由性质 $\circledast$ 确定的。根结点的黑高称为红黑树的黑高。  

结论1：从根到叶结点的最长路径不大于最短路径的2倍。  

由性质 $\circledast$ ，当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。由性质 $\textcircled{4}$ ，当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时红结点和黑结点的数量相同。图7.18中的 $_{6-2}$ 和 $6\!-\!15\!-\!18\!-\!20$ 就是这样的两条路径。  

# 结论2：有 $n$ 个内部结点的红黑树的高度 $h{\leqslant}2{\log_{2}(n+1)}$  

证明：由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为 $h/2$ ，于是有 $n{\geqslant}2^{h/2}{-}1$ ，即可求得结论。  

可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任意一个结点左右子树的高度，相差不超过2倍”，也降低了动态操作时调整的频率。对于一棵动态查找树，若插入和删除操作比较少，查找操作比较多，则采用AVL树比较合适，否则采用红黑树更合适。但由于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛， $\mathrm{C++}$ 中的map和set（Java Tree Map Tree Set）就是用红黑树实现的。  

# 2.红黑树的插入  

红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新结点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。  

# 结论3：新插入红黑树中的结点初始着为红色。  

假设新插人的结点初始看为黑色，则这个结点所在的路径比其他路径多出一个黑结点（几乎每次插人都破坏性质 $\circledast$ ），调整起来也比较麻烦。若插人的结点是红色的，则此时所有路径上的黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。  

设结点z为新插入的结点。插入过程描述如下：  

1）用二叉查找树插入法插入，并将结点z着为红色。若结点z的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树。2）若结点z是根结点，则将 $\mathrm{_{z}}$ 着为黑色（树的黑高增1)，结束。3）若结点z不是根结点，且z的父结点z.p是红色的，则分为下面三种情况，区别在于z的叔结点y的颜色不同，因z.p是红色的，插入前的树是合法的，根据性质 $\mathcal{Q}$ 和 $\textcircled{4})$ ，爷结点Z.P.P必然存在且为黑色。性质 $\textcircled{4}$ 只在 $\mathrm{_{Z}}$ 和z.p之间被破坏了。  
情况1：z的叔结点y是黑色的，且z是一个右孩子。情况2：z的叔结点y是黑色的，且z是一个左孩子。每棵子树 $T_{\parallel}$ 、 $T_{2}$ 、 $T_{3}$ 和 $T_{4}$ 都有一个黑色根结点，且具有相同的黑高。  

情况1（LR，先左旋，再右旋），即z是其爷结点的左孩子的右孩子。先做一次左旋将此情形转变为情况2（变为情况2后再做一次右旋），左旋后z和父结点z.p交换位置。因为z和z.p都是红色的，所以左旋操作对结点的黑高和性质 $\circledast$ 都无影响。  

情况2（LL，右单旋），即 $\mathrm{_{z}}$ 是其爷结点的左孩子的左孩子。做一次右旋，并交换z的原父结点和原爷结点的颜色，就可以保持性质 $\circledast$ ，也不会改变树的黑高。这样，红黑树中也不再有连续两个红结点，结束。情况1和情况2的调整方式如图7.19所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6141fe894e84b2ccf481ee1228f8dde35deaefe9f7c1b34e6857aad4fded5586.jpg)  
图7.19情况1和情况2的调整方式  

若父结点z.p是爷结点z.p.p的右孩子，则还有两种对称的情况：RL（先右旋，再左旋）和RR（左单旋），这里不再赘述。红黑树的调整方法和AVL树的调整方法有异曲同工之妙。  

情况3：z的叔结点y是红色的。  

情况3 $\mathrm{_{Z}}$ 是左孩子或右孩子无影响）， $_\mathrm{z}$ 的父结点z.p和叔结点y都是红色的，因为爷结点Z.p.p是黑色的，将z.p和y都着为黑色，将z.p.p着为红色，以在局部保持性质 $\textcircled{4}$ 和 $\circledast$ 。然后，把z.p.p作为新结点z来重复循环，指针z在树中上移两层。调整方式如图7.20所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f5ccc56ed08320a072e5b4dc2d9a90053800244c9efa93005dfc054cd43073d8.jpg)  
图7.20情况3的调整方式  

若父结点z.p是爷结点z.p.p的右孩子，也还有两种对称的情况，不再赘述。  

只要满足情况3的条件，就会不断循环，每次循环指针z都会上移两层，直到满足2）（表示z上移到根结点）或情况1或情况2的条件。效  

可能的疑问：虽然插入的初始位置一定是红黑树的某个叶结点，但因为在情况3中，结点z存在不断上升的可能，所以对于三种情况，结点z都有存在子树的可能。  
以图7.21（a）中的红黑树为例（虚线表示插入后的状态），先后插入5、4和12的过程如图7.21所示。插入5，为情况3，将5的父结点3和叔结点10着为黑色，将5的爷结点变为红色，此时因为7已是根，所以又重新着为黑色，树的黑高加1，结束。插入4，为情况1的对称情况（RL），此时特别注意虚构黑色空结点的存在，先对5做右旋：转变为情况2的对称情况（RR），交换3和4的颜色，再对3做左旋，结束。插入12，父结点是黑色的，无须任何调整，结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/866a8fdbeb20f4f9f1017d2842fcadd4a0308566f5ba94047bdd131149297787.jpg)  
图7.21红黑树的插入过程  

# \*3.红黑树的删除  

红黑树的插入操作容易导致连续的两个红结点，破坏性质 $\textcircled{4}$ 。而册除操作容易造成子树黑高的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质 $\circledast$  

删除过程也是先执行二叉查找树的册除方法。若待删结点有两个孩子，不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后继结点至多只有一个孩子，这样就转换为待删结点是终端结点或仅有一个孩子的情况。  

最终，删除一个结点有以下两种情况：  

待删结点只有右子树或左子树。待删结点没有孩子。1）若待删结点只有右子树或左子树，则只有两种情况，如图7.22所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cab26f5079edd0a6447893d1eae634ce7de3b9df2de6eabbb5a6359254c2e364.jpg)  
图7.22只有右子树或左子树的删除情况  

只有这两种情况存在。子树只有一个结点，且必然是红色，否则会破坏性质 $\circledast$ 2）待删结点无孩子，且该结点是红色的，这时可直接删除，而不需要做任何调整。3）待删结点无孩子，且该结点是黑色的，这时设待删结点为y，x是用来替换y的结点（注  
意，当y是终端结点时，x是黑色的NULL结点）。删除y后将导致先前包含y的任何路径上的黑结点数量减1，因此y的任何祖先都不再满足性质 $\circledast$ ，简单的修正办法就是将替换y的结点x视为还有额外一重黑色，定义为双黑结点。也就是说，若将任何包含结点x的路径上的黑结点数量加1，则在此假设下，性质 $\circledast$ 得到满足，但破坏了性质 $\circledcirc$ 。于是，删除操作的任务就转化为将双黑结点恢复为普通结点。  

分为以下四种情况，区别在于x的兄弟结点w及w的孩子结点的颜色不同。  

情况1：X的兄弟结点W是红色的。  

情况1，w必须有黑色左右孩子和父结点。交换w和父结点x.p的颜色，然后对x.p做一次左旋，而不会破坏红黑树的任何规则。现在，x的新兄弟结点是旋转之前w的某个孩子结点，其颜色为黑色，这样，就将情况1转换为情况2、3或4处理。调整方式如图7.23所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60760335c4d8bc8941e363634d6e9120ff151d6b6f52818aa54fe7a239bac7ed.jpg)  
图7.23情况1的调整方式  

情况2：x的兄弟结点W是黑色的，且w的右孩子是红色的。情况3：x的兄弟结点W是黑色的，W的左孩子是红色的，W的右孩子是黑色的。  

情况2（RR，左单旋），即这个红结点是其爷结点的右孩子的右孩子。交换w和父结点x.P的颜色，把w的右孩子着为黑色，并对x的父结点x.p做一次左旋，将x变为单重黑色，此时不再破坏红黑树的任何性质，结束。调整方式如图7.24所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0acf8e79a22ee8cdebb7c67323a375bbd51c9a6a9a72ff5305d1ec8bf75d6c37.jpg)  
图7.24情况2的调整方式  

情况3（RL，先右旋，再左旋），即这个红结点是其爷结点的右孩子的左孩子。交换W和其左孩子的颜色，然后对w做一次右旋，而不破坏红黑树的任何性质。现在， $_\mathrm{x}$ 的新兄弟结点W的右孩子是红色的，这样就将情况3转换为了情况2。调整方式如图7.25所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21ad3f76de9b3e1effcce1f8a03e3fcbb06283ab2c8c5ded905ca2ecfa56abc7.jpg)  
图7.25情况3的调整方式  
情况4：x的兄弟结点W是黑色的，且w的两个孩子结点都是黑色的。  

在情况4中，因为w也是黑色的，所以可从 $_\mathrm{x}$ 和w上去掉一重黑色，使得 $_\mathrm{x}$ 只有一重黑色而w变为红色。为了补偿从x和w中去掉的一重黑色，把 $\mathbf{X}$ 的父结点xp额外着一层黑色，以保持局部的黑高不变。通过将x.p作为新结点 $_\mathrm{x}$ 来循环，×上升一层。若是通过情况1进入情况4的，因为原来的x.p是红色的，将新结点 $_\textrm{x}$ 变为黑色，终止循环，结束。调整方式如图7.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f77f4733c0cffc561dc2e545e593ce2eb429d88b4703d725d26d24d9778e963.jpg)  
图7.26情况4的调整方式  

若×是父结点x.p的右孩子，则还有四种对称的情况，处理方式类似，不再赘述。  

归纳总结：在情况4中，因x的兄弟结点w及左右孩子都是黑色，可以从 $_\mathrm{x}$ 和w中各提取一重黑色（以让×变为普通黑结点），不会破坏性质 $\textcircled{4}$ ，并把调整任务向上“推”给它们的父结点xp。在情况1、2和3中，因为x的兄弟结点w或w左右孩子中有红结点，所以只能在x.p子树内用调整和重新着色的方式，且不能改变 $_\mathrm{x}$ 原根结点的颜色（否则向上可能破坏性质 $^{(4)}$ ）。情况1虽然可能会转换为情况4，但因为新 $\mathbf{X}$ 的父结点 $\mathrm{x.p}$ 是红色的，所以执行一次情况4就会结束。情况1、2和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯一情况，每执行一次指针x上升一层，至多 $O(\log_{2}n)$ 次。  

以图7.27a)中的红黑树为例（虚线表示删除前的状态），依次删除5和15的过程如图7.27所示。删除5，用虚构的黑色NULL结点替换，视为双黑NULL结点，为情况1，交换兄弟结点12和父结点8的颜色，对8做一次左旋；转变为情况4，从双黑NULL结点和10中各提取一重黑色（提取后，双黑NULL结点变为普通NULL结点，图中省略，10变为红色），因原父结点8是红色，所以将8变为黑色，结束。删除15，为情况3的对称情况（LR），交换8和10的颜色，对8做左旋；转变为情况2的对称情况（LL），交换10和12的颜色（两者颜色一样，无变化），将10的左孩子8着为黑色，对12做右旋，结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16b040213c28dc879ebf6aede317568cd287ae396fdf09e05e9949dcf6c67b0e.jpg)  
图7.27红黑树的删除过程  
# 7.3.4 本节试题精选  

# 一、单项选择题  

01.对于二叉排序树，下面的说法中，（）是正确的。  

A.二叉排序树是动态树表，查找失败时插入新结点，会引起树的重新分裂和组合 B.对二叉排序树进行层序遍历可得到有序序列C.用逐点插入法构造二叉排序树，若先后插入的关键字有序，二叉排序树的深度最大D.在二叉排序树中进行查找，关键字的比较次数不超过结点数的1/2  

02.按（）遍历二叉排序树得到的序列是一个有序序列。  

A.先序B.中序C.后序D.层次  

03.在二叉排序树中进行查找的效率与（）有关。  

A.二叉排序树的深度B.二叉排序树的结点的个数C.被查找结点的度D.二叉排序树的存储结构  

04.在常用的描述二叉排序树的存储结构中，关键字值最大的结点（）。  

A.左指针一定为空B.右指针一定为空C.左右指针均为空D.左右指针均不为空  

05.设二叉排序树中关键字由1到1000的整数构成，现要查找关键字为363的结点，下述关键字序列中，不可能是在二叉排序树上查找的序列是（）  

A.2,252,401,398,330,344,397,363 B.924,220,911,244,898,258,362,363 C.925,202,911,240,912,245,363 D.2,399,387,219,266,382,381,278,363  

06.分别以下列序列构造二叉排序树，与用其他3个序列所构造的结果不同的是（）。  

A.（100,80,90,60,120,110,130)B.（100,120,110,130,80,60,90）C.（100,60,80,90,120,110130) D.(100,80,60,90,120,130,110)  

07.从空树开始，依次插入元素52，26，14，32，71，60，93，58，24和41后构成了一棵二叉排序树。在该树查找60要进行比较的次数为（）  

A.3 B.4 C.5 D.6  

08.在含有n个结点的二叉排序树中查找某个关键字的结点时，最多进行（）次比较  

A.n/2 B.log2n C.  $\log_{2}\!n+1$  D.n  

09.五个不同结点构造的二叉查找树的形态共有（）种。  

A.20 B.30 C.32 D.42  

10.构造一棵具有 $n$ 个结点的二叉排序树时，最理想情况下的深度为（）  

A.n/2 B.n C.  $\lfloor\log_{2}(n+1)\rfloor$  D.  $\lceil\log_{2}(n+1)\rceil$  

11.含有20个结点的平衡二叉树的最大深度为（）  

A.4 B.5 C.6 D.7  

12.具有5层结点的平衡二叉树至少有（）个结点。  

A.10 B.12 C.15 D.17  

13.高度为3的平衡二叉排序树的形态共有（）种。  

A.13 B.14 C.16 D.15  

14.在平衡二叉树的基本操作中，可能发生两次旋转的操作是（）  

A.添加、删除结点B.仅删除结点C.仅添加结点D.都不会  

15.将关键字 $1,2,3,\cdots$ ，1024依次插入到初始为空的平衡二叉树中，假设只有一个根结点的二叉树的高度为0，则插入结束后的平衡二叉树的高度是（）A.8 B.9 C.10 D.11  
16.下列关于红黑树和AVL树的说法中，不正确的是（）  

I.一棵含有 $n$ 个结点的红黑树的高度至多为 $2\log_{2}(n+1)$ I1.若一个结点是红色的，则它的父结点和孩子结点都是黑色的III.红黑树的查询效率一般要优于含有相同结点数的AVL树IV.若AVL树的某结点的左右孩子的平衡因子都是零，则该结点的平衡因子也是零  

A.I、IIIB.IⅢIC.II、IVD.III、IV

17.下列关于红黑树和AVL树的描述中，不正确的是（）  

A.两者都属于自平衡的二叉树 B.两者查找、插入、删除的时间复杂度都相同0.红黑树插入和删除过程至多有2次旋转操作D.红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过2  

18.下列关于红黑树的说法中，正确的是（）  

A.红黑树的红结点的数目最多和黑结点的数目相同 B.若红黑树的所有结点都是黑色的，则它一定是一棵满二叉树C.红黑树的任何一个分支结点都有两个非空孩子结点D.红黑树的子树也一定是红黑树  

19.下列四个选项中，满足红黑树定义的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/163d2c1c24d51082b4e3d8856b95339ee3e673164beafa2f96cf980e9aa814c0.jpg)  

20.将关键字 $1,2,3,4,5,6,7$ 依次插入初始为空的红黑树 $T_{c}$ 则 $T$ 中红结点的个数是（）A.1 B.2 C.3 D.4

 21.将关键字5，4，3，2，1依次插入初始为空的红黑树 $T_{\ast}$ 则 $T$ 的最终形态是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fb9f751a239f192d32a03a91f5c9a80712aaa3db250d7f8231832c8ea5fea238.jpg)  

22.在下图所示的红黑树中插入结点2且染成红色后，则下一步应进行的操作是（）。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/24e0d835ffb74dd4617321a3dec991e5e8ed0ed460d51cb11ed2e5d5521edbb4.jpg)  

A.左旋 B.右旋 C.变色 D.无须调整

 23.【2009统考真题】下列二叉排序树中，满足平衡二叉树定义的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d15c90af1a8f5f933149a2fc29f5af4b11488c2c321ddc1eb431e88c285c94a.jpg)  

24.【2010统考真题】在下图所示的平衡二叉树中插入关键字48后得到一棵新平衡二叉树 在新平衡二叉树中，关键字37所在结点的左、右子结点中保存的关键字分别是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/88fd92cebf308f9fe22fc16b0a18416cde8f242c7f0cf2aacba9b840039cfb6c.jpg)  

A.13,48 B.24,48 C.24,53 D.24,90

 25.【2011统考真题】对下列关键字序列，不可能构成某二叉排序树中一条查找路径的是（）。  

A.95,22,91,24,94,71 B.92,20,91,34,88,35 C.21,89,77,29,36,38 D.12,25,71,68,33,34  

26.【2012统考真题】若平衡二叉树的高度为6，且所有非叶结点的平衡因子均为1，则该平衡二叉树的结点总数为（）。  

A.12 B.20 C.32 D.33  

27.【2013统考真题】在任意一棵非空二叉排序树 $T_{\parallel}$ 中，删除某结点v之后形成二叉排序树 $T_{2}$ ，再将 $\nu$ 插入 $T_{2}$ 形成二叉排序树 $T_{3}$ 。下列关于 $T_{1}$ 与 $T_{3}$ 的叙述中，正确的是（）。  

I.若 $\nu$ 是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 不同II.若v是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  相同 I1.若v不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 不同IV.若 $v$ 不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 相同  

A.仅I、IⅢIB.仅I、IVC.仅II、IIID.仅II、IV  

28.【2013统考真题】若将关键字1，2，3，4，5，6，7依次插入初始为空的平衡二叉树  $T_{e}$  则  $T$  中平衡因子为0的分支结点的个数是（）。  

A.0 B.1 C.2 D.3  

29.【2015统考真题】现有一棵无重复关键字的平衡二叉树（AVL），对其进行中序遍历可得到一个降序序列。下列关于该平衡二叉树的叙述中，正确的是（）  

A.根结点的度一定为2B.树中最小元素一定是叶结点C.最后插入的元素一定是叶结点D.树中最大元素一定是无左子树  
30.【2018统考真题】已知二叉排序树如下图所示，元素之间应满足的大小关系是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c0339e3f9f5a37b8f71445dcb279a11b83cedd1bd8134be673fb284ac424743.jpg)  

A.  $x_{1}\!<\!x_{2}\!<\!x_{5}$  B.  $x_{1}\!<\!x_{4}\!<\!x_{5}$  C.  $x_{3}\!<\!x_{5}\!<\!x_{4}$  D.  $x_{4}\!<\!x_{3}\!<\!x_{5}$  

31.【2019统考真题】在任意一棵非空平衡二叉树（AVL树） $T_{\parallel}$ 中，删除某结点 $v$ 之后形成平衡二叉树 $T_{2}$ ，再将 $v$ 插入 $T_{2}$ 形成平衡二叉树 $T_{3\circ}$ 下列关于 $T_{1}$ 与 $T_{3}$ 的叙述中，正确的是（）。  

I.若 $v$ 是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 可能不相同II.若 $v$ 不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 一定不相同IⅢ.若 $v$ 不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 一定相同  

A.仅IB.仅ⅡIC.仅I、IID.仅I、II

32.【2020统考真题】下列给定的关键字输入序列中，不能生成右边二叉排序树的是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/969432b052ae7342c68faa602d2c92cee50cf468340b5f5468af6b0b4f401857.jpg)  

A.4,5,2,1,3 B.4,5,1,2,3 C.4,2,5,3,1 D.4,2,1,3,5

 33.【2021统考真题】给定平衡二叉树如下图所示，插入关键字23后，根中的关键字是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/703412ed88fe1e8b11c35bac1174ef38dd3cb015652a29dedb3f08a32bfe7703.jpg)  

A.16 B.20 C.23 D.25  

# 二、综合应用题  

01.一棵二叉排序树按先序遍历得到的序列为（50,38，30,45，40,48，70,60，75，80），试画出该二叉排序树，并求出等概率下查找成功和查找失败的平均查找长度。

02.按照序列（40，72，38，35，67，51，90，8,55，21）建立一棵二叉排序树，画出该树，并求出在等概率的情况下，查找成功的平均查找长度。

03.依次把结点（34，23，15，98，115，28，107）插入初始状态为空的平衡二叉排序树，使得在每次插入后保持该树仍然是平衡二叉树。请依次画出每次插 $\leftthreetimes$ 后所形成的平衡二叉排序树。

04.给定一个关键字集合25，18，34，9，14，27，42，51，38}，假定查找各关键字的概率相同，请画出其最佳二叉排序树。

05.试编写一个算法，判断给定的二叉树是否是二叉排序树。

06.设计一个算法，求出指定结点在给定二叉排序树中的层次。

07.利用二叉树遍历的思想编写一个判断二叉树是否是平衡二叉树的算法。08.设计一个算法，求出给定二叉排序树中最小和最大的关键字。  
09.设计一个算法，从大到小输出二叉排序树中所有值不小于 $k$ 的关键字。  

10.编写一个递归算法，在一棵有 $n$ 个结点的、随机建立起来的二叉排序树上查找第 $k$  $1\!\leqslant\!k\!\leqslant\!n$ ）小的元素，并返回指向该结点的指针。要求算法的平均时间复杂度为 $O(\log_{2}n)$ 。二叉排序树的每个结点中除data、1child、rchild等数据成员外，增加一个count成员，保存以该结点为根的子树上的结点个数。  

# 7.3.5 答案与解析  

# 一、单项选择题  

01.C  

二叉排序树插入新结点时不会引起树的分裂组合。对二义排序树进行中序遍历可得到有序序列。当插入的关键字有序时，二叉排序树会形成一个长链，此时深度最大。在此种情况下进行查找，有可能需要比较每个结点的关键字，超过总结点数的1/2。  

02.B  

由二叉排序树的定义不难得出中序遍历二叉树得到的序列是一个有序序列。  

03.A 二叉排序树的查找路径是自顶向下的，其平均查找长度主要取决于树的高度。  

04.B  

在二叉排序树的存储结构中，每个结点由三部分构成，其中左（或右）指针指向比该结点的关键字值小（或大）的结点。关键字值最大的结点位于二义排序树的最右位置，因此它的右指针一定为空（有可能不是叶结点）。还可用反证法，若右指针不为空，则右指针上的关键字肯定比原关键字大，所以原关键字结点一定不是值最大的，与条件矛盾，所以右指针一定为空。  

05.C  

在二叉排序树上查找时，先与根结点值进行比较，若相同，则查找结束，否则根据比较结果，沿看左子树或石子树向下继续查找。根据二义排序树的定义，有左子树结点值 $\leqslant$ 根结点值≤石子树结点值。C序列中，比较911关键字后，应转向其左子树比较240，左子树中不应出现比911更大的数值，但240竟有一个右孩子结点值为912，所以不可能是正确的序列。  

06.C  

按照二叉排序树的构造方法，不难得到A，B，D序列的构造结果相同。  

07.A  

以第一个元素为根结点，依次将元素插入树，生成的二叉排序树如下图所示。进行查找时，先与根结点比较，然后根据比较结果，继续在左子树或右子树上进行查找。比较的结点依次为5271,60。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cbf41c7577b0831c9694e0c6c9bc117557c0447488336244f4c33e1a37935b8.jpg)  

08.D  

当输入序列是一个有序序列时，构造的二叉排序树是一个单支树，当查找一个不存在的关键字值或最后一个结点的关键字值时，需要 $n$ 次比较。  
09.D  

五个不同结点构造的二叉查找树，中序序列是确定的。先序序列的个数为 $n=5$ 的卡特兰数，加上中序序列和先序序列能唯一确定一棵二叉树，因此二叉排序树的形态共有Catalan（5） $=42$ 种。  

10.D  

当二叉排序树的叶结点全部都在相邻的两层内时，深度最小。理想情况是从第一层到倒数第二层为满二叉树。类比完全二叉树，可得深度为 $\lceil\log_{2}(n+1)\rceil_{\circ}$  

11.C  

平衡二叉树结点数的递推公式为 $n_{0}=0\,,\,\,\,n_{1}=1\,,\,\,\,n_{2}=2\,,\,\,\,n_{h}=1+n_{h-1}+n_{h-2}$  $h$ 为平衡二叉树高度， $n_{h}$ 为构造此高度的平衡二叉树所需的最少结点数）。通过递推公式可得，构造5层平衡二叉树至少需12个结点，构造6层至少需要20个结点。  

12.B  

设 $n_{h}$ 表示高度为 $h$ 的平衡二叉树中含有的最少结点数，则有 $n_{1}\!=\!1,n_{2}\!=\!2,n_{h}\!=\!n_{h\!-\!1}+n_{h\!-\!2}+1$ ，由此求出 $n_{5}\!=\!12$ ，对应的AVL如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/757001b26f14b87e57a0a567962e98dcdb3faf19b2a4437b34b3496e2840997d.jpg)  

13.D  

高度为3的平衡二叉树的左右子树的高度共有三种情况： $\textcircled{\scriptsize{1}}$ 左右子树都是高度为2的平衡二叉树： $\circledcirc$ 左子树是高度为1的平衡二叉树，右子树是高度为2的平衡二叉树： $\textcircled{3}$ 左子树是高度为2的平衡二叉树，右子树是高度为1的平衡二叉树。高度为1的平衡二叉树只有1种形态，即单个结点，如图1所示；高度为2的平衡二叉树有3种形态，如图2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4fc3ce99f5862697a27c711091a41697b49da44fec0085171c1a1d8409225a9d.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c0d86e39e94af8af3761adaa7c6e466b34128d1c70d0d1e5bdb10540c6feedc.jpg)  
图2  

因此，对于情况 $\textcircled{\scriptsize{1}}$ ，共有 $3{\times}3=9$ 种树形态：对于情况 $\circledcirc$ ，共有 $1\!\times\!3=3$ 种树形态；情况 $\circledast$ 和情况②类似，也有3种树形态，所以共有 $9+3+3=15$ 种树形态。  

14.A  

插入和删除结点都有可能引起LR平衡旋转或者RL平衡旋转，发生两次旋转操作。  

15.C  

当按关键字有序的顺序插入初始为空的平衡二叉树时，若关键字个数 $n=2^{k}-1$ 时，则该平衡二叉树一定是一棵满二叉树（可以用 $1{\sim}3\times1{\sim}7$ 手工验证）。当插入关键字1023时，平衡二叉树正好是一棵满二义树，高度是9。因此，插入关键字1024后，平衡二叉树的高度是10。  

16.D  

I和IⅡI都是红黑树的性质。AVL是高度平衡的二叉查找树，红黑树是适度平衡的二叉查找树，从这一点也可以看出AVL的查询效率往往更优，III错误。AVL的某结点的左右孩子的平衡因子都是零，并不能说明左右子树的高度相等，因此该结点的平衡因子不一定为零，IV错误。  

17.C  
自平衡的二叉排序树是指在插入和册除时能自动调整以保持其所定义的平衡性，两者都属于自平衡二叉树，A正确。两者的查找、插入、删除操作的时间复杂度都为 $O(\log_{2}n)$ ，B正确。在红黑树中删除结点时，情况1可能变为情况2、3或4，情况2会变为情况3，可能会出现旋转次数超过2次的情况，C错误。从任一结点到每个叶结点的所有路径都包含相同数目的黑结点，没有两个连续的红结点，且叶结点是红色的，这意味看在任一结点到其左石子树中最远和最近的时结点之间，红结点的数目小于或等于黑结点的数目，路径长度之比不超过2，D正确。  

# 18.B  

红黑树的红结点数目最大可以是黑结点数目的2倍（如一棵有3个结点的红黑树，第1层为黑色，第2层为红色），A错误。从根结点出发到所有叶结点的黑结点数是相同的，若所有结点都是黑色，则一定是满二叉树，B正确。考虑某个黑结点，它可以有一个空叶结点孩子和一个非空红结点孩子，C错误。红黑树中可能存在红结点，根结点为红色的子树不是红黑树，D错误。  

# 19.A  

红黑树是一种特殊的二叉排序树，B项不满足二叉排序树的性质。C项中，结点2的左右黑结点数不同。D项中，结点3的左右黑结点数不同。只有A项满足红黑树的定义。  

20.C  

关键字 $1,2,3,4,5,6,7$ 依次插入红黑树后的形态变化如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c27a51c5772a51bcde439143b9c61d568b118a23dad1a6807fd9d25b0457f9da.jpg)  

# 21.D  

关键字 $5,4,3,2,1$ 依次插入红黑树后的形态变化如下：  

# 22.B  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9289eb1ec4af4861df533975c421bce082e01497e341be62ddbc12eec3f167.jpg)  

插入结点2且将其染成红色后违反不红红原则，并且叔结点是黑色，应进行LL旋转，将结点3右旋旋转到结点5的位置，结点2和结点5分别成为结点3的左、右孩子，然后将结点3染成黑色，结点2和结点5染成红色。因此，下一步应进行右旋操作。  
23.B  

根据平衡二叉树的定义，任意结点的左、右子树高度差的绝对值不超过1。而其余3个答案均可以找到不满足条件的结点。答题时可以把每个非叶结点的平衡因子都写出来。  

24.C  

插入48以后，该二叉树根结点的平衡因子由-1变为-2，在最小不平衡子树根结点的右子树（R）的左子树（L）中插入新结点引起的不平衡属于RL型平衡旋转（先右旋后左旋）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e81662b64bcb48da34de429ff499625461f0aa969233b426ca6107eccc92514.jpg)  
调整后，关键字37所在结点的左、右子结点中保存的关键字分别是24、53。  

25.A  

在二叉排序树中，左子树结点值小于根结点，右子树结点值大于根结点。在选项A中，当查找到91后再向24查找，说明这一条路径（左子树）之后查找的数都要比91小，而后面却查找 到了94（解题过程中，建议配合画图），因此错误。  

画图法：各选项对应的查找过如下图，选项B、C、D对应的查找树都是二叉排序树，选项A对应的查找树不是二叉排序树，因为在91为根的左子树中出现了比91大点的结点94。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e22f0ee6e7d5424ac3de4239981d63f25c35cb583db1ec9a129e4dc4ffb49de.jpg)  
（a）选项A的查找过程（b）选项B的查找过程（c）选项C的查找过程（d）选项D的查找过程  

26.B  

所有非叶结点的平衡因子均为1，即平衡二叉树满足平衡的最少结点情况，如下图所示。对于高度为 $n_{\checkmark}$ 左右子树的高度分别为 $n-1$ 和 $n\!-\!2\cdot$ 所有非叶结点的平衡因子均为1的平衡二叉树，计算总结点数的公式为 $C_{n}=C_{n-1}+C_{n-2}+1,\,C_{1}=1,\,C_{2}=2,\,C_{3}=2+1+1=4$ 可推出 $C_{6}\!=\!20$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6275c40fc894320237a3f623a550474064c28f50c6e018df50beb44373431f21.jpg)  

画图法：先画出 $T_{1}$ 和 $T_{2}$ ：然后新建一个根结点，连接 $T_{2}$ 、 $T_{1}$ 构成 $T_{3}$ ：新建一个根结点，连接 $T_{3}$ 、 $T_{2}$ 构成 $T_{4}$ 直到画出 $T_{6}$ ，可知 $T_{6}$ 的结点数为20。  
排除法：对于A，高度为6、结点数为12的树怎么也无法达到平衡。对于C，结点较多时，考虑较极端的情形，即第6层只有最左叶子的完全二叉树刚好有32个结点，虽然满足平衡的条件，但显然再删去部分结点依然不影响平衡，不是最少结点的情况。同理D错误。  

27.C  

由于在二义排序树中插入结点的位置是一个新的叶结点，若删除的是叶结点，则重新插入后得到的二叉排序树与原来的二叉排序树相同。若删除的是非叶结点，在删除过程中会找其他结点填补，重新插入后变成叶结点，则得到的二叉排序树与原来的二叉排序树不同。  

28.D  

利用7个关键字构建平衡二叉树T，平衡因子为0的分支结点个数为3，构建的平衡二叉树及构造与调整过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1f35f2259f4716c9e2ffea999ad8aab2c71a3318e2c97905e13236b5579256b.jpg)  

29.D  

大多数教材将平衡二叉树定义为一种高度平衡的二叉排序树，二叉排序树的中序序列是一个升序序列，而题意正好相反。由此可知，命题老师认为平衡二叉树仅为一棵满足高度平衡的二叉 树，不一定是二叉排序树。只有两个结点的平衡二义树的根结点的度为1，A错误。中序遍历后得到一个降序序列（与二叉排序树正好相反），树中最大元素一定无左子树（可能有右子树），这与二叉排序树也正好相反，也因此不一定是叶结点，B错误，D正确。最后插入的结点可能会导致平衡调整，而不一定是叶结点，C错误。  

30.C  

根据二叉排序树的特性：中序遍历（LNR）得到的是一个递增序列。图中二叉排序树的中序遍历序列为 $x_{1},x_{3},x_{5},x_{4},x_{2}$ ，可知 $x_{3}\!<\!x_{5}\!<\!x_{4}$  

31.A  

在非空平衡二叉树中插入结点，在失去平衡调整前，一定插入在叶结点的位置。  

若删除的是 $T_{1}$ 的叶结点，则删除后平衡二叉树可能不会失去平衡，即不会发生调整，再插入此结点得到的二叉平衡树 $T_{1}$ 与 $T_{3}$ 相同：若删除后平衡二叉树失去平衡而发生调整，再插入结点得到的二叉平衡树 $T_{3}$ 与 $T_{1}$ 可能不同。说法I正确。例如，如下图所示，删除结点0，平衡二叉树失衡调整，再插入结点0后，平衡二义树和以前不同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8bee9e20b5f41eb72f9be27f992fccadae215df16b6446ea9167c732e1855826.jpg)  
对于比较绝对的说法ⅡI和Ⅲ1，通常只需举出反例即可。  

若删除的是 $T_{\downarrow}$ 的非叶结点，且删除和插入操作均没有导致平衡二叉树的调整（这时可以首先想到删除的结点只有一个孩子的情况），则该结点从非叶结点变成了叶结点， $T_{1}$ 与 $T_{3}$ 显然不同。例如，如下图所示，删除结点2，用右孩子结点3填补，再插入结点2，平衡二叉树和以前不同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/04a663aef7a3b681eb2339aa426e9f5e1daa776dbbe7661ea3ff1f14664ae0ba.jpg)  

若删除的是 $T_{\parallel}$ 的非叶结点，且删除和插入操作后导致了平衡二叉树的调整，则该结点有可能通过旋转后继续变成非叶结点， $T_{1}$ 与 $T_{3}$ 相同。例如，如下图所示，删除结点2，用右孩子结点3填补，再插入结点2，平衡二叉树失衡调整，调整后的平衡二叉树和以前相同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aaa01fa6cb5ec56375e69a522c869a72b953704fd0cf11b32fc43437d142956.jpg)  

32.B  

每个选项都逐一验证，选项B生成二叉排序树的过程如下图所示，显然错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/200820177957ee15e4eb3c9f6e86744c0dd2db0c2478eee8fc74fd1849303370.jpg)  

33.D  

关键字23的插入位置为25的左孩子，此时破坏了平衡的性质，需要对平衡二叉树进行调整。最小不平衡子树就是该树本身，插入位置在根结点的右子树的左子树上，因此需要进行RL旋转，RL旋转过程如下图所示，旋转完成后根结点的关键字为25，所以选D。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/964e6d538821f6beab710647587b6bd65b259e660d25419acb9a05269a421223.jpg)  

# 二、综合应用题  

01.【解答】  

先序序列为（50，38，30，45，40，48，70，60，75，80），二叉树的中序序列是一个有序序列，所以为（30,38，40，45，48，50，60，70，75，80），由先序序列和中序序列可以构造出对应的二叉树，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e8352c6cc4340d5e771f7d9b0d954db2926162c7b9ecf27cafd20a6fb034d9e.jpg)  

查找成功的平均查找长度为  

$$
\mathrm{ASL}=(1\!\times\!1+2\!\times\!2+3\!\times\!4+4\!\times\!3)/10=2.9
$$  

图中的方块结点为虚构的查找失败结点，其查找路径为从根结点到其父结点（圆形结点）的结点序列，所以对应的查找失败平均长度为  

$$
\mathrm{ASL}=(3{\times}5+4{\times}6)/11=39/11
$$  

# 02.【解答】  

根据二叉排序树的定义，该序列所对应的二叉排序树如下图所示  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/98bb969effa80a78785a477d91aafc868a54ef5ca349485e71b06be2ff5dd08f.jpg)  

平均查找长度为 $\mathrm{ASL}=(1+2{\times}2+3{\times}3+4{\times}2+5{\times}2)/10=3.2$  

03.【解答】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/87e92e1261fb3e42755f1304eab95e621f370a86ba53f454d2123b41c55af0a0.jpg)  

第一步：插入结点34，23.15后，需要根结点34的子树做LL调整。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/147225c38e376997c8ee95b5b6237c773fed8ffde4d21a2cfd36e2f4dc993868.jpg)  

第二步：插入结点98.115后，需要根结点34的子树做RR调整。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4002ba341039ae309747a895cc3e4aee686217a98abd61089d381df4192dfdd9.jpg)  
第三步：插入结点28后，需要根结点23的子树做RL调整。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05536c6e8542eb0430d79c91ae1171417af3378dd638113342a5b9a5fd761913.jpg)  

第四步：插入结点107后，需要根结点98的子树做RL调整。  

04.【解答】  

当各关键字的查找概率相等时，最佳二叉排序树应是高度最小的二叉排序树。构造过程分两步走：首先对各关键字按值从小到大排序，然后仿照折半查找的判定树的构造方法构造二叉排序 树。这样得到的就是最佳二义排序树，结果如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c00a0b7152ef11d3113a91edbc8987195d90fa33fe1f1979b0d14a781472574d.jpg)  

05.【解答】  

对二义排序树来说，其中序遍历序列为一个递增有序序列。因此，对给定的二义树进行中序遍历，若始终能保持前一个值比后一个值小，则说明该二叉树是一棵二叉排序树。算法实现如下：  

KeyType predt  $=$  -32767;  

int JudgeBST（BiTree bt) int bl,b2; if(bt  $==$  NULL) returnl;  

l/predt为全局变量，的值，初值为-  

/空树  

b1  $=$  JudgeBsT(bt->lchild); //判断左子树是否是二叉排序树 if $\tt^{b1}\!\!=\!\!=\!\!0$ lpredt>=bt->data）//若左子树返回值为0或前驱大于或等于当前结点return0;//则不是二叉排序树predt=bt->data;//保存当前结点的关键字 ${\tt b}2{\tt=}$  JudgeBsT(bt->rchild); //判断右子树 return b2;//返回右子树的结果  

06.【解答】  

算法思想：设二叉树采用二叉链表存储结构。在二叉排序树中，查找一次就下降一层。因此，查找该结点所用的次数就是该结点在二义排序树中的层次。采用二义排序树非递归查找算法，用 $n$ 保存查找层次，每查找一次， $n$ 就加1，直到找到相应的结点。算法如下：  

int level（BiTree bt,BSTNode  ${\star_{\mathsf{P}}}$  int $\scriptstyle{\mathrm{~n}=0}$ 川统计查找次数BiTreet=bt; if(bt）  $!=$  NULL){  $\mathrm{n++}$  
while(t->data!=p->data){ if(p->data<t->data) /在左子树中查找 t=t->lchild; else //在右子树中查找 t=t->rchild;  $\mathrm{n++}$  /层次加1 return n;  

07.【解答】  

设置二叉树的平衡标记balance，以标记返回二叉树bt是否为平衡二叉树，若为平衡二叉树，则返回1，否则返回0：h为二义树bt的高度。采用后序遍历的递归算法：  

1）若bt为空，则高度为0，balance  $^{=1}$  

2）若bt仅有根结点，则高度为1，balance  $^{=1}$  

3）否则，对bt的左、右子树执行递归运算，返回左、右子树的高度和平衡标记，bt的高度为最高子树的高度加1。若左、右子树的高度差大于1，则balance $\scriptstyle{i=0}$ ；若左、右子树的高度差小于或等于1，且左、右子树都平衡时，balance $^{=1}$ ，否则balance $_{:=0}$ 算法如下：  

void Judge AVL（BiTree bt,int &balance，int &h）{ int $_{b1=0}$ ,br $\scriptstyle{:=0}$  $_{\mathrm{h1}=0}$  $\scriptstyle\mathtt{h r}=0$ /左、右子树的平衡标记和高度if(bt  $==$  NULL){ /空树，高度为0  $\scriptstyle{\mathrm{h}}=0$  balance  $^{=1}$  } elseif（bt->lchild  $==$  NULL&&bt->rchild=  $=$  NULL）（//仅有根结点，则高度为1  $\mathtt{h}\!=\!\mathtt{1}$  balance  $^{=1}$  elsef JudgeAVL(bt->lchild,bl,hl); //递归判断左子树 Judge AvL(bt->rchild,br,hr); /递归判断右子树  $\mathrm{h}{=}$  (hl>hr?hl:hr)  $^{+1}$  if(abs(hl-hr) $^{<2}$ /若子树高度差的绝对值<2，则看左、右子树是否都平衡balance=bl&&br；//&&为逻辑与，即左、右子树都平衡时，二叉树平衡else balance  $=\!0$  

08.【解答】  

在一棵二叉排序树中，最左下结点即为关键字最小的结点，最右下结点即为关键字最大的结点，本算法只要找出这两个结点即可，而不需要比较关键字。算法如下：  

KeyType MinKey(BSTNode\*bt) while(bt->lchild!  $=$  NULL) bt=bt->lchild; return bt->data;  

KeyType MaxKey（BSTNode\*bt) 求出二叉排序树中最大关键字结点  
while(bt->rchild!  $=$  NULL) bt  $=$  bt->rchild; return bt->data;  

09.【解答】  

由二义排序树的性质可知，右子树中所有的结点值均大于根结点值，左子树中所有的结点值均小于根结点值。为了从大到小输出，先遍历右子树，再访问根结点，后遍历左子树。算法如下：  

{//本算法从大到小输出二叉排序树中所有值不小于 $\kappa$ 的关键字  

if(bt  $==$  NULL) return; if(bt->rchild！  $=$  NULL) OutPut（bt->rchild,k);/递归输出右子树结点if(bt->data>  $\mathbf{\Psi}^{=}\mathbf{k}$  printf("&d",bt->data); //只输出大于或等于  $\kappa$  的结点值 if(bt->lchild  $!=$  NULL) OutPut（bt->lchild,k);/递归输出左子树的结点  

本题也可采用中序遍历加辅助栈的方法实现。  

10.【解答】  

设二叉排序树的根结点为\*t，根据结点存储的信息，有以下几种情况：  

当t->lchild为空时，情况如下：  

1）若t->rchild非空且 $\kappa{=}{1}$ ，则 $\star_{\mathsf{C}}$ 即为第 $\kappa$ 小的元素，查找成功。2）若t->rchild非空且 $\mathtt{k H}\!=\!\mathtt{1}$ ，则第 $\kappa$ 小的元素必在\*t的右子树。  

当t->lchild非空时，情况如下：  

1)t->lchild->count  $==\!\!1\!\!-\!1$  ，  $\star_{\mathsf{C}}$  即为第  $\mathtt{k}$  小的元素，查找成功 2)t->lchild->count>k-1，第 $\boldsymbol{\mathrm{k}}$ 小的元素必在 $\star_{\mathsf{C}}$ 的左子树，继续到 $\star_{\mathsf{C}}$ 的左子树中查找。3)t->lchild->count<k-1，第 $\boldsymbol{\mathrm{k}}$ 小的元素必在右子树，继续搜索右子树，寻找第k-（t->lchild->count $^{+1}$ ）小的元素。  

对左右子树的搜索采用相同的规则，递归实现的算法描述如下：  

BSTNode\*Search Small BST Node\*t,intk){ //在以t为根的子树上寻找第 $\kappa$ 小的元素，返回其所在结点的指针。 $\kappa$ 从11开始计算/在树结点中增加一个count数据成员，存储以该结点为根的子树的结点个数if(k<lllk>t->count)return NuLL; if(t->lchild=  $=$  NULL){ if(  $\kappa{=}{1}$  ）return t; else return Search Small(t->rchild,k-l); elset if(t->lchild->count  $==\!\!1\!\!-\!1$  )return t; if(t->lchild->count>k-1) return Search Small(t->lchild,k); if(t->lchild->count<k-1) return Search Small(t->rchild,k-(t->lchild->count+1));  

最大查找长度取决于树的高度。由于二叉排序树是随机生成的，其高度应是 $O(\log_{2}\!n)$ ，算法的时间复杂度为 $O(\log_{2}n)$  
# B树和  $\mathbf{B}+$  树  

考研大纲对B树和 $^{\mathrm{B+}}$ 树的要求各不相同，重点在于考查B树，不仅要求理解B树的基本特点，还要求掌握B树的建立、插入和删除操作，而对 $^{\mathrm{B+}}$ 树则只考查基本概念。  

# 7.4.1B树及其基本操作  

所谓 $m$ 阶B树是所有结点的平衡因子均等于0的 $m$ 路平衡查找树。  

# 命题追踪B树的定义和特点（2009）  

一棵 $m$ 阶B树或为空树，或为满足如下特性的 $m$ 叉树：  

1）树中每个结点至多有 $m$ 棵子树，即至多有 $m-1$ 个关键字。2）若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字。3）除根结点外的所有非叶结点至少有 $\lceil m/2\rceil$ 棵子树，即至少有 $\lceil m/2\rceil_{-1}$ 个关键字。  

4）所有非叶结点的结构如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/641123898fc54d168c81307aaa0f46a0aeb4dc3c39dc6bc0add67a795683e706.jpg)  

其中， $K_{i}$  $(i=1,2,\cdots,n)$ 为结点的关键字，且满足 $K_{1}<K_{2}<\cdots<K_{n};\,\,\,P_{i}\,\,(i=0,\,1,\cdots,n)$ 为指向子树根结点的指针，且指针 $P_{i+1}$ 所指子树中所有结点的关键字均小于 $K_{i}$ ， $P_{i}$ 所指子树中所有结点的关键字均大于 $K_{i}$ ； $n~(\lceil m/2\rceil\!-\!1\!\leqslant\!n\!\leqslant\!m-1)$ 为结点中关键字的个数。  

5）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的失败结点，实际上这些结点并不存在，指向这些结点的指针为空）。  

# 命题追踪B树中关键字数和结点数的分析（2013、2014、2018、2021）  

图7.28所示为一棵5阶B树，可以借助该实例来分析上述性质：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3296559c5d2d7110e03f8b45bfcbf4ee8b8931f234697bbe0eba579683969db7.jpg)  
图7.28一棵5阶B树的实例  

1）结点的孩子个数等于该结点中关键字个数加1。  

2）若根结点没有关键字就没有子树，则此时B树为空；若根结点有关键字，则其子树个数必然大于或等于2，因为子树个数等于关键字个数加1。  

3）除根结点外的所有非叶结点至少有 $\scriptstyle{m/2}\,=\,\left\lceil5/2\right\rceil=3$ 棵子树（即至少有 $\lceil m/2\rceil\!-1\!=\!\lceil5/2\rceil\!-1=$  
2个关键字）；至多有5棵子树（即至多有4个关键字）。  

4）结点中的关键字从左到右递增有序，关键字两侧均有指向子树的指针，左侧指针所指子树的所有关键字均小于该关键字，右侧指针所指子树的所有关键字均大于该关键字。或者看成下层结点的关键字总是落在由上层结点的关键字所划分的区间内，如第二层最左结点的关键字划分成了3个区间： $(-\infty,5),(5,11),(11,+\infty)$ ，该结点中的3个指针所指子树的关键字均分别落在这3个区间内。  

5）所有叶结点均在第4层，代表查我失败的位置。  

# 1.B树的查找  

在B树上进行查找与二叉排序树很相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。  

B树的查找包含两个基本操作： $\textcircled{\scriptsize{1}}$ 在B树中找结点； $\textcircled{2}$ 在结点内找关键字。由于B树常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查我操作是在内存中进行的，即在磁盘上找到目标结点后，先将结点信息读入内存，然后再采用顺序查找法或折半查找法。因此，在磁盘上进行查找的次数即目标结点在B树上的层次数，决定了B树的查找效率。  

在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找（例如，在图7.28中查找关键字42，首先从根结点开始，根结点只有一个关键字，且 $42>22$ ，若存在，必在关键字22的右边子树上，右孩子结点有两个关键字，而 $36<42<45$ ，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查我成功)。查找到叶结点时（对应指针为空），则说明树中没有对应的关键字，查找失败。  

# 2.B树的高度（磁盘存取次数）  

由上一节得知，B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。  

下面来分析B树在不同情况下的高度。当然，首先应该明确B树的高度不包括最后的不带任何信息的叶结点所处的那一层（有些书对B树的高度的定义中，包含最后的那一层）。  

若 $n\!\geqslant\!1$ ，则对任意一棵包含 $n$ 个关键字、高度为 $h$ 、阶数为 $m$ 的B树：1）若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小。  

因为B树中每个结点最多有 $m$ 棵子树， $m-1$ 个关键字，所以在一棵高度为 $h$ 的 $m$ 阶B树中关键字的个数应满足 $n\!\leqslant\!(m-1)(1+m+m^{2}+\cdots+m^{h-1})=m^{h}-1$ ，因此有  

$h\geqslant\log_{m}\left(n+1\right)$  

2）若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大。  

第一层至少有1个结点；第二层至少有2个结点：除根结点外的每个非叶结点至少有 $\lceil m/2\rceil$ 棵子树，则第三层至少有 $2\left\lceil m/2\right\rceil$ 个结点第 $h+1$ 层至少有 $2(\lceil m/2\rceil)^{h-1}$ 个结点，注意到第 $h+1$ 层是不包含任何信息的叶结点。对于关键字个数为 $n$ 的B树，叶结点即查找不成功的结点为 $n+1$ ，由此有 $n+1\!\geqslant\!2(\lceil m/2\rceil)^{h-1}$ ，即 $h{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1.$  

例如，假设一棵3阶B树共有8个关键字，则其高度范围为 $2\!\leqslant\!h\!\leqslant\!3.17$ ，取整数。  

# 3.B树的插入  

# 命题追踪通过插入操作构造一棵初始为空的B树（2020）  

与二叉排序树的插入操作相比，B树的插入操作要复杂得多。在B树中查找到插入的位置后，并不能简单地将其添加到终端结点（最底层的非叶结点）中，因为此时可能会导致整棵树不再满足B树定义中的要求。将关键字key插入B树的过程如下：  
1）定位。利用前述的B树查找算法，我出插入该关键字的终端结点（在B树中查找key时，会找到表示查找失败的叶结点，因此插入位置一定是最底层的非叶结点）。  

2）插入。每个非根结点的关键字个数都在  $[\lceil m/2\rceil\!-\!1,\,m\!-\!1]$  。若结点插入后的关键字个数小 于 $m$ ，可以直接插入；若结点插入后的关键字个数大于 $m-1$ ，必须对结点进行分裂。  

分裂的方法是：取一个新结点，在插入key后的原结点，从中间位置 $(\lceil m/2\rceil)$ 将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置 $(\lceil m/2\rceil)$ 的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。  

对于 $m=3$ 的B树，所有结点中最多有 $m-1=2$ 个关键字，若某结点中已有两个关键字，则结点已满，如图7.29(a)所示。插入一个关键字60后,结点内的关键字个数超过了 $m-1$ ,如图7.29(b)所示，此时必须进行结点分裂，分裂的结果如图7.29（c)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80d65ed644ea63d8e94f85979f930603e6eb9b46bb9c910cd6cf03ad6c8bf748.jpg)  
图7.29结点的“分裂”示意  

# 4.B树的删除  

B树的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数≥m/21-1，因此将涉及结点的“合并”问题。  

# 命题追踪B树的删除操作的实例（2012、2022）  

当被删关键字 $k$ 不在终端结点中时，可以用 $k$ 的前驱（或后继） $k^{\prime}$ ，即 $k$ 的左侧子树中“最右下”的元素（或右侧子树中“最左下”的元素），来替代 $k$ ，然后在相应的结点中删除 $k^{\prime}$ ，关键字 $k^{\prime}$ 必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在图7.30的4阶B树中，删除关键字80，用其前驱78替代，然后在终端结点中删除78。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7238b2b80bcf193f427d7371143169091e88dc7e89de6a71f0c30816046d808c.jpg)  
图7.30B树中删除非终端结点关键字的取代  

因此只需讨论被删关键字在终端结点中的情形，有下列三种情况：  

1）直接删除关键字。若被删关键字所在结点删除前的关键字个数 $\geqslant\!\lceil m/2\rceil$ ，表明删除该关键字后仍满足B树的定义，则直接删去该关键字。  

2）兄弟够借。若被删关键字所在结点删除前的关键字个数 $\scriptstyle[=\lceil m/2\rceil-1$ ，且与该结点相邻的右（或左）兄弟结点的关键字个数 $\geqslant\!\left\lceil m/2\right\rceil$ ，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡。在图7.31(a)中删除4阶B树的关键字65，右兄弟关键字个数 $\geqslant\!\left\lceil m/2\right\rceil\!=2$ ，将71取代原65的位置，将74调整到71的位置。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/215b6baf0ac411ac31105377425b16f9f12f9828b89f9a64b2c180cfee010990.jpg)  
图7.314阶B树中删除终端结点关键字的示意图  

3）兄弟不够借。若被删关键字所在结点删除前的关键字个数 $\scriptstyle\cdot=\left\lceil m/2\right\rceil-1$ ，且此时与该结点相邻的左、右兄弟结点的关键字个数都 $\scriptstyle\left\langle=\left\lceil m/2\right\rceil-1$ ，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。在图7.31（b）中删除4阶B树的关键字5，它及其右兄弟结点的关键字个数 $\it{\Delta}=\left\lceil m/2\right\rceil-1=1$ ，所以在5删除后将60合并到65结点中。  

# 命题追踪非空B树的查找、插入、删除操作的特点（2023）  

在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根：若双亲结点不是根结点，且关键字个数减少到 $\lceil m/2\rceil_{-2}$ ，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。  

# 7.4.2 $\mathbf{B}+$ 树的基本概念  

# 命题追踪 $^{\mathsf{B}+}$ 树的应用场合（2017）  

$^{\mathrm{B+}}$ 树是应数据库所需而出现的一种B树的变形树。一棵 $m$ 阶 $^{\mathrm{B+}}$ 树应满足下列条件  

1）每个分支结点最多有 $m$ 棵子树（孩子结点）。2）非叶根结点至少有两棵子树，其他每个分支结点至少有 $\lceil m/2\rceil$ 棵子树3）结点的子树个数与关键字个数相等。4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）。5）所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。  

# 命题追踪B树和 $^{\mathsf{B}+}$ 树的差异的分析（2016）  

$m$ 阶 $^{\mathrm{B+}}$ 树与 $m$ 阶B树的主要差异如下  

1）在 $^{\mathrm{B+}}$ 树中，具有 $n$ 个关键字的结点只含有 $n$ 棵子树，即每个关键字对应一棵子树：而在 $n+1$  

B树中，具有 $n$ 个关键字的结点含有棵子树。2）在 $\mathbf{B}+$ 树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\lceil m/2\rceil{\leqslant}n{\leqslant}m$ （非叶根结点： $2\!\leqslant\!n\!\leqslant\!m)$ ：而在B树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\lceil m/2\rceil_{-1}$  ${\leqslant}n{\leqslant}m-1$ （根结点： $1\!\leqslant\!n\!\leqslant\!m\!-\!1!$ 。  
3）在 $^{\mathrm{B+}}$ 树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。  

4）在 $^{\mathrm{B+}}$ 树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快。  

5）在 $^{\mathrm{B+}}$ 树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表。  

图7.32所示为一棵4阶B+树。可以看出，分支结点的关键字是其子树中最大关键字的副本。通常在 $^{\mathrm{B+}}$ 树中有两个头指针：一个指尚根结点，另一个指向关键字最小的叶结点。因此，可以对 $^{\mathrm{B+}}$ 树进行两种查找运算：一种是从最小关键学开始的顺序查找，另一种是从根结点开始的多路查找  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db9dc115f173d19c088aab329b4f42f2125e735f6d5222eacbec4640c3e2ffab.jpg)  
图7.32B+树结构示意图  

$^{\mathrm{B+}}$ 树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。所以，在 $^{\mathrm{B+}}$ 树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。  

# 7.4.3 本节试题精选  

# 一、单项选择题  

01.下图所示是一棵（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1ac19a6ecb5d0be8b5a3089fba49718c702d91b1d8fb04ba5e110211820e4c7a.jpg)  

A.4阶B树B.3阶B树C.4阶 $^{\mathrm{B+}}$ 树D.无法确定02.下列关于 $m$ 阶B树的说法中，错误的是（）。  

A.根结点至多有  $m$  棵子树 B.所有叶结点都在同一层次上C.非叶结点至少有  $m/2$  (  $m$  为偶数）或  $(m+1)/2$  (  $m$  为奇数）棵子树 D.根结点中的数据是有序的  

03.以下关于 $m$ 阶B树的说法中，正确的是（）。  

1.每个结点至少有两棵非空子树 11.树中每个结点至多有 $m\!-\!1$ 个关键字I1I所有叶结点在同一层IV.插入一个元素引起B树结点分裂后，树长高一层  
A.I、IIB.II、IIC.III、IVD.I、II、IV  

04.在一棵 $m$ 阶B树中做插入操作前，若一个结点中的关键字个数等于（），则插入操作后必须分裂成两个结点；在一棵 $m$ 阶B树中做删除操作前，若一个结点中的关键字个数等于（），则删除操作后可能需要同它的左兄弟或右兄弟结点合并成一个结点。  

A.  $m$   $\lceil m/2\rceil_{-2}$  B.m-1，[m/2]-1 C.  $m+1$   $\lceil m/2\rceil$  D.m/2,  $\lceil m/2\rceil+1$  

05.具有 $n$ 个关键字的 $m$ 阶B树，应有（）个叶结点。A.  $n+1$  B.  $n-1$  C.mn D.nm/2

 06.高度为5的3阶B树至少有（）个结点，至多有（）个结点。A.32 B.31 C.120 D.121

 07.含有 $n$ 个非叶结点的 $m$ 阶B树中至少包含（）个关键字。A.  $n(m+1)$  B.  $n$  C.  $n(\lceil m/2\rceil_{-1})$  D.  $(n-1)(\lceil m/2\rceil\!-\!1)+1$  08.已知一棵5阶B树中共有53个关键字，则树的最大高度为（），最小高度为（）。A.2B.3C.4D.5

09.已知一棵3阶B树中有2047个关键字，则此B树的最大高度为（），最小高度为（）。A.11 B.10 C.8 D.7

 10.下列关于B树和 $\mathbf{B}+$ 树的叙述中，不正确的是（）。  

A.B树和 $^{\mathrm{B+}}$ 树都能有效地支持顺序查找B.B树和 $\mathbf{B}+$ 树都能有效地支持随机查找C.B树和  $\mathbf{B}+$  树都是平衡的多叉树 D.B树和 $^{\mathrm{B+}}$ 树都可以用于文件索引结构  

11.在7阶B树中搜索第2016个关键字，若根结点已读入内存，则最多需启动（）次1/OA.4 B.5 C.6 D.7  

12.【2009统考真题】下列叙述中，不符合 $m$ 阶B树定义要求的是（）。  

A.根结点至多有 $m$ 棵子树B.所有叶结点都在同一层上C.各结点内关键字均升序或降序排列 D.叶结点之间通过指针链接  

13.【2012统考真题】已知一棵3阶B树，如下图所示。删除关键字78得到一棵新B树，其最右叶结点中的关键字是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a786127a16bf8bcbf4297060523f4f656161e7ac19fd06e281a471ae5b332eda.jpg)  

A.60 B.60,62 C.62,65 D.65

 14.【2013统考真题】在一棵高度为2的5阶B树中，所含关键字的个数至少是（）A.5 B.7 C.8 D.14

 15.【2014统考真题】在一棵有15个关键字的4阶B树中，含关键字的结点个数最多是（）。A.5 B.6 0 C.10 D.15

 16.【2016统考真题】 $^{\mathrm{B+}}$ 树不同于B树的特点之一是（）  

A.能支持顺序查找B.结点中含有关键字C.根结点至少有两个分支D.所有叶结点都在同一层上  
17.【2017统考真题】下列应用中，适合使用 $^{\mathrm{B+}}$ 树的是（）  

A.编译器中的词法分析B.关系数据库系统中的索引C.网络中的路由表快速查找D.操作系统的磁盘空闲块管理  

18.【2018统考真题】高度为5的3阶B树含有的关键字个数至少是（）A.15 B.31 C.62 D.242  

19.【2020统考真题】依次将关键字5，6，9，13，8，2，12，15插入初始为空的4阶B树后，根结点中包含的关键字是（）。  

A.8 B.6,9 C.8,13 D.9,12  

20.【2021统考真题】在一棵高度为3的3阶B树中，根为第1层，若第2层中有4个关键字，则该树的结点数最多是（）。  

A.11K B.10 C.9 D.8  

21.【2022统考真题】在下图所示的5阶B树 $T$ 中，删除关键字260之后需要进行必要的调整，得到新的B树 $T_{1\circ}$ 下列选项中，不可能是 $T_{1}$ 根结点中关键字序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f3a2b9d42d3ee340695a6f6dbb54a8d6f9eec22569ffef599a94af089d854a8d.jpg)  

A.60,90,280 B.60,90,350 C.60,85,110,350 D.60,90,110,350  

22.【2023统考真题】下列关于非空B树的叙述中，正确的是（）。  

I.插入操作可能增加树的高度11.删除操作一定会导致叶结点的变化III.查找某关键字总是要查找到叶结点IV.插入的新关键字最终位于叶结点中  

A.仅IB.仅I、ⅡIC.仅IⅢI、IVD.仅I、Ⅱ、IV  

# 二、综合应用题  

01.给定一组关键字20，30.50，52.60，68.70，给出创建一棵3阶B树的过程。  

02.对如下图所示的3阶B树，依次执行下列操作，画出各步操作的结果。1）插入90 2）插入25 3）插入45 4）删除60 5）删除80  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a49427774f9917d43cdfcc10a2f671cb4d94c024b87f657aae9324cb2bb34312.jpg)  

03.利用B树做文件索引时，若假设磁盘页块的大小是4000B（实际应是2的次幂，此处是为了计算方便），指示磁盘地址的指针需要5B。现有20000000个记录构成的文件，每个记录为200B，其中包括关键字5B。  

试问在这个采用B树作索引的文件中，B树的阶数应为多少？假定文件数据部分未按关键字有序排列，则索引部分需要占用多少磁盘页块？  

# 7.4.4 答案与解析  

# 一、单项选择题  

01.D  

关键字数目比子树数目少1，首先可排除 $^{\mathrm{B+}}$ 树。对于4阶B树，根结点至少有2棵子树（关键字数至少为1)，其他非叶结点至少有 $\overset{\cdot}{n}/2\,\overset{\cdot}{\left}\,=2\right$ 棵子树（关键字数至少为1）、至多有4棵子树（关键字数至多为3）。5阶B树和6阶B树的分析也类似。题目所示的B树，同时满足4阶B树、5阶B树和6阶B树的要求，因此不能确定是哪种类型的B树。  
02.C  

除根结点外的所有非叶结点至少有 $\dot{}_{m/2}$ 棵子树。对于根结点，最多有 $m$ 棵子树，若其不是叶结点，则至少有2棵子树。  

03.B  

每个非根的内部结点必须至少有 $\lceil m/2\rceil$ 棵子树，而根结点至少要有两棵子树，所以选项I不正确。选项ⅡI、ⅢI显然正确。对于IV，插入一个元素引起B树结点分裂后，只要从根结点到该元素插入位置的路径上至少有一个结点未满，B树就不会长高，如图1所示；只有当结点的分裂传到根结点，并使根结点也分裂时，才会导致树高增1，如图2所示，因此选项IV错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6b70ea789351b9436e9ce2a3bf9da40873cc2757acd01ee0f1573c4de34bd70f.jpg)  
图1结点分裂不导致树高增1（3阶B树）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ec8ae0dd430f2a129d4c07e31e6fb710c86e06f5d28ce3d315106a797815c733.jpg)  
图2结点分裂导致树高增1（3阶B树）  

04.B  

由于B树每个结点内的关键字个数最多为 $m-1$ ，所以当关键字个数大于 $m-1$ 时，则应该分裂。每个结点内的关键字个数至少为 $\bar{m}/2^{\top}\!\!-1$ 个，所以当关键字个数少于 $\lceil m/2\rceil_{-1}$ 时，则可能与其他结点合并（除非只有根结点）。若将本题题干改为 $^{\mathrm{B+}}$ 树，请读者思考上述问题的解答。  

05. A  

B树的叶结点对应查找失败的情况，对有 $n$ 个关键字的查找集合进行查找，失败可能性有 $^{n+}$ 1种。  

06.B、D  

由 $m$ 阶B树的性质可知，根结点至少有2棵子树；根结点外的所有非终端结点至少有 $\left\lceil m/2\right\rceil$ 棵子树，结点数最少时，3阶B树形状至少类似于一棵满二叉树，即高度为5的B树至少有 $2^{5}\!-\!1\!=$ 31个结点。由于每个结点最多有 $m$ 棵子树，所以当结点数最多时，3阶B树形状类似于满三叉树，结点数为 $(3^{5}-1)/2=121$ （注意，这里求的是结点数而非关键字数，若求的是关键字数，则还应把每个结点中关键字数的上下界确定出来）。  

# 07.D  

除根结点外， $m$ 阶B 树中的每个非叶结点至少有 $\lceil m/2\rceil_{-1}$ 个关键字，根结点至少有一个关键字，所以总共包含的关键字最少个数 $=(n-1)(\lceil m/2\rceil_{-}1)+1$  

# 注意  

由以上题目可知B树和 $^{\mathrm{B+}}$ 树的定义与性质尤为重要，需要熟练掌握。  
08.C、B  

5阶B树中共有53个关键字，由最大高度公式 $H{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1$ 得最大高度 $H\leqslant$  $\log_{3}[(53+1)/2]+1=4$ ，即最大高度为4；由最小高度公式 $h{\geqslant}\log_{m}(n+1)$ 得最小高度 $h\!\gg\!\log_{5}\!54\!\approx\!2.5$ 从而最小高度为3。  

09.A、D  

利用前面的公式即最小高度 $h{\geqslant}\log_{m}(n+1)$ 和最大高度 $H{\leqslant}\log_{\lceil m/2\rceil}[(n+1)/2]+1$ ，易算出最大高度 $H{\leqslant}\log_{2}[(2047+1)/2]+1=11$ ，最小高度 $h\!\geq\!\log_{3}\!2048=6.9$ ，从而最小高度取7（注意，有些辅导书针对本题算出的高度要比这里给出的答案多1，因为它们在对B树的高度定义中，把最底层不包含任何关键字的叶结点也算进去了）。  

10.A  

B树和 $^{\mathrm{B+}}$ 树的差异主要体现在： $\textcircled{\scriptsize{1}}$ 结点关键字和子树的个数： $^{\textregistered}\mathrm{B}^{+}$ 树非叶结点仅起索引作用： $(\mathbf{\mathcal{3}})\mathbf{B}$ 树叶结点关键字和其他结点包含的关键字是不重复的： $\textcircled{4}$ B+树支持顺序查找和随机查找，而B树仅支持随机查找。由于 $^{\mathrm{B+}}$ 树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，因此可以进行顺序查找，而B树不支持顺序查找。B树和 $\mathbf{B}+$ 树都可用于文件索引结构，但 $^{\mathrm{B+}}$ 树更适合做数据库索引和文件索引，因为它的磁盘读/写代价更低。  

11.A  

根据B树树高 $h$ 的计算公式： $\log_{m}(n+1){\leqslant}h{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1$ ，计算得 $h\!=\!5$ （取整数），因为B树的根结点已读入内存，所以最多需再启动4次磁盘 $\mathrm{I}/\mathrm{O}$  

12.D  

$m$ 阶B树不要求将各叶结点之间用指针链接。选项D描述的实际上是 $^{\mathrm{B+}}$ 树。  

13.D  

对于图中所示的3阶B树，被删关键字78所在的结点在删除前的关键字个数 $=1=\!\!\lceil3/2\rceil\!\!-\!\!1$ 且其左兄弟结点的关键字个数 $=2\!\geqslant\!\!\lceil3/2\rceil$ ，属于“兄弟够借”的情况，因此要把该结点的左兄弟结点中的最大关键字上移到双亲结点中，同时把双亲结点中大于上移关键字的关键字下移到要删除关键字的结点中，这样就达到了新的平衡，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84cffa5a4e36be277510866df229dad3433a44c6c4593cd4b7a91f8f06bd4432.jpg)  

14.A  

对于5阶B树，根结点的分支数最少为2（关键字数最少为1），其他非叶结点的分支数最少为 $\left\lceil n/2\right\rceil=3$ （关键字数最少为2），因此关键字个数最少的情况如下图所示（叶结点不计入高度）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f8f59e804ac095fa4ad361b3178550c2a93112e18e01d3c4093a9e714ac51c16.jpg)  
# 注意  

一般对于某个具体的B树图形，并不能确定是几阶B树。对于本题所述的5阶B树，不要误认为：“存在至少有一个含关键字结点中的关键字达到 $4^{\circ}$ 才符合5阶B树的要求，因为5阶B树中各个结点包含的关键字个数最少为2（ $\lceil5/2\rceil_{-1}=2$ )，最多为4 ( $5\!-\!1=\!4$ )。当5阶B树中各个结点包含的关键字个数为2时，也满足5阶B树的要求。  

15.D  

关键字数量不变，要求结点数量最多，即要求每个结点中含关键字的数量最少。根据4阶B树的定义，根结点最少含1个关键字，非根结点中最少含  $\lceil4/2\rceil-1=1$  个关键字，所以每个结 点中关键字数量最少都为1个，即每个结点都有2个分支，类似于排序二叉树，而15个结点正好可以构造一个4层的4阶B树，使得终端结点全在第四层，符合B树的定义，因此选D。  

16.A  

由于 $^{\mathrm{B+}}$ 树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，因此可以进行顺序查找，而B树不支持顺序查找（只支持多路查找）。  

17. B  

$^{\mathrm{B+}}$ 树是应文件系统所需而产生的B树的变形，前者比后者更加适用于实际应用中的操作系统的文件索引和数据库索引，因为前者的磁盘读/写代价更低，查询效率更加稳定。编译器中的词法分析使用有穷自动机和语法树。网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法。系统一般使用空闲空间链表管理磁盘空闲块。  

18.B  

$m$ 阶B树的基本性质：根结点以外的非叶结点最少含有 $\lceil m/2\rceil_{-1}$ 个关键字，代入 $m=3$ 得到每个非叶结点中最少包含1个关键字，而根结点含有1个关键字，因此所有非叶结点都有两个孩子。此时其树形与  $h=5$  的满二叉树相同，可求得关键字最少为31个。  

19.B  

一个4阶B树的任意非叶结点至多含有 $m\!-\!1\!=\!3$ 个关键字，在关键字依次插入的过程中，会导致结点的不断分裂，插入过程如下图所示。得到根结点包含的关键字为6,9。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d973b047763897bf348baea36055d366507ab95fbb33e08e0c536905e65e903d.jpg)  

20. A  

在阶为3的B树中，每个结点至多含有2个关键字（至少1个），至多有3棵子树。本题规定第二层有4个关键字，欲使B树的结点数达到最多，则这4个关键字包含在3个结点中，B树树形如下图所示，其中A,B,C,，M表示关键字，最多有11个结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1876fb411dc415a97896e022a84ffdce44ee8c844cd9ba4feb4002883493f38a.jpg)  
21.D  

在5阶B树中，除根结点外的非叶结点的关键字数 $k$ 需要满足 $2\leqslant k\leqslant4$ 。当被删关键字x不在终端结点（最底层非叶结点）时，可以用x的前驱（或后继）关键字V来替代 $_\mathrm{x}$ ，然后在相应结点中删除y。情况  $\textcircled{\scriptsize{1}}$  ：删除260，将其前驱110放入260处，删除110后的结点  $<\!100\!>$  不满足 5阶B树定义，从左兄弟中借85，将85放入根中，将根中的90移入结点 $<\!100\!>$ 变为 $\mathord{\lvert<\!90}$  $100{>}$ 情况 $\circledcirc$ ：删除260，将其后继280放入260处，结点 $<\!300\!>$ 不满足5阶B树定义且左右兄弟都不够借，结点 $<\!300\!>$ 可以和左兄弟 $\mathord{<}100$  $110\substack{>}$ 以及关键字280合并成一个新的结点 ${<}100$ 110,280, $300{>}$ 。情况 $\textcircled{3}$ ：在情况 $\circledcirc$ 中，结点 $<\!300\!>$ 也可以和右兄弟 ${\tt<}400$ .500>以及关键字350合并成一个新的结点 $<\!300.$ ,350, 400, $500\substack{>}$ 。综上， $T_{1}$ 根结点中的关键字序列可能是 ${<\!60}$ 85,110,350>或 ${\mathord{<}}60,$ 90, $350{>}$ 或 ${\tt<}60$ 90, $280{>}$ ，仅D不可能。  

快速解法：假如选项D的60,90,110,350作为根结点，则在90和110之间只有100这一个数据，显然不符合5阶B树的定义，因此D项不可能。  

22.B  

B树的插入操作可能导致叶结点分裂，而叶结点分裂可能导致父结点分裂，若这个分裂过程传导到根结点，则会导致B树高度增1，I正确。若被删结点是叶结点，则显然会导致叶结点变 化；若被删结点不是叶结点，则要先将被删结点和它的前驱或后继交换，最终转换为删除叶结点，还是导致叶结点变化，Ⅱ正确。若在非叶结点中查找到了给定的关键字，则不用向下继续查找， ⅢI错误。插入关键字的初始位置是最底层叶结点，但可能因结点分裂而被转移到父结点中，IV错误。  

# 二、综合应用题  

# 01.【解答】  

$m=3$ ，因此除根结点外，非叶结点关键字个数为 $_{1\sim2}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8250b9758269a977f34e3cef30fdda41fdef47e0b546280a99d3e28470950f2.jpg)  

如上图所示，首先插入20，30，结点内关键字个数不超过 $m-1=2$ ，不会引起分裂；插入50，插入20,30所在的结点，引起分裂，结点内第 $\lceil m/2\rceil$ 个关键字30上升为父结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1babae086f1fd49f6dc59ecc541439f4f994923be9710fd264a4ce098a39a207.jpg)  

如上图所示，插入52，插入50所在的结点，不会引起分裂；继续插入60，插入50.52所在的结点，引起分裂，52上升到父结点中，不会引起父结点的分裂。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5cca2de7289e0f067eb089a65d7e23d55a4199971a31bb96620b3482cc1c3585.jpg)  

如上图所示，插入68，插入60所在的结点，不会引起分裂；继续插入70，插入60,68所在的结点，引起分裂，68上升为新的父结点，68上升到30.52所在的结点后，会继续引起该结点的分裂，所以52上升为新的根结点。最后得到的B树如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5063156976442bac31f278c2809bfc32599ef28647f038954981baefcccc6620.jpg)  

# 02.【解答】  

1）插入90：将90插入100所在的结点，插入90后该结点中的元素个数不超过 $\left\lceil3/2\right\rceil=2$ 不会引起结点的分裂，插入后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92ea03be230fd165f2eccc0a312692706a04fee071d58beaf48797db372afd18.jpg)  

2）插入25：将25插入8，20所在的结点，插入后结点内的元素个数为3，引起分裂。所以将结点内的中间元素20上升到父结点中，此时父结点中的元素个数为2（元素20和30）不会引起继续分裂，插入25后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1953444666fce4e5c614460b7334ef98bf1c8bc6aba164f11c5e74923f7ad73.jpg)  

3）插入45：将45插入35，40所在的结点，引起分裂，中间元素40上升到父结点（20，30所在的结点）中，引起父结点分裂，中间元素30上升到父结点（50所在的结点）中，两次分裂后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e33900611d2dd51774b8b72702b89f90933940171e0e6d3103ef1ffe77da326.jpg)  

4）删除60：删除60后，其所在的结点元素为空，从而导致借用右兄弟结点的元素，调整后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7ea07cf34b158b258e09049544dd929fbac26b467f0056fcdb6617f41723c202.jpg)  

5）删除80：删除80后，导致80所在结点的父结点与其右兄弟结点合并，这时父结点元素个数为0，再次对父结点进行调整。将50与40合并成一个新结点，则90.100所在结点为这个结点的子结点。从而构造的B树如下图所示。注意，这次调整的过程实际上包含多次调整过程，希望读者对照考点讲解中的删除过程仔细思考。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d40411ff0fb9b2ee27179dc17e36e4b5e15242536957796ca4fce04a5553f149.jpg)  

# 注意  

B树中结点的插入、删除操作（特别是插入、删除后的结点分裂与合并）是本节的重点，也是难点，请读者务必熟练掌握。  

03.【解答】  

根据B树的概念，一个索引结点应适应操作系统一次读/写的物理记录大小，其大小应取不超过但最接近一个磁盘页块的大小。假设B树为 $m$ 阶，一个B树结点最多存放 $m-1$ 个关键字（5B）和对应的记录地址（5B）、 $m$ 个子树指针（5B）和1个指示结点中的实际关键字个数的整数（2B），则有  

$$
(2{\times}(m-1)+m){\times}5+2{\leqslant}4000
$$  

计算结果为 $m{\leqslant}267$  

一个索引结点最多可以存放 $m\!-\!1=\!266$ 个索引项，最少可以存放 $\lceil m/2\rceil\!-\!1=133$ 个索引项。全部有 $n\,{=}\,20000000$ 个记录，每个记录占用空间200B，每个页块可以存放 $4000/200=20\$ 个记录，则全部记录分布在 $2000000/20=1000000$ 个页块中，最多需要占用 $1000000/133=7519$ 个磁盘页块作为B树索引，最少需要占用 $1000000/266=3760$ 个磁盘页块作为B树索引（注意B树与 $^{\mathrm{B+}}$ 树的不同，B树所有对数据记录的索引项分布在各个层次的结点中， $^{\mathrm{B+}}$ 树所有对数据记录的索引项都在叶结点中）。  

# 7.5散列（Hash）表  

# 7.5.1散列表的基本概念  

在前面介绍的线性表和树表的查找中，查找记录需进行一系列的关键字比较，记录在表中的位置与记录的关键字之间不存在映射关系，因此在这些表中的查找效率取决于比较的次数。  

散列函数（也称哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 $\operatorname{Hash}(\ker)=$ Addr（这里的地址可以是数组下标、索引或内存地址等）。  

散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生冲突的不同关键字称为同义词。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。  

散列表（也称哈希表）：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。  

理想情况下，对散列表进行查找的时间复杂度为 $O(1)$ ，即与表中元素的个数无关。下面分别介绍常用的散列函数和处理冲突的方法。  

# 7.5.2散列函数的构造方法  

在构造散列函数时，必须注意以下几点：  

1）散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小  
2）散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。  

3）散列函数应尽量简单，能在较短的时间内计算出任意一个关键字对应的散列地址。  

下面介绍常用的散列函数。  

# 1.直接定址法  

直接取关键字的某个线性函数值为散列地址，散列函数为  

式中， $a$ 和 $b$ 是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。  

# 2.除留余数法  

这是一种最简单、最常用的方法，假定散列表表长为 $m$ ，取一个不大于 $m$ 但最接近或等于 $m$ 的质数 $p$ ，利用以下公式把关键字转换成散列地址。散列函数为  

$$
H(\mathrm{kcy})=\mathrm{kcy}\,\%\,p
$$  

除留余数法的关键是选好 $p$ ，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。  

# 3.数字分析法  

设关键字是 $r$ 进制数（如十进制数），而 $r$ 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。  

# 4.平方取中法  

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。  

在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况。  

# 7.5.3处理冲突的方法  

应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。用 $H_{i}$ 表示处理冲突中第 $i$ 次探测得到的散列地址，假设得到的另一个散列地址 $H_{1}$ 仍然发生冲突，只得继续求下一个地址 $H_{2}$ ，以此类推，直到 $H_{k}$ 不发生冲突为止，则 $H_{k}$ 为关键字在表中的地址。  

# 1.开放定址法  

所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为  

$$
H_{i}\,{=}\,(H(\mathrm{kcy})+d_{i})\,\%\,m
$$  

式中，H(key)为散列函数； $i=1,2,\cdots,k$  $.k{\leqslant}m-1)$ ； $m$ 表示散列表表长； $d_{i}$ 为增量序列。取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：  

# 命题追踪堆积现象导致的结果（2014）  

1）线性探测法，又称线性探测再散列法。 $d_{i}=1,2,\cdots,m-1$ 。它的特点是：冲突发生时，顺  
序查看表中下一个单元（探测到表尾地址 $m\!-\!1$ 时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。  

线性探测法可能使第 $i$ 个散列地址的同义词存入第 $i+1$ 个散列地址，这样本应存入第 $i+$ 1个散列地址的元素就争夺第 $i+2$ 个散列地址的元素的地址从而造成大量元素在相邻的散列地址上聚集（或堆积）起来，大大降低了查找效率。  

2）平方探测法，又称二次探测法。 $d_{i}=1^{2},-1^{2},2^{2},-2^{2},\cdots,k^{2},-k^{2}$ ，其中 $k{\leqslant}m/2$ ，散列表长度 $m$ 必须是一个可以表示成 $4k+3$ 的素数。平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。  

3）双散列法。 $d_{i}=i{\times}\mathrm{Hash}_{2}(\mathrm{ker})$ 。需要使用两个散列函数，当通过第一个散列函数H(key）得到的地址发生冲突时，则利用第二个散列函数Hashz（key)计算该关键字的地址增量。它的具体散列函数形式如下：  

$$
H_{i}\,{=}\,(H(\mathrm{kcy})+i{\times}\mathrm{Hash}_{2}(\mathrm{kcy}))\:\%\:m
$$  

初始探测位置 $H_{0}\,{=}\,H(\mathrm{kcy})\;\%\,m$ 。 $i$ 是冲突的次数，初始为0。  

4）伪随机序列法。 $d_{i}\!=$ 伪随机数序列。  

# 命题追踪散列表中删除部分元素后的查找效率分析（2023）  

# 注意  

采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径。因此，要删除一个元素时，可以做一个删除标记，进行逻辑删除。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。  

# 2.拉链法（链接法，chaining）  

显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表的第 $i$ 个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。  

例如，关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，散列函数 $H(\mathrm{kcy})=\mathrm{kcy}\%13$ 用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可以尝试计算本例的平均查找长度ASL)。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1940764bbe5838b67ac8609d78335783a585aa5c7fc0cb6560c6e81692cd7da.jpg)  
图7.33拉链法处理冲突的散列表  
# 7.5.4散列查找及性能分析  

# 命题追踪散列表的构造及查找效率的分析（2010、2018、2019）  

散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：  

初始化：Addr $\smile$ Hash (key) ;  

$\textcircled{\scriptsize{1}}$ 检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，  

比较它与key的值，若相等，则返回查找成功标志，否则执行步骤 $\mathcal{Q}$  

$\circledcirc$ 用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤 $^\mathrm{(Q)}$  

例如，关键字序列{19,14,23,01,68,20,84,27,55,11,10,79}按散列函数H(key) $=$ key%13和线性探测处理冲突构造所得的散列表 $\mathbb{L}$ 如图7.34所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/37af350f00080c15707906e376408f9d353587a88dd2c9322a9a8e4bad9e594b.jpg)  

给定值84的查找过程为：首先求得散列地址1 $\nexists\left(\,8\,4\,\right)=\,6$ ，因L[6]不空且 $\mathtt{L}\left[\,6\,\right]\neq8\,4$ ，则我第一次冲突处理后的地址 $\mathrm{{H_{1}}\mathrm{{=}}\left(\mathrm{{6}\mathrm{{+}1}\right)\mathrm{{\circ}1\mathrm{{6}\mathrm{{=}7}}}}}$ ，而L[7]不空且 $\mathtt{L}\left[\,7\,\right]\neq\!8\,4$ ，则找第二次冲突处理后的地址 $\mathrm{H}_{2}{=}\left(6{+}2\right)\circ16{=}8$ ，L[8]不空且 $\mathtt{L}\left[\,8\,\right]\mathtt{=}8\,4$ ，查找成功，返回记录在表中的序号8。  

给定值38的查找过程为：先求散列地址H $(38){=}12$ ，L[12]不空且 $\mathtt{L}\,[\,12\,]\,\neq\,38$ ，则找下一地址 $\mathrm{H}_{1}{=}\,(12{+}1)\,\%16{=}13$ ，由于L[13]是空记录，所以表中不存在关键字为38的记录。  

查找各关键字的比较次数如图7.35所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/becdbede030512e5e2ac3b81b756cc81d076a78bca8c20dbff207903db34e92a.jpg)  

平均查找长度ASL为  

$$
\operatorname{ESL}\!\!=(1\!\times\!\!6+2+3\!\times\!3+4+9)/12=2.5
$$  

对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同，本例与上节采用拉链法的平均查找长度不同。  

从散列表的查找过程可见：  

1）虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，  

使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍然需要以平均查找长度作为衡量散列表的查找效率的度量。  

命题追踪影响散列表查找效率的因素（2011、2022）2）散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。装填因子。散列表的装填因子一般记为 $\alpha$ ，定义为一个表的装满程度，即  

$$
\alpha\!=~\frac{\ddagger\!\mp\!\mathrm{i}\vec{\mathrm{x}}\!\stackrel{\sharp}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!n}{\ddagger\!\!/\!\!\chi\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!m}
$$  

散列表的平均查找长度依赖于散列表的装填因子 $\alpha$ ，而不直接依赖于 $n$ 或 $m$ 。直观地看， $\alpha$ 越大，表示装填的记录越“满”，发生冲突的可能性越大；反之发生冲突的可能性越小。  
读者应能在给出散列表的长度、元素个数及散列函数和解决冲突的方法后，在求出散列表的基础上计算出查找成功时的平均查找长度和查找不成功的平均查找长度。  

# 7.5.5 本节试题精选  

# 一、单项选择题  

01.只能在顺序存储结构上进行的查找方法是（）A.顺序查找法B.折半查找法C.树形查找法D.散列查找法02.散列查找一般适用于（）的情况下的查找。  

A.查找表为链表B.查找表为有序表C.关键字集合比地址集合大得多D.关键字集合与地址集合之间存在对应关系  

03.下列关于散列表的说法中，正确的是（）  

I.若散列表的填装因子 $\alpha\!<\!1$ ，则可避免碰撞的产生I1.散列查找中不需要任何关键字的比较I1I.散列表在查找成功时平均查找长度仅与表长有关IV.若在散列表中删除一个元素，不能简单地将该元素删除  

A.I和IV B.II和III C. 1 Y D.IV 04.在开放定址法中散列到同一个地址而引起的“堆积”问题是由于（）引起的  

A.同义词之间发生冲突B.非同义词之间发生冲突C.同义词之间或非同义词之间发生冲突D.散列表“溢出”  

05.下列关于散列冲突处理方法的说法中，正确的有（）。  

I.采用平方探测法处理冲突时不易产生聚集II.采用线性探测法处理冲突时，所有同义词在散列表中一定相邻III.采用链地址法处理冲突时，若限定在链首插入，则插入任意一个元素的时间相同IV.采用链地址法处理冲突易引起聚集现象  

A.I和IIIB.I、Ⅱ和IⅢIC.II和IVD.I和IV  

06.设有一个含有200个表项的散列表，用线性探测法解决冲突，按关键字查询时找到一个表项的平均探测次数不超过1.5，则散列表项应能够容纳（）个表项（设查找成功的平均查找长度为 $\mathrm{ASL}=[1+1/(1-\alpha)]/2$ ，其中α为装填因子）。  

A.400 B.526 C.624 D.676  

07.假定有 $K$ 个关键字互为同义词，若用线性探测法把这 $K$ 个关键字填入散列表，至少要进行（）次探测。  

A.  $K-1$  B.  $K$  C.  $K+1$  D.  $K(K+1)/2$  08.对包含 $n$ 个元素的散列表进行查找，平均查找长度（）A.为 $O(\log_{2}n)$ B.为 $O(1)$ C.不直接依赖于 $n$ D.直接依赖于表长 $m$ 09.采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（）。  

A.数据元素过多B.负载因子过大C.散列函数选择不当D.解决冲突的方法选择不当  
10.当用线性探测再散列法解决冲突时，计算出的一系列“下一个空位”的要求是（）。  

A.必须大于或等于原散列地址 B.必须小于或等于原散列地址 C.可以大于或小于但不等于原散列地址D.对地址在何处没有限制  

11.一组记录的关键字为19，14,23，1,68,20，84，27,55，11,10,79}，用链地址法构造散列表，散列函数为 $\mathtt{H}\left(\mathtt{k e y}\right)\mathtt{=}\mathtt{k}$ eymod13，散列地址为1的链中有（）个记录。  

A.1 B.2 C.3 D.4  

12.在采用链地址法处理冲突所构成的散列表上查找某一关键字，则在查找成功的情况下，所探测的这些位置上的关键字值（）；若采用线性探测法，则（）。  

A.一定都是同义词B.不一定都是同义词C.都相同D.一定都不是同义词  

13.若采用链地址法构造散列表，散列函数为 $\mathtt{H}\,(\,\mathtt{k e y})=\mathtt{k e y}$ mod17，则需（ $\textcircled{\scriptsize{1}}$ ）个链表。这些链的链首指针构成一个指针数组，数组的下标范围为（ $\circledcirc$ )。  

$\textcircled{\scriptsize{1}}$  A.17 B.13 C.16 D.任意  $\circledcirc$  A.0\~17 B.1\~17 C.0\~16 D.1\~16  

14.设散列表长 $m\,=\,14$ ，散列函数为 $\mathrm{H\,(\,k e y)=k e y\,\%\,1\,1}$ ，表中仅有4个结点 $\mathrm{~H~}(15)\!=\!4$ ， $\mathrm{H}\left(38\right){=}5$ ， $\mathrm{H}\left(61\right)=6$ ， $\mathrm{~H~}(\,8\,4\,)=7$ ，若采用线性探测法处理冲突，则关键字为49的结点地址是（）。  

A.8 B.3 C.5 D.9  

15.现有长度为17、初始为空的散列表HT，散列函数H $(\mathtt{k e y})\!=\!\mathtt{k e y}\!\circ\!17$ ，用线性探查法解决冲突。将关键字序列26,25，72，38，8，18,59依次插入HT后，则查找59需探查（）次。  

A.2B.3C.4D.5  

16.现有长度为17、初始为空的散列表HT，散列函数H（key） $=\ \ker\gamma\sqrt[\circ]{17}$ ，用平方探测法解决冲突： $\mathtt{H}_{i}\,(\,\mathtt{k e y})=(\mathtt{H}\,(\,\mathtt{k e y})\pm i^{2})\mathbb{s}\,\mathtt{l}\,\mathtt{7}$ 。将关键字序列6,22，7，26，9，23依次插入HT后，则关键字23存放在散列表中的位置是（）。  

A.0 B.2 C.6 D.15  

17.将10个元素散列到100000个单元的散列表中，则（）产生冲突。  

A.一定会B.一定不会C.仍可能会D.不确定  

18.【2011统考真题】为提高散列表的查找效率，可以采取的正确措施是（）。I.增大装填（载）因子II1设计冲突（碰撞）少的散列函数IⅢI.处理冲突（碰撞）时避免产生聚集（堆积）现象  

A.仅IB.仅ⅡIC.仅I、ⅡID.仅Ⅱ、III  

19.【2014统考真题】用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象，下列选项中，会受堆积现象直接影响的是（）。  

A.存储效率B.散列函数C.装填（装载）因子D.平均查找长度  

20.【2018统考真题】现有长度为7、初始为空的散列表HT，散列函数 $\mathrm{H\left(k\right)=k\leqslant7}$ ，用线性探测再散列法解决冲突。将关键字22，43，15依次插入HT后，查找成功的平均查找长度是（）。  

A.1.5 B.1.6 C.2 D.3  
21.【2019统考真题】现有长度为11且初始为空的散列表HT，散列函数是F $\mathrm{i}\,(\,\mathrm{keV})\,{=}\,\mathrm{keV}\,^{\circ}\,7$ 采用线性探查（线性探测再散列）法解决冲突。将关键字序列87，40,30，6,11，22，98,20依次插入HT后，HT查找失败的平均查找长度是（）。  

A.4 B.5.25 C.6 D.6.29

 22.【2022统考真题】下列因素中，影响散列（哈希）方法平均查找长度的是（））  

I.装填因子II.散列函数III.冲突解决策略A.仅I、ⅡIB.仅I、IIIC.仅II、IIID.I、II、IⅢI  

23.【2023统考真题】现有长度为5、初始为空的散列表HT，散列函数 $\mathrm{H}\left(\mathsf{k}\right)=\left(\mathsf{k}\!+\!4\right)$ %5，用线性探查再散列法解决冲突。若将关键字序列2022，12，25依次插入HT，然后删除关键字25，则HT中查找失败的平均查找长度为（）。  

A.1 B.1.6 C.1.8 D.2.2  

# 二、综合应用题  

01.若要在散列表中删除一个记录，应如何操作？为什么？按照处理冲突的方法为开放地址法和拉链法分别说明。  

02.假定把关键字keY散列到有 $n$ 个表项（从0到 $n\!-\!1$ 编址）的散列表中。对于下面的每个函数H（key）（key为整数），这些函数能够当作散列函数吗？若能，它是一个好的散列函数吗？说明理由。设函数random（n）返回一个0到 $n-1$ 之间的随机整数（包括0与 $n\!-\!1$ 在内）。  

1)  $\mathrm{H\left(kg\right)=}\mathrm{keV/n_{\circ}}$  2)H  $(\mathtt{k e y})\!=\!1$  3)H $(\mathsf{k e y})=(\mathsf{k e y}\!+\!1$ random（n))&n。4）H $\mathrm{i}\left(\mathrm{secy}\right){=}\mathrm{secy\,\%\,p\left(n\right)}$ ；其中p（n）是不大于 $n$ 的最大素数。  

03.使用散列函数 $\mathrm{H_{\tau}(k e y)=k e y\circ11}$ ，把一个整数值转换成散列表下标，散列表的长度为11，现在要把数据1，13，12，34，38，33，27，22依次插入散列表1）使用线性探测法来构造散列表。2）使用链地址法构造散列表。试针对这两种情况，分别确定查找成功所需的平均查找长度，及查找不成功所需的平均查找长度。  

04.已知一组关键字为26，36,41，38，44，15，68，12，6,51，25}，用链地址法解决冲突，假设装填因子 $\alpha\,{=}\,0.73$ ，散列函数的形式为 $\mathtt{H}\left(\mathtt{k e y}\right)=\mathtt{k e y}\,^{\circ}\mathtt{P}$ ，P为不大于表长的最大素数，请回答以下问题：1）构造出散列函数。2）分别计算出等概率情况下查找成功和查找失败的平均查找长度（查找失败的计算中只将与关键字的比较次数计算在内即可）。  

$m=13$  再散列函数分别为： $\mathrm{H}_{0}\left(\mathrm{ker}\right)=\mathrm{ker}{\mathfrak{S}}13$ 注：是求余数运算（ $=$ mod） $\mathrm{H}_{i}{=}\left(\mathrm{H}_{i-1}{+}\mathrm{REV}\left(\mathrm{ker}{+}1\right)\mathrm{\S}\boldsymbol{1}\boldsymbol{1}{+}1\right)\mathrm{\S}\boldsymbol{1}\boldsymbol{3};\quad i=1,2,3,\cdots,m-1$  其中，函数 $\scriptstyle{\mathrm{REV}}(x)$ 表示颠倒十进制数 $x$ 的各位，如RE $\nabla\left(37\right){=}73$ ，REV $(7){=}7$ 等。若插入的关键码序列为（2，8，31，20，19，18，53，27），请回答：1）画出插入这8个关键码后的散列表。2）计算查找成功的平均查找长度ASL，  
06.【2010统考真题】将关键字序列（7，8，30，11，18，9,14)散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组，散列函数为 $\mathtt{H}\left(\mathtt{k e y}\right)=\left(\mathtt{k e y}\times3\right)$ mod7，处理冲突采用线性探测再散列法，要求装填（载）因子为0.7。  

1）请画出所构造的散列表2）分别计算等概率情况下，查找成功和查找不成功的平均查找长度。  

# 7.5.6 答案与解析  

# 一、单项选择题  

01.B  

顺序查找可以是顺序存储或链式存储：折半查找只能是顺序存储且要求关键字有序：树形查我法要求采用树的存储结构，既可以采用顺序存储也可以采用链式存储：散列查找中的链地址法解决冲突时，采用的是顺序存储与链式存储相结合的方式。  

02. D  

关键字集合与地址集合之间存在对应关系时，通过散列函数表示这种关系。这样，查找以计算散列函数而非比较的方式进行查找。  

03.D  

冲突（碰撞）是不可避免的，与装填因子无关，因此需要设计处理冲突的方法，1错误。散列查找的思想是计算出散列地址来进行查找，然后比较关键字以确定是否查找成功，ⅡI错误。散列查找成功的平均查找长度与装填因子有关，与表长无直接关系，ⅢI错误。在开放定址的情形下，不能随便删除散列表中的某个元素，否则可能会导致搜索路径被中断（因此通常的做法是在要册除的地方做删除标记，而不是直接删除），IV正确。  

04.C  

在开放定址法中散列到同一个地址而产生的“堆积”问题，是同义词冲突的探查序列和非同义词之间不同的探查序列交织在一起，导致关键字查询需要经过较长的探测距离，降低了散列的效率。因此要选择好的处理冲突的方法来避免“堆积”。  

05.A  

平方探测法采用的增量序列是非线性的，它可以跳过一些已被占用的单元，而不是顺序地探测下一单元，这样能减小冲突的概率，1正确。散列地址 $i$ 的关键字，和为解决冲突形成的某次探测地址为 $i$ 的关键字，都争夺地址 $i,\,i+1,\cdots$ ，因此不一定相邻，ⅡI错误。ⅢI正确。同义词冲突不等于聚集，链地址法处理冲突时将同义词放在同一个链表中，不会引起聚集现象，IV错误。  

06. A  

若有200个表项要放入散列表，采用线性探测法解决冲突，限定查找成功的平均查找长度不 超过1.5，则  

$$
\mathsf{A S L}_{n\!g\!;\!m}=\frac{1}{2}\bigg(1\!+\!\frac{1}{1\!-\!\alpha}\bigg)\!\leqslant\!1.5\Rightarrow\alpha\!=\!\frac{200}{m}\!\leqslant\!\frac{1}{2}\!\Rightarrow m\!\geqslant\!400
$$  

07.D  

$K$ 个关键字在依次填入的过程中，只有第一个不会发生冲突，所以探测次数为 $1+2+3+\cdots+K=$  $K(K+1)/2$  

08.C  

散列表的平均查找长度与装填因子 $\alpha$ 直接相关，表的查找效率不直接依赖于表中已有表项个数  $n$  或表长  $m$  。若表中存放的记录全是某个地址的同义词，则平均查找长度为  $O(n)$  而非  $O(1)$  
09.D  

聚集是因选取不当的处理冲突的方法，而导致不同关键字的元素对同一散列地址进行争夺的现象。用线性探查法时，容易引发聚集现象。  

10.C “下一个空位”可以大于或小于但不等于原散列地址，等于原散列地址是没有意义的。  

11.D 由散列函数计算可知，14，1，27，79散列后的地址都是1，所以有4个记录。  

12.A,B  

因为在链地址法中，映射到同一地址的关键字都会链到与此地址相对应的链表上，所以探测过程一定是在此链表上进行的，从而这些位置上的关键字均为同义词：但在线性探测法中出现两个同义关键字时，会把该关键字对应地址的下一个地址也占用掉，两个地址分别记为Addr、Addr $^{\cdot+1}$ 查找一个满足 $\mathtt{H}\left(\mathtt{k e y}\right)\mathtt{=}\mathtt{A d d r+1}$ 的关键字key时，显然首次探测到的不是key的同义词。  

13. A, C  

H 的取值有17种可能，对应到不同的链表中，所以链表的个数应为17。由于H(key)的取值范围是 $0{\sim}16$ ，所以数组下标为 $0{\sim}16$  

14.A  

线性探测法的公式为 $\mathrm{H}_{i}{=}\left(\mathrm{H}\left(\mathrm{kep}\right){+}\mathrm{d}_{i}\right)\,\%\mathrm{m}$ ，其中 $d_{i}=1$ 2,.., $m-1$ 。 $\mathrm{~H~}(\,49\,)\!=\!49\,\%\,11\!=\!5$ ，有冲突； $\mathrm{H}_{1}{=}\left(\mathrm{H}\left(49\right){+}\mathbb{1}\right)\circ\mathbb{1}{4}{=}6$ ，有冲突； $\mathrm{H}_{2}{=}\left(\mathrm{H}\left(49\right){+}2\right)\circ14{=}7$ ，有冲突； $\mathrm{H}_{3}\mathrm{=(H}\left(49\right)+3)\stackrel{\circ}{\circ}\!14\mathrm{=}8$ ，无冲突。  

15.C  

插入过程如下： $\mathrm{H}\left(26\right){=}9$ ，不冲突；H $(25){=}8$ ，不冲突； $\mathrm{~H~}(72)\!=\!4$ ，不冲突； $\mathrm{H}\left(38\right){=}4$ ，冲突，冲突处理后的地址为5； $\mathrm{H}\left(8\right){=}8$ ，冲突，冲突处理后的地址为10； $\mathrm{H}\left(18\right){=}1$ ，不冲突； $\mathrm{H}\left(59\right){=}8$ ，冲突，冲突处理后的地址为11。因此，在表中查找59需要探查4次。  

16.B  

插入过程如下： $6\!\stackrel{\circ}{\otimes}\!17\!=\!6$ ； $22\!\leqslant\!17\!=\!5$ ； $7\,\%\,1\,7\!=\!7$ ； $26817{=}9$ ； $9\%17{=}9$ ，冲突，平方探测法探测10（无冲突）； $23\!\leqslant\!17\!=\!6$ ，冲突，平方探测法探测7（冲突），探测5（冲突），探测10（冲突)探测2（无冲突）。因此，关键字23应放在位置2。构造的散列表如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de875321c5ffb1c7d6626f77a8d8d4f773e2a3f046b3bdbf2cd7574208e6f7a5.jpg)  

17.C  

由于散列函数的选取，仍然有可能产生地址冲突，冲突不能绝对地避免。  

18.D  

散列表的查找效率取决于散列函数、处理冲突的方法和装填因子。显然，冲突的产生概率与装填因子（即表中记录数与表长之比）的大小成正比，1与题意相反。ⅡI显然正确。采用合适的冲突处理方法可避免聚集现象，也将提高查找效率，Ⅲ正确。例如，用链地址法处理冲突时不存在聚集现象，用线性探测法处理冲突时易引起聚集现象。  

19.D  

堆积现象因冲突而产生，它对存储效率、散列函数和装填因子均不会有影响，而平均查找长度会因为堆积现象而增大。散列函数是指将关键字映射到哈希地址的函数。存储效率和装填（装载）因子的定义相同，指哈希表中已存储的元素个数与哈希表长度的比值。这些因素都与堆积现象无关，而只与哈希表的结构和设计有关。  
20.C  

根据题意，得到的HT如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1f79e6cf33d4630a5bb54160b88b8adc98a306b814bcf3659065adc540026756.jpg)  

ASL  $\L_{n\&h}=(1+2+3)/3=2\,\circ$  

21.C  

采用线性探查法计算每个关键字的存放情况如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d6c5fc2bc665fb26fdb6a83cbddf241eae8a7f0593b25861a4b0dfd2852eaf1.jpg)  

由于 $\mathtt{H}\,(\,\mathtt{k e y})\!=\!\!0\!\sim\!6$ ，查找失败时可能对应的地址有7个，对于计算出地址为0的关键字key0，只有比较完 $_{0\sim8}$ 号地址后才能确定该关键字不在表中，比较次数为9；对于计算出地址为1的关键字keyl，只有比较完 $\pmb{1}\!\sim\!8$ 号地址后才能确定该关键字不在表中，比较次数为8；以此类推。需要特别注意的是，散列函数不可能计算出地址7，因此有  

$$
\ast\kappa=(9+8+7+6+5+4+3)/7=6
$$  

22.D  

原题再现。填装因子越大，说明哈希表中存储的元素越满，发生冲突的可能性就越高，导致平均查找长度越大。散列函数、冲突解决策略也会影响发生冲突的可能性。I、ⅡI、Ⅲ都正确。  

23.C  

当采用开放定法时，不能随便物理删除表中的已有元素，因为若删除元素，则可能截断其他具有相同散列地址的元素的查找地址。因此，当要删除一个元素时，可给它做一个删除标记。依次将2022，12，25插入散列表，然后删除25，得到的散列表如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0dca011576076efde8af6d061e4c266422582a12cfa1bd5e5ba10ae8394db2c.jpg)  

当查找位置是删除标记时，应继续往后查找。查找失败的平均查找长度为 $(1+3+2+1+2)/5=1.8$  

# 二、综合应用题  

01.【解答】  

在散列表中删除一个记录，在拉链法情况下可以物理地删除。但在开放定址法情况下，不能物理地删除，只能做删除标记。该地址可能是该记录的同义词查找路径上的地址，物理地删除就中断了查找路径，因为查找时碰到空地址就认为是查找失败。  

02.【解答】  

1）不能作为散列函数，因为key/n可能大于 $n$ ，这样就无法找到适合的位置2）能够作为散列函数，但不是一个好的散列函数，因为所有关键字都映射到同一位置，造成大量的冲突机会。3）不能当作散列函数，因为该函数的返回值不确定，这样无法进行正常的查找。  
4）能够作为散列函数，是一个好的散列函数  

# 03.【解答】  

由散列函数可知散列地址的范围为 $0{\sim}10$  

采用线性探测法构造散列表时，首先应计算出关键字对应的散列地址，然后检查散列表中对应的地址是否已经有元素。若没有元素，则直接将该关键字放入散列表对应的地址中：若有元素则采用线性探测的方法查找下一个地址，从而决定该关键字的存放位置。  

采用链地址法构造散列表时，在直接计算出关键字对应的散列地址后，将关键字结点插入此散列地址所在的链表。  

具体解答如下。  

1）线性探测法。  

H  $(\mathbb{1})=\mathbb{1}$  ，无冲突，地址1存放关键字  $1\!\circ\!\mathrm{H}\left(13\right)\!=\!2$  ，无冲突，地址2存放关键字13。H  $(\mathbb{1}2)=\mathbb{1}$  发生冲突，根据线性探测法： $\mathtt{H}_{1}{=}2$ ，发生冲突，继续探测 $\mathtt{H}_{2}{=}3$ ，无冲突，于是12存放在地址为3的表项中。H $(34){=}1$ ，发生冲突，根据线性探测法： $_\mathrm{H_{l}}{=}2$ ，发生冲突， $\mathtt{H}_{2}{=}3$ ，发生冲突， $\mathtt{H}_{3}{=}4$ ，没有冲突，于是34存放在地址为4的表项中。  

同理，可以计算其他的数据存放情况，最后结果如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7345b2f08c4b4921f6bcfe02930d17754488ea02f7d9aefc759d2138744943f9.jpg)  

下面计算平均查找长度：  

查找成功时，显然查找每个元素的概率都是1/8。对于33，由于冲突次数为0，所以仅需1次比较便可查找成功；对于22，由于计算出的地址为0，但需要8次比较才能查找成功，所以22的查找长度为8：其他元素的分析类似。因此有  

$$
_{w h}=(1+1+1+3+4+1+2+8)/8=21/8
$$  

查找失败时，由于 $\mathrm{H\(kg)}\!=\!0\!\sim\!10$ ，因此对每个位置查找的概率都是1/11，对于计算出的地址为0的关键字key0，只有探测完 $_{0\sim8}$ 号地址后才能确定该元素不在表中，比较次数为9；对于计算出的地址为1的关键字key1，只有探测完 $\pm\!\sim\!8$ 号地址后，才能确定该元素不在表中，比较次数为8，以此类推。而对于计算出的地址为8，9，10的关键字，这些单元中没有存放元素，所以只需比较1次便可确定查找失败，因此有  

$$
\mathrm{ASL}_{\mathrm{\scriptsize~\#~}}=(9+8+7+6+5+4+3+2+1+1+1)/11=47/11
$$  

2）链地址法构造的表如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dad8bd3bf4db7a9e81b9a1fd719441116853a9562ac4487e6126b5fa030915ae.jpg)  

在链地址表中查找成功时，查找关键字为33的记录需进行1次比较，查找关键字为22的记录需进行2次比较，以此类推。因此有  
$$
\mathrm{ASL}_{\mathbb{R}^{n h}}=(1\!\times\!4+2\!\times\!3+3)/8=13/8
$$  

查找失败时，对于地址0，比较3次后确定元素不在表中（空指针算1次），所以其查找长度为3：对于地址1，其查找长度为4：对于地址2，查找长度为2；以此类推。因此有  

$$
\mathrm{ASL}_{\mathrm{\scriptsize~\#~}}=(3+4+2+1+1+3+1+1+1+1+1)/11=19/11
$$  

注意，求查找失败的平均查找长度时有两种观点：其一，认为比较到空结点才算失败，所以比较次数等于冲突次数加1；其二，认为只有与关键字的比较才算比较次数。  

# 04.【解答】  

由装填因子的计算公式 $\scriptstyle\alpha\,=\,n/N$  $n$ 为关键字个数， $N$ 为表长），不难得出表长，而根据散列函数的选择要求， $P$ 应该取不大于表长的最大素数，从而可以确定 $P$ 的大小，也就构造出了散列函数。这里采用链地址法解决冲突，两种情况下的平均查找长度的计算过程与上一题完全相似。  

具体解答如下。  

1）由 $\alpha\!=\!n/N$ 得 $N\!=\!n/\alpha$ 由于 $N$ 为整数，所以应该向上取整，即 $N\!=\!\!\lceil n/\alpha\rceil\!=\!15$ ，从而 $P=13$ 6因此散列函数为 $\mathtt{H}\,(\,\mathtt{k e y})\!=\!\mathtt{k e y}\!\circ\!13$ 6  

2）由1）求出的散列函数，计算各关键字对应的散列地址如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28a3192a05cddf0924e0e302178484f784cec7e6ebab5acc08ab3cc0ba284477.jpg)  

由此构造的链地址法处理冲突的散列表为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/49d70cef373cdb1c5c2147ba92f934d33ca15bb6ee57a133157851d01087c260.jpg)  

由上图不难计算出  

$\mathrm{ASL}_{\mathbb{R}^{3\mathbb{h}}}=(1\!\times\!7+2\!\times\!2+3\!\times\!1+4\!\times\!1)/11=18/11$   $\begin{array}{r}{\mathsf{A S L}_{\mathcal{H}}=(1+0+2+1+0+1+1+0+0+0+1+0+4)/13=11/13}\end{array}$  

05.【解答】  

1) $\mathtt{H}_{0}\left(2\right)=2$ ， $\mathrm{H}_{0}\left(8\right){=}8$ ， $\mathrm{H}_{0}\left(31\right){=}5$ ， $\mathrm{H}_{0}\left(20\right){=}7$ ， $\mathrm{H}_{0}\left(19\right){=}6$ ，没有冲突。 $\mathrm{H}_{0}\left(18\right){=}5$ ，发生冲突， $\mathtt{H}_{1}\left(\mathtt{1}\,\mathtt{8}\right)=\left(\mathtt{H}_{0}\left(\mathtt{1}\,\mathtt{8}\right)\,+\mathtt{R E V}\left(\mathtt{1}\,\mathtt{8}\,\mathtt{+}\,\mathtt{1}\right)\,\mathtt{S l1}\,\mathtt{+}\,\mathtt{1}\right)\,\mathtt{S l3}=\left(\mathtt{5}\,\mathtt{+}\,\mathtt{3}\,\mathtt{+}\,\mathtt{1}\right)\,\mathtt{S l3}=9\,\mathtt{s i d}\,\mathtt{s p a}\,\mathtt{F},$ ，没有冲突。 $\mathrm{H}_{0}\left(53\right)\mathrm{=}1$ ，没有冲突。 $\mathrm{H}_{0}\left(27\right){=}1$ ，发生冲突， $\mathtt{H}_{1}\left({27}\right){=}\left(\mathtt{H}_{0}\left({27}\right){+}\mathtt{R E V}\left({27{+}1}\right)\mathbb{S}\mathtt{11}{+}\mathtt{1}\right)\mathbb{S}\mathtt{13}{=}$  $(1\!+\!5\!+\!1)\,\circ\,13\!=\!7$ ，发生冲突，H2（27）=（H（27）+REV（27+1） $^{\circ}^{\perp\perp+1}$  $\stackrel{\circ}{\circ}\!\bot\!3\!=\!0$ ，没有冲突。构造的散列表如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/625fd0636210f4574d07a4898e4082050a4123637d9a782448b943f98a41c5a5.jpg)  
2）由1）中散列表的构造过程，各个关键字查找成功的比较次数如上表所示，所以有  

$$
,\,_{i i v h}=(3+1+1+1+1+1+1+2)/8=11/8
$$  

06.【解答】  

1）由装填因子0.7和数据总数7，得一维数组大小为 $7/0.7=10\$ ，数组下标为 $_{0\sim9}$ 。所构造的散列函数值如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/358953af5aeabecde87bbb12614a23cf1a01ba593d2cd6553420b155c1c0c8e6.jpg)  

采用线性探测再散列法处理冲突，所构造的散列表为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/07cb86b65e45ffcd55fe2ab43973be64df37775eb62e8cb65d75c0b7a42ac71d.jpg)  

2）查找成功时，在等概率情况下，查找每个表中元素的概率是相等的。因此，根据表中元素的个数来计算平均查找长度，各关键字的比较次数如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9e4ac265f11d106ab91877b12711e02dd03ba83e2164a55346b9307ebcfa2871.jpg)  

所以ASL $\psi(x)=$ 查找次数/元素个数 $=(1+2+1+1+1+3+3)/7=12/7.$  

在计算查找失败时的平均查找长度时，要特别注意防止思维定式，在查找失败的情况下既不是根据表中的元素个数，也不是根据表长来计算平均查找长度的。  

查找失败时，在等概率情况下，经过散列函数计算后只可能映射到表中的 $0{\sim}6$ 位置，且映射到 $0{\sim}6$ 中任意一个位置的概率是相等的。因此，是根据散列函数（mod后面的数字）来计算平均查找长度的。在等概率情况下，查找失败的比较次数如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d5915433b5a31ba16d6e994357731f4aef9885391a2bf681d0e7d72e08e914d4.jpg)  

所以ASL $_{\mp i k x y}=$ 查找次数/散列后的地址个数 $=(3+2+1+2+1+5+4)/7=18/7\,\circ$  

# 归纳总结  

本章的核心考查点是求平均查找长度（ASL），以度量各种查找算法的性能。查找算法本身依托于查找结构，查找结构又是由相同数据类型的记录或结点构成的，所以最终落脚于数据结构类型的区别。不管是何种查找算法，其平均查找长度的计算公式都是一样的。  

查找成功的平均查找长度AS $\mathrm{~L~}_{n\in i}=\sum_{i=1}^{n}p_{i}c_{i}$ 查找失败的平均查找长度A $\backslash\mathrm{SL}_{\mathbb{F}^{n\mathbb{W}}}=\sum_{j=0}^{n}q_{j}c_{j}$  

设一个查找集合中已有 $n$ 个数据元素，每个元素的查找概率为 $p_{i}$ ，查找成功的数据比较次数为 $c_{i}\ (i=1,2,\cdots,n)$ ：不在此集合中的数据元素分布在由这 $n$ 个元素的间隔构成的 $n+1$ 个子集合内，每个子集合元素的查找概率为 $q_{j}$ ，查找不成功的数据比较次数为 $c_{j}\ (j=0,\,1,\cdots,\,n)$ 。因此，对某一特定查找算法的查找成功的ASL成动和查找失败的ASL $\exp[-]$ ，是综合考虑还是分开考虑呢？  
若综合考虑，即 $\sum_{i=1}^{n}p_{i}+\sum_{j=0}^{n}q_{j}=1$ ，若所有元素查找概率相等，则有 $p_{i}=q_{j}=\frac{1}{2n+1}$ 若分开考虑，即 $\sum_{i=1}^{n}p_{i}=1\;,\;\;\sum_{j=0}^{n}q_{j}=1$ ，若所有元素查找概率相等，则有 $p_{i}={\frac{1}{n}}\,,\;\;q_{j}={\frac{1}{n+1}}\,.$  

虽然综合考虑更为理想，但在实际应用中多数是分开考虑的，因为对于查找不成功的情况，很多场合下没有明确给出，往往会被忽略掉。不过读者仍要注意的是，这两种考虑的计算结果是不同的，考试中一定要仔细阅读题目的要求，以免失误。  

# 思维拓展  

本章介绍了几种基本的查找算法，在实际中又会碰到怎样的查找问题呢？  

题目：数组中有一个数字出现的次数超过了数组长度的一半，请找出这个数字。读者也许会想到先进行排序，位于位置 $(n+1)/2$ 的数即为要找的数，这样最小时间复杂度就为 $O(n\mathrm{log}_{2}n)$ ；若进行散列查找，数字的范围又未知，则应如何将时间复杂度控制在 $O(n)$ 内呢？  

提示：出现的次数超过数组长度的一半，表明这个数字出现的次数比其他数字出现的次数的总和还多。所以我们可以考虑每次删除两个不同的数，则在剩下的数中，待查找数字出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除其他的数字，最终剩下的都为同一个数字，即为要找的数字。  
# 第8章排序  

# 【考纲内容】  

（一）排序的基本概念  

（二）插入排序直接插入排序：折半插入排序：希尔排序（shellsort）（三）交换排序冒泡排序（bubblesort）：快速排序（四）选择排序简单选择排序：堆排序 （五）二路归并排序（mergesort）（六）基数排序（七）外部排序（八）排序算法的分析和应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/08a16d8a8b640262f36d9686866d92f5ba9d690ee8e2b9b03a94808ae99e6d5b.jpg)  

# 【复习提示】  

堆排序、快速排序和归并排序是本章的重难点。读者应深入掌握各种排序算法的思想、排序过程（能动手模拟）和特征（初态的影响、复杂度、稳定性、适用性等），通常以选择题的形式考查不同算法之间的对比。此外，对于一些常用排序算法的关键代码，要达到熟练编写的程度：看到某特定序列，读者应具有选择最优排序算法（根据排序算法特征）的能力。  
# 8.1排序的基本概念  

# 8.1.1排序的定义  

排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下：  

输入： $n$ 个记录 $R_{1},R_{2},\cdots,R_{n}$ ，对应的关键字为 $k_{1},k_{2},\cdots,k_{n}$  

输出：输入序列的一个重排 $R_{1}^{\prime},R_{2}^{\prime},\cdots,R_{n}^{\prime}$ ，使得 $k_{1}^{\prime}\leqslant k_{2}^{\prime}\leqslant\cdots\leqslant k_{n}^{\prime}$ （其中“≤”可以换成其他的比较大小的符号)。  

算法的稳定性。若待排序表中有两个元素 $R_{i}$ 和 $R_{j}$ ，其对应的关键字相同，即 ${\bf k e y}_{i}={\bf k e y}_{j}$ ，且在排序前 $R_{i}$ 在 $R_{j}$ 的前面，若使用某一排序算法排序后， $R_{i}$ 仍然在 $R_{j}$ 的前面，则称这个排序算法是稳定的，否则称这个排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。若待排序表中的关键字不充许重复，排序结果是唯一的，则对于排序算法的选择，稳定与否无关紧要。  

# 注意  

对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。  

在排序过程中，根据数据元素是否完全存放在内存中，可将排序算法分为两类： $\textcircled{\scriptsize{1}}$ 内部排序，是指在排序期间元素全部存放在内存中的排序： $\circledcirc$ 外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中粮据要求不断地在内、外存之间移动的排序。  

一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，基数排序就不基于比较操作。  

每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。  

# 注意  

大多数的内部排序算法都更适用于顺序存储的线性表。  

# 8.1.2 本节试题精选  

# 一、单项选择题  

01.下述排序算法中，不属于内部排序算法的是（）。  

A.插入排序 B.选择排序 C.拓扑排序 D.冒泡排序  

02.排序算法的稳定性是指（）  

A.经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变B.经过排序后，能使关键字相同的元素保持原顺序中的绝对位置不变C.排序算法的性能与被排序元素个数关系不大  
D.排序算法的性能与被排序元素的个数关系密切 03.下列关于排序的叙述中，正确的是（）。  

A.稳定的排序算法优于不稳定的排序算法B.对同一线性表使用不同的排序算法进行排序，得到的排序结果可能不同C.排序算法都是在顺序表上实现的，在链表上无法实现排序算法D.在顺序表上实现的排序算法在链表上也可以实现  

04.对任意7个关键字进行基于比较的排序，至少要进行（）次关键字之间的两两比较。  

A.13 B.14 C.15 D.6  

# 8.1.3 答案与解析  

# 一、单项选择题  

01.C  

拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于我们这里所提到的内部排序范畴，也不满足前面排序的定义。  

02.A  

注意，这里的绝对位置是指若在排序前元素 $R$ 在位置，则绝对位置就是i，即排序后 $R$ 的位置不发生变化，显然B是不对的。C、D与题自要求无关。  

03.B  

算法的稳定性与算法优劣无关，A排除。使用链表也可以进行排序，只是有些排序算法不再适用，因为这时定位元素只能顺序逐链查找，如折半插入排序。  

04.A  

对于任意序列进行基于比较的排序，求至少的比较次数应考虑最坏情况。对任意 $n$ 个关键字排序的比较次数至少为 $\lceil\log_{2}(n!)\rceil$ .将 $n=7$ 代入公式，答案为13。  

上述公式的证明：在基于比较的排序算法中，每次比较两个关键字后，仅出现两种可能的转移。假设整个排序过程至少要做 $t$ 次比较，显然会有 $2^{t}$ 种情况。由于 $n$ 个记录共有 $_{n}$ 种不同的排列，因此有 $n!$ 种不同的比较路径，于是有 $2^{t}{\geqslant}n!$ ，即 $\scriptstyle t\geq\log_{2}(n!)$ 。考虑到 $t$ 为整数，所以比较次数为 $\lceil\log_{2}(n!)\rceil.$  

# 8.2 插入排序  

插入排序是一种简单直观的排序算法，其基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。  

# 8.2.1直接插入排序  

根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表L[1..n]在某次排序过程中的某一时刻状态如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d25ff3c4c8f034d8e69956e4e46fa3d66458180385b7fec90ac66beacd5b43c8.jpg)  
要将元素L（i）插入已有序的子序列L[1i-1]，需要执行以下操作（为避免混淆，下面用L[表示一个表，而用L（）表示一个元素）：  

1）查找出L（i）在L[1.i-1]中的插入位置k。  

2）将L[k...i-1]中的所有元素依次后移一个位置。  

3）将L（i）复制到L（k）。  

为了实现对L[1.n]的排序，可以将 $\mathtt{L}\left(2\right)\sim\mathtt{L}\left(\mathtt{n}\right)$ 依次插入前面已排好序的子序列，初始工[1]可以视为一个已排好序的子序列。上述操作执行 $n-1$ 次就能得到一个有序的表。插入排序在实现上通常采用原地排序（空间复杂度为 $O(1)$ ），因而在从后往前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。  

下面是直接插入排序的代码，其中再次用到了前面提到的“哨兵”（作用相同）  

void InsertSort（ElemType A[],int n){ inti,j; for( $_{\pm=2}$  $\scriptstyle{\dot{\mathbf{\rho}}}_{\mathrm{E}}<={\mathbf{\rho}}_{\mathrm{E}}$  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ //依次将 $\mathtt{A}\left[2\right]\sim\mathtt{A}\left[\mathfrak{n}\right]$ 插入前面已排序序列if(A[i] $<\mathtt{A}$ [i-1]){/若A[i]关键码小于其前驱，将A[i]插入有序表 $\mathbb{A}\left[\,0\,\right]=\mathbb{A}\left[\,{\mathrm{i}}\,\right]$ //复制为哨兵，A[0]不存放元素for（j=i-1；A[0]<A[j]；--j）/从后往前查找待插入位置A[ $_{1+1]=\mathbb{A}}$ [j];/向后挪位 $\mathbb{A}\left[\,\mathfrak{j}+1\,\right]=\mathbb{A}\left[\,\mathfrak{O}\right.$ /复制到插入位置  

假定初始序列为49，38，65，97，76，13，27，49，初始时49可以视为一个已排好序的子序列，按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f692fcf6091936b992c48b73392b1b8b99439fcc63adb80f34bf4a92dc3a7bc.jpg)  
图8.1直接插入排序示例  

直接插入排序算法的性能分析如下：  

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了 $n\!-\!1$ 趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。  

在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 $O(n)$  

在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大，总的时间复杂度为 $O(n^{2})$  

平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为  
平均情况下的时间复杂度，总的比较次数与总的移动次数均约为 $n^{2}/4$ 因此，直接插入排序算法的时间复杂度为 $O(n^{2})$  

稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序算法。  

适用性：直接插入排序适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。  

# 8.2.2 折半插入排序  

从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作： $\textcircled{\scriptsize{1}}$ 从前面的有序子表中查找出待插入元素应该被插入的位置： $\circledcirc$ 给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下：  

void InsertSort（ElemType A[l,int n){ int i,j,low,high,mid; for(  $_{\dot{\mathbf{1}}=2}$   $\scriptstyle{\dot{\mathbf{1}}}<={\boldsymbol{\mathrm{n}}}$   $\ \ \mathrm{i++}$  //依次将A[2]\~A[n]插入前面的已排序序列  $\mathtt{A}\left[\,0\,\right]\mathrm{=A}$  [i]; //将A[i]暂存到A[0] low  $^{=1}$  ;high  $\scriptstyle{\cfrac{\sinh(i-1)}{\sinh(i-1)}}$  //设置折半查找的范围 while(low< $\mathbf{\beta}=$ high){//折半查找（默认递增有序）mid=（low+high)/2;//取中间点if（A[mid]>A[0]）high=mid-1；//查找左半子表elselow=mid+l;//查找右半子表for( $\scriptstyle{\mathrm{j}}={\mathrm{i}}-1$ ;j>=high+1;--j)A[j $+1]=\mathtt{A}$ [j];//统一后移元素，空出插入位置A[high+1] $\mathtt{\ =}\mathtt{A}$ [0];/插入操作  

# 命题追踪直接插入排序和折半插入排序的比较（2012）  

从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，时间复杂度约为 $O(n\mathrm{log}_{2}n)$ 该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数 $n$ ：而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为 $O(n^{2})$ ，但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序算法。  

折半插入排序仅适用于顺序存储的线性表。  

# 8.2.3 希尔排序  

从前面的分析可知，直接插入排序算法的时间复杂度为 $O(n^{2})$ ，但若待排序列为“正序”时，其时间效率可提高至 $O(n)$ ，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。  

# 命题追踪希尔排序中各子序列采用的排序算法（2015）  

希尔排序的基本思想是：先将待排序表分割成若干形如 $\operatorname{L}[i,i+d,i+2d,\cdots,i+k d]|$ 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。  
# 命题追踪根据希尔排序的中间过程判断所采用的增量（2014、2018）  

希尔排序的过程如下：先取一个小于 $n$ 的增量 $d_{1}$ ，把表中的全部记录分成 $d_{1}$ 组，所有距离为 $d_{1}$ 的倍数的记录放在同一组，在各组内进行直接插入排序；然后取第二个增量 $d_{2}\!<\!d_{1}$ ，重复上述过程直到所取到的 $d_{t}=1$ ，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，因此可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以8.2.1节的关键字为例，假定第一趟取增量 $d_{1}=5$ ，将该序列分成5个子序列，即图中第2行至第6行，分别对各子序列进行直接插入排序，结果如第7行所示：假定第二趟取增量 $d_{2}\!=\!3$ ，分别对三个子序列进行直接插入排序，结果如第11行所示：最后对整个序列进行一趟直接插入排序，整个排序过程如图8.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fed15f10d006d56734ed7a4ea13576087c06e17f9b076afa8e5ea4725e0fb071.jpg)  
图8.2希尔排序示例  

希尔排序算法的代码如下：  

void ShellSort（ElemType A[],int n)( I/A[0】只是暂存单元，不是哨兵，当 $\scriptstyle{\frac{1}{3}}<=0$ 时，插入位置已到int dk,i，j; for( ${\mathsf{d k}}{=}{\mathsf{n}}/2$ ;dk ${>}{=}1$ ;dk=dk/2)/增量变化（无统一规定）for(  $\scriptstyle{\dot{1}}=\mathrm{d}k+1$   $\scriptstyle{\mathrm{i}}<={\mathrm{n}}$   ${++}\,{\mathrm{i}}$  if(A[i]<A[i-dk]){ //需将A[i]插入有序增量子表  $\mathbb{A}\left[0\right]{=}\mathbb{A}\left[\mathrm{i}\right]$ //暂存在A[0]for(  $\scriptstyle{\dot{\mathbf{j}}}={\dot{\mathbf{i}}}\cdot$  -dk;j>0&&A[0]<A[j];j-=dk) A[j+dk] $\mathtt{\ =A}$ [j];//记录后移，查找插入的位置A[j+dk] $\mathbf{\equiv}\mathtt{A}\left[0\right]$ //插入  

希尔排序算法的性能分析如下：  

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间效率：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 $n$ 在某个特定范围时，希尔排序的时间复杂度约为 $O(n^{1.3})$ 在最坏情况下希尔排序的时间复杂度为 $O(n^{2})$  
稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序算法。例如，图8.2中49与49的相对次序已发生了变化。适用性：希尔排序仅适用于顺序存储的线性表。  

# 8.2.4 本节试题精选  

# 一、单项选择题  

01.对5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（）A.8 B.10 C.15 D.25 02.在待排序的元素序列基本有序的前提下，效率最高的排序算法是（）。A.直接插入排序B.简单选择排序C.快速排序D.归并排序  

03.在图书馆中，计算机类书籍区共有12列书架，书架上的书都是按照编号排列好的，其中有些书被读者放错了地方，但通常不超过一个书架。未来将这些书重新放回正确的位置，应该采用何种排序算法？（）。  

A.堆排序B.直接插入排序C.归并排序D.简单选择排序  

04.对有 $n$ 个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是（），在最好情况下所需的比较次数是（）。  

A.n-1 B.  $n+1$  C.n/2 D.  $n(n-1)/2$  05.数据序列 $\{8,10,13,4,6,7,22,2,3\}$ 只能是（）两趟排序后的结果。A.简单选择排序B.冒泡排序 C.直接插入排序 D.堆排序 06.用直接插入排序算法对下列4个表进行（从小到大）排序，比较次数最少的是（）。  

A.94,32,40,90,80,46,21,69 B.21,32,46,40,80,69,90,94 C.32,40,21,46,69,94,90,80 D.90,69,80,46,21,32,94,40  

07.在下列算法中，（）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上。  

A.堆排序B.冒泡排序C.直接插入排序D.快速排序  

08.希尔排序属于（）  

A.插入排序 B.交换排序 C.选择排序 D.归并排序  

09.对序列15，9，7，8，20，-1，41采用希尔排序，经一趟后序列变为 $\{15,-1,4,8,20,9,7\}$ ，则该次采用的增量是（）。  

A.1T B.4 C.3 D.2  

10.若序列15，9,7,8,20，-1,41经一趟排序后变成{9，15，7,8,20，-1,4}，则采用的是（）方法。  

A.选择排序B.快速排序C.直接插入排序D.冒泡排序  

11.对序列98，36，-9,0,47,23，1，8,10,71采用希尔排序，下列序列（）是增量为4的一趟排序结果。  

A.{10,7,-9,0,47,23,1,8,98,36 B.{-9,0,36,98,1,8,23,47,7,10} C.{36,98,-9,0,23,47,1,8,7,10}D.以上都不对  

12.对序列E，A,S，Y，Q，U，E，S,T,I,O,N按照字典顺序排序，采用增量  $d\!=\!6,3,1$  的希尔排 序算法。则前两趟排序后，关键字的总比较次数为（）。  

A.15 B.17 C.16 D.18 13.已知输入序列13,24，7,1,8,9,11,56,34,51,2,77,5}，增量序列  $d\!=\!5,3,1$  ，采用希尔排  
序算法进行排序，则两趟排序后的结果为（）。  

A.17,8,9,13,24,11,34,51,2,5,56,77 B.17,5,2,8,9,24,11,34,51,13,77,56 C.2,11,5,1,8,9,24,7,34,51,13,77,56 D.2,5,11,1,8,9,7,24,34,13,51,77,56  

14.折半插入排序算法的时间复杂度为（）  

A. O(n) B.O(nlog2n) C. 0(n) D. 0(n)  

15.有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，（）算法不会出现此种情况。  

A.希尔排序 B.堆排序 C.冒泡排序 D.快速排序  

16.以下排序算法中，不稳定的是（）  

A.冒泡排序B.直接插入排序C.希尔排序D.归并排序  

17.以下排序算法中，稳定的是（）  

A.快速排序B.堆排序C.直接插入排序D.简单选择排序  

18.【2012统考真题】对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是（）。  

A.排序的总趟数B.元素的移动次数C.使用辅助空间的数量D.元素之间的比较次数  

19.【2014统考真题】用希尔排序算法对一个数据序列进行排序时，若第一趟排序结果为9，1]4，13，7，8，20，23，15，则该趟排序采用的增量（间隔）可能是（）。  

A.2B.3C.D.520.【2015统考真题】希尔排序的组内排序采用的是（）A.直接插入排序B.折半插入排序C.快速排序D.归并排序  

21.【2018统考真题】对初始数据序列（8.3，9,11，2,1，4，7,5，10,6）进行希尔排序。若第一趟排序结果为 $1,3,7,5,2,6,4,9,11,10,8)$ ，第二趟排序结果为 $(1,2,6,4,3,7,5,8,11,10,9)$ ，则两趟排序采用的增量（间隔）依次是（）。  

A.3,1 B.3,2 C.5,2 D.5,3  

# 二、综合应用题  

01.给出关键字序列4，5，1，2，6,31的直接插入排序过程。  

02.给出关键字序列50，26,38,80,70,90,8,30,40,20}的希尔排序过程（取增量序列为 $d\!=$ {5，3，1，排序结果为从小到大排列）。  

# 8.2.5 答案与解析  

# 一、单项选择题  

01.B  

直接插入排序在最坏的情况下要做 $n(n-1)/2$ 次关键字的比较，当 $n=5$ 时，关键字的比较次数为10。注意不考虑与哨兵的比较。  

02.A  

由于序列初始基本有序，因此使用直接插入排序算法的时间复杂度接近 $O(n)$ ，而使用其他算法的时间复杂度均大于 $O(n)$  

03.B  
由于大部分图书都是有序的，因此采用直接插入排序比较合适。  

04.D、A  

待排序表为反序时，直接插入排序需要进行 $n(n-1)/2$ 次比较（从前往后依次需要比较 $1,2,\cdots$  $n\!-\!1$ 次)；待排序表为正序时，只需进行 $n\!-\!1$ 次比较。注意本题不考虑与哨兵的比较。  

05.C  

冒泡排序和选择排序经过两趟排序后，应该有两个最大（或最小）元素放在其最终位置；插入排序经过两趟排序后，前三个元素应该是局部有序的。只可能是插入排序。  

# 注意  

在排序过程中，每趟都能确定一个元素在其最终位置的有冒泡排序、简单选择排序、堆排序、快速排序，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。  

06.B  

越接近正序的序列，直接插入排序的比较次数就越少。B和C是比较接近正序的，然后分别判断两个序列的比较次数，以B为例：第一趟，插入32，比较1次；第二趟，插入46，比较1次；第三趟，插入40，因为40比46小但比32大，所以比较2次；第四趟，插入80，比较1次；第五趟，插入69，比较2次；以此类推，共比较9次。同理求出C的比较次数为11次。所以选B项。  

07. C  

在直接插入排序中，若待排序列中的最后一个元素应插入表中的第一个位置，则前面的有序子序列中的所有元素都不在最终位置上。  

08.A 希尔排序是对直接插入排序算法改进后提出来的，本质上仍属于插入排序的范畴。  

09.B 希尔排序将序列分成若干组，记录只在组内进行交换。由观察可知，经过一趟后9和-1交换，7和4交换，可知增量为4。  

10.C 前两个元素已经局部有序，很明显一趟直接插入排序算法有效。再排除其他算法即可。  

11.A  

增量为4意味着所有相距为4的记录构成一组，然后在组内进行直接插入排序，经观察，只有A项满足要求。  

12.B  

第一趟：EE为一组，比较；AS为一组，比较；ST为一组，比较；YI为一组，比较后交换；QO为一组，比较后交换；UN为一组，比较后交换，结果为EASIONESTYQU。第二趟：EIEY为一组，用直接插入排序需要依次比较I和E、E和I、E和E、Y和I；AOSQ为一组，依次比较O和A、S和O、Q和S、Q和O；SNTU为一组，依次比较N和S、T和S、U和T。第一趟比较次数为6，第二趟比较次数为11，总比较次数为17。  

13.B  

第一趟增量 $d\!=\!5$ ，第一趟排序后，结果为2，11,5，1,8,9,24,7,34,51,13,77,56。第二趟增量 $d\!=\!3$ ，第二趟排序后，结果为1,7,5,2,8,9,24,11,34,51,13,77,56。  

14.C 虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数未发生变化，时间复杂度仍为 $O(n^{2})$  
15.A  

因为希尔排序是基于插入排序算法提出的，所以它不一定在每趟排序过程后将某一元素放置到最终位置上。  

16.C  

希尔排序是一种复杂的插入排序算法，它是一种不稳定的排序算法。  

17.C  

基于插入、交换、选择的三类排序算法中，通常简单方法是稳定的（直接插入、折半插入、冒泡），但有一个例外就是简单选择，复杂方法都是不稳定的（希尔排序、快速排序、堆排序）。  

18.D  

折半插入排序与直接插入排序都将待插入元素插入前面的有序子表，区别是：确定当前记录在前面有序子表中的位置时，直接插入排序采用顺序查找法，而折半插入排序采用折半查找法。排序的总趟数取决于元素个数  $n$  ，两者都是  $n\!-\!1$  趟。元素的移动次数都取决于初始序列，两者相 同。使用辅助空间的数量也都是 $O(1)$ 。折半插入排序的比较次数与序列初态无关，时间复杂度为为 $O(n\log_{2}n)$ ：而直接插入排序的比较次数与序列初态有关，时间复杂度为 $O(n){\sim}O(n^{2})$  

19.B  

首先，第二个元素为1，是整个序列中的最小元素，可知该希尔排序为从小到大排序。然后考虑增量问题，若增量为2，则第1+2个元素4明显比第1个元素9要小，排除A。若增量为3，则第 $i,$  $i+3,i+6\;\;(i=1,2,3\,)$ 个元素都为有序序列，符合希尔排序的特点。若增量为4，则第1个元素9比第 $1+4$ 个元素7要大，排除C。若增量为5，则第1个元素9比第1+5个元素8要大，排除D。  

20.A  

希尔排序的思想是：先将待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。  

21.D  

如下图所示。初始序列：8,3,9,11,2.1,4,7,5,10,6第一趟：1,3,7,5.2,6,4,9,11,10,8第二趟：1,2,6.4.3,7,5,8,11,10, 第一趟分组：8.1.6；3.4：9.7：11.5：2.10：间隔为5，排序后组内递增第二趟分组：1，5，4.10：3.2.9.8；7.6,11：间隔为3，排序后组内递增。因此，选择选项D。  

二、综合应用题  

01.【解答】  

直接插入排序过程如下。  

初始序列： $\begin{array}{l}{4,5,1,2,6,3}\\ {4,5,1,2,6,3}\\ {1,4,5,2,6,3}\\ {1,2,4,5,6,3}\\ {1,2,4,5,6,3}\\ {1,2,3,4,5,6}\end{array}$ 第一趟：（将5插入{4}）第二趟：（将1插入{4.5}）第三趟：（将2插入{1,4,5}）第四趟：（将6插入{1,2,4,5}）第五趟：（将3插入 $\{1,2,4,5,6\}$  
# 02.【解答】  

原始序列： $\begin{array}{c}{50,26,38,80,70,90,8,30,40,20}\\ {50,8,30,40,20,90,26,38,80,70}\\ {26,8,30,40,20,80,50,38,90,70}\\ {8,20,26,30,38,40,50,70,80,90}\end{array}$ 第一趟（增量5）：第二趟（增量3）：第三趟（增量1）：  

# 8.3 交换排序  

所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，一般很少直接考查，通常会重点考查快速排序算法的相关内容。  

# 8.3.1 冒泡排序  

冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般遂渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置·这样最多做 $n-1$ 趟冒泡就能把所有元素排好序。  

图8.3所示为冒泡排序的过程，第一趟冒泡时： $27<\overline{{49}}$ ，不交换； $13<27$ ，不交换； $76>13$ 交换； $97>13$ ，交换； $65>13$ ，交换； $38>13$ ，交换； $49>13$ ，交换。通过第一趟冒泡后，最小元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排序，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ed7cdadbc990048828d90cd70389495b74cc134c304ca5434cc034bef5c682a7.jpg)  
图8.3冒泡排序示例  

冒泡排序算法的代码如下：  

void BubbleSort（ElemType A[],int for(int  $\scriptstyle{\dot{\boldsymbol{\perp}}}=0$  ;i<n-1;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  boolflag  $=$  false; for(int  $\scriptstyle{\mathfrak{j}}=\mathbf{n}-1$  ;j>i;j--) if(A[j-1]>A[j]){  

//表示本趟冒泡是否发生交换的标志

/一趟冒泡过程

//若为逆序  
swap（A[j-1]，A[j]）；//使用封装的swap函数交换flag  $=$  true; if(flag  $==$  false) return;川本趟遍历后没有发生交换，说明表已经有序  

冒泡排序的性能分析如下：  

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换），从而直接跳出循环，比较次数为 $n\!-\!1$ ，移动次数为0，从而最好情况下的时间复杂度为 $O(n)$ ：当初始序列为逆序时，需要进行 $n-1$ 趟排序，第 $i$ 趟排序要进行 $_{n-i}$ 次关键字的比较，而且每次比较后都必须移动元素3次来交换元素位置。这种情况下，  

$=\sum_{i=1}^{n-1}3(n-i)={\frac{3n(n-1)}{2}}$  

从而，最坏情况下的时间复杂度为 $O(n^{2})$ ，平均时间复杂度为 $O(n^{2})$ 稳定性：由于 $i\!>\!j$ 且 $\mathbb{A}\left[\dot{\mathtt{\lambda}}\right]{=}\mathbb{A}$ [j]时，不会发生交换，因此冒泡排序是一种稳定的排序算法。适用性：冒泡排序适用于顺序存储和链式存储的线性表。  

# 注意  

冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于（或大于）无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。  

# 8.3.2 快速排序  

快速排序（以下有时简称快排）的基本思想是基于分治法的：在待排序表L[1..n]中任取一个元素pivot作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1.k-1]和 $\operatorname{L}\left[\mathsf{k}\!+\!1...\mathsf{n}\right]$ ，使得L[1.k-1]中的所有元素小于pivot， $\mathrm{L}\,[\,\mathsf{k}\!+\!1...\mathsf{n}\,]$ 中的所有元素大于或等于pivot，则pivot放在了其最终位置L（k）上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。Y  

一趟快速排序的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针和j，初值分别为low和high，取第一个元素49为枢轴赋值到变量pivot。  

指针j从high往前搜索找到第一个小于枢轴的元素27，将27交换到i所指位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/526c93eb7112f29a9e13e9ad683c9d3dc855c77dc463ca2b2d7e5ec96387ca9d.jpg)  

指针i从1ow往后搜索找到第一个大于枢轴的元素65，将65交换到j所指位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/567c047e31d6ce1a994c684a4dfb4b2d64c9ba4e4c04b1136c9c4c4e3317aa7d.jpg)  
指针继续往前搜索找到小于枢轴的元素13，将13交换到1所指位置。  

27 38 97 76 13 65 49  

指针i继续往后搜索找到大于枢轴的元素97，将97交换到j所指位置。  

27 38 13 97 76 65 4S  

指针j继续往前搜索小于枢轴的元素，直至 $\scriptstyle{\dot{\Sigma}}=={\dot{\bar{\jmath}}}$  

27 38 13 76 97 65 49  

命题追踪快速排序的中间过程的分析（2014、2019、2023）  

此时，指针i（ $==$ ）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放在 $i$ 所指位置即其最终位置，经过第一趟排序后，将原序列分割成了前后两个子序列。  

第一趟后：{273813}4976976549}按照同样的方法对各子序列进行快速排序，若待排序列中只有一个元素，显然已有序。  

第二趟后：{13}27{38}49{4965}76{97}第三趟后：1327384949{65)76{97}第四趟后：13273849496576(97}  

用二叉树的形式描述这个举例的递归调用过程，如图8.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2bdd6336cf0831776e3ad890454e55448ca6aee0524d2ccb668cfe812107e532.jpg)  
图8.4快速排序的递归执行过程  

假设划分算法已知，记为Partition（），返回的是上述的 $\boldsymbol{\kappa}$ ，则L（k）已放在其最终位置。因此可以先对表进行划分，然后对两个子表递归地调用快速排序算法进行排序。代码如下：  
//Partition（）就是划分操作，将表A[low"high]划分为满足上述条件的两个子表 in t pivot pos $=$ Partition（A,low，high）;//划分QuickSort（A，low，pivotpos-l）；//QuickSort(A,pivotpos  $^{+1}$  ,high);  

# 命题追踪  

（算法题）快速排序中划分操作的应用（2016）  

快速排序算法的性能主要取决于划分操作的好坏。考研所考查的快速排序的划分操作通常总以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，使得一趟Partition（)操作后，表中的元素被枢轴一分为二。代码如下：  

in t Partition（ElemTypeA[]，intlow，inthigh）{//一趟划分 ElemType pivot $\mathtt{=}\mathtt{A}$ [1ow］；//将当前表中第一个元素设为枢轴，对表进行划分while（low<high){//循环跳出条件while（low<high&&A[high]>=pivot)--high; A[low]  $\mathtt{\ =}\mathtt{A}$  [high]；//将比枢轴小的元素移动到左端 while(low<high&&A[low]  $<=$  pivot)  $++\bot{\mathrm{or}}w$  A[high] $\mathtt{\ =}\mathtt{A}$ [low]；/将比枢轴大的元素移动到右端A[low] $=$ pivot;//枢轴元素存放到最终位置returnlow;/返回存放枢轴的最终位置  

快速排序算法的性能分析如下：  

# 命题追踪快速排序中递归次数的影响因素分析（2010）  

空间效率：由于快速排序是递归的，因此需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大层数一致。最好情况下为 $O(\log_{2}\!n)$ ；最坏情况下，要进行 $n-1$ 次递归调用，因此栈的深度为 $O(n)$ ；平均情况下，栈的深度为 $O(\log_{2}n)$  

时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含 $n\!-\!1$ 个元素和0个元素时，这种最大限度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为 $O(n^{2})$  

有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。  

在最理想的状态下，即Partition（)能做到最平衡的划分，得到的两个子问题的大小都不可能大于 $n/2$ ，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为 $O(n\mathrm{log}_{2}n)$ 好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。  

稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序算法。例如，表 $L=$ 3，2，2}，经过一趟排序后 $L=\{2,2,3\}$ ，最终排序序列也是 $L=\{2,2,3\}$ ，显然，2与2的相对次序已发生了变化。  

# 命题追踪快速排序适合采用的存储方式（2011）  

适用性：快速排序仅适用于顺序存储的线性表。  
# 注意  

在快速排序算法中，并不产生有序子序列，但每一趟排序后会将上一趟划分的各个无序子表的枢轴（基准）元素放到其最终的位置上。  

# 8.3.3 本节试题精选  

# 一、单项选择题  

01.对 $n$ 个不同的元素利用冒泡法从小到大排序，在（）情况下元素交换的次数最多。  

A.从大到小排列好的B.从小到大排列好的C.元素无序D.元素基本有序  

02.若用冒泡排序算法对序列10，14，26，29，41，52}从大到小排序，则需进行（）次比较。A.3 B.10 C.15 D.25  

03.用某种排序算法对线性表25，84，21，47，15，27，68，35，20进行排序时，元素序列的变化情况如下：  

1)25,84,21,47,15,27,68,35,20 2）20,15,21,25,47,27,68,35,84 3）15,20,21,25,35,27,47,68,84 4）15.20.21,25,27,35,47,68,84 则所采用的排序算法是（）  

A.选择排序 B.插入排序 C.二路归并排序 D.快速排序  

04.一组记录的关键码为（46，79，56，38，40，84），则利用快速排序算法，以第一个记录为基准，从小到大得到的一次划分结果为（）  

A.（38,40,46,56,79,84)B.（40,38,46,79,56,84）C.（40,38,46,56,79,84)D.（40,38,46,84,56,79）  

05.快速排序算法在（）情况下最不利于发挥其长处。  

A.要排序的数据量太大B.要排序的数据中含有多个相同值C.要排序的数据个数为奇数D.要排序的数据已基本有序  

06.就平均性能而言，目前最好的内部排序算法是（！）A.冒泡排序B.直接插入排序C.希尔排序D.快速排序  

$F\!=\{2,1,4,9,8,10,6,20\}$ 只能是下列排序算法中的（）两趟排序后的结果。A.快速排序 B.冒泡排序 C.选择排序 D.插入排序  

08.对数据序列 $\{8,9,10,4,5,6,20,1,2\}$ 采用冒泡排序（从后往前次序进行，要求升序），需要进行的趟数至少是（）。  

A.3 B.4 C.5 D.8  

09.双向冒泡排序是指对一个序列在正反两个方向交替进行扫描，第一趟把最大值放在序列的最右端，第二趟把最小值放在序列的最左端，之后在缩小的范围内进行同样的扫描，放在次右端、次左端，直至序列有序。对数组4，7，8，3，5，6，10，9，1，21进行双向冒泡排序，则排序趟数是（）。（第一趟从左往右开始，从左往右或从右往左都称为一趟。）  

A.7 B.6 C.8 D.9  

10.对下列关键字序列用快速排序进行排序时，每次选取的基准元素都为待处理序列的第一个元素，速度最快的情形是（），速度最慢的情形是（）。  
A.{21,25,5,17,9,23,30} B.{25,23,30,17,21,5,9} C.{21,9,17,30,25,23,5} D.{5,9,17,21,23,25,30}  

11.对下列4个序列，以第一个关键字为基准用快速排序算法进行排序，在第一趟过程中移动记录次数最多的是（）。  

A.92,96,88,42,30,35,110,100 B.92,96,100,110,42,35,30,88 C.100,96,92,35,30,110,88,42 D.42,30,35,92,100,96,88,110  

12.下列序列中，（）可能是执行第一趟快速排序后所得到的序列（按从大到小排序和从小到大排序来分别讨论）。  

1.{68,11,18,69,23,93,73} II.{68,11,69,23,18,93,73} IⅢI.{93,73,68,11,69,23,18} IV.{68,11,69,23,18,73,93} A.I、IVB.II、IⅢIC.IⅢI、IVD.只有IV  

13.对 $n$ 个关键字进行快速排序，最大递归深度为（），最小递归深度为（）A. 1 B.n C. log2n D. nlog2n

 14.对8个元素的序列进行快速排序，在最好情况下的关键字比较次数是（）。A. 7 B.8 C. 12 D.13  

15.【2010统考真题】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是（）。  

A.递归次数与初始数据的排列次序无关B.每次划分后，先处理较长的分区可以减少递归次数C.每次划分后，先处理较短的分区可以减少递归次数D.递归次数与每次划分后得到的分区的处理顺序无关  

16.【2011统考真题】为实现快速排序算法，待排序序列宜采用的存储方式是（）。A.顺序存储 B．散列存储 C.链式存储 D.索引存储

 17.【2014统考真题】下列选项中，不可能是快速排序第二趟排序结果的是（）  

A.2,3,5,4,6,7,9 B.2,7,5,6,4,3,9 C.3,2,5,4,7,6,9 D.4,2,3,5,7,6,9  

18.【2019统考真题】排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列序列中，不可能是快速排序第二趟结果的是（）。  

A.5,2,16,12,28,60,32,72 B.2,16,5,28,12,60,32,72 C.2,12,16,5,28,32,72,60 D.5,2,12,28,16,32,72,60  

19.【2023统考真题】使用快速排序算法对数据进行升序排序，若经过一次划分后得到的数据序列是68,11,70,23,80,77,48,81,93,88，则该次划分的枢轴是（）。  

A. 11 B.70 C. 80 D. 81  

# 二、综合应用题  

01.已知线性表按顺序存储，且每个元素都是不相同的整数型元素，设计把所有奇数移动到所有偶数前边的算法（要求时间最短，辅助空间最小）。  

02.试编写一个算法，使之能够在数组L[l..n]中找出第 $k$ 小的元素（即从小到大排序后处于第 $k$ 个位置的元素）  

03.荷兰国旗问题：设有一个仅由红、白、蓝三种颜色的条块组成的条块序列，存储在一个顺序表中，请编写一个时间复杂度为 $O(n)$ 的算法，使得这些条块按红、白、蓝的顺序排好，即排成荷兰国旗图案。请完成算法实现：typedef enum(RED,WHITE,BLUE} color; /设置枚举数组 void Flag Arrange（color a[],int n) $\{\mathrm{~\,~\,~}\}$  
04.【2016统考真题】已知由  $n$  C  $n\!\geqslant\!2$  ）个正整数构成的集合  $A\!=\!\{a_{k}|0\!\leqslant\!k<\!n\}$  ，将其划分为 两个不相交的子集 $A_{1}$ 和 $A_{2}$ ，元素个数分别是 $n_{1}$ 和 $n_{2}$ ， $A_{1}$ 和 $A_{2}$ 中的元素之和分别为 $S_{1}$ 和 $S_{2}.$ ，设计一个尽可能高效的划分算法，满足 $|n_{1}\!-\!n_{2}|$ 最小且 $|S_{1}\!-\!S_{2}|$ 最大。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明所设计算法的平均时间复杂度和空间复杂度。  

# 8.3.4 答案与解析  

# 一、单项选择题  

01.A  

冒泡排序最少进行1趟冒泡，最多进行 $n\!-\!1$ 趟冒泡。初始序列为逆序时，需进行 $n\!-\!1$ 趟冒孢，并且元素交换的次数最多。初始序列为止序时，进行1趟冒泡（无交换）就可结束算法。  

02.C  

冒泡排序始终在调整“逆序”，因此交换次数为排列中逆序的个数。对逆序序列进行冒泡排序，每个元素向后调整时都需要进行比较，因此共需要比较 $5+4+3+2+1=15$ 次。  

03.D  

选择排序在每趟结束后可以确定一个元素的最终位置，不对。插入排序，第 $i$ 趟后前 $i+1$ 个元素应该是有序的，不对。第二趟{20,15}和{21，25}是反序的，因此不是归并排序。快速排序每趟都将基准元素放在其最终位置，然后以它为基准将序列划分为两个子序列。观察题中的排序过程，可知是快速排序。  

04.C  

以46为基准元素，首先从后往前扫描比46小的元素，并与之进行交换，而后从前往后扫描比46大的元素并将46与该元素交换，得到(40,46,56,38，79,84)。此后，继续重复从后往前扫描与从前往后扫描的操作，直到46处于最终位置。  

05.D  

当待排序数据为基本有序时，每次选取第 $n$ 个元素为基准，会导致划分区间分配不均匀，不利于发挥快速排序算法的优势。相反，当待排序数据分布较为随机时，基准元素能将序列划分为两个长度大致相等的序列，这时才能发择快速排序的优势。  

06.D  

这里问的是平均性能，选项A、B的平均性能都会达到 $O(n^{2})$ ，而希尔排序虽然大大降低了直接插入排序的时间复杂度，但其平均性能不如快速排序。另外，虽然众多排序算法的平均时间复杂度也是 $O(n\log_{2}n)$ ，但快速排序算法的常数因子是最小的。  

07. A  

若为插入排序，则前三个元素应该是有序的，显然不对。而冒泡排序和选择排序经过两趟排序后应该有两个元素处于最终位置（最左/右端），无论是按从小到大还是从大到小排序，数据序列中都没有两个满足这样的条件的元素，因此只可能选A项。  

【另解】先写出排好序的序列，并和题中的序列做对比。题中序列：2149810620已排好序序列：1246891020  
在已排好序的序列中，与题中序列相同的元素有4、8和20，最左和最右两个元素与题中的序列不同，所以不可能是冒泡排序、选择排序或插入排序。  

08.C  

从后往前冒泡的过程为，第一趟{1,8,9,10,4,5,6,20,2}，第二趟/1,2,8,9,10,4,5，6,20}，第三趟 $\{1,2,4,8,9,10,5,6,20\},$ 第四趟1,2,4,5,8,9,10,6,20}，第五趟{1,2,4,5,6,8,9,10,20}，经过第五趟冒泡后，序列已经全局有序，所以选择选项C。实际每趟冒泡发生交换后可以判断是否会产生新的逆序对，若不会产生，则本趟冒泡之后序列全局有序，所以最少5趟即可。  

# 09.B  

第一趟从左往右的排序结果为 $4,7,3,5,6,8,9,1,2,10;$ ：第二趟从右往左的排序结果为1，4,7，3,5，6,8,9,2,10；第三趟从左往右的排序结果为1,4,3，5，6,7,8,2，9,10；第四趟从右往左的排序结果为1,2,4，3,5，6，7,8,9,10；第五趟从左往右的排序结果为 $1,2,3,4,5,6,7,8,9,10$ ，此时序列已有序，但仍需进行一趟无交换的排序才能确定序列已有序，因此共需6趟排序。  

10.A、D  

当每趟的枢轴值都把表等分为长度相近的两个子表时，速度是最快的；当表本身已经有序或逆序时，速度最慢。选项D中的序列已按关键字排好序，因此它是最慢的，而选项A中第一趟枢轴值21将表划分为两个子表{9，17，5}和{25，23，30}，而后对两个子表划分时，枢轴值再次将它们等分，所以该序列是快速排序最优的情况，速度最快。针对其他选项，可以进行类似的分析。  

11.B  

对各序列分别执行一趟快速排序，可做如下分析（以选项A为例）：由于枢轴值为92，因此35移动到第一个位置，96移动到第六个位置，30移动到第二个位置，再将枢轴值移动到30所在的单元，即第五个位置，所以A项中序列移动的次数为4。同样，可以分析出B项中序列的移动次数为8，C项中序列的移动次数为4，D项中序列的移动次数为2。  

12.C  

显然，若按从小到大排序，则最终有序的序列是{11,18,23,68,69,73,93}；若按从大到小排 序，则最终有序的序列是93，73.69.68.23.18.11。对比可知选项1、ⅡI中没有处于最终位置的元素，所以I、Ⅱ项都不可能。Ⅲ项中73和93处于从大到小排序后的最终位置，而且73将序列分割成大于73和小于73的两部分，所以IⅢI项是有可能的。IV项中73和93处于从小到大排列后的最终位置，73也将序列分割成大于73和小于73的两部分。  

13.B、C  

快速排序过程构成一个递归树，递归深度即递归树的高度。枢轴值每次都将子表等分时，递归树的高为 $\log_{2}\!n$ ；枢轴值每次都是子表的最大值或最小值时，递归树退化为单链表，树高为 $n$  

14. D  

快速排序的最好情况是每次划分将待排序列划分为等长的两部分。因此，第一趟将第1个元素与后面的7个元素进行比较，将原序列划分为长度为3和4的两个子表，比较7次：第二趟对两个子表进行划分，将长度为3的子表划分为长度为1的两个子表（不用继续划分），比较2次，将长度为4的子表划分为长度为1和2的两个子表，比较3次；第三趟将长度为2的子表划分为长度为1的子表，比较1次。至此，排序结束，共进行的比较次数是 $7+2+3+1=13$  

15.D  

快速排序的递归次数与元素的初始排列有关。若每次划分后分区比较平衡，则递归次数少：若划分后分区不平衡，则递归次数多。递归次数与分区处理顺序无关。  

16.A  
对于绝大部分内部排序而言，只适用于顺序存储结构。快速排序在排序的过程中，既要从后往前查找，也要从前往后查找，因此宜采用顺序存储。  

17. C  

对 $n$ 个元素进行第一趟快速排序后，会确定一个基准元素，根据这个基准元素在数组中的位置，有两种情况： $\textcircled{\scriptsize{1}}$ 基准元素在数组的首端或尾端，接下来对剩下的 $n^{-1}$ 个元素构成的子序列进行第二趟快速排序，再确定一个基准元素。这样，在两趟排序后就至少能确定两个元素的最终位置，其中至少有一个元素是在数组的首端或尾端。 $\circledcirc$ 基准元素不在数组的首端或尾端，第二趟快快速排序对基准元素划分开的两个子序列分别进行一次划分，两个子序列各确定一个基准元素。这样，两趟排序后就至少能确定三个元素的最终位置。基于上述结论，观察题中的四个选项，A项的2,3，6,7，9符合第一种或第二种情况；B项中2，9符合第一种情况；D项中5，9符合第一种情况；最后看C项，只有9处于最终位置，因此不可能是快速排序第二趟的结果。  

18.D  

基于上题中分析得出的结论，观察题中的四个选项，A项的28，72符合第一种情况；B项的2，72符合第一种情况；C项的2，28，32符合第一种或第二种情况：最后看D项，只有12和32处于最终位置，既不符合第一种情况，又不符合第二种情况。  

19.D  

第一趟划分后得到的序列中只有一个枢轴，因此可将当前序列和最终排好序的序列进行比较，如下表所示。枢轴会出现在两个序列的相同位置，可以看出枢轴只可能是77、81，选项只有81。在当前序列中，77左边有比它大的元素80，因此77不是枢轴；而81左边都是比它小的元素，右边都是比它大的元素，因此81是枢轴。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/14ea3a3aee3d03b516d8d5f1e07e7e546d7165bc0b12e5b009d41cbf65597c2a.jpg)  

# 二、综合应用题  

01.【解答】  

本题可采用基于快速排序的划分思想来设计算法，只需遍历一次即可，其时间复杂度为 $O(n)$ 空间复杂度为 $O(1)$ 。假设表为L[l.n]，基本思想是：先从前往后找到一个偶数元素L（i），再从后往前找到一个奇数元素L(j)，将二者交换；重复上述过程直到i大于j。  

算法的实现如下：  

void move(ElemType A[l,intlen){ //对表A按奇偶进行一趟划分int  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\dot{\mathbf{\rho}}}=\mathbf{L}\mathbf{e n}-1$  //i表示左端偶数元素的下标；j表示右端奇数元素的下标 while(i<j){ while（i<j&&A[i]2！=0) $\ \ \mathrm{i}_{++}$ ；//从前往后找到一个偶数元素while（i<j&&A[j]2！=1）j--；//从后往前找到一个奇数元素if (i<j){ Swap(A[i],A[j]);//交换这两个元素 $\ \ \mathrm{i++}$ ;j--;  

02.【解答】  

显然，本题最直接的做法是用排序算法对数组先进行从小到大的排序，然后直接提取L(k)便得到了第 $k$ 小的元素，但其平均时间复杂度将达到 $O(n\mathrm{log}_{2}n)$ 以上。此外，还可采用小顶堆的方法，每次堆顶元素都是最小值元素，时间复杂度为 $O(n+k\log_{2}n)$ 。下面介绍一个更精彩的算法，它基于快速排序的划分操作。  
这个算法的主要思想如下：从数组L[1..n]中选择枢轴pivot（随机或直接取第一个）进行和快速排序一样的划分操作后，表L[1.n]被划分为L[1..m-1]和 $\mathbb{L}\left[\mathbb{m}\!+\!\mathbb{1}\mathrm{...n}\right]$ ，其中L $\mathrm{(m)=}$ pivot。  

讨论 $m$ 与 $k$ 的大小关系：  

1）当 $m\!=\!k$ 时，显然pivot就是所要寻找的元素，直接返回pivot即可。2）当 $m<k$ 时，所要寻找的元素一定落在 $\mathbb{L}\left[\mathbb{m}\!+\!1...\mathbb{n}\right]$ 中，因此可对 $\mathbb{L}\left[\mathbb{m}\!+\!1...\mathbb{n}\right]$ 递归地查找第 $k\!-\!m$ 小的元素。3）当 $m>k$ 时，所要寻找的元素一定落在L[1.m-1]中，因此可对 $\mathbb{L}\left[1...\mathbb{m}^{-1}\right]$ 递归地查找第 $k$ 小的元素。  

该算法的时间复杂度在平均情况下可以达到 $O(n)$ ，而所占空间的复杂度则取决于划分的方法。算法的实现如下：  

int kth elem（int a[],int low,int high,int k)( int pivot=a[low]; int low temp $=$ low;//由于下面会修改1ow与high，在递归时又要用到它们int high temp  $\scriptstyle\varepsilon=$  high; while（low<high){ while（low<high&&a[high]  $>=$  pivot) --high; a[low]  $=\mathtt{a}$  [high]; while（low<high&&a[low]  $<=$  pivot)  $++1o w$  a[high]  $=\mathtt{a}$  [low]; a[low]=pivot; //上面为快速排序中的划分算法//以下是本算法思想中所述的内容if（low $\scriptstyle{\left(==k\right.}$ /由于与 $\kappa$ 相同，直接返回pivot元素returna[low]; else if(low>k)在前一部分表中递归寻找return kth_elem(a,low_temp,low-1,k); else/在后一部分表中递归寻找returnkth elem（a,low+1,high temp,k）;  

03.【解答】  

算法思想：顺序扫描线性表，将红色条块交换到线性表的最前面，蓝色条块交换到线性表的最后面。为此，设立三个指针，其中， $j$ 为工作指针，表示当前扫描的元素，i以前的元素全部为红色， $k$ 以后的元素全部为蓝色。根据 $j$ 所指示元素的颜色，决定将其交换到序列的前部或尾部。初始时 $i=0$ ， $k\!=\!n-1$ ，算法的实现如下：  

type de fe num{RED，WHITE，BLUE}color；//设置枚举数组void Flag Arrange（colora[],int n）int  $\scriptstyle{\dot{\mathtt{i}}}=0\,,\;{\dot{\mathtt{j}}}=0\,,\;{\dot{\mathtt{k}}}={\mathtt{n}}-1$  while  $|j<=k$  switch（a[jl）（//判断条块的颜色caseRED:Swap（a[i],a[j]);  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  ;j++;break; 川红色，则和i交换CaseWHITE:  $\,\mathsf{j}^{++}$  ;break;  
case BLUE:Swap（a[j],a[k]);k--;//蓝色，则和  $\kappa$  交换 /这里没有 $\j++$ 语句，以防止交换后a[j]仍为蓝色  

例如，将元素值正数、负数和零排序为前面都是负数，接着是0，最后是正数，也用同样的方法。思考：为什么caseRED语句不用考虑交换后a[j]仍为红色，而caseBLUE语句中却需要考虑交换后a[j]仍为蓝色？  

# 04.【解答】  

1）算法的基本设计思想  

由题意可知，将最小的 $_{n/2,}$ 个元素放在 $A_{1}$ 中，其余的元素放在 $A_{2}$ 中，分组结果即可满足题自要求。仿照快速排序的思想，基于枢轴将 $n$ 个整数划分为两个子集。根据划分后枢轴所处的位置i分别处理：  

$\textcircled{\scriptsize{1}}$ 若 $i\!=\!\lfloor n/2\rfloor$ ，则分组完成，算法结束。  

$\circledcirc$ 若 $i<\lfloor n/2\rfloor$ ，则枢轴及之前的所有元素均属于 $A_{1}$ ，继续对 $i$ 之后的元素进行划分。  

$\textcircled{3}$ 若 $i\!>\!\lfloor n/2\rfloor$ ，则枢轴及之后的所有元素均属于 $A_{2}$ ，继续对 $i$ 之前的元素进行划分。  

基于该设计思想实现的算法，无须对全部元素进行全排序，其平均时间复杂度是 $O(n)$ ，空间复杂度是  $O(1)$  

2）算法实现  

int set Partition（int a[],int n){ int pivotkey，low  $\scriptstyle{\prime=0}$  ,low  $){=}0$  ,high=n-1,high0=n-l,flag  $\scriptstyle{=1}$  ，  $\scriptstyle\kappa=n/2$  ,i; int  $_{s1=0}$   $_{{\tt S Z}=0}$  while（flag){ pivotkey  $\mathrm{=a}$  [low]; /选择枢轴 while（low<high)//基于枢轴对数据进行划分while（low<high&& a[high]  $>=$  pivotkey)--high; if(low!  $=$  high)a[low]  $=\mathtt{a}$  [high]; while（low<high&& a[low]  $<=$  pivotkey)++low; if(low!  $=$  high)a[high]  $=\mathrm{a}$  [low]; llend of while（low<high) a[low]  $=$  pivotkey; if(low  $\scriptstyle{\prime=k-1}$  /若枢轴是第  $\mathrm{n}/2$  小的元素，划分成功 flag  $=\!0$  elsef1/是否继续划分if（low<k-1){ lowo  $\scriptstyle\left(=++\right.$  low; high  $\scriptstyle=$  higho; elsef higho  $=$  --high; low=low0; for $|\dot{\mathbf{\nabla}}\dot{\mathbf{\mathrm{i}}}\!=\!0$ ;i<k;i++）sl+=a[i];for  $(\mathrm{i}\!=\!\!\mathrm{k}$   $\scriptstyle{\mathrm{~i~}}<{\mathrm{n}}$   $\ \ \mathrm{i}_{\leftarrow}$  ）s2+=a[i]; return s2-sl;  
3）本算法的平均时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$  

# 8.4 选择排序  

选择排序的基本思想是：每一趟（如第 $i$ 趟）在后面 $n-i+1\ (i=1,2,\cdots,n-1)$ 个待排序元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到第 $n\!-\!1$ 趟做完，待排序元素只剩下1个，就不用再选。选择排序中的堆排序是历年统考考查的重点。  

# 8.4.1 简单选择排序  

根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为L[1.n]，第 $i$ 趟排序即从L[i.n]中选择关键字最小的元素与L（i）交换，每一趟排序可以确定一个元素的最终位置，这样经过 $n\!-\!1$ 趟排序就可使得整个排序表有序。  

简单选择排序算法的代码如下：  

void SelectSort（ElemType A[l,int n){ for(int  $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$   $\scriptstyle{\mathrm{i}}<{\mathrm{n}}-1$   $\ \ \mathrm{i}_{\mathrm{^{++}}}$  //一共进行n-1趟 int min $\mathbf{\tau}=\dot{\mathbf{\tau}}\mathbf{\Gamma}$ //记录最小元素位置for（int $\scriptstyle{\mathrm{j}}={\mathrm{i}}+1$ ;j<n; $\j++$ //在A[in-1]中选择最小的元素if(A[j] $\tt<\tt A$ [min]） min=j;/更新最小元素位置if(min ${\mathfrak{z}}={\mathfrak{z}}$ ）swap（A[i]，A[min]）；//封装的swap（）函数共移动元素3次  

简单选择排序算法的性能分析如下：  

空间效率：仅使用常数个辅助单元，所以空间效率为 $O(1)$  

时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过 $3(n-1)$ 次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是 $n(n-1)/2$ 次，因此时间复杂度始终是 $O(n^{2})$  

稳定性：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与含有相同关键字的元素的相对位置发生改变。例如，表 $L=\{2,2,1\}$ ，经过一趟排序后 $L=\{1,2,2\}$ ，最终排序序列也是 $L=\{1,2,2\}$ ，显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳定的排序算法。女  

适用性：简单选择排序适用于顺序存储和链式存储的线性表，以及关键字较少的情况。  

# 8.4.2 堆排序  

堆的定义如下， $n$ 个关键字序列L[1..n]称为堆，当且仅当该序列满足：  

$\textcircled{1}\,\texttt{L}(\dot{\texttt{i}})>=\texttt{L}$ （2i）且 $\tt L\left(\mathrm{i}\right)\mathrm{>=}\tt L$ （2i+1）或 $\circledcirc\mathrm{~\bf~L~}(\dot{\mathrm{~\bf~i~}})<=\tt{L}$ （2i）且 $\mathrm{~\tt~L~}(\mathrm{i})<=\tt L\;(2\,\mathrm{i}+1)$ （1≤i≤Ln/2]）  

命题追踪堆的性质与特点（2020）  

可以将堆视为一颗完全二叉树，满足条件 $\circledcirc$ 的堆称为大根堆（大顶堆），大根堆的最大元素存放在根结点，且其任意一个非根结点的值小于或等于其双亲结点值。满足条件 $\mathcal{Q}$ 的堆称为小根堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2247078dce401249cf3e73341e50d39d624875f9123a83d24eb59f6fed868004.jpg)  
图8.5一个大根堆示意图  

堆排序的思路很简单：首先将存放在L[1.n]中的 $n$ 个元素建成初始堆，因为堆本身的特点（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再 输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见，堆排序需要解决两个问题： $\textcircled{\scriptsize{1}}$ 如可将无序序列构造成初始堆？ $\circledcirc$ 输出堆顶元素后，如何将剩余元素调整成新的堆？  

# 命题追踪初始建堆的操作（2018、2021）  

堆排序的关键是构造初始堆。 $n$ 个结点的完全二叉树，最后一个结点是第 $\lfloor n/2\rfloor$ 个结点的孩子。对以第 $\lfloor n/2\rfloor$ 个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点 $(\lfloor n/2\rfloor-1{\sim}1)$ 为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。  

如图8.6所示，初始时调整  $L(4)$  子树，  $09<32$  ，交换，交换后满足堆的定义；向前继续调整 L(3）子树， $78<$ 左右孩子的较大者87，交换，交换后满足堆的定义；向前调整 $L(2)$ 子树， $17<$ 左右孩子的较大者45，交换后满足堆的定义：向前调整至根结点 $L(1)$ ， $53<$ 左右孩子的较大者87，交换，交换后破坏了 $L(3)$ 子树的堆，采用上述方法对 $L(3)$ 进行调整， $53<$ 左右孩子的较大者78，交换，至此该完全二叉树满足堆的定义。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a02575fe03c9077c1e1b12da0a42128eed1a6389ff67ccc69548cc3ecd8c9411.jpg)  
图8.6自下往上逐步调整为大根堆  
# 命题追踪输出堆顶元素后调整堆的比较次数的分析（2015）  

输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。将09和左右孩子的较大者78交换，交换后破坏了 $L(3)$ 子树的堆，继续对 $L(3)$ 子树向下筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.7所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/705800718fde337b1004d353eb67a4467c05345b00380d86c440143a0192d934.jpg)  
图8.7输出堆顶元素后再将剩余元素调整成新堆  

下面是建立大根堆的算法：  

void Build Max Heap（ElemType A[],intlen) for（inti=len/2;i>0;i--) 川/从  $\mathrm{i}\!=\![\mathrm{n}/2]\!\sim\!1$  ，反复调整堆 HeadAdjust（A,i,len);  

void HeadAdjust（ElemType A[],int k,int len）(//Head Adjust  $\kappa$  为根的子树进行调整  

$\mathtt{A}\left[\,0\,\right]\mathtt{=A}\left[\,k\,\right]$  I/A[0】暂存子树的根结点 for（int $\scriptstyle{\dot{1}}=Z^{\star}k$  $\scriptstyle{\mathrm{i}}<={\mathrm{1em}}$  $\scriptstyle{\mathrm{~i~}}\star=2$ ）/沿key较大的子结点向下筛选if（i<len&&A[i]<A[i+l])  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ //取key较大的子结点的下标if  $\scriptstyle(\mathtt{A}\,[\,0\,]\,>=\mathtt{A}\,[\,\mathtt{i}\,]$  )break; 筛选结束 elsel A[k]  $\mathtt{\ =A}$  [i]; //将A[i]调整到双亲结点上  $\kappa{=}1$ //修改 $\kappa$ 值，以便继续向下筛选A[k]=A[0];//被筛选结点的值放入最终位置  

调整的时间与树高有关，为 $O(h)$ 。在建含 $n$ 个元素的堆时，关键字的比较总次数不超过 $4n$ 时间复杂度为 $O(n)$ ，这说明可以在线性时间内将一个无序数组建成一个堆。  

下面是堆排序算法：  

void HeapSort（ElemType A[],int len){ Build Max Heap(A,len); /初始建堆 for（int i=len; $^{\mathrm{i}>1}$ ;i--）{ ${\mathrm{{//n-1}}}$ 趟的交换和建堆过程Swap(A[i],A[1]);//输出堆顶元素（和堆底元素交换）HeadAdjust（A,l,i-1); /调整，把剩余的i-1个元素整理成堆  

# 命题追踪堆的插入操作及比较次数的分析（2009、2011）  

同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。大根堆的插入操作示例如图8.8所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/98ce82e66a4eab0bac8b05ca1e714ecc3d9283c4602d47d25fd506bba0c39752.jpg)  
图8.8大根堆的插入操作示例  

# 命题追踪堆在海量数据中选出最小 $\pmb{k}$ 个数的应用及效率分析（2022）  

堆排序适合关键字较多的情况。例如，在1亿个数中选出前100个最大值。首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。  

堆排序算法的性能分析如下：  

空间效率：仅使用了常数个辅助单元，所以空间复杂度为 $O(1)$  

时间效率：建堆时间为 $O(n)$ ，之后有 $n\!-\!1$ 次向下调整操作，每次调整的时间复杂度为 $O(h)$ 所以在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n\log_{2}n)$  

稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序算法。例如，表 $L=\{1,2,2\}$ ，构造初始堆时可能将2交换到堆顶，此时 $L=\{2,1,2\}$ 最终排序序列为 $L=\{1,2,2\}$ ，显然，2与2的相对次序已发生变化。  

适用性：堆排序仅适用于顺序存储的线性表。  

# 8.4.3 本节试题精选  

# 一、单项选择题  

01.在以下排序算法中，每次从未排序的记录中选取最小关键字的记录，加入已排序记录的末尾，该排序算法是（）。  

A.简单选择排序B.冒泡排序 C.堆排序 D.直接插入排序  

02.简单选择排序算法的比较次数和移动次数分别为（）  

A. O(n),  $O(\log_{2}n)$  B.  $O(\log_{2}\!n)$   $O(n^{2})$  C. $O(n^{2})$ ，0(n)D. $O(n\mathrm{log}_{2}n)$ ， $O(n)$  

03.若只想得到100000个元素组成的序列中第10个最小元素之前的部分排序的序列，用（）方法最快。  

A.冒泡排序 B.快速排序 C.归并排序 D.堆排序  

04.下列（）是一个堆。  

A.19,75,34,26,97,56 B.97,26,34,75,19,56 C.19,56,26,97,34,75 D.19,34,26,97,56,75  

05.在含有 $n$ 个关键字的小根堆中，关键字最大的记录有可能存储在（）位置。A.n/2 B.  $n/2+2$  XC.1 D.n/2-1 06.向具有 $n$ 个结点的堆中插入一个新元素的时间复杂度为（），删除一个元素的时间复杂  
度为（）。  

A.0(1) B.O(n) C.  $O(\log_{2}\!n)$  D.O(nlog2n)  

07.构建 $n$ 个记录的初始堆，其时间复杂度为（）；对 $n$ 个记录进行堆排序，最坏情况下其时间复杂度为（）。  

A.O(n) B.O(n²) C.  $O(\log_{2}\!n)$  D.O(nlog2n)  

08.下列4种排序算法中，排序过程中的比较次数与序列初始状态无关的是（）  

A.简单选择排序B.直接插入排序C.快速排序D.冒泡排序  

09.对由相同的 $n$ 个整数构成的二叉排序树和小根堆，下列说法中不正确的是（）。  

A.二叉排序树的高度大于或等于小根堆的高度B.对二叉排序树进行中序遍历可以得到从小到大的序列C.从小根堆的根结点到任意叶结点的路径构成从小到大的序列D.对小根堆进行层序遍历可以得到从小到大的序列  

10.有一组数据（15，9,7，8,20，-1，7，4），用堆排序的筛选方法建立的初始小根堆为（））  

A.-1,4,8,9,20,7,15,7 B.-1,7,15,7,4,8,20,9 C.-1,4,7,8,20,15,7,9 D.A、B、C均不对  

11.对关键字序列{23，17,72，60,25，8,68,71,52}进行堆排序，输出两个最小关键字后的剩余堆是（）)。  

A.{23,72,60,25,68,71,52} B.{23,25,52,60,71,72,68} C.{71,25,23,52,60,72,68} D.{23,25,68,52,60,72,71}  

12.堆排序分为两个阶段：第一阶段将给定的序列构造成一个初始堆，第二阶段逐次输出堆顶元素，并调整使其保持堆的性质。设有给定序列48，62，35，77，55，14，35，98，若在堆排序的第一阶段将该序列构造成一个大根堆，则交换元素的次数为（）。  

A.5 B.6 C.7 D.8  

13.已知大根堆62，34，53，12，8，46，22}，删除堆顶元素后需要重新调整堆，则在此过程中关键字的比较次数为（）  

A.2B.3C.4D.5

14.哪种数据结构从根结点到任意叶结点的路径都是有序的（）A.红黑树 B.二叉查找树 C.哈夫曼树 D.堆  

15.【2009统考真题】已知关键字序列15，8,12,19,28，20，15，221是小根堆，插入关键字3，调整好后得到的小根堆是（）  

A.3,5,12,8,28,20,15,22,19 B.3,5,12,19,20,15,22,8,28 C.3,8,12,5,20,15,22,28,19 D.3,12,5,8,28,20,15,22,19  

16.【2011统考真题】已知序列{25，13，10，12，9是大根堆，在序列尾部插入新元素18，再将其调整为大根堆，调整过程中元素之间进行的比较次数是（）。  

A. 1 B.2 C.4 D.5  

17.【2015统考真题】已知小根堆为8，15，10,21，34，16，12，删除关键字8之后需重建堆，在此过程中，关键字之间的比较次数是（）  

A.1 B.2 WTC.3 D.4  

18.【2018统考真题】在将序列 $(6,1,5,9,8,4,7)$ 建成大根堆时，正确的序列变化过程是（）。A.  $6,1,7,9,8,4,5\to6,9,7,1,8,4,5\to9,6,7,1,8,4,5\to9,8,7,1,6,4,5$  B.  $6,9,5,1,8,4,7\rightarrow6,9,7,1,8,4,5\rightarrow9,6,7,1,8,4,5\rightarrow9,8,7,1,6,4,5$  C.  $6,9,5,1,8,4,7\rightarrow9,6,5,1,8,4,7\rightarrow9,6,7,1,8,4,5\rightarrow9,8,7,1,6,4,5$  
D.  $6,1,7,9,8,4,5\to7,1,6,9,8,4,5\to7,9,6,1,8,4,5\to9,7,6,1,8,4,5\to9,8,6,1,7,4,5$  

19.【2020统考真题】下列关于大根堆（至少含2个元素）的叙述中，正确的是（）  

1.可以将堆视为一棵完全二叉树11.可以采用顺序存储方式保存堆III.可以将堆视为一棵二叉排序树IV.堆中的次大值一定在根的下一层  

A.仅I、ⅡIB.仅II、IIIC.仅I、ⅡI和IVD.I、IⅢI和IV

20.【2021统考真题】将关键字6,9,1,5，8,4，7依次插入初始为空的大根堆H，得到的H是（）A.9,8,7,6,5,4,1 B.9,8,7,5,6,1,4 C.9,8,7,5,6,4,1 D.9,6,7,5,8,4,1  

# 二、综合应用题  

01.指出堆和二叉排序树的区别？  

02.画出一棵二叉树，使得它既满足大根堆的要求又满足二叉排序树的要求。  

03.若只想得到一个序列中第k（ $k{\geqslant}5$ ）个最小元素之前的部分的排序序列，则最好采用什么排序算法？  

04.通常使用的堆又称二叉堆，因为它是用完全二叉树来实现的，树中结点最多只有两个孩子。同理可以有 $m$ 叉堆，即用完全 $m$ 叉树来实现的堆。1）下图是一个 $m$ 叉小根堆，问 $m$ 值是多少？向这个堆插入一个元素65后，堆中的元素如何变化？再删除堆顶元素呢？请画出变化后的树形。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/feb1f44db8a85d6f4578848663fb91e1e680ba5b352d71751b25f36677bc9f98.jpg)  

2）从0开始对完全4叉树中的结点从左到右、从上到下进行编号。若给定一个结点 $k$ 其父结点的编号是多少？（若存在），其第i（ $(i\!=\!1,2,3,4$ ）个孩子的编号是多少？3）在 $m$ 叉堆中进行插入和删除操作的时间复杂度是多少？  

05.编写一个算法，在基于单链表表示的待排序关键字序列上进行简单选择排序。  

06.试设计一个算法，判断一个数据序列是否构成一个小根堆。  

07.【2022统考真题】现有 $n$ ( $n>100000$ ）个数保存在一维数组M中，需要查找M中最小的10个数。请回答下列问题。  

1）设计一个完成上述查找任务的算法，要求平均情况下的比较次数尽可能少，简述其算法思想（不需要编程实现）。2）说明你所设计的算法平均情况下的时间复杂度和空间复杂度。  

# 8.4.4 答案与解析  

# 一、单项选择题  

01.A 02.C  
注意，读者应熟练掌握各种排序算法的思想、过程和特点。  

03.D  

采用堆排序时，读入前10个元素，建立含10个元素的大根堆，而后依次扫描剩余元素，若大于堆顶，则舍弃，否则用该元素取代堆顶并重新调整堆，当元素全部扫描完毕，堆中保存的即是最小的10个元素。冒泡排序需要从后往前执行10趟冒泡才能得到10个最小的元素。两者的时间复杂度都和数据规模 $n$ 线性相关，但显然堆排序的常系数更小。而快速排序、归并排序的每一趟都不能保证得到当前序列的最小值，也无法达到线性时间复杂度。  

04.D  

可将每个选项中的序列表示成完全二叉树，再看父结点与子结点的关系是否全部满足堆的定义。例如，项A中序列对应的完全二义树如下图所示。显然，最小元素19在根结点，因此可能是小根堆，但75与26的关系却不满足小根堆的定义，所以项A中的序列不是一个堆。其他选项采用类似的过程分析。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9ab8e0f9cdbe44b2f873611d240a932e4089ac3d5650c75adea56060a9e7698.jpg)  

05.B  

这是小根堆，关键字最大的记录一定存储在这个堆所对应的完全二叉树的叶结点中：又因为二叉树中的最后一个非叶结点存储在 $_{n/2}$ 中，所以关键字最大记录的存储范围为n/2+ $1\!\sim\!n$  

06.C、C  

在向有 $n$ 个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等于树的高度减1，因为树的高度为 $\lfloor\log_{2}\!n\rfloor+1$ ，所以堆的向上调整算法的比较次数最多等于 $\lfloor\log_{2}\!n\rfloor_{\circ}$ 此处需要注意，调整堆和建初始堆的时间复杂度是不一样的，读者可以仔细分析两个算法的具体执行过程。  

07.A、D  

建堆过程中，向下调整的时间与树高 $h$ 有关，为 $O(h)$ 。每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为 $n$ 的序列上建堆，其时间复杂度为 $O(n)$ 。无论是在最好情况下还是在最坏情况下，堆排序的时间复杂度均为 $O(n\mathrm{log}_{2}n)$  

08.A  

简单选择排序的比较次数始终为 $n(n-1)/2$ ，与序列状态无关。  

09.D  

堆是顺序存储的完全二叉树，因此其高度小于或等于结点数相同的二叉排序树，A正确。B显然正确。根据小根堆的定义，其根结点到任意叶结点的路径构成从小到大的序列，C正确。堆的各层结点之间没有大小要求，因此层序遍历不能保证得到有序序列，D错误。  

10.C  

从 $\lfloor n/2\rfloor\!\sim\!1$ 依次筛选堆的过程如下图所示，显然选C项。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c1e9addeca78e042908b93b3601b16e5fb2407c67be9afd0bc616dde71c7033d.jpg)  

11.D  

筛选法初始建堆为{8,17,23,52,25,72,68,71,60}，输出8后重建的堆为{17,25,23,52,60,72，68,71}，输出17后重建的堆为{23,25,68,52,60.72,71}。  

12.B  

初始序列是一棵顺序存储的完全二叉树，然后根据大根堆的要求，按照从下到上、从右到左的顺序进行调整。98和77比较，98和77交换（交换1次）：14和35比较，35和35比较，不交换：98和55比较，98和62比较，98和62交换（交换1次）；62和77比较，77和62交换（交换1次）：98和35比较，98和48比较，98和48交换（交换1次）：77和55比较，77和48比较，77和48交换（交换1次）；48和62比较，62和48交换（交换1次），一共交换6 次。  

13.B  

删除堆顶62后，将堆尾22放入堆顶，然后自上而下调整。首先34与53比较（第一次比较），较大者53与根22比较（第二次比较），53被换至堆顶：22只有一个孩子，直接与其左孩子46比较（第3次比较），22与46交换，至此大根堆调整结束，具体过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba69cc31bfb95c944e8f4daaea81f4735512a8fef5c8bf3c776921efe99ca5aa.jpg)  

14.D  

红黑树和二叉查找树的中序序列是有序序列，从根结点到任意叶结点的路径不能保证是有序的。哈夫曼树是根据权值按一定规则构造的树，和关键字次序无关。若是小根堆，则从根结点到任意叶结点的路径是升序序列：若是大根堆，则从根结点到叶结点的路径是降序序列。  

15.A  

插入关键字3后，堆的变化过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aab4d7b8744ed7ff4aff7922991879f0ed31d57dbca9e7a05f8af20ad0e802d.jpg)  

16.B  

首先18与10比较，交换；18与25比较，不交换。共比较2次，调整过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d2994bb10da15e0a39af61ecf17f161f834550dc2f78acc7206ab1da944f48d1.jpg)  

17.C  

删除8后，将12移动到堆顶，第一次是15和10比较，第二次是10和12比较并交换，第三次还需比较12和16，所以比较次数为3。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8cc075f07a664909645f82aebb0d5286d84fdb8ac9d37c86bbb8aa3aed6ab63f.jpg)  

18.A  

要熟练掌握建堆和调整堆的方法，从序列末尾开始向前遍历，变换过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4f456f2485b9a3f8d8e9e2465b318bf14df528d977d88ecbd7c7f943a5880725.jpg)  

19.C  

简单概念题。堆是一棵完全树，采用一维数组存储，I正确，IⅡI正确。大根堆只要求根结点值大于左右孩子值，并不要求左右孩子值有序，IⅢ错误。堆的定义是递归的，所以其左右子树也是大根堆，所以堆的次大值一定是其左孩子或右孩子，IV正确。  

20.B  

要熟练掌握调整堆的方法，建堆的过程如下图所示，所以答案选择选项B。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d30fdad61c740e7b029d170ee5baa1d17ca5e297cfe31f053c0808b91328c16b.jpg)  

注意，给定序列依次插入空堆的结果与给定序列直接调整成堆的结果是不同的，最终得到的堆的形式也不同。若对序列6,9，1,5,8，4,7直接调整成堆，则会误选C项。  

# 二、综合应用题  

01.【解答】  

以小根堆为例，堆的特点是双亲结点的关键字必然小于或等于该孩子结点的关键字，而两个孩子结点的关键字没有次序规定。在二叉排序树中，每个双亲结点的关键字均大于左子树结点的关键字，均小于右子树结点的关键字，也就是说，每个双亲结点的左、右孩子的关键字有次序关系。这样，当对两种树执行中序遍历后，二叉排序树会得到一个有序的序列，而堆则不一定能得到一个有序的序列。  

02.【解答】  

大根堆要求根结点的关键字值既大于或等于左子女的关键字值，又大于或等于右子女的关键字值。二义排序树要求根结点的关键字值大于左子女的关键字值，同时小于石子女的关键字值。两者的交集是：根结点的关键字值大于左子女的关键字值。这意味着它是一棵左斜单支树，但大根堆要求是完全二叉树，因此最后得到的只能是如下图所示的两个结点的二叉树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/57a37593ae1db77ae3725de3e991c6748d5fe0b23ced68bf572f47cb03024344.jpg)  

读者也可能会注意到，当只有一个结点时，显然是满足题意的，但我们不举一个结点的例子是为了体现出排序树与大根堆的区别。  

03.【解答】  

在基于比较的排序算法中，插入排序、快速排序和归并排序只有在将元素全部排完序后，才能得到前 $k$ 个最小的元素序列，算法的效率不高。  

冒泡排序、堆排序和简单选择排序可以，因为它们在每一趟中都可以确定一个最小的元素。采用堆排序最合适，对于 $n$ 个元素的序列，建立初始堆的时间不超过 $4n$ ，取得第 $k$ 个最小元素之前的排序序列所花的时间为 $k{\mathrm{log}}_{2}n$ ，总时间为 $4n+k{\log_{2}}n$ ；冒泡和简单选择排序完成此功能所花的时间为km，当 $k{\geqslant}5$ 时，通过比较可以得出堆排序最优。  

# 注意  

求前 $k$ 个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序，  

04.【解析】  

1）除最后一个分支结点外，其余每个分支结点都有4个孩子，所以该树是完全4叉树。插入元素65后，再删除堆顶元素的树形分别如下图1和图2所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/585fc9ae0f04fc7396f5cda5301e8799dab4fb5907b8f483238fb81e070f0070.jpg)  

2）父结点的编号为 $k/4$ ，第 $i$ 个孩子的编号为 $4{\times}k+i,\,\,\,i=1,\,2,\,3,\,4$  

3）与二叉堆类似，插入和删除操作都有向上、向下调整的过程，操作时间都与树的高度有 关。因此，插入和删除操作的时间复杂度都为 $O(\log_{m}\!n)$ ，其中 $n$ 为元素个数。  

# 05.【解答】  

算法的思想是：每趟在原始链表中摘下关键字最大的结点，把它插入结果链表的最前端。由于在原始链表中摘下的关键字越来越小，在结果链表前端插入的关键字也越来越小，因此最后形成的结果链表中的结点将按关键字非递减的顺序有序链接。  

单链表的定义如第2章所述，假设它不带表头结点。  

void selectSort(LinkedList& L)( //对不带表头结点的单链表L执行简单选择排序 LinkNode  $^{\star}\mathrm{h}{=}\mathbb{L}$   $\star_{\mathsf{P}}$  ,\*q，\*r，\*s;  $\scriptstyle{\mathrm{L}}=$  NULL; while(h! $=$ NULL)I//持续扫描原链表 $\scriptstyle{\mathtt{p}}={\mathtt{S}}={\mathtt{h}}$   $\scriptstyle{\mathfrak{q}}={\mathfrak{r}}=$  NULL; /指针s和 $\boldsymbol{\tau}$ 记忆最大结点和其前驱：p为工作指针，g为其前驱while(p!=NULL){ //扫描原链表寻找最大结点s if(p->data>s->data)( $\scriptstyle{\mathtt{S}}={\mathtt{P}}$  $\scriptstyle\mathtt{r}=\mathtt{q}_{i}$ ）//找到更大的，记忆它和它的前驱q=p;p-p->link; //继续寻找 if(  $\scriptstyle{\mathrm{s}}=={\mathrm{h}}$  1  $\mathtt{h}{=}\mathtt{h}$ ->link;/最大结点在原链表前端else r->link $\scriptstyle=$ s->link;最大结点在原链表表内s->link  $\mathbf{\mu=}\mathbb{L}$   $\scriptstyle{\mathbb{L}}={\mathbb{S}}$  结点s插入结果链前端  

# 06.【解答】  

将顺序表L[1..n]视为一个完全二叉树，扫描所有分支结点，遇到孩子结点的关键字小于根结点的关键字时返回false，扫描完后返回true。算法的实现如下：  

bool IsMinHeap(ElemType A[],int len)（if（ $\scriptstyle1\in\mathbb{S}^{2}=0.$ l/len为偶数，有一个单分支结点if(A[len/2]>A[len])/判断单分支结点  
return false; for( $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}={\boldsymbol{\mathbf{I}}}$ en/2-1; $\scriptstyle{\mathrm{~i~}}>=1$ ；i--）//判断所有双分支结点if(A[i]>A[2\*i]llA[i]>A  $[2^{\star}\,\mathtt{i}\,\mathtt{+}\,\mathtt{1}\,]$  return false; elsef//len为奇数时，没有单分支结点for( $\scriptstyle{\dot{\mathbf{1}}}\,=$ len/2; $_\mathrm{i}\!>=\!1$ 八 $\mathrm{i--}$ //判断所有双分支结点if(A[i]>A[2\*i]l|A[i]>A[2\*i+1]) return false; return true;  

07.【解答】  

1）算法思想。  

【方法1】定义含10个元素的数组A，初始时元素值均为该数组类型能表示的最大数MAX。forM中的每个元素s  

if（ $\mathsf{S<A}\left[\mathsf{9}\right]$ 一丢弃A[9]并将s按升序插入A；当数据全部扫描完毕，数组 $\mathtt{A}\left[\,0\,\right]\sim_{\mathtt{A}}[\,9\,]$ 保存的就是最小的10个数。  

【方法2】定义含10个元素的大根堆H，元素值均为该堆元素类型能表示的最大数MAX。  

forM中的每个元素sif（ $\tt s\!<\!H$ 的堆顶元素）删除堆顶元素并将s插入H；当数据全部扫描完毕，堆日中保存的就是最小的10个数。  

2）算法平均情况下的时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$  

# 8.5 归并排序、基数排序和计数排序  

# 8.5.1 归并排序  

命题追踪二路归并操作的功能（2022）  

归并排序与上述基于交换、选择等排序的思想不一样，归并的含义是将两个或两个以上的有序表合并成一个新的有序表。假定待排序表含有  $n$  个记录，则可将其视为  $n$  个有序的子表，每个 子表的长度为1，然后两两归并，得到 $\lceil n/2\rceil$ 个长度为2或1的有序表；继续两两归并如此重复，直到合并成一个长度为 $n$ 的有序表为止，这种排序算法称为二路归并排序。  

图8.9所示为二路归并排序的一个例子，经过三趟归并后合并成了有序序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/365d58fda45f0a53c2d1bd276f956db5d5d2faf07813666f234e33ea5ffff7d7.jpg)  
图8.9二路归并排序示例  
# 命题追踪（算法题）归并排序思想的应用（2011）  

Merge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[low..mid]、A[mid+1..high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从B的两段中取出一个记录进行关键字的比较，将较小者放入A中，当B中有一段的下标超出其对应的表长（即该段的所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A中。算法如下：  

ElemType ${}^{\star}\mathtt{B}=$ （ElemType \*)malloc（ $(\mathtt{n}\!+\!1)$ \*sizeof（ElemType））；//辅助数组Bvoid Merge（ElemType A[],int low,int mid,int high)(表A的两段A[low..mid]和A[mid+1..high]各自有序，将它们合并成一个有序表int i,j，k; for(  $\kappa=$  low;  $\kappa\!<=$  high;  $\kappa++$  B[k]  $\mathtt{\ =}\mathtt{A}$  [k]; /将A中所有元素复制到B中 for(  $\dot{x}=$  low,j=mid+1,  $\kappa{=}1$   $\mathrm{i}<=$  mid&&j  $<=$  high;  $\kappa++$  if（B[i] $<=\mathtt{B}$ [j])/比较B的两个段中的元素A[k] $\mathbf{\tau}=\mathbf{F}$ 3 $\mathtt{i}_{\mathcal{+++}}$ //将较小值复制到A中else A[k]=B[j++]; while $\scriptstyle{\dot{\mathbf{z}}}<={\mathfrak{m}}$ id) $\mathbb{A}\left[\mathbb{k}^{++}\right]\!=\!\mathbb{B}\left[\mathbb{i}^{++}\right]$ ：//若第一个表未检测完，复制while( $\scriptstyle{\mathrm{~j}}<=$ high) $\mathbb{A}\left[\mathbb{k}{+}{+}\right]{=}\mathbb{B}\left[\mathbb{j}{+}{+}\right]$ ：//若第二个表未检测完，复制  

# 注意  

在上面的代码中，最后两个while循环只有一个会执行  

一趟归并排序的操作是，调用 $\left(n/2h\right]$ 次算法merge（），将L[1..n]中前后相邻且长度为 $h$ 的有序段进行两两归并，得到前后相邻、长度为 $_{2h}$ 的有序段，整个归并排序需要进行1ogn趟。  

递归形式的二路归并排序算法是基于分治的，其过程如下。  

分解：将含有 $n$ 个元素的待排序表分成各含 $n/2$ 个元素的子表，采用二路归并排序算法对两个子表递归地进行排序。  

合并：合并两个已排序的子表得到排序结果。  

void MergeSort（ElemType A[],int low,int high）{if(low<high){ int mid $=$ (low+high)/2;从中间划分两个子序列MergeSort（A,low,mid);//对左侧子序列进行递归排序MergeSort(A,mid+l,high); /对右侧子序列进行递归排序 Merge(A,low,mid,high); /归并  

# 命题追踪 归并排序和插入排序的对比（2017）  

二路归并排序算法的性能分析如下：  

空间效率：Merge（）操作中，辅助空间刚好为 $n$ 个单元，因此算法的空间复杂度为 $O(n)$  

时间效率：每趟归并的时间复杂度为 $O(n)$ ，共需进行 $\lceil\log_{2}n\rceil$ 趟归并，因此算法的时间复杂度为 $O(n\mathrm{log}_{2}n)$  

稳定性：由于Merge（）操作不会改变相同关键字记录的相对次序，因此二路归并排序算法是一种稳定的排序算法。  
适用性：归并排序适用于顺序存储和链式存储的线性表。  

# 注意  

一般而言，对于 $N$ 个元素进行 $k$ 路归并排序时，排序的趟数 $m$ 满足 $k^{m}\!=\!N$ ，从而 $m\!=\!\log_{k}\!N$ 又考虑到 $m$ 为整数，因此 $\scriptstyle m\,=\,\lceil\log_{k}N\rceil_{\circ}$ 这和前面的二路归并排序算法是一致的。  

# 8.5.2 基数排序  

基数排序是一种很特别的排序算法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。  

假设长度为  $n$  的线性表中每个结点  $a_{j}$  的关键字由  $d$  元组  $(\,k_{j}^{d-1}\,,k_{j}^{d-2}\,,\cdots,k_{j}^{1}\,,k_{j}^{0}\,)$  ）组成，满足  $0\!\leqslant\!k_{j}^{\iota}\!\leqslant\!r\!-\!1\:\:(0\!\leqslant\!j\!<\!n,0\!\leqslant\!i\!\leqslant\!d\!-\!1)$ 。其中 $k_{j}^{d-1}$ 为最主位关键字， $k_{j}^{0}$ 为最次位关键字。  

为实现多关键字排序，通常有两种方法：第一种是最高位优先（MISD）法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列：第二种是最低位优先（LSD）法，按关键字位权重递增依次进行排序，最后形成一个有序序列。  

下面描述以 $r$ 为基数的最低位优先基数排序的过程，在排序过程中，使用 $r$ 个队列 $Q_{0},\boldsymbol{Q}_{1},\cdots$  $Q_{r-1}$ 。基数排序的过程如下：  

对 $i\!=\!0,1,\cdots,d\!-\!1$ ，依次做一次分配和收集（其实是一次稳定的排序过程）。  

$\textcircled{\scriptsize{1}}$ 分配：开始时，把 $\mathcal{Q}_{0},\mathcal{Q}_{1},\cdots,\mathcal{Q}_{r-1}$ 各个队列置成空队列，然后依次考察线性表中的每个结点 $a_{j}$  $_i\ (j\,{=}\,0,1,\cdots,n-1)$ ，若 $a_{j}$ 的关键字 $k_{j}^{i}\!=\!k_{i}$ ，就把 $a_{j}$ 放进 $Q_{k}$ 队列中。  

$\circledcirc$ 收集：把 $\mathcal{Q}_{0},\mathcal{Q}_{1},\cdots,\mathcal{Q}_{r-1}$ 各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。  

# 命题追踪基数排序的中间过程的分析（2013、2021）  

通常采用链式基数排序，假设对如下10个记录进行排序：  

$$
\twoheadrightarrow\left[278\right]\twoheadrightarrow\left[109\right]\twoheadrightarrow\left[063\right]\twoheadrightarrow\left[589\right]\twoheadrightarrow\left[184\right]\twoheadrightarrow\left[505\right]\twoheadrightarrow\left[269\right]\twoheadrightarrow\left[008\right]\twoheadrightarrow\left[083\right]
$$  

每个关键字是1000以下的正整数，基数 $r=10$ ，在排序过程中需借助10个链队列，每个关键字由3位子关键字构成一一 $\cdot\mathrm{K}^{1}\mathrm{K}^{2}\mathrm{K}^{3}$ ，分别代表百位、十位和个位，一共进行三趟“分配”和“收集”操作。第一趟分配用最低位子关键字 $\mathrm{K}^{3}$ 进行，将所有最低位子关键字（个位）相等的记录分配到同一个队列，如图8.10(a)所示，然后进行收集操作。第一趟收集后的结果如图8.10(b)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/48cc62165ce2360ed01930db009972b6262a390392448a6089225dc7f219ffea.jpg)  
图8.10第一趟链式基数排序操作  

第二趟分配用次低位子关键字 $\mathrm{K}^{2}$ 进行，将所有次低位子关键字（十位）相等的记录分配到同一个队列，如图8.11(a)所示。第二趟收集后的结果如图8.11(b)所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c6f2bf6f54e66bb9877535bef33f0c0f8826a93ead82956fa1cc97ee0d7f7ec.jpg)  
图8.11第二趟链式基数排序操作  

第三趟分配用最高位子关键字 $\mathrm{K}^{1}$ 进行，将所有最高位子关键字（百位）相等的记录分配到同一个队列，如图8.12（a）所示，第三趟收集后的结果如图8.12（b）所示，至此整个排序结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16003a2547311992cc50f4c5ee3d857229a213f2dc465318c889f2714a206b93.jpg)  
图8.12第三趟链式基数排序操作  

基数排序算法的性能分析如下。  

空间效率：一趟排序需要的辅助存储空间为 $r~(r$ 个队列： $r$ 个队头指针和 $r$ 个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为 $O(r)$  

# 命题追踪元素的移动次数与序列初态无关的排序算法（2015）  

时间效率：基数排序需要进行 $d$ 趟“分配”和”收集”操作。一趟分配需要遍历所有关键字，时间复杂度为 $O(n)$ ；一趟收集需要合并 $r$ 个队列，时间复杂度为 $O(r)$ 。因此基数排序的时间复杂度为 $O(d(n+r))$ ，它与序列的初始状态无关。  

稳定性：每一趟分配和收集都是从前往后进行的，不会交换相同关键字的相对位置，因此基数排序是一种稳定的排序算法。  

适用性：基数排序适用于顺序存储和链式存储的线性表。  

#  ${\bf\ast8.5.3}$  计数排序  

# 命题追踪（算法题）计数排序思想的应用（2013、2015、2018）  

计数排序也是一种不基于比较的排序算法。计数排序的思想是：对每个待排序元素 $x$ ，统计小于 $x$ 的元素个数，利用该信息就可确定 $x$ 的最终位置。例如，若有8个元素小于 $x$ ，则 $x$ 就排在第9号位置上。当有几个元素相同时，该排序方案还需做一定的优化。  

# 注意  

计数排序并不在统考大纲的范围内，但其排序思想在历年真题中多次涉及！  
在计数排序算法的实现中，假设输入是一个数组A[n]，序列长度为n，我们还需要两个数组：B[n]存放输出的排序序列，C[k]存储计数值。用输入数组A中的元素作为数组C的下标（索引），而该元素出现的次数存储在该元素作为下标的数组C中。算法如下：  

# 命题追踪计数排序相关的思想和代码的分析（2021）  

void CountSort（ElemType A[],ElemType B[],int n,int k){ int i,C[k]; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<k;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$   ${\textsf{C}}\left[{\dot{\Sigma}}\right]\,=\,0$ //初始化计数数组for( $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$ ;i<n; $\ \ \dot{\mathbf{i}}_{++}$ 1//遍历输入数组，统计每个元素出现的次数C[A[i] $]{++}$ //C[A[i]]保存的是等于A[i]的元素个数for(  $_\mathrm{i}\!=\!\mathtt{1}$   $\scriptstyle{\dot{\mathbf{1}}}\times\mathbf{k}$   $\dot{\mathbf{1}}++$  C[i]=C[i]+C[i-1];//C[x]保存的是小于或等于 $\mathrm{_x}$ 的元素个数for( $\scriptstyle{\dot{\mathbf{z}}}=\mathbf{n}-1$  $\scriptstyle{\dot{\mathbf{z}}}>=0$ ;i--）{1/从后往前遍历输入数组B[C[A[i]-1]]=A[i];//将元素A[i]放在输出数组B[]的正确位置上C[A[i]]  $\scriptstyle{=\mathbb{C}}$  [A[i]]-1;  

第一个for循环执行完后，数组c的值初始化为0。第二个for循环遍历输入数组A，若一个输入元素的值为 $_\mathrm{x}$ ，则将c[x]值加1，该for循环执行完后，C[x]中保存的是等于 $_\mathrm{x}$ 的元素个数。第三个for循环通过累加计算后，C[x]中保存的是小于或等于 $_\mathrm{x}$ 的元素个数。第四个for循环从后往前遍历数组A，把每个元素A[i1放入它在输出数组B的正确位置上。若数组A中不存在相同的元素，则C[A[i]]-1就是A[i]在数组B中的最终位置，这是因为共有C[A[i]]个元素小于或等于A[i]。若数组A中存在相同的元素，将每个元素A[i]放入数组B[]后，都要将C[A[i]]减1，这样，当遇到下一个等于A[i]的输入元素（若存在）时，该元素就可放在数组B中A[i]的前一个位置上。  

假设输入数组 $\mathbb{A}\left[\,\right]=\left\{\,2\,,\,4\,,\,3\,,\,0\,,\,2\,,\,3\,\right\}$ ，第二个for循环执行完后，辅助数组c的情况如图8.13（a）所示；第三个for循环执行完后，辅助数组c的情况如图8.13（b）所示。图8.13（c）至图8.13（h）分别是第四个for循环每迭代一次后，输出数组B和辅助数组c的情况。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6d44032ce8506b47ebbb00a8709f6c74ae4f9f3c10eef0ae5cff2a9686fb669.jpg)  
图8.13计数排序的过程  
由上面的过程可知，计数排序的原理是：数组的索引（下标）是递增有序的，通过将序列中的元素作为辅助数组的索引，其个数作为值放人辅助数组，遍历辅助数组来排序。  

计数排序算法的性能分析如下。  

空间效率：计数排序是一种用空间换时间的做法。输出数组的长度为 $n$ ：辅助的计数数组的长度为 $k$ ，空间复杂度为 $O(n+k)$ 。若不把输出数组视为辅助空间，则空间复杂度为 $O(k)$  

时间效率：上述代码的第1个和第3个for循环所花的时间为 $O(k)$ ，第2个和第4个for循环所花的时间为 $O(n)$ ，总时间复杂度为 $O(n+k)$ 。因此，当 $k=O(n)$ 时，计数排序的时间复杂度为 $O(n)$ ：但当 $k\!>\!O(n\!\log\!n)$ 时，其效率反而不如一些基于比较的排序（如快速排序、堆排序等）。  

稳定性：上述代码的第4个for循环从后往前遍历输入数组，相同元素在输出数组中的相对位置不会改变，因此计数排序是一种稳定的排序算法。  

适用性：计数排序更适用于顺序存储的线性表。计数排序适用于序列中的元素是整数且元素范围 $(0{\sim}\mathrm{k{-}l}$ ）不能太大，否则会造成辅助空间的浪费。  

# 8.5.4 本节试题精选  

# 一、单项选择题  

01.以下排序算法中，（）在一趟结束后不一定能选出一个元素放在其最终位置上。A.简单选择排序B.冒泡排序 C.归并排序 D.堆排序 02.以下排序算法中，（）不需要进行关键字的比较。A.快速排序 B.归并排序 C.基数排序 D.堆排序  

03.在下列排序算法中，平均情况下空间复杂度为 $O(n)$ 的是（），最坏情况下空间复杂度为O(n)的是（)。  

I.希尔排序 II.堆排序 III冒泡排序 IV.归并排序 V.快速排序 VI.基数排序 A.I、IV、VIB.ⅡI、VC.IV、VD.IV  

04.下列排序算法中，排序过程中比较次数的数量级与序列初始状态无关的是（）  

A.归并排序 B.插入排序 C.快速排序 D.冒泡排序  

05.二路归并排序中，归并趟数的数量级是（）  

A. O(n) B.  $O(\log_{2}\!n)$  C.   $O(n\mathrm{log}_{2}n)$  D. 0(n)  

06.若对27个元素只进行三趟多路归并排序，则选取的归并路数最少为（）  

A. 2  B.3 C.4 D.5  

07.将两个各有 $N$ 个元素的有序表合并成一个有序表，最少的比较次数是（），最多的比较次数是(）。  

A.  $N$  B.2N-1 C. 2N D. N-1 08.用归并排序算法对序列 $\{1,2,6,4,5,3,8,7\}$ 进行排序，共需要进行（）次比较A.12 B.13 C.14 D.15  

09.一组经过第一趟二路归并排序后的记录的关键字为{25,50,15,35,80,85,20,40,36,70}，其中包含5个长度为2的有序表，用二路归并排序算法对该序列进行第二趟归并后的结果为()。  

A.15,25,35,50,80,20,85,40,70,36 B.15,25,35,50,20,40,80,85,36,70 C.15,25,50,35,80,85,20,36,40,70 D.15,25,35,50,80,20,36,40,70,85  

10.若将中国人按照生日（不考虑年份，只考虑月、日）来排序，则使用下列排序算法时，最快的是（）。  
A.归并排序 B.希尔排序 C.快速排序 D.基数排序  

11.设线性表中每个元素有两个数据项 $k_{1}$ 和 $k_{2}$ ，现对线性表按以下规则进行排序：先看数据项 $k_{1}$ ， $k_{1}$ 值小的元素在前，大的元素在后；在 $k_{1}$ 值相同的情况下，再看 $k_{2}$ ， $k_{2}$ 值小的元素在前，大的元素在后。满足这种要求的排序算法是（）。  

A.先按 $k_{1}$ 进行直接插入排序，再按 $k_{2}$ 进行简单选择排序B.先按 $k_{2}$ 进行直接插入排序，再按 $k_{1}$ 进行简单选择排序C.先按 $k_{1}$ 进行简单选择排序，再按 $k_{2}$ 进行直接插入排序D.先按 $k_{2}$ 进行简单选择排序，再按 $k_{1}$ 进行直接插入排序  

12.对{05,46,13，55，94，17,421进行基数排序，一趟排序的结果是（）  

A.05,46,13,55,94,17,42 B.05,13,17,42,46,55,94 C.42,13,94,05,55,46,17 D.05,13,46,55,17,42,94  

13.有 $n$ 个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队列个数是（）。  

A. n B.2 C. 5 D.10

 14.下列各种排序算法中，（）需要的附加存储空间最大。A.快速排序 B.堆排序 C.归并排序 D.插入排序  

15.【2013统考真题】已知两个长度分别为 $m$ 和 $n$ 的升序链表，若将它们合并为长度为 $m+n$ 的一个降序链表，则最坏情况下的时间复杂度是（）。  

A. O(n) B.O(mn) C.   $O(\operatorname*{min}(m,n))$  D.  $O(\operatorname*{max}(m,n))$  

16.【2013统考真题】对给定的关键字序列110,119,007,911,114,120,122进行基数排序，第二趟分配、收集后得到的关键字序列是（）。  

A.007,110,119,114,911,120,122 B.007,110,119,114,911,122,120 C.007,110,911,114,119,120,122 D.110,120,911,122,114,007,119  

17.【2015统考真题】下列排序算法中，元素的移动次数与关键字的初始状态无关的是（）。A.直接插入排序B.冒泡排序C.基数排序D.快速排序  

18.【2021统考真题】设数组S[]={93，946，372，9，146，151，301，485，236，327，43，892），采用最低位优先（LSD）基数排序将S排列成升序序列。第一趟分配、收集后，元素372之前、之后紧邻的元素分别是（）。  

A.43,892 B.236,301 C.301,892 D.485,301  

19.【2022统考真题】使用二路归并排序对含 $n$ 个元素的数组M进行排序时，二路归并排序的功能是（）。  

A.将两个有序表合并为一个新的有序表B.将M划分为两部分，两部分的元素个数大致相等C.将M划分为 $n$ 个部分，每个部分中仅含有一个元素D.将M划分为两部分，一部分元素的值均小于另一部分元素的值  

# 二、综合应用题  

01.已知序列{503，87，512，61，908，170,897，275，653，462}，采用非递归的二路归并排序算法对该序列做升序排序时需要几趟排序？给出每一趟的结果。  

02.设待排序的关键字序列为{12，2，16，30，28，10，16，20,6，18}，试写出使用最低位优先（LSD）基数排序算法每趟排序后的结果，并说明做了多少次关键字比较。  

03.【2021统考真题】已知某排序算法如下：  

void cmp Count Sort（int a[],int b[],int n）{inti,j,\*count;  
count $=$ （int\*)malloc（sizeof（int） $\star_{\mathrm{n}})$ //C $^{++}$ 语言：count $=$ newint[n];for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  八  $\scriptstyle{\mathrm{~i~}}<{\mathrm{n}}$   $\ \ \mathrm{i}_{\mathrm{++}}$  1 count  $[\dot{\bf x}]\!=\!0$  for( $\scriptstyle{\dot{\mathbf{z}}}=0$ ;i<n-l;i++）for(  $\mathfrak{j}\!=\!\mathrm{i}\!+\!\mathrm{1}$  ;j<n;j++) if(a[i]<a[j]) count[j]  $^{++}$  else count[i]++; for(  $\scriptstyle{\dot{\mathbf{\tau}}}=0$  ;i<n;i++） b[count[i]]  $=$  a[i]; free（count);//C++语言：delete count；  

请回答下列问题。  

1）若有inta[] $=$ （25，-10，25，10，11，19}，b[6];，则调用cmpCountSort（a，b，6）后数组b中的内容是什么？2）若a中含有 $n$ 个元素，则算法执行过程中，元素之间的比较次数是多少？3）该算法是稳定的吗？若是，阐述理由；否则，修改为稳定排序算法。  

# 8.5.5 答案与解析  

# 一、单项选择题  

01.C  

我们知道插入排序不能保证在一趟排序结束后一定有元素放在最终位置上。事实上，归并排序也不能保证。例如，序列 $\{6,5,7,8,2,1,4,3\}$ 进行一趟二路归并排序（从小到大）后为{5，6，7，81，2，3，4，显然它们都未被放在最终位置上。  

02.C  

基数排序是基于关键字各位的大小进行排序的，而不是基于关键字的比较进行的，  

03.D、C  

归并排序在平均情况和最坏情况下的空间复杂度都是 $O(n)$ ，快速排序只在最坏情况下才是 $O(n)$ ，平均情况是 $O(\log_{2}\!n)$ 。因此，归并排序是本章所有排序算法中占用辅助空间最多的。  

04.A  

前面已讲过选择排序的比较次数与序列初始状态无关，归并排序的比较次数的数量级也与序列的初始状态无关。读者应能从算法的原理方面来考虑为什么和初始状态无关。  

05.B  

$N$ 个元素进行 $k$ 路归并排序的趟数 $m$ 满足 $k^{m}\!=\!N$ ，即 $m=\lceil\log_{k}N\rceil$ ，本题中为 $\lceil\log_{2}\!n\rceil,$  

06.B  $N$ 个元素进行 $k$ 路归并排序的趟数 $m$ 满足 $k^{m}\!=\!N$ ，这里要求的是 $k$ ，代入可得 $k\!=\!3$  

07.A、B  

注意，当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比较 $N$ 次；而当两个表中的元素依次间隔地比较时，即 $a_{1}\!<\!b_{1}\!<\!a_{2}\!<\!b_{2}\!<\!\cdots\!<\!a_{n}\!<\!b_{n}$ 时，比较的次数是最多的，为 $2N{-1}$ 次。  

建议读者对此举一反三：若将本题中的两个有序表的长度分别设为 $M$ 和 $N_{e}$ 则最多（或最少）的比较次数是多少？时间复杂度又是多少？  

08.C  

第一趟归并后{1,2}，{4,6}，{3,5}，{7,8}，共比较4次；第二趟归并后 $\{1,2,4,6\},\{3,5,7,8\}$ 共比较4次；第三趟归并后 $\{1,2,3,4,5,6,7,8\}$ ，共比较6次。三趟归并共需进行14次比较。  

09.B  
由于这里采用二路归并排序算法，而且是第二趟排序，因此每4个元素放在一起归并，可将序列划分为{25,50,15,35}，{80,85,20,40}和{36,70}，分别对它们进行排序后有{15,25,35,50}，20,40,80,85}和36,70。  

10.D  

按照所有中国人的生日排序，一方面 $N$ 是非常大的，另一方面关键字所含的排序码数为2，且一个排序码的基数为12，另一个排序码的基数为31，都是较小的常数值，因此采用基数排序可以在 $O(N)$ 内完成排序过程。  

11.D  

本题思路来自基数排序的LSD，首先应确定 $k_{1}$ 、 $k_{2}$ 的排序顺序，若先排 $k_{1}$ 再排 $k_{2}$ ，则排序结果不符合题意，排除A和C。再考虑排序的稳定性，当 $k_{2}$ 排好序后，再对 $k_{1}$ 排序，若对 $k_{1}$ 排序采用的方法是不稳定的，则对于 $k_{1}$ 相同而 $k_{2}$ 不同的元素可能会改变相对次序，从而不一定能满足题设要求。直接插入排序是稳定的，而简单选择排序是不稳定的，只能选D。  

12.C  

基数排序有MSD和LSD两种，基数排序是稳定的。对于A，不符合LSD和MSD；对于B，符合MSD，但关键字42、46的相对位置发生了变化：对于D，不符合LSD和MSD。  

13.D  

基数排序中建立的队列个数等于进制数。  

14.C  

快速排序的平均空间复杂度是 $O(\log n)$ ，归并排序的空间复杂度是 $O(n)$ ，其他都是 $O(1)$  

15.D  

考虑两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置（取较小元素，头插法）。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为 $2\mathrm{max}(m,n)\!\geqslant\!m\!+\!n$ ，所以时间复杂度为 $O(\operatorname*{max}(m,n))$ 。此外，每次比较把两个链表中的较小结点插入新链表的表头，直到一个链表为空，因为原链表是升序排列的，要求合并后为降序排列的，因此还要把另一个链表剩下的结点一一插入新链表的表头，不论是最好情况还是最坏情况，都需要遍历两个链表中的所有结点，  

16.C  

基数排序的第一趟排序是按照个位数字的大小来进行的，第二趟排序是按照十位数字的大小来进行的，排序的过程如下图所示。  
17.C  

基数排序的元素移动次数与序列初态无关，而其他三种排序算法都与序列初态有关。  

18.C  

基数排序是一种稳定的排序算法。由于采用最低位优先（LSD）的基数排序，即第一趟对个位进行分配和收集操作，因此第一趟分配和收集后的结果是151，301，372，892，93，43，485，946146，236，327，91，元素372之前、之后紧邻的元素分别是301和892。  

19.A。  

送分题。本书对归并的定义原话是“归并的含义是将两个或两个以上的有序表合并成一个新的有序表”，而二路归并是将两个有序表合并为一个新的有序表。  

# 二、综合应用题  

01.【解答】  

$n=10$ ，需要排序的趟数 $=\!\left\lceil\log_{2}\!10\right\rceil\!=\!4$ ，各趟的排序结果如下：初始序列：503,87,512,61,908,170,897,275,653,462第一趟：87,503,61,512,170,908,275,897,462,653（长度为2）第二趟：61,87,503,512,170,275,897,908,462,653（长度为4）第三趟：61,87,170,275,503,512,897,908,462,653（长度为8）第四趟：61,87,170,275,462,503,512,653，897,908（长度为10）  

# 02.【解答】  

使用链式队列的基数排序的排序过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db244ef47f0991b5f9d0832e962e39a8ba55bc7b6bbba6df51bc5d66373c7897.jpg)  

需要通过2次分配和收集完成排序。  
# 03.【解答】  

cmpCountSort算法基于计数排序的思想，对序列进行排序。cmpCountSort算法遍历数组中的元素，count数组记录比对应待排序数组元素下标大的元素个数，例如，count $[\mathbb{1}]\!=\!3$ 的意思是数组a中有三个元素比a[1]小，即a[1]是第四大元素，a[1]的正确位置应是b[3]。  

1）排序结果为 $\mathsf{b}\left[6\right]\!=\!\{\substack{-10\,,\,10\,,\,11\,,\,19\,,\,25\,,\,25\}$  

2）由代码for $\scriptstyle\left({\mathrm{i}=0};{\mathrm{i}<\mathrm{n}-1};{\mathrm{i}++}\right)$ 和for( $\scriptstyle{\dot{\boldsymbol{\mathrm{\phi}}}}={\dot{\boldsymbol{\mathrm{I}}}}+{\boldsymbol{\mathrm{I}}}$ ;j<n; $\gimel^{++}$ ）可知，在循环过程中，每个元素都与它后面的所有元素比较一次（即所有元素都两两比较一次），比较次数之和为 $(n-1)+(n-2)+\cdots+1$ ，所以总比较次数是 $n(n\!-\!1)/2$ 。  

3）不是。需要将程序中的if语句修改如下：  

if(  $\mathsf{a}\left[\dot{\mathbf{i}}\right]\mathsf{<=a}\left[\dot{\mathbf{j}}\right]$  ）count[j]  $^{++}$  else count[i]  $^{++}$  

若不加等号，两个相等的元素比较时，前面元素的count值会加1，则导致原序列中靠 前的元素在排序后的序列中处于靠后的位置。  

# 8.6各种内部排序算法的比较及应用  

# 8.6.1 内部排序算法的比较  

前面讨论的排序算法很多，对各种排序算法的比较是考研常考的内容。一般基于五个因素进行对比：时间复杂度、空间复杂度、稳定性、适用性和过程特征。  

# 命题追踪各种排序算法的特点、比较和适用场景（2017、2020、2022）  

从时间复杂度看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为 $O(n^{2})$ ，且实现过程也较为简单，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到 $O(n)$ ，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可以在线性时间内完成建堆，且在 $O(n\mathrm{log}_{2}n)$ 内完成排序过程。快速排序基于分治的思想，虽然最坏情况下的时间复杂度会达到 $O(n^{2})$ ，但快速排序的平均性能可以达到 $O(n\mathrm{log}_{2}n)$ ，在实际应用中常常优于其他排序算法。归并排序同样基于分治的思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为 $O(n\log_{2}n)$  

从空间复杂度看：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数个辅助空间。快速排序需要借助一个递归工作栈，平均大小为 $O(\log_{2}\!n)$ ，当然在最坏情况下可能会增长到 $O(n)_{\circ}$ 二路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为 $O(n)$ 虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。  

# 命题追踪排序算法的稳定性判断及改进（2021、2023）  

从稳定性看：插入排序、冒泡排序、归并排序和基数排序是稳定的排序算法，而简单选择排 序、快速排序、希尔排序和堆排序都是不稳定的排序算法。平均时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的稳定排序算法只有归并排序，对于不稳定的排序算法，只需举出一个不稳定的实例即可。对于排序算法的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。  

# 命题追踪更适合采用顺序存储的排序算法（2017）  

从适用性看：折半插入排序、希尔排序、快速排序和堆排序适用于顺序存储。直接插入排序、冒泡排序、简单选择排序、归并排序和基数排序既适用于顺序存储，又适用于链式存储。  
# 命题追踪  

# 命题追踪  

根据排序的中间过程判断所采用的排序算法（2009、2010）  

每趟排序后都至少能确定一个元素的最终位置的排序算法（2012）  

从过程特征看：采用不同的排序算法，在一趟或几趟处理后的排序结果通常是不同的，考研题中经常出现给出一个待排序的初始序列和已部分排序的序列，问其采用何种排序算法。这就要对各类排序算法的过程特征十分熟悉，如冒泡排序、简单选择排序和堆排序在每趟处理后都能产生当前的最大值或最小值，而快速排序一趟处理至少能确定一个元素的最终位置等。  

表8.1列出了各种排序算法的时空复杂度和稳定性情况，其中空间复杂度仅列举了平均情况的复杂度，因为希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。  

表8.1各种排序算法的性质
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b1409c5ee2c569d34f51b5f3a267d60625ccf83b77b7de8ecb3eb03282fc0fb.jpg)  

# 8.6.2内部排序算法的应用  

通常情况，对排序算法的比较和应用应考虑以下情况。  

# 命题追踪选取排序算法时需要考虑的因素（2019）  

# 1.选取排序算法需要考虑的因素  

1）待排序的元素个数 $n$ 2）待排序的元素的初始状态。3）关键字的结构及其分布情况。4）稳定性的要求。5）存储结构及辅助空间的大小限制等。  

# 2.排序算法小结  

1）若 $n$ 较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因此当记录本身信息量较大时，用简单选择排序较好。  

2）若 $n$ 较大，应采用时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的排序算法：快速排序、堆排序或归并排序。当待排序的关键字随机分布时，快速排序被认为是目前基于比较的内部排序算法中最好的算法。堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能的最坏情况，这两种排序都是不稳定的。若要求稳定且时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，可选用归并排序。  

3）若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。4）在基于比较的排序算法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，  
因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 $n$ 个关键字随机分布时，任何借助于“比较”的排序算法，至少需要 $O(n\mathrm{log}_{2}n)$ 的时间。  

5）若 $n$ 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。  

6）当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。  

# 8.6.3 本节试题精选  

# 一、单项选择题  

01.若要求排序是稳定的，且关键字为实数，则在下列排序算法中应选（）A.直接插入排序B.选择排序C.基数排序D.快速排序

02.以下排序算法中时间复杂度为 $O(n\mathrm{log}_{2}n)$ 且稳定的是（）A.堆排序B.快速排序C.归并排序D.直接插入排序  

03.设被排序的结点序列共有 $n$ 个结点，在该序列中的结点已十分接近有序的情况下，用直接插入排序、归并排序和快速排序对其进行排序，这些算法的时间复杂度应为（）。  

A.  $O(n),O(n),O(n)$  B. O(n), O(nlogzn), O(nlog2n) C.   $O(n),O(n\mathrm{log}_{2}n),O(n^{2})$  D.  $O(n^{2}),O(n\mathrm{log}_{2}n),O(n^{2})$  

04.下列排序算法中属于稳定排序的是（ $\textcircled{\scriptsize{1}}$ )，平均时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的是( $\circledcirc$ )，在最好的情况下，时间复杂度可以达到线性时间的有（ $\textcircled{3}$ )。（注：多选题）  

I.冒泡排序ⅡI.堆排序III.选择排序IV.直接插入排序V.希尔排序VI.归并排序 VII.快速排序  

05.就排序算法所用的辅助空间而言，堆排序、快速排序和归并排序的关系是（）。  

A.堆排序<快速排序 $<$ 归并排序B.堆排序<归并排序<快速排序C.堆排序  $>$  归并排序>快速排序 D.堆排序>快速排序  $\scriptscriptstyle\cdot>$  归并排序  

06.排序趟数与序列的原始状态无关的排序算法是（）。  

I.直接插入排序ⅡI.简单选择排序IⅢI.冒泡排序IV.基数排序A.I、ⅢIB.I、II、IVC. 1、ⅡI、IⅢID.1、IV  

07.对 $n$ 个元素进行排序，其排序趟数肯定为 $n-1$ 趟的排序算法是（）  

A.直接插入排序和快速排序B.冒泡排序和快速排序C.简单选择排序和直接插入排序D.简单选择排序和冒泡排序  

08.若序列的原始状态为 $\{1,2,3,4,5,10,6,7,8,9\}$ ，要想使得排序过程中的元素比较次数最少，则应该采用（）方法。  

A.插入排序 B.选择排序 C.希尔排序 D.冒泡排序

 09.一般情况下，以下查找效率最低的数据结构是（）。A.有序顺序表 B.二叉排序树 C.堆 D.平衡二叉树

 10.排序趟数与序列的原始状态有关的排序算法是（）排序算法。A.插入B.选择C.冒泡D.基数

11.对于同等大小的不同初始序列，总比较次数一定的是（）。  

A.折半插入排序和简单选择排序 B.基数排序和归并排序 C.冒泡排序和快速排序 D.堆排序  

12.一台计算机具有多核CPU，可以同时执行相互独立的任务。归并排序的各个归并段可以并行执行，在下列排序算法中，不可以并行执行的有（）。  

I．基数排序 II.快速排序 III.冒泡排序 IV.堆排序 A.I、ⅢIB.I、IIC.I、Ⅲ、IVD.II、IV  
13.【2009统考真题】若数据元素序列{11，12,13，7，8，9,23，4,5}是采用下列排序算法之一得到的第二趟排序后的结果，则该排序算法只能是（）。  

A.冒泡排序 B.插入排序 C.选择排序 D.二路归并排序  

14.【2010统考真题】对一组数据（2，12,16,88,5,10）进行排序，若前3趟排序结果如下：第一趟排序结果：2.12.16.5.10.88第二趟排序结果：2,12，5.10,16.88第三趟排序结果：2，5，10.12,16,88则采用的排序算法可能是（）。  

A.冒泡排序 B.希尔排序 C.归并排序 D.基数排序  

15.【2012统考真题】在内部排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序算法中，每趟排序结束都至少能够确定一个元素最终位置的方法是()。  

I.简单选择排序II.希尔排序II.快速排序 IV.堆排序 V.二路归并排序  

A.仅I、III、IVB.仅I、ⅢI、VC.仅II、II、IVD.仅IⅢI、IV、V  

16.【2017统考真题】在内部排序时，若选择了归并排序而未选择插入排序，则可能的理由是(）。  

1.归并排序的程序代码更短II.归并排序的占用空间更少IIL.归并排序的运行效率更高  

A.仅IIB.仅IⅢIC.仅I、ID.仅I、II  

17.【2017统考真题】下列排序算法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是（）。  

ⅡI.选择排序III.冒泡排序IV.希尔排序V.堆排序 A.仅I、IⅡIB.仅ⅡI、IIIC.仅IⅢI、IVD.仅IV、V  

18.【2019统考真题】选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是()。  

I.数据的规模II.数据的存储方式III.算法的稳定性IV.数据的初始状态A.仅IⅢIB.仅I、ⅡIC.仅I、III、IVD.I、II、III、IV  

19.【2020统考真题】对大部分元素已有序的数组排序时，直接插入排序比简单选择排序效率更高，其原因是（）。  

1.直接插入排序过程中元素之间的比较次数更少 I1.直接插入排序过程中所需的辅助空间更少I11.直接插入排序过程中元素的移动次数更少  

A.仅IB.仅IIIC.仅I、IID.I、ⅡI和Ⅲ  

20.【2022统考真题】对数据进行排序时，若采用直接插入排序而不采用快速排序，则可能的原因是（）  

I.大部分元素已有序II.待排序元素数量很少II.要求空间复杂度为 $O(1)$ IV.要求排序算法是稳定的A仅IIIB.仅IIIVC.仅I、IIIVD.I、IIII、IV  

21.【2023统考真题】下列排序算法中，不稳定的是（）。I.希尔排序 I1.归并排序 III.快速排序 IV.堆排序 V.基数排序 A.仅I、IⅡIB.仅II、VC.仅I、II、IVD.仅III、IV、V  
# 二、综合应用题  

01.设关键字序列为 $\{3,7,6,9,7,1,4,5,20\}$ ，对其进行排序的最小交换次数是多少？  

02.设顺序表用数组A表示，表中元素存储在数组下标 $1\sim m+n$ 的范围内，前 $m$ 个元素递增有序，后 $n$ 个元素递增有序，设计一个算法，使得整个顺序表有序。1）给出算法的基本设计思想。2）根据设计思想，采用 $\mathrm{C}/\mathrm{C++}$ 描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度与空间复杂度。  

03.设有一个数组中存放了一个无序的关键序列 $K_{1},K_{2},\cdots,K_{n}.$ 现要求将 $K_{n}$ 放在将元素排序后的正确位置上，试编写实现该功能的算法，要求比较关键字的次数不超过 $n_{\circ}$  

# 8.6.4 答案与解析  

# 一、单项选择题  

01.A  

采用排除法。由于题目要求是稳定排序，因此排除B项和D项，又由于基数排序不能对f1oat和double类型的实数进行排序，因此排除C项。  

02.C 堆排序和快速排序不是稳定排序算法，而直接插入排序算法的时间复杂度为 $O(n^{2})$  

03.C 各种排序算法的时间和空间复杂度、稳定性等见表8.1。04. $\textcircled{\scriptsize{1}}$ I、IV、VI $\textcircled{2}$ II、VI、VII $\textcircled{3}$ 1、IV读者应能从算法的原理上理解算法的稳定性情况。堆排序和归并排序在最坏情况下的时间复杂度与最好情况下的时间复杂度是同一数量级的，都是 $O(n\mathrm{log}_{2}n)$  

05.A  

由于堆排序的空间复杂度为 $O(1)$ ，因此快速排序的空间复杂度在最坏情况下为 $O(n)$ ，平均空间复杂度为  $O(\log_{2}n)$  ，归并排序的空间复杂度为  $O(n)$  

06.B  

冒泡排序的趟数为 $1\!\sim\!n-1$ ，和序列初态有关。直接插入排序每趟都插入一个元素，排序趟数固定为 $n\!-\!1$ 。简单选择排序每趟都选出一个最小（或最大）的元素，排序趟数固定为 $n-1$ 。基数排序每趟都要进行分配和收集，排序趟数固定为 $d$  

07.C  

不论序列的原始状态如何，简单选择排序和直接插入排序的趟数都是 $n\!-\!1$ 。冒泡排序的趟数为 $1\!\sim\!n-1$ ，快速排序的趟数为 $\log_{2}\!n\!\sim\!n\!-\!1$ ，具体取决于序列的原始状态（快速排序还取决于划分方法）。  

08.A  

选择排序和序列初态无关，直接排除。初始序列基本有序时，插入排序比较次数较少。本题中，插入排序仅需比较 $n-1+4$ 次，而希尔排序和冒泡排序的比较次数均远大于此。  

09.C 堆是用于排序的，在查找时它是无序的，所以效率没有其他查找结构的高。  
10.C  

插入排序和选择排序的趟数始终为  $n\!-\!1$  ，与序列的原始状态无关。对于冒泡排序，某趟比较 后没有发生元素交换，则说明已排好序。基数排序的趟数由元素的位数决定，与原始状态无关。  

11.A  

简单选择排序的总比较次数显然是确定的。折半插入排序每趟的比较次数都为 $O(\log_{2}m)$ (m为当前已排好序的子序列的长度），因此总比较次数也是确定的。基数排序不是基于比较的排序算法。其他几种排序算法的比较次数显然和序列的初始状态有关。  

12.A  

基数排序每趟需要利用前一趟已排好的序列，无法并行执行。快速排序每趟划分的子序列互不影响，可以并行执行。冒泡排序每趟对未排序的所有元素进行一趟处理，无法并行执行。堆排序可以并行执行，因为根结点的左右子树构成的子堆在执行过程中是互不影响的。  

13.B  

每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里{11，12}和{4,5}所处的位置并不是最终位置，因此不可能是冒泡和选择排序。二路归并算法经过第二趟后应该是每4个元素有序的，但{11，12，13，7并非有序，因此也不可能是二路归并排序。  

14.A  

题中给出的排序过程，每一趟都是从前往后依次比较使最大值沉底，符合冒泡排序的特点。分别用其他3种排序算法尝试，归并排序第一趟后的结果为(2，12，16,88，5，10)，基数排序第一趟后的结果为(10,2，12，5，16,88)，希尔排序显然不符合。  

15.A  

对于1，简单选择排序每次选择未排序序列中的最小元素放入其最终位置。对于ⅡI，希尔排序每次对划分的子表进行排序，得到局部有序的结果，所以不能保证每趟结束都能确定一个元素的最终位置。对于Ⅲ，快速排序每趟结束后都将枢轴元素放到最终位置。对于IV，堆排序属于选择排序，每次都将大根堆的根结点与表尾结点交换，确定其最终位置。对于V，二路归并排序每趟对子表进行两两归并，从而得到若干局部有序的结果，但无法确定最终位置。  

16.B  

归并排序的代码比插入排序的代码更为复杂，前者的空间复杂度是 $O(n)$ ，后者是 $O(1)$ 。但是前者的时间复杂度是 $O(n\mathrm{log}n)$ ，后者是 $O(n^{2})$  

17.D  

在顺序存储的条件下，插入排序、选择排序、冒泡排序的时间复杂度都是 $O(n^{2})$ ，更换为链式存储后的时间复杂度还是 $O(n^{2})$ 。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加。  

18.D  

当数据规模较小时可选择复杂度为 $O(n^{2})$ 的简单排序算法，当数据规模较大时应选择复杂度为 $O(n\log_{2}n)$ 的排序算法，当数据规模大到内存无法放下时需选择外部排序算法，I正确。数据的存储方式主要分为顺序存储和链式存储，有些排序算法（如堆排序）只能用于顺序存储方式，Ⅱ正确。若对数据稳定性有要求，则不能选择不稳定的排序算法，ⅢI显然正确。当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是 $O(n)$ ，而归并排序的时间复杂度依旧是 $O(n\log_{2}n)$ ，IV正确。  

19.A  

考虑比较极端的情况，对于有序数组，直接插入排序的比较次数为 $_{n-1}$ ，简单选择排序的比较次数始终为 $1+2+\cdots+n-1=n(n-1)\,/\,2$ ，I正确。两种排序算法的辅助空间都是 $O(1)$ ，无差别，Ⅱ错误。初始有序时，移动次数均为0：对于通常情况，直接插入排序每趟插入都需要依次向后挪位，而简单选择排序只需与找到的最小元素交换位置，后者的移动次数少很多，1ⅢI错误。  
20.D  

直接插入排序和快速排序的特点如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/030693ca731850651b62ecd565fba55cab84dcd086c7fa264dc7742c6cc873a4.jpg)  

可见，选项I、II、IⅢI、IV都是采用直接插入排序而不采用快速排序的可能原因。  

21.C  

稳定的内部排序算法：插入排序、冒泡排序、归并排序和基数排序。不稳定的内部排序算法：简单选择排序、快速排序、希尔排序和堆排序。  

# 二、综合应用题  

01.【解答】  

由于直接插入排序的交换次数更多，因此应当采用简单选择排序。  

初始序列： $3,7,6,9,7,1,4,5,20$ 第一次：1,7,6,9,7,3,4,5,20交换1,3第二次： $1,3,6,9,7,7,4,5,20$ 交换3.7第三次： $1,3,4,9,7,7,6,5,20$ 交换4.6第四次： $1,3,4,5,7,7,6,9,20$ 交换5.9第五次： $1,3,4,5,6,7,7,9,20$ 交换67所以最小交换次数为5（注意这里求的是交换次数，而不是移动次数或比较次数）  

# 02.【解答】  

1）算法的基本设计思想如下：将数组 $\mathbb{A}\left[1...\mathbb{m}\mathbf{+}\mathbf{n}\right]$ 视为一个已经过 $m$ 趟插入排序的表，则从 $m+1$ 趟开始，将后 $n$ 个元素依次插入前面的有序表中。  

2）算法的实现如下：  

void Insert Sort（ElemType A[l,int m,int n){ int i,j; for( $\scriptstyle{\dot{\mathbf{1}}}={\mathfrak{m}}+1$  $\scriptstyle{\dot{\mathbf{1}}}<={\mathfrak{m}}+\mathbf{n}$  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ /依次将 $\mathbb{A}\left[\mathfrak{m}\!+\!1...\mathfrak{m}\!+\!\mathfrak{n}\right]$ 插入有序表 $\mathtt{A}\left[\,0\,\right]\mathrm{=A}$ [i];/复制为哨兵for( $\scriptstyle{\dot{\boldsymbol{\mathrm{\omega}}}}={\dot{\boldsymbol{\mathrm{\omega}}}}-1$ ;A[j]>A[0];j--)//从后往前插入A[  $_{\bar{1}+1\bar{1}=\bar{A}}$  [j]; //元素后移  $\mathbb{A}\left[\,\mathbb{j}\!+\!\mathbb{1}\,\right]\!=\!\mathbb{A}\left[\,0\,\right]$ //插入  

3）时间复杂度由 $m$ 和 $n$ 共同决定，从上面的算法不难看出，在最坏情况下元素的比较次数为 $O(m n)$ ，而元素移动的次数为 $O(m n)$ ，所以时间复杂度为 $O(m n)$ 6因为算法只用到了常数个辅助空间，所以空间复杂度为 $O(1)$ 此外，本题也可采用归并排序，将A[1..m]和A $\mathbf{\lambda},[\mathfrak{m}+1...\mathfrak{m}+\mathfrak{n}]$ 视为两个待归并的有序子序列，算法的时间复杂度为 $O(m+n)$ ，空间复杂度为 $O(m+n)$  

03.【解答】  

基本思想：以 $K_{n}$ 为枢轴进行一趟快速排序。将快速排序算法改为以最后一个元素为枢轴  
先从前往后，再从后往前。算法的代码如下：  

in t Partition（ElemType K[],intn)( /交换序列k[1..n]中的记录，使枢轴到位，并返回其所在位置int $_\pm=1$  $\scriptstyle{\dot{\mathbf{j}}}={\boldsymbol{\mathbf{n}}}$ //设置两个交替变量初值分别为1和 $\mathtt{n}$ ElemType pivot  $\mathbf{\mu=}\mathbb{K}$  [j]; /枢轴 while(i<j)(/循环跳出条件while（i<j&&K[i] $<=$ pivot) $\ \ \mathrm{i++}$ //从前往后找比枢轴大的元素if（i<j) K[j]  $\mathbf{\mu=}\mathbb{K}$  [i]; //移动到右端 while（i<j&&K[j] $>=$ pivot)j--;川/从后往前找比枢轴小的元素if（i<j) K[i]  $\mathbf{\mu=}\mathbb{K}$  []; /移动到左端 }l/while K[i]=pivot;/枢轴存放在最终位置returni;/返回存放枢轴的位置  

# 8.7 外部排序  

外部排序可能会考查相关概念、方法和排序过程，外部排序的算法比较复杂，不会在算法设计上进行考查。本节的主要内容有：  

$\textcircled{\scriptsize{1}}$ 外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的自的。 $\circledcirc$ 为减少平衡归并中外存读/写次数所采取的方法：增大归并路数和减少归并段个数。  

$\textcircled{3}$ 利用败者树增大归并路数。  

$\textcircled{4}$ 利用置换-选择排序增大归并段长度来减少归并段个数。 $\circledast$ 由长度不等的归并段进行多路平衡归并，需要构造最佳归并树。  

# 8.7.1外部排序的基本概念  

前面介绍过的排序算法都是在内存中进行的（称为内部排序）。而在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序算法就称为外部排序。  

# 8.7.2外部排序的方法  

文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读/写的。因为磁盘读/写的机械动作所需的时间远远超过在内存中进行运算的时间（相比而言可以忽略不计），因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即1/O次数。  

# 命题追踪对大文件排序时使用的排序算法（2016）  

外部排序通常采用归并排序算法。它包括两个阶段： $\textcircled{\scriptsize{1}}$ 根据内存缓冲区大小，将外存上的文件分成若干长度为 $\ell$ 的子文件，依次读入内存并利用内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串； $\circledcirc$ 对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。  
例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部排序得到8个初始归并段 $\mathrm{R1\!\sim\!R8}$ ，每段都含250条记录。然后对该文件做如图8.15所示的两两归并，直至得到一个有序文件。可以把内存工作区等分为三个缓冲区，如图8.14所示，其中的两个为输入缓冲区，一个为输出缓冲区。首先，从两个输入归并段R1和R2中分别读入一个块，放在输入缓冲区1和输入缓冲区2中。然后，在内存中进行二路归并，归并后的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段（R1）中，再清空输出缓冲区，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上趟的结果R1'和R2、R3'和R4'两两归并，这又是一趟归并。最后把R1"和R2"两个归并段归并，得到最终的有序文件，一共进行了3趟归并。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9dfc2273b2657ab8f22bac4053500f6f3c968af70843c709cd6de6d27e0e7f8.jpg)  
图8.14二路归并  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/594c62b9eed6c74fbcd2ef228dc89133d1f7dacc1faac7b8cf3699861e02d96b.jpg)  
图8.15二路平衡归并的排序过程  

在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果段同时存放在内存中，因此需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：  

外部排序的总时间 $=$ 内部排序的时间 $^+$ 外存信息读/写的时间 $^+$ 内部归并的时间  

显然，外存信息读/写的时间远大于内部排序和内部归并的时间，因此应着力减少1/0次数。由于外存信息的读/写是以“磁盘块”为单位的，因此可知每趟归并需进行16次读和16次写，3趟归并加上内部排序时所需进行的读/写，使得总共需进行 $32\!\times\!3+32=128$ 次读/写。  

若改用4路归并排序，则只需2趟归并，外部排序时的总读/写次数便减至 $32\!\times\!2+32=96.$ 因此，增大归并路数，可减少归并趟数，进而减少总的磁盘1/0次数，如图8.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/29ffd4a87f89e3a71844bdb43087db397877ef3872bcda905c7c5cc68854e819.jpg)  
图8.164路平衡归并的排序过程  

一般地，对 $r$ 个初始归并段，做 $k$ 路平衡归并（即每趟将 $k$ 个或 $k$ 个以下的有序子文件归并成一个有序子文件）。第一趟可将 $r$ 个初始归并段归并为 $\bar{_{r/k}}$ 个归并段，以后每趟归并将 $m$ 个归并段归并成 $\dot{}_{m/k}$ 个归并段，直至最后形成一个大的归并段为止。树的高度 $-1=\lceil\log_{k}r\rceil=$ 归并趟数S。可见，只要增大归并路数  $k$  ，或减少初始归并段个数  $r$  ，都能减少归并趟数  $S$  ，进而减少读/写 磁盘的次数，达到提高外部排序速度的目的。  

# 8.7.3 多路平衡归并与败者树  

增加归并路数 $k$ 能减少归并趟数S，进而减少1/O次数。然而，增加归并路数 $k$ 时，内部归并的时间将增加。做内部归并时，在 $k$ 个元素中选择关键字最小的元素需要 $k\!-\!1$ 次比较。  
每趟归并 $n$ 个元素需要做 $(n-1)(k-1)$ 次比较， $S$ 趟归并总共需要的比较次数为  

$$
S(n-1)(k-1)=\lceil\log_{k}r\rceil(n-1)(k-1)=\lceil\log_{2}r\rceil(n-1)(k-1)/\lceil\log_{2}k\rceil
$$  

式中， $(\,k-1\,)/\left\lceil\log_{2}\!k\right\rceil$ 随 $k$ 增长而增长，因此内部归并时间亦随 $k$ 的增长而增长。这将抵消因增大 $k$ 而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。  

为了使内部归并不受 $k$ 的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。 $k$ 个叶结点分别存放 $k$ 个归并段在归并过程中当前参加比较的元素，内部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。  

如图8.17(a)所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，b2 是败者,将段号2写入 ls[3]。b3与b4 的胜者b3与b0 比较,b0是败者,将段号0写入 Is[2]。最后两个胜者 b3与b1 比较,b1是败者，将段号1写入Is[1]。而将胜者b3 的段号 3写入 ls[0]。此时，根结点ls[0]所指的段的关键字最小。对于 $k$ 路归并，初始构造败者树需要 $k-1$ 次比较。b3中的6输出后，将下一关键字填入b3，继续比较。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e2a0f7cbaa050a4bfea0e9a28cf40956989e3d9e2e56ab38136f036fb8d98f85.jpg)  
图8.17实现5路归并的败者树  

因为 $k$ 路归并的败者树深度为 $\lceil\log_{2}\!k\rceil\!+\!1$ ，所以从 $k$ 个记录中选择最小关键字，仅需进行[logzk]次比较。因此总的比较次数约为  

$$
S(n-1)\,{\widetilde{\Gamma\log_{2}\!k}}\,{=}\,{\widetilde{\Gamma\log_{k}\!r}}\,(n-1)\,{\widetilde{\Gamma\log_{2}\!k}}\,{=}\,(n-1)\,{\widetilde{\Gamma\log_{2}\!r}}\,{\widetilde{\Gamma\log_{2}\!r}}\,{\widetilde{\Gamma\log_{2}\!r}}\,
$$  

可见，使用败者树后，内部归并的比较次数与 $k$ 无关了。因此，只要内存空间允许，增大归并路数 $k$ 将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。  

值得说明的是，归并路数 $k$ 并不是越大越好。归并路数 $k$ 增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当 $k$ 值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。  

# 8.7.4置换-选择排序（生成初始归并段）  

从8.7.2节的讨论可知，减少初始归并段个数 $r$ 也可以减少归并趟数 $S_{\circ}$ 若总的记录个数为 $n$ 每个归并段的长度为，则归并段的个数 $\scriptstyle{r=\left\lceil n/\ell\right\rceil}$ 1。采用内部排序算法得到的各个初始归并段长度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的方法，用来产生更长的初始归并段，这就是本节要介绍的置换-选择算法。  
# 命题追踪置换-选择排序生成初始归并段的实例（2023）  

设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳 $w$ 个记录。置换-选择算法的步骤如下：  

1）从FI输入 $w$ 个记录到工作区WA。  

2）从WA中选出其中关键字取最小值的记录，记为MINIIMAX记录。  

3）将MINIMAX记录输出到FO中去。  

4）若FI不空，则从FI输入下一个记录到WA中。  

5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为MINI MAX。  

6）重复 $3)\sim\!51$ ），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。  

7）重复 $2)\sim\!6)$ ，直至WA为空。由此得到全部初始归并段。设待排文件 $\mathrm{FI}=\{17,21$ ，05,44,10,12,56,32,29}，WA容量为3，排序过程如表8.2所示。  

表8.2置换-选择排序过程示例
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/06a91576d394233195d293599a1105b769edc8b13f4d56330f10343b1c301dd4.jpg)  

上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。  

# 8.7.5最佳归并树  

文件经过置换-选择排序后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等的初始归并段的归并顺序，使得1/0次数最少。假设由置换-选择排序得到9个初始归并段，其长度（记录数）依次为 $9,30,12,18,3,17,2,6,24$ 。现做3路平衡归并，其归并树如图8.18所示。  

在图8.18中，各叶结点表示一个初始归并段，上面的权值表示该归并段的长度，叶结点到根的路径长度表示其参加归并的趟数，各非叶结点代表归并成的新归并段，根结点表示最终生成的归并段。树的带权路径长度WPL为归并过程中的总读记录数，所以I/O次数 $\stackrel{\cdot}{=}2\times\mathrm{WPL}=484$  
# 命题追踪构造三叉哈夫曼树及相关的分析和计算（2013）  

显然，归并方案不同，所得归并树不同，树的带权路径长度（I/O次数）亦不同。为了优化归并树的WPL，可以将哈夫曼树的思想推广到 $m$ 叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的1/0次数最少的最佳归并树。上述9个初始归并段可构造成一棵如图8.19所示的归并树，按此树进行归并，仅需对外存进行446次读/写，这棵归并树便称为最佳归并树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/750b4b70d0ce28d6e100a1915c1ed3b27078c90f2f1ab7eb391e62ad4abbcbd8.jpg)  
图8.183路平衡归并的归并树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c05244e5d184f1800bafd18f0e9500aee22c219443d98eaf2a153b89b8ca4f3.jpg)  
图8.193路平衡归并的最佳归并树  

图8.19中的哈夫曼树是一棵严格3叉树，即树中只有度为3或0的结点。若只有8个初始归并段，如上例中少了一个长度为30的归并段。若在设计归并方案时，缺额的归并段留在最后，即除最后一次做二路归并外，其他各次归并仍是3路归并，此归并方案的1/0次数为386。显然，这不是最佳方案。正确的做法是：若初始归并段不足以构成一棵严格 $k$ 叉树（也称正则 $k$ 叉树）时，需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。因此，最佳归并树应如图8.20所示，此时的1/0次数仅为326。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/400c7ffb6e3e01b16694a55f891313b9094c8e8fae3723f8318229f52ec41d71.jpg)  
图8.208个归并段的最佳归并树  

如何判定添加虚段的数目？  

设度为0的结点有  $n_{0}$  个，度为  $k$  的结点有  $n_{k}$  个，归并树的结点总数为  $n$  ，则有：  

$n\,{=}\,n_{k}+n_{0}$ （总结点数 $=$ 度为 $k$ 的结点数 $^+$ 度为0的结点数） $n=k n_{k}+1$ （总结点数 $=$ 所有结点的度数之和+1)因此，对严格 $k$ 叉树有 $n_{0}\!=\!(k\!-\!1)n_{k}\!+1$ ，由此可得 $n_{k}\!=\!(n_{0}\!-\!1)/(k\!-\!1)\,\circ$ 若 $(n_{\scriptscriptstyle0}-1)\%(k-1)=0$ ( $\%$ 为取余运算)，则说明这 $n_{0}$ 个叶结点（初始归并段）正好可以构造  $k$  叉归并树。此时，内结点有  $n_{k}$  个。 若 $(n_{\scriptscriptstyle0}-1)\%(k-1)=u\neq0$ ，则说明对于这 $n_{0}$ 个叶结点，其中有 $u$ 个多余，不能包含在 $k$ 叉归并树中。为构造包含所有 $n_{0}$ 个初始归并段的 $k$ 叉归并树，应在原有 $n_{k}$ 个内结点的基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被代替的叶结点加上刚才多出的 $u$ 个叶结点，即再加上 $k\!-\!u\!-\!1$ 个空归并段，就可以建立归并树。  

# 命题追踪实现最佳归并时需补充的虚段数量的分析（2019）  

以图8.19为例，用8个归并段构成3叉树， $(n_{\scriptscriptstyle0}-1)\%(k-1)=(8-1)\%(3-1)=1$ ，说明7个归并段刚好可以构成一棵严格3叉树（假设把以5为根的树视为一个叶子)。为此，将叶子5变成一个内结点，再添加 $3\!-\!1\!-\!1\!=\!1$ 个空归并段，就可以构成一棵严格3叉树。  
# 8.7.6 本节试题精选  

# 一、单项选择题  

01.外部排序和内部排序的主要区别是（）  

A.内部排序的数据量小，而外部排序的数据量大B.内部排序不涉及内、外存数据交换，而外部排序涉及内、外存数据交换C.内部排序的速度快，而外部排序的速度慢D.内部排序所需的内存小，而外部排序所需的内存大  

02.下列关于外部排序的说法中，正确的是（）  

A.置换选择排序得到的初始归并段的长度一定相等B.内外存交换数据的时间只占总排序时间的一小部分C.败者树是一棵完全二叉树D.外部排序不涉及对文件的读/写操作  

03.多路平衡归并的作用是（）  

A.减少归并趟数B.减少初始归并段的个数C.便于实现败者树D.以上都对  

04.设在磁盘上存放有375000个记录，做5路平衡归并排序，内存工作区能容纳600个记录，为把所有记录排好序，需要做（）趟归并排序。  

A.3 B.4 C.5 D.6 05.在下列关于外部排序过程输入/输出缓冲区作用的叙述中，不正确的是（）  

A.暂存输入/输出记录B.内部归并的工作区C.产生初始归并段的工作区D.传送用户界面的消息  

06.在做 $m$ 路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置（ $\textcircled{\scriptsize{1}}$ 个输入缓冲区和（ $\circledcirc$ ）个输出缓冲区。  

$\textcircled{\scriptsize{1}}$ A.2B.mC.2m-1D.2m $\circledcirc$ A.2B.mC.2m-1D.2m  

07.若只需3趟排序就可完成64个元素的多路归并排序，则选取的归并路数最少是（）  

A.2K B.3 C.4 D.5  

08.置换-选择排序的作用是（）  

A.用于生成外部排序的初始归并段B.完成将一个磁盘文件排序成有序文件的有效的外部排序算法C.生成的初始归并段的长度是内存工作区的2倍D.对外部排序中输入/归并/输出的并行处理  

09.一个无序文件的 $n$ 个记录采用置换选择排序产生 $m$ 个有序段，则 $m$ 和 $n$ 的关系是（）A. $m$ 与 $n$ 成正比B. $m=\log_{2}\!n$ C. $m$ 与 $n$ 成反比D.以上都不对10.在由 $k$ 路归并构建的败者树中选取一个关键字最小的记录，则所需时间为（）A. $O(1)$ B.O(k)uC. $O({\log}k)$ D.以上都不对11.下列关于小顶堆和败者树的说法中，正确的是（）  

1.败者树从下往上维护，每上一层，只需和失败结点比较1次II.败者树的每次维护，必定要从叶结点一直走到根结点，不可能从中间停止  
IⅢI.堆从上往下维护，每下一层，若其左右孩子均不为空，则需比较2次IV.堆的每次维护，必定要从根结点一直走到叶结点，不可能从中间停止  

A.I、IⅢIB.IⅡI、IⅢIC.I、II、ⅢID.I、II、IV  

12.最佳归并树在外部排序中的作用是（）  

A.完成 $m$ 路归并排序B.设计 $m$ 路归并排序的优化方案C.产生初始归并段 D.与锦标赛树的作用类似  

13.在由 $m$ 个初始归并段构建的 $k$ 阶最佳归并树中，度为 $k$ 的结点个数是（）A. $(m-1)/k$ B.m/kC. $(m\!-\!1)/(k\!-\!1)$ D.无法确定  

14.【2013统考真题】已知三叉树  $T$  中6个叶结点的权分别是2，3，4,5，6,7，T的带权（外 部）路径长度最小是（）。  

A.27 B.46 C.54 D.56

 15.【2016统考真题】对10TB的数据文件进行排序，应使用的方法是（）。A.希尔排序 B.堆排序 C.快速排序 D.归并排序  

16.【2019统考真题】设外存上有120个初始归并段，进行12路归并时，为实现最佳归并，需要补充的虚段个数是（）。  

A.1 B.2 C.3 D.4  

# 二、综合应用题  

01.若某个文件经内部排序得到80个初始归并段，试问：  

1）若使用多路平衡归并执行3趟完成排序，则应取得的归并路数至少应为多少？2）若操作系统要求一个程序同时可用的输 $\mathrm{\sim}$ 输出文件的总数不超过15个，则按多路归并至少需要几趟可以完成排序？若限定这个趟数，可取的最低路数是多少？  

02.假设文件有4500个记录，在磁盘上每个块可放75个记录。计算机中用于排序的内存区可容纳450个记录。试问：1）可以建立多少个初始归并段？每个初始归并段有多少记录？存放于多少个块中？2）应采用几路归并？请写出归并过程及每趟需要读/写磁盘的块数。  

03.设初始归并段为(10,15,31),(9,20),(22,34,37),(6,15,42),(12,37),(84,95)。试利用败者树进行 $m$ 路归并，手工执行选择最小的5个关键字的过程。  

04.给出12个初始归并段，其长度分别为 $30,44,8,6,3,20,60,18,9,62,68,85.$ 现要做4路外归并排序，试画出表示归并过程的最佳归并树，并计算该归并树的带权路径长度WPL。  

05.【2023统考真题】对含有 $n$  $n>0$ ）个记录的文件进行外部排序，采用置换-选择排序生成初始归并段时需要使用一个工作区，工作区中能保存 $m$ 个记录。请回答：  

1)若文件中含有19个记录，其关键字依次是51,94,37,92,14,63,15,99,48,56,23,60,31，17,43.8.90.166,100，则当 $m=4$ 时，可生成几个初始归并段？各是什么？  

2）对任意的 $m$  $n\!\gg\!m>0$ )，生成的第一个初始归并段的长度最大值和最小值分别是多少?  

# 8.7.7 答案与解析  

# 一、单项选择题  

01.B 外部排序和内部排序最主要的区别是是否涉及内存、外存的数据交换。  

02.C  
置换选择排序得到的是长度不一定相等的归并段，A错误。外部排序的主要时间消耗在内外存之间的数据交换上，B错误。败者树是一棵完全二叉树，C正确。外部排序包括两个阶段：生成初始归并段和对初始归并段进行归并，这两个阶段都涉及对文件的读/写操作，D错误。  

03.A  

多路平衡归并的目的是减少归并趟数，因为当 $m$ 个初始归并段采用 $k$ 路平衡归并时，所需趟数  $s=\lceil\log_{k}m\rceil$  ，若不采用多路平衡归并，则其归并趟数大于  $s$  

04.B  

初始归并段的个数 $r=375000/600=625$ ，因此，归并趟数 $S=\!\lceil\log_{m}\!r\rceil\!=\!\lceil\log_{5}\!625\rceil\!=4$ 。第一趟把625个归并段归并成 $625/5=125$ 个；第二趟把125个归并段归并成 $125/5=25\$ 个；第三趟把25个归并段归并成  $25/5=5$  个；第四趟把5个归并段归并成  $5/5=1$  个。  

05.D  

在外部排序过程中输入/输出缓冲区就是排序的内存工作区，例如做 $m$ 路平衡归并需要 $m$ 个输入缓冲区和1个输出缓冲区，用以存放参加归并的和归并完成的记录。在产生初始归并段时也可用作内部排序的工作区。它没有传送用户界面的消息的任务。  

06.D、A  

相比普通的 $m$ 路归并：需增加一个输出缓冲区，当一个输出缓冲区满时，输出一个缓冲区的同时归并程序可向另一个输出缓冲区填充数据，这就实现了内部归并和输出的并行。需增加 $m$ 个输入缓冲区，当 $m$ 个输入缓冲区正在运行时，外部可向新增的 $m$ 个缓冲区写入数据，这就实现了输入和内部归并的并行。综上，需设置2个输出缓冲区， $2m$ 个输入缓冲区。  

07.C  

归并趟数 $\scriptstyle\stackrel{\cdot}{=}$  $\mathbf{\mu}=\left\lceil\log_{k}n\right\rceil$ ，其中 $k$ 表示归并的路数， $n$ 表示元素个数，当 $k=4$ 、 $n=64$ 时，归并趟数恰好等于3，因此选取的归并路数至少是4。  

08.A  

置换-选择排序是外部排序中生成初始归并段的方法，用此方法得到的初始归并段的长度是不等长的，其长度平均是传统等长初始归并段的2倍，从而使得初始归并段数减少到原来的近二分之一。但是，置换-选择排序不是一种完整的生成有序文件的外部排序算法。  

09.D  

设内存工作区 $w=1$ ，则文件{1,2,3,4,5}产生1个有序段，而文件{5,4,3,2,1}产生5个有序段，因此 $m$ 与待排文件、内存工作区大小 $w$ 和 $n$ 都有关，但不是A、B、C项描述的直接关系。  

10.D  

在败者树中选取最小关键字的时间复杂度取决于败者树的高度，所需时间为 $O(\log k)$  

11.D  

I正确，是败者树的性质。在败者树的维护过程中，会让胜利者一直调整到根结点，I1正确。以小根堆为例，每次调整时，先比较下一层的两个元素（1次），找出较小值，然后比较当前元素和下一层的较小元素（1次），以决定是否向下交换位置，ⅡI1正确。堆在维护时，可能会在中间某层停止（若此处无须调整），而不一定要走到叶结点，IV错误。  

12.B  

最佳归并树在外部排序中的作用是设计 $m$ 路归并排序的优化方案，仿照构造哈夫曼树的方法，以初始归并段的长度为权值，构造具有最小带权路径长度的 $m$ 叉哈夫曼树，可以有效地减少归并过程中的读/写记录数，加快外部排序的速度。  

13.C  

$k$ 阶最佳归并树中只有度为0和 $k$ 的结点。设结点总数为 $n$ ，度为0的结点数为 $n_{0}$ ，度为 $k$ 的结点数为 $n_{k},$ 则 $n_{0}\!=\!m$  $n\!-\!1\!=\!k\!\times\!n_{k}$  $n\!=\!n_{0}\!+n_{k}$ ，因此 $\scriptstyle{k\times n_{k}=m+n_{k}-1}$ ，求得 $n_{k}\!=(m-1)/(k\!-\!1),$  
14.B  

题中的三叉树为使WPL最小，必须构造三叉哈夫曼树，应满足 $(n_{0}\!-\!1)\%(3-1)\!=\!0$ 的条件，因此需添加1个权值为0的虚叶结点，说明7个叶结点刚好可构成一棵严格的三叉树。按照哈夫曼树的原则，权为0的叶结点应离树根最远，构造三叉哈夫曼树的过程如下：  

$\textcircled{\scriptsize{1}}$ 合并权值最小的三个结点0,2,3，得到新结点的权值 $=5$ ，剩下5,4.5.6,7。 $\circledcirc$ 合并权值最小的三个结点4，5，5，得到新结点的权值 $=14$ ，剩下14，6,7。 $\textcircled{3}$ 合并权值最小的三个结点6，7，14，得到新结点的权值 $=27$ ，仅有27，建树完成。  

${\mathrm{WPL=}}\sum_{1}^{n}$ 权值 $W_{n+i;i,j,i}\times$ 深度 $\begin{array}{r}{!D_{n+s+k i j}=(2+3){\times}3+(4+5){\times}2+(6+7){\times}1=46}\end{array}$  

或  

$$
\begin{array}{r}{\mathrm{WPL}\!=\!\sum_{i}^{m}\!\!\!\!\slash\!\!\!\mathbb{X}\!\left\{\!\!\mathbb{H}W_{\!\hat{\gamma}\!+\!\hat{\chi}\!\left\{\!\mathbb{H}W_{i\!j}\!+\!\hat{\chi}\!+\!\hat{\kappa}\!\right\}\!\!\right\}\!\!=\!27+14+5=46}\end{array}
$$  

每个分支结点的权值都累加了其下面所有分支结点的权值，因此采用第二种方法更方便。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/761fec12638927f96a7953aca068bb2474057195863cc8533c11f12119ec300e.jpg)  

15.D  

外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的目的。外部排序通常采用归并排序算法。A、B、C项都是内部排序的方法。  

16.B  

在12路归并树中只存在度为0和度为12的结点，设度为0的结点数、度为12的结点数和要补充的结点数分别为 $n_{0}$  $n_{12}$ 和 $n_{\psi}$ ，则有 $n_{\scriptscriptstyle0}=120\,+\,n_{\scriptscriptstyle\ddag|}$ ， $n_{\scriptscriptstyle0}=(12\!-\!1)n_{\scriptscriptstyle12}+\!1$ ，可得 $n_{12}=(120\,{-}1\,{+}\,n_{\psi})/(12\,{-}1)$ 因为结点数 $n_{12}$ 为整数，所以 $n_{\mp}$ 是使上式整除的最小整数，求得 $n_{\#}=2$ 。  

此外，题中为实现最佳归并，应满足12叉哈夫曼树， $n=120$  $m\!=\!12$ ，不满足 $(n-1)\%(m-1)\!=\!0$ 的条件，因此需要添加两个权值为0的叶结点，使得 $n=121$ ，才能满足条件。  

# 二、综合应用题  

01.【解答】  

1）设归并路数为 $m$ ，初始归并段个数 $r=80$ ，根据归并趟数计算公式 $S\!=\!\lceil\log_{m}\!r\rceil\!=\!\lceil\log_{m}\!80\rceil\!=$ 3，得 $\log_{m}\!80\!\leqslant\!3$ ， $m^{3}\!\geqslant\!80$ 。由此解得 $m{\gtrsim}5$ ，即应取的归并路数至少为5。  

2）设多路归并的归并路数为 $m$ ，需要 $m$ 个输入缓冲区和1个输出缓冲区。一个缓冲区对应一个文件，有 $m+1=15$ ，因此 $m=14$ ，可做14路归并。由 $S\!=\!\lceil\log_{m}\!r\rceil\!=\!\lceil\log_{14}\!80\rceil\!=\!2$ 即至少需要2趟归并可完成排序。若限定趟数为2，由 $S=\lceil\log_{m}\!80\rceil=2$ ，有 $80\!\leqslant\!m^{2}$ ，可取的最低路数为9。即要在2趟内完成排序，进行9路归并排序即可。  

02.【解答】  

1）文件有4500个记录，用于排序的内存区可容纳450个记录，可建立的初始归并段有 $4500/450=10$  个。每个初始归并段中有450个记录，存于  $450/75=6$  个块中。  

2）内存区可容纳6个块，可建立6个缓冲区，其中5个缓冲区用于输入，1个缓冲区用于输出，因此可采用5路归并，归并过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ea0271abdff5d80c703229c32e11a07fbd61b3f1692b4b5daf3ee4cb0748da5.jpg)  

共做了2趟归并，每趟需要读60块、写60块。  

03.【解答】  

做6路归并排序，选择最小的5个关键字的败者树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/70cf272dc093f3cdbd0fbe2f862cf089af6f92b42e39d25ae1acc8420688e1be.jpg)  

04.【解答】  

设初始归并段个数 $n=12$ ，外归并路数 $k\!=\!4$ ，计算 $(n-1)\%(k-1)=11\%3=2\neq0$ ，说明不能做完全的4路归并，因为多出了两个初始归并段，必须添加 $k\!-\!2-\!1=1$ 个长度为0的空归并段，才能构成严格的4路归并树，即每次归并都有 $k$ 个归并段参加归并。  

此时，归并树的内结点应有 $(n-1+1)/(k-1)=12/3=4$ 个，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4ad5518f64fb36d9ebbd5e3f05f8de61e8848933add9bbd3138da133fa311627.jpg)  

$\mathrm{WPL}=(3+6+8)\times3+(9+18+20+30+44+60+62)\times2+(68+85)\times1=51+486+153=6$  590  

05.【解答】  

1）当文件中的 $n$ 个记录升序排列时，只生成一个归并段，长度达到最大，为 $n$ 。若初始工作区内的 $m$ 个元素都大于输入文件中剩下的所有记录，则第一个归并段的长度就为 $m$ ，此时为第一个归并段长度最小的情况。排序过程如下表所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f0ab4e2407d1c4dcd015077c8ec0ce880d41962100a754c5b17f10d7a0cbb996.jpg)  
生成三个初始归并段，分别是37,51,63,92,94,99；14,15,23,31,48,56,60,90,166；8,17,43,100。2）最大值为 $n$ ，最小值为 $m$  

# 归纳总结  

下面对本章所介绍的排序算法进行一次系统的比较和复习。  

1．直接插入排序、冒泡排序和简单选择排序是基本的排序算法，它们主要用于元素个数 $n$ 不是很大 ( $n<10000$ ）的情形。  

它们的平均时间复杂度均为 $O(n^{2})$ ，实现也都非常简单。直接插入排序对于规模很小的元素序列（ $_{,n\leqslant25}$ ）非常有效。它的时间复杂度与待排序元素序列的初始排列有关。在最好情况下，直接插入排序只需要 $n-1$ 次比较操作就可以完成，且不需要交换操作。在平均情况下和最差情况下，直接插入排序的比较和交换操作都是 $O(n^{2})$ 。冒泡排序在最好情况下只需要一趟排序过程就可以完成，此时也只需要 $n\!-\!1$ 次比较操作，不需要交换操作。简单选择排序的关键字比较次数与待排序元素序列的初始排列无关，其比较次数总是 $O(n^{2})$ ，但元素移动次数则与待排序元素序列的初始排列有关，最好情况下数据不需要移动，最坏情况下元素移动次数不超过 $3(n-1)$  

从空间复杂度来看，这三种基本的排序算法除一个辅助元素外，都不需要其他额外空间。从稳定性来看，直接插入排序和冒泡排序都是稳定的，但简单选择排序不是。  
2.对于中等规模的元素序列（ $n{\leqslant}1000$ ），希尔排序是一种很好的选择。  

在希尔排序中，开始时增量较大，分量较多，每个组内的记录数较少，因而记录的比较和移动次数较少，且移动距离较远；到后来步长越来越小（最后一步为1），分组越少，每个组内的记录数越多，但同时记录次序也越来越接近有序，因而记录的比较和移动次数也都比较少。从理论上和实验上都已证明，在希尔排序中，记录的总比较次数和总移动次数比直接插入排序时少得多，特别是当 $n$ 越大时效果越明显。而且，希尔排序代码简单，基本上不需要什么额外内存，但希尔排序是一种不稳定的排序算法。  

3.对于元素个数 $n$ 很大的情况，可以采用快速排序、堆排序、归并排序或基数排序，其中快速排序和堆排序都是不稳定的，而归并排序和基数排序是稳定的排序算法。  

快速排序是最通用的高效内部排序算法，特别是它的划分思想经常在很多算法设计题中出现。平均情况下它的时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，一般情况下所需要的额外空间也是 $O(\log_{2}n)$ 。但是快速排序在有些情况下也可能会退化（如元素序列已经有序时），时间复杂度会增加到 $O(n^{2})$ ，空间复杂度也会增加到 $O(n)$ 。但我们可以通过“三者取中”法来避免最坏情况的发生。  

堆排序也是一种高效的内部排序算法，它的时间复杂度是 $O(n\mathrm{log}_{2}n)$ ，而且没有什么最坏情况会导致堆排序的运行明显变慢，并且堆排序基本上不需要额外的空间。但堆排序不大可能提供比快速排序更好的平均性能。  

归并排序也是一个重要的高效排序算法，它的一个重要特性是性能与输入元素序列无关，时间复杂度总是 $O(n\mathrm{log}_{2}n)$ 。归并排序的主要缺点是需要 $O(n)$ 的额外存储空间。  

基数排序是一种相对特殊的排序算法，这类算法不仅是对元素序列的关键字进行比较，更重要的是它们对关键字的不同位部分进行处理和比较。虽然基数排序具有线性增长的时间复杂度，但由于在常规编程环境中，基数排序的线性时间开销实际上并不比快速排序的时间开销小很多，并且由于基数排序基于的关键字抽取算法受到操作系统和排序元素的影响，其适应性远不如普通的进行比较和交换操作的排序算法。因此，在实际工作中，常规的高效排序算法如快速排序的应用要比基数排序广泛得多。基数排序需要的额外存储空间包括和待排序元素序列规模相同的存储空间及与基数数目相等的一系列桶（一般用队列实现）。  

# 4.混合使用。  

我们可以混合使用不同的排序算法，这也是得到普遍应用的一种算法改进方法，例如，可以将直接插人排序集成到归并排序的算法中。这种混合算法能够充分发挥不同算法各自的优势，从而在整体上得到更好的性能。  

# 思维拓展  

下面是一道看起来很吓人的题目：对 $n$ 个整数进行排序，要求时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

提示：假设待排序整数的范围为 $0\sim65535$ ，设定一个数组intcount[65535]并初始化为0，则所需空间与  $n$  无关，为  $O(1)$  。扫描一遍待排序列x[]，count[α[i]]++，时间复杂度为  $O(n)$  再 扫描一次count[]，当count[i] ${>}0$ 时，输出count[i]个i，排序完毕所需的时间复杂度也为 $O(n)$ ；所以总的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1).$ 另外，读者可能会问假如有负整数怎么办，这种情况下可以给所有整数都加上一个偏移量，使之都变成正整数，再使用上述方法即可。  
# 参考文献  

[1]严蔚敏，吴伟民.数据结构（C语言版）[M].北京：清华大学出版社，2018.

[2]托马斯·科尔曼，查尔斯·雷瑟尔森，罗纳德·李维斯特，等.算法导论[M].北京：机械工业出版社，2013.

[3]李春葆，陈良臣，尹为民，等，数据结构教程（C++语言描述）[M].北京：清华大学出版社，2009.

[4]陈守孔，胡潇琨，李玲，算法与数据结构考研试题精析[M]：北京：机械工业出版社，2007.

[5]夏清国.数据结构考研教案[M].西安：西北工业大学出版社，2006.

[6]本书编写组.全国硕士研究生入学统一考试计算机专业基础综合考试大纲解析[M]：北京：高等教育出版社，2023.  

[7]李春葆，尹为民，陈良臣.数据结构联考辅导教程[M].北京：清华大学出版社，2010  
