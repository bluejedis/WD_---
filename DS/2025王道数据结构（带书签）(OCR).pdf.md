# 1.1.4 答案与解析  

# 一、单项选择题  

01.D  

抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用（数据对象，数据关系，基本操作集）这样的三元组来表示，从而可构成一个完整的数据结构定义。  

02.A  

树和图是典型的非线性数据结构，其他选项都属于线性数据结构。  

03.C  

顺序表、哈希表和单链表是三种不同的数据结构，既描述逻辑结构，又描述存储结构和数据运算。而有序表是指关键字有序的线性表，仅描述元素之间的逻辑关系，它既可以链式存储，又可以顺序存储，所以属于逻辑结构。  

04.A  

数据的逻辑结构是从面向实际问题的角度出发的，只采用抽象表达方式，独立于存储结构，数据的存储方式有多种不同的选择；而数据的存储结构是逻辑结构在计算机上的映射，它不能独立于逻辑结构而存在。数据结构包括三个要素，缺一不可。  

05.C  

在存储数据时，不仅要存储数据元素的值，而且要存储数据元素之间的关系。  

# 二、综合应用题  

01.【解答】  

应该注意到，数据的运算也是数据结构的一个重要方面，  

- 对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同
  - 二叉树和二叉排序树 
    1. 结构特点
    - 两者在物理结构和逻辑结构上完全相同
    - 二叉排序树直接使用二叉树的表示方式和存储结构

    2. 应用目的
    - 二叉树：主要用于表示层次关系
    - 二叉排序树：专门用于排序和查找

    3. 基本操作
    两者都支持以下基本操作:
    - 建立树结构
    - 插入新节点
    - 删除已有节点  
    - 查找特定节点

    4. 性能区别
    以查找操作为例:
    - 二叉树:需要遍历整棵树,平均时间复杂度为O(n)
    - 二叉排序树:利用节点的有序性,平均时间复杂度为O(log₂n)

02.【解答】  

- 线性表
  - 在顺序存储方式下，插入和删除元素
    - 平均要移动近一半的元素，时间复杂度为 $O(n)$ ；
  - 在链式存储方式下
    - 插入和删除的时间复杂度都是 $O(1)$  



# 1.2.4 答案与解析  

# 一、单项选择题  

01.B  

- 算法定义相关
  - 程序不一定满足有穷性(如死循环、操作系统等)
  - 算法必须有穷
  - 算法代表对问题求解步骤的描述
  - 程序是算法在计算机上的特定实现
  - 选项C只是算法的必要条件，不能成为算法的定义

02.C  

- 时间复杂度分析
  - 时间复杂度为 $O(n^2)$ 表示算法的时间复杂度 $T(n)$ 满足 $T(n) \leq cn^2$ (c为比例常数)
  - 时间复杂度 $T(n)$ 是问题规模 $n$ 的函数
  - 问题规模仍然是 $n$ 而不是 $n^2$

03.B  

- 空间复杂度说明
  - 空间复杂度为 $O(1)$ 表示执行算法所需辅助空间大小相对输入数据规模是常量
  - 不表示算法执行时不需要任何空间或辅助空间

04.D  

- 不同算法的时间复杂度分析
  - A: 最高阶是 $n\log_2n$，时间复杂度是 $O(n\log_2n)$
  - B: 最高阶是 $n^2$，时间复杂度是 $O(n^2)$
  - C: 最高阶是 $n\log_2n$，时间复杂度是 $O(n\log_2n)$
  - D: 最高阶是 $\log_2n$，时间复杂度是 $O(\log_2n)$

05.D  

- 算法分析
  - 基本运算: $i = i \times 2$
  - 执行条件: $2^t \leq n$，即 $t \leq \log_2n$
  - 时间复杂度: $T(n) = O(\log_2n)$

06.C  

- 基本运算分析
  - 基本运算为 $i++$
  - 执行次数 $t$ 满足: $t^3 \leq n$
  - 因此 $t \leq \sqrt[3]{n}$
  - 时间复杂度: $T(n) = O(\sqrt[3]{n})$

07.D  

- 冒泡排序分析
  - 最坏情况下的元素交换次数
  - 当所有相邻元素都为逆序时
  - 时间复杂度计算:
    $T(n) = \sum_{i=2}^{n-1}\sum_{j=1}^{i-1}1 = \sum_{i=2}^{n-1}(i-1) = (n-2)(n-1)/2 = O(n^2)$

08.A  

- 条件判断语句的时间复杂度
  - 取分支路径上的最大时间复杂度

09.A  

- 执行次数分析
  - m++语句的执行次数:
    $\sum_{i=1}^{n}\sum_{j=1}^{2i}1 = \sum_{i=1}^{n}2i = 2\sum_{i=1}^{n}i = n(n+1)$

10.C  

- 递归调用分析
  - 基本语句: if(==1) return 1
  - 递归次数 $t$ 满足: $2^t \leq n$，即 $t \leq \log_2n$
  - 总执行次数: $T = \log_2n \times 1$
  - 时间复杂度: $O(\log_2n)$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/aa8dedd06a9f028de2264878353fdb08edfddc818067525979b9fba87b412c3f.jpg)

11.A

- 时间复杂度分析
  - 基本运算为 $x = 2x$
  - 每执行一次，x乘以2
  - 设执行次数为t，则有 $2^{t+1} < n/2$
  - 所以 $t < \log_2(n/2)-1 = \log_2n-2$
  - 得出时间复杂度 $T(n) = O(\log_2n)$

12.B

- 递归调用分析
  - 递归调用可视为多重循环
  - 基本语句: if(n <= 1) return 1
  - 执行n次递归调用
  - 总执行次数 $T = 1 + 1 + \cdots + 1 = n$
  - 时间复杂度为 $O(n)$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3ab9ce82545c510a967e2aa7380a6cff1ac13187c9ce99d37eb227b11041d1ad.jpg)

13.C

- 多层循环分析
  - 单层循环转换
    - for(j=1; j<=n; j++) sum++
    - 执行次数为n
  - 循环变量幂次分析
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a400bc01830453167d54fa241d4b38f2db460ad45444a287364591b203b67ae3.jpg)
  - 外层循环条件 $k \leq n$
  - 循环结束时 $2^t \leq n < 2^{t+1}$，即 $t \leq \log_2n$
  - 总执行次数 $T = n(t+1) = n(\log_2n+1)$
  - 时间复杂度为 $O(n\log_2n)$

14.B

- 基本运算分析
  - 基本运算为 sum += ++i
  - 等价于 ++i; sum = sum+i
  - 执行过程分析:
    - i=1时，sum = 0+1
    - i=2时，sum = 0+1+2
    - i=3时，sum = 0+1+2+3
  - 得出 sum = (1+i)×i/2
  - 循环次数t满足 $(1+t)×t/2 < n$
  - 时间复杂度为 $O(n^{1/2})$

> attention 统考真题中常将 $\log_2$ 书写为log，此时默认底数为2。

15.B

- 循环终止条件分析
  - 第k次循环终止时 $(x+1)^2 > n$
  - x的初始值为0
  - 第k次判断时 x = k-1
  - 即 $k^2 > n$，$k > \sqrt{n}$
  - 时间复杂度为 $O(\sqrt{n})$

16.B

- 多层循环分析
  - 单层循环示例
    - for(i=0; i<=i; i++) sum++;
    - 执行次数为i
  - 循环变量幂次分析
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ee2c2b9c81f65e302f00979b05a9498bd4beda72833e193092a1a2853947da0.jpg)
  - 外层循环条件 i<n
  - 循环变量幂次t满足 $2^t < n \leq 2^{t+1}$
  - 总执行次数 $T = 1 + 2^1 + 2^2 + \dots + 2^t = 2^{t+1}-1$
  - 即 $n-1 \leq T < 2n-1$
  - 时间复杂度为 $O(n)$
# 二、综合应用题  

01.【解答】

- 时间复杂度分析
  - 第一种情况
    - 基本语句 $k = k + 10 \times i$ 执行 $n-2$ 次
    - 时间复杂度 $T(n) = O(n)$
  
  - 第二种情况
    - 设循环体执行 $t$ 次
    - 每次循环变量 $y$ 增加1
    - 最终 $t = y$
    - 满足 $t^2 \leq n$
    - 时间复杂度 $T(n) = O(\sqrt{n})$
  
  - 第三种情况
    - 内循环执行 $m$ 次
    - 外循环执行 $n$ 次 
    - 根据乘法原理总执行次数为 $m \times n$
    - 时间复杂度 $T(m,n) = O(mn)$


# 2.1.4 答案与解析  

# 单项选择题  

01.C
- 线性表的组成
  - 由具有相同数据类型的有限数据元素组成
  - 数据元素是由数据项组成的

02.B
- 线性表定义的要求
  - 相同数据类型
  - 有限序列
- 选项分析
  - 选项C：元素个数无穷个，错误
  - 选项A：集合中元素无前后驱关系，错误
  - 选项D：属于存储结构而非具体线性表，错误
  - 选项B：符合线性表定义要求

03.A
- 线性表元素的关系
  - 除最后一个元素外，每个元素只有一个后继
  - 除第一个元素外，每个元素只有一个前驱

04.A
- 线性表特殊元素的特点
  - 第一个元素：无直接前驱
  - 最后一个元素：无直接后继
  - 仅有一个元素时：既无直接前驱，又无直接后继



# 2.2.4 答案与解析  

# 一、单项选择题  

01.A
- 顺序表的优点
  - 存储密度较大，不需存放指针域
  - 选项B和C是链表的优点
  - 选项D错误，树形结构更适合链表表示

02.C
- 顺序表的特点
  - 必须连续存放相同类型元素
  - 与一维数组的区别
    - 数组元素可不连续存放
    - 数组可表示其他逻辑结构(栈、队列、树等)
  - 逻辑相邻元素物理位置也相邻

03.A
- 存取方式特点
  - 支持随机存取
  - 可根据起始地址加元素序号访问任意元素

04.C
- 随机存取特性
  - 访问第 $i$ 个元素时间为 $O(1)$
  - 访问时间与元素个数 $n$ 无关

05.B
- 存储空间影响因素
  - 表长
  - 元素类型大小
  - 结构体各字段类型(若元素为结构体)

06.D
- 快速存取相邻元素分析
  - 顺序表：$O(1)$ 时间复杂度
  - 其他选项：$O(n)$ 时间复杂度，需从头结点查找

07.A
- 顺序表操作特点
  - 支持随机存取
  - 末尾插入删除无需移动元素

08.C
- 操作时间复杂度分析
  - 末尾插入：$O(1)$
  - 删除操作：$O(n)$，需移动后续元素
  - 插入操作：$O(n)$，需移动 $n-i$ 个结点

09.C
- 操作效率比较
  - 交换操作：顺序表3次，链表需多次操作
  - 顺序访问：两者时间复杂度相同

10.C
- 删除元素移动分析
  - 需移动元素个数：$n-i$ 个
  - 涉及元素：$a_{i+1}$ 到 $a_n$

11.C
- 插入操作分析
  - 移动元素个数：$n-i+1$
  - 时间复杂度：$O(n)$

12.C
- 操作时间复杂度
  - 排序：最小 $O(n)$，通常 $O(n\log_2n)$ 或 $O(n^2)$
  - 支持随机存取

13.B
- 序号特点
  - 线性表序号从1开始
  - 第 $n+1$ 位置插入等同表尾追加

14.D
- 存储空间扩展
  - 需申请 $n+m$ 个连续空间
  - 复制原有 $n$ 个元素到新空间

15.D
- 有序表操作复杂度
  - 查找：$O(\log n)$（折半查找）
  - 插入：$O(n)$
  - 删除：$O(n)$
  - 按位置访问：$O(1)$
# 二、综合应用题  

01.【解答】
- 删除最小值元素
  - 算法思想
    - 搜索整个顺序表找最小值元素位置
    - 用最后一个元素填补空出位置
  - 代码实现

bool Del Min(SqList &L,ElemType &value) {
    if(L.length == 0) return false;
    value = L.data[0];
    int pos = 0;
    for(int i=1; i<L.length; i++) {
        if(L.data[i]<value){
            value = L.data[i];
            pos = i;
        }
    }
    L.data[pos] = L.data[L.length-1];
    L.length--;
    return true;
}


> attention 本题也可用函数返回值返回，两者的区别是：函数返回值只能返回一个值，而参数返回（引用传参）可以返回多个值。

02.【解答】
- 逆置顺序表
  - 算法思想
    - 扫描前半部分元素
    - 将L.data[i]与L.data[L.length-i-1]交换
  - 代码实现

void Reverse(SqList &L){
    ElemType temp;
    for(int i=0; i<L.length/2; i++) {
        temp = L.data[i];
        L.data[i] = L.data[L.length-i-1];
        L.data[L.length-i-1] = temp;
    }
}


03.【解答】
- 删除值为x的元素
  - 解法1
    - 用k记录不等于x的元素个数
    - 扫描时将不等于x的元素前移
  - 代码实现1

void delx1(SqList &L,ElemType x){
    int k = 0;
    for(int i=0; i<L.length; i++) {
        if(L.data[i] != x) {
            L.data[k] = L.data[i];
            k++;
        }
    }
    L.length = k;
}

  - 解法2  
    - 用k记录等于x的元素个数
    - 扫描时将不等于x的元素前移k位
  - 代码实现2

void delx2(SqList &L,ElemType x){
    int k = 0;
    int i = 0;
    while(i < L.length) {
        if(L.data[i] == x)
            k++;
        else
            L.data[i-k] = L.data[i];
        i++;
    }
    L.length = L.length-k;
}


04.【解答】
- 删除s到t之间的元素
  - 算法思想
    - 用k记录s到t之间元素个数
    - 不在区间内的元素前移k位
  - 代码实现

bool Del_s_t(SqList &L,ElemType s,ElemType t){
    int i, k=0;
    if(L.length==0 || s>=t)
        return false;
    for(i=0; i<L.length; i++) {
        if(L.data[i]>=s && L.data[i]<=t)
            k++;
        else
            L.data[i-k] = L.data[i];
    }
    L.length -= k;
    return true;
}


05.【解答】
- 删除有序表中重复元素
  - 算法思想
    - 将第一个元素视为非重复有序表
    - 依次判断后续元素是否与前面最后一个元素相同
  - 代码实现

bool Delete_Same(SeqList& L){
    if(L.length == 0) return false;
    int i, j;
    for(i=0,j=1; j<L.length; j++) {
        if(L.data[i] != L.data[j])
            L.data[++i] = L.data[j];
    }
    L.length = i+1;
    return true;
}


06.【解答】
- 合并两个有序表
  - 算法思想
    - 比较两表表头取较小者
    - 剩余部分直接加入新表
  - 代码实现

bool Merge(SeqList A,SeqList B,SeqList &C){
    if(A.length+B.length>C.maxSize)
        return false;
    int i=0, j=0, k=0;
    while(i<A.length && j<B.length) {
        if(A.data[i] <= B.data[j])
            C.data[k++] = A.data[i++];
        else
            C.data[k++] = B.data[j++];
    }
    while(i<A.length)
        C.data[k++] = A.data[i++];
    while(j<B.length)
        C.data[k++] = B.data[j++];
    C.length = k;
    return true;
}


07.【解答】
- 算法思想
  - 将数组A[m+n]中全部元素原地逆置
  - 对前n个元素和后m个元素分别使用逆置算法
  - 实现顺序表的位置互换

typedef int DataType;
void Reverse(DataType A[], int left, int right, int arraySize) {
    if(left >= right || right >= arraysize) return;
    int mid = (left+right)/2;
    for(int i=0; i <= mid-left; i++) {
        DataType temp = A[left+i];
        A[left+i] = A[right-i];
        A[right-i] = temp;
    }
}

void Exchange(DataType A[], int m, int n, int arraySize) {
    Reverse(A,0,m+n-1,arraySize);
    Reverse(A,0,n-1,arraySize);
    Reverse(A,n,m+n-1,arraysize);
}

08.【解答】
- 算法思想
  - 顺序存储的线性表递增有序
  - 可以顺序查找或折半查找
  - 要求最少时间查找，应使用折半查找法

void SearchExchangeInsert(ElemType A[], ElemType x) {
    int low=0, high=n-1, mid;
    while(low <= high) {
        mid = (low+high)/2;
        if(A[mid] == x) break;
        else if(A[mid] < x) low = mid+1;
        else high = mid-1;
    }
    if(A[mid] == x && mid != n-1) {
        ElemType t = A[mid];
        A[mid] = A[mid+1];
        A[mid+1] = t;
    }
    if(low > high) {
        for(int i=n-1; i>high; i--)
            A[i+1] = A[i];
        A[high+1] = x;
    }
}

09.【解析】
- 算法基本设计思想
  - 使用三个下标变量从小到大遍历数组
  - 当三个下标变量指向元素相等时，输出并向前推进指针
  - 否则仅移动小于最大元素的下标变量
  - 直到某个下标变量移出数组范围停止

void samekey(int A[], int B[], int C[], int n) {
    int i=0, j=0, k=0;
    while(i<n && j<n && k<n) {
        if(A[i] == B[j] && B[j] == C[k]) {
            printf("%d\n", A[i]);
            i++; j++; k++;
        } else {
            int maxNum = max(A[i], max(B[j], C[k]));
            if(A[i] < maxNum) i++;
            if(B[j] < maxNum) j++;
            if(C[k] < maxNum) k++;
        }
    }
}

10.【解答】
- 算法基本设计思想
  - 将问题视为把数组ab转换成数组ba
  - 先将a逆置得到$a^{-1}b$
  - 再将b逆置得到$a^{-1}b^{-1}$
  - 最后将整个$a^{-1}b^{-1}$逆置得到$(a^{-1}b^{-1})^{-1}=ba$

void Reverse(int R[], int from, int to) {
    int i, temp;
    for(i=0; i<(to-from+1)/2; i++) {
        temp = R[from+i];
        R[from+i] = R[to-i];
        R[to-i] = temp;
    }
}

void Converse(int R[], int n, int p) {
    Reverse(R,0,p-1);
    Reverse(R,p,n-1);
    Reverse(R,0,n-1);
}

11.【解答】
- 算法基本设计思想
  - 分别求两个升序序列A、B的中位数a和b
  - 若$a=b$，则a或b即为所求中位数
  - 若$a<b$，舍弃A中较小一半和B中较大一半
  - 若$a>b$，舍弃A中较大一半和B中较小一半
  - 重复上述过程直到两序列各只含一个元素

int MSearch(int A[], int B[], int n) {
    int s1=0, d1=n-1, m1, s2=0, d2=n-1, m2;
    while(s1!=d1 || s2!=d2) {
        m1 = (s1+d1)/2;
        m2 = (s2+d2)/2;
        if(A[m1] == B[m2]) return A[m1];
        if(A[m1] < B[m2]) {
            if((s1+d1)%2 == 0) {
                s1 = m1;
                d2 = m2;
            } else {
                s1 = m1+1;
                d2 = m2;
            }
        } else {
            if((s1+d1)%2 == 0) {
                d1 = m1;
                s2 = m2;
            } else {
                d1 = m1;
                s2 = m2+1;
            }
        }
    }
    return A[s1]<B[s2] ? A[s1] : B[s2];
}

12.【解答】
- 算法基本设计思想
  - 选取候选主元素
    - 扫描数组记录第一个整数及其出现次数
    - 遇到相同数计数加1，不同数计数减1
    - 计数为0时重新选取候选元素
  - 判断候选元素是否为主元素
    - 再次扫描统计出现次数
    - 若大于n/2则为主元素
    - 否则不存在主元素

int Majority(int A[], int n) {
    int i, c, count=1;
    c = A[0];
    for(i=1; i<n; i++) {
        if(A[i] == c)
            count++;
        else if(count > 0)
            count--;
        else {
            c = A[i];
            count = 1;
        }
    }
    if(count > 0) {
        for(i=count=0; i<n; i++)
            if(A[i] == c)
                count++;
        if(count > n/2)
            return c;
    }
    return -1;
}

13.【解答】
- 算法基本设计思想
  - 采用空间换时间策略
  - 分配标记数组B[n]记录1~n是否出现
  - 遍历A标记出现的正整数
  - 扫描B找到第一个未标记位置
  - 返回结果为未标记位置+1

int findMissMin(int A[], int n) {
    int i, *B;
    B = (int *)malloc(sizeof(int)*n);
    memset(B,0,sizeof(int)*n);
    for(i=0; i<n; i++)
        if(A[i]>0 && A[i]<=n)
            B[A[i]-1] = 1;
    for(i=0; i<n; i++)
        if(B[i] == 0)
            break;
    return i+1;
}

14.【解答】
- 分析
  - 当$a=b=c$时距离最小
  - 其他情况下关键是a和c之间的距离
  - 问题简化为固定c找合适的a使$|c-a|$最小

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d6964726b38ffa443e58331e9e888368e3ccb0103edcae2ddb0866240cdc33b.jpg)

- 算法基本设计思想
  - 使用$D_{min}$记录最小距离
  - 三个集合分别存在数组A、B、C中
  - 循环比较并更新最小距离
  - 移动最小值的下标寻找更小距离

#define INT_MAX 0x7fffffff
int abs_(int a) {
    if(a < 0) return -a;
    else return a;
}

bool xls_min(int a, int b, int c) {
    if(a < b && a < c) return true;
    return false;
}

int findMinOfTrip(int A[], int n, int B[], int m, int C[], int p) {
    int i=0, j=0, k=0, Dmin=INT_MAX, D;
    while(i<n && j<m && k<p && Dmin>0) {
        D = abs_(A[i]-B[j]) + abs_(B[j]-C[k]) + abs_(C[k]-A[i]);
        if(D < Dmin) Dmin = D;
        if(xls_min(A[i],B[j],C[k])) i++;
        else if(xls_min(B[j],C[k],A[i])) j++;
        else k++;
    }
    return Dmin;
}


# 2.3.8 答案与解析  

# 一、单项选择题  

01.B
- 存储结构比较
  - 不能简单比较优劣
  - 链式存储优点
    - 用指针表示逻辑结构更灵活
    - 插入删除效率高
  - 顺序存储特点
    - 支持随机存取和顺序存取
    - 链式结构只能顺序存取

02.B
- 存储结构选择
  - 散列存储不适合表示逻辑关系
  - 链式存储优势
    - 方便表示各种逻辑关系
    - 插入删除时间复杂度为 $O(1)$

03.A
- 链式存储特点
  - 结点间存储空间可不连续
  - 结点内存储单元必须连续

04.D
- 存储结构特性分析
  - 顺序存储适用于图和树
  - 删除表尾结点需遍历找前驱
  - 循环单链表特点
    - 最后结点指向头结点
    - 不存在空指针
  - 有序单链表查找插入位置时间复杂度为 $O(n)$
  - 队列操作效率
    - 带尾指针循环链表适合队列操作
    - 插入删除时间复杂度为 $O(1)$

05.A
- 不同操作效率比较
  - 单链表和顺序表时间复杂度均为 $O(n)$
  - 单链表无需移动元素效率更高

06.C
- 链表插入操作
  - s插入后g为前驱
  - p为后继

> attention:  

可能有读者认为选项C中的两条语句交换后才正确。实际上，因为本题插入位置的前后结点都有指针指示（这与前面介绍的插入操作是不同的），所以选项C中的语句顺序并不会造成断链。在此提醒读者在学习过程中一定要多动脑思考，而不要生搬硬套。

07.D
- 有序链表建立方法比较
  - 边建立边插入排序
    - 每次插入需遍历寻找位置
    - 时间复杂度 $O(n^2)$
  - 先排序后建立链表
    - 排序时间复杂度 $O(n\log_2n)$
    - 建表时间复杂度 $O(n)$
    - 总时间复杂度 $O(n\log_2n)$

08.C
- 链表连接操作
  - 遍历长度为 $m$ 的链表找尾结点
  - 将尾结点next指向另一链表首结点
  - 时间复杂度 $O(m)$

09.C
- 头结点设置目的
  - 统一插入删除算法
    - 无需特判第一个元素
  - 统一空表非空表处理
    - 头指针始终非空
    - 指向头结点位置固定

10.B
- 删除最后结点分析
  - 需要遍历找前驱结点
  - 时间复杂度 $O(n)$
  - 与表长相关

11.B，A
- 带头结点单链表判空条件
  - 头指针head指向头结点
  - 头结点next域指向第一个元素结点
  - head->next == NULL表示空表

- 不带头结点单链表判空条件
  - head直接指向第一个元素结点
  - head == NULL表示空表

12.D
- 线性表存储结构比较
  - 链式存储：删除 $a_{50}$ 不需移动元素
  - 顺序存储：需移动50个元素

13.B
- 头插法建立单链表特点
  - 数组后面元素插入链表最前端
  - 链表元素次序与数组相反

14.C
- 双链表优点分析
  - 可方便访问前驱和后继
  - 删除和插入数据方便

15.D
- 双链表插入操作步骤
  - p前一结点next域指向q
  - q的next域指向p
  - q的prior域指向p的前一结点
  - p的prior域指向q

16.A
- 双链表删除操作要点
  - 将p的前后两结点链接
  - 保证修改过程不断链

17.A
- 双链表指针修改顺序
  - 先执行q->next指向结点C
  - 再执行p->next和p->next->prior的修改

18.C
- 双链表插入结点修改指针域
  - 新结点前驱指向第一个结点
  - 新结点后继指向第二个结点
  - 第一个结点后继指向新结点
  - 第二个结点前驱指向新结点

19.B
- 有序单链表插入操作
  - 查找第一个大于x的结点前驱p
  - 在p之后插入结点
  - 查找时间复杂度 $O(n)$
  - 插入时间复杂度 $O(1)$
  - 总时间复杂度 $O(n)$

20.D
- 单链表与双链表比较
  - 插入删除都不需移动元素
  - 双链表修改指针操作更复杂
  - 双链表可快速访问前驱后继结点
21.C
- 带头结点循环单链表空表判断
  - 满足L->next = L
  - 头结点指针域与L值相等
  - 不存在空指针

22.D
- 循环双链表判空条件
  - 头结点prior和next域指向自身

23.A
- 链表末尾操作效率分析
  - 带头结点双循环链表寻找尾结点时间最少

24.C
- 链表操作时间复杂度分析
  - 删除尾结点需找前驱，时间复杂度O(n)
  - 删除首结点通过尾结点prior找到，时间复杂度O(n)
  - C选项四种算法时间复杂度均为O(1)

25.B
- 循环单链表合并要求
  - O(1)时间头尾相接
  - 两个指针需指向尾结点

26.A
- 循环单链表删除首元结点分析
  - 带头结点：删除时间O(1)
  - 不带头结点
    - 有表尾指针：时间O(1)
    - 只有表头指针：时间O(n)

27.D
- 循环单链表特性
  - 空表：head->next = head
  - 一个元素：head->next->next = head

28.D
- 双链表删除操作时间复杂度
  - 删除首结点：O(1)
  - 非循环双链表删除尾结点：O(n)
  - 循环双链表删除尾结点：O(1)

29.D
- 链表操作时间复杂度分析
  - 单循环链表
    - 尾部插入：O(n)
    - 删除首元素：O(n)
  - 双链表
    - 一种操作O(n)
    - 另一种操作O(1)
  - 有尾指针时均为O(1)

30.B
- 静态链表特点
  - 预先分配连续空间
  - 插入删除不需移动元素

31.B
- 静态链表性质
  - 存储空间顺序分配
  - 元素存储非顺序
  - 查找需按链依次进行
  - 插入删除不需移动元素
  - 存储空间一次性申请
  - 可能造成空间浪费

32.D
- 链表操作正确性分析
  - A错误：p前驱结点后继指向自身
  - B、C错误：p后继结点前驱指向自身
  - D正确

33.D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b55a688d62e061aac2783fc9eb75defada7af6550a63e9c7b42b9d53b37c3156.jpg)
- 单链表结构分析
  - a指向f：1014H
  - e指向b：1004H
  - f指向e：1010H

34.D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40ecdba2635a5405a27a716a55ab619dbad757661cefd9ea9abd3703ec340d62.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb89761bdf04ec2379266087a002c11425642f0f57076c13332cc656353865a7.jpg)
- 循环单链表删除首元素步骤
  - 临时指针q指向待删结点
  - 断开链接：h->next = q->next
  - 特殊情况处理：
    - 只有一个元素时
    - 删除后尾指针指向头结点

35.C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16abd2a2bd12a95c373225b152f3441b03f18d02706ed28c57dc271185f3bdb2.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e0e53bff60da6a9d34e202f5bf9321d9e9f0a18db590b023d5ecaeaa3d68a085.jpg)
- 链表插入操作分析
  - A错误：s->next->prev = p
  - B错误：p->next->prev = s
  - D错误：两句代码均错
  - C正确：满足插入要求
# 二、综合应用题  

01.【解答】

- 解法1：删除值为x的结点
  - 算法思路
    - 用p从头至尾扫描单链表
    - pre指向 $p$ 结点的前驱
    - 若p所指结点值为x则删除
    - 否则pre、p指针同步后移
  - 代码实现

void Del_X1(Linklist &L, ElemType x) {
    LNode *p = L->next, *pre = L, *q;
    while(p != NULL) {
        if(p->data == x) {
            q = p;
            p = p->next;
            pre->next = p;
            free(q);
        } else {
            pre = p;
            p = p->next;
        }
    }
}

  - 算法特点
    - 可用于删除满足任意条件的结点
    - 只需修改if条件即可

- 解法2：尾插法建立新链表
  - 算法思路
    - p指针扫描L的所有结点
    - 值不为x时链接到L之后
    - 值为x时释放结点
  - 代码实现

void Del_X2(Linklist &L, ElemType x) {
    LNode *p = L->next, *r = L, *q;
    while(p != NULL) {
        if(p->data != x) {
            r->next = p;
            r = p;
            p = p->next;
        } else {
            q = p;
            p = p->next;
            free(q);
        }
    }
    r->next = NULL;
}

  - 算法复杂度
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(1)$

02.【解答】

- 删除最小值结点算法
  - 算法思路
    - p从头至尾扫描单链表
    - pre指向p结点前驱
    - minp保存最小值结点指针
    - minpre指向minp结点前驱
    - 扫描比较更新最小值位置
    - 最后删除最小值结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/426fab6a29a1b98105d6229a52dc7ba3019b0fcf791fcd5eed97bd777d64f2d1.jpg)

  - 代码实现

LinkList Delete_Min(LinkList &L) {
    LNode *pre = L, *p = pre->next;
    LNode *minpre = pre, *minp = p;
    while(p != NULL) {
        if(p->data < minp->data) {
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
    return L;
}

  - 算法复杂度
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(1)$

03.【解答】

- 解法1：头插法逆置
  - 算法思路
    - 摘下头结点
    - 从第一结点开始依次插入头结点后

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8fb1d58c340cdc0b3385e86efb2b4444a351c4d8c9e303ee38554c09e7558076.jpg)

  - 代码实现

LinkList Reverse_1(LinkList L) {
    LNode *p, *r;
    p = L->next;
    L->next = NULL;
    while(p != NULL) {
        r = p->next;
        p->next = L->next;
        L->next = p;
        p = r;
    }
    return L;
}


- 解法2：就地逆置
  - 算法思路
    - pre、p、r指向三个相邻结点
    - 调整指针指向原前驱结点
    - 注意首尾结点特殊处理

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75abfb30b62d57bed70f7dbf7e20b96aaffc9536f0d9a70a136fadb4a7e9bf36.jpg)

  - 代码实现

LinkList Reverse_2(LinkList L) {
    LNode *pre, *p = L->next, *r = p->next;
    p->next = NULL;
    while(r != NULL) {
        pre = p;
        p = r;
        r = r->next;
        p->next = pre;
    }
    L->next = p;
    return L;
}

  - 算法复杂度
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(1)$

04.【解答】

- 区间删除算法
  - 算法思路
    - 逐个检查结点
    - 删除区间内的结点
  - 代码实现

void Range_Delete(LinkList &L, int min, int max) {
    LNode *pr = L, *p = L->link;
    while(p != NULL) {
        if(p->data > min && p->data < max) {
            pr->link = p->link;
            free(p);
            p = pr->link;
        } else {
            pr = p;
            p = p->link;
        }
    }
}


05.【解答】

- 查找公共结点算法
  - 问题分析
    - 公共结点后所有结点重合
    - 呈Y型而非X型结构
  - 算法思路
    - 分别遍历得到长度
    - 计算长度差k
    - 长链表先走k步
    - 同步遍历找公共结点
  - 算法复杂度
    - 蛮力法：$O(len1 \times len2)$
    - 优化后：$O(len1 + len2)$
06.【解答】

- 算法思想
  - 循环遍历链表C
  - 采用尾插法将奇数号结点插入表A，保持原顺序
  - 采用头插法将偶数号结点插入表B，顺序相反

- 代码实现
LinkList DisCreat 2(LinkList &A){ 
    LinkList $B$ = (LinkList）malloc（sizeof（LNode））;
    B->next = NULL;
    LNode $\star p = A$ ->next, $\star q$;
    LNode $\star ra = A$;
    while（p!=NULL){
        ra->next=p; 
        ra=p;
        p=p->next;
        if（p!=NULL）{
            q=p->next;
            p->next = B->next;
            B->next=p;
            p=q;
        }
    }
    ra->next = NULL;
    return B;

- 注意事项
  - 头插法插入后需保存后继结点防止断链

07.【解答】

- 算法思想
  - 扫描有序递增单链表
  - 比较相邻结点值域
  - 相等则删除后者
  - 不等则移向下一结点

- 代码实现
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0058d92a881f85ba1e46fec044cd9bb432b880617610e3b87d17f8b78b320301.jpg)

- 复杂度分析
  - 时间复杂度：$O(n)$
  - 空间复杂度：$O(1)$

- 替代方案
  - 可采用尾插法
  - 从第一结点开始比较
  - 不等则插入
  - 相等则删除当前结点

08.【解答】

- 算法思想
  - 比较A、B两表元素
  - 值小的指针后移
  - 值相等时创建新结点
  - 使用尾插法插入新链表

- 代码实现
void Get Common（LinkList A,LinkList B）{
    LNode $\star p = A$ ->next, $\star q = B$ ->next, $\star r$, $\star s$;
    LinkList C = （LinkList）malloc（sizeof（LNode））;
    r = C;
    while(p!=NULL&&q!=NULL){
        if(p->data<q->data)
            p=p->next;
        else if(p->data>q->data)
            q=q->next;
        else{
            s = (LNode*)malloc(sizeof(LNode));
            s->data=p->data;
            r->next=s;
            r=s;
            p=p->next;
            q=q->next;
        }
    }
    r->next=NULL;

09.【解答】

- 算法思想
  - 采用归并思想
  - 设置工作指针pa和pb
  - 同时出现的元素保留一个
  - 其他结点全部释放

- 代码实现
Link List Union（LinkList &la,LinkList &lb){
    LNode *pa = la->next;
    LNode *pb = lb->next;
    LNode *u, $\star pc = la$;
    while(pa&&pb){
        if(pa->data == pb->data){
            pc->next=pa;
            pc=pa;
            pa=pa->next;
            u=pb;
            pb=pb->next;
            free(u);
        }
        else if(pa->data<pb->data){
            u=pa;
            pa=pa->next;
            free(u);
        }
        else{
            u=pb;
            pb=pb->next;
            free(u);
        }
    }
    while(pa){
        u=pa;
        pa=pa->next;
        free(u);
    }
    while(pb){
        u=pb;
        pb=pb->next;
        free(u);
    }
    pc->next=NULL;
    free(lb);
    return la;

- 复杂度分析
  - 时间复杂度：$O(len1+len2)$
  - 空间复杂度：$O(1)$

10.【解答】

- 算法思想
  - 从两链表第一个结点开始
  - 数据相等则后移指针
  - 不等则A链表从后继开始
  - B链表从第一个结点开始
  - 记录A链表每次开始结点

- 代码实现
int Pattern（LinkList A,LinkList B）{
    LNode $\star p = A$;
    LNode *pre = p;
    LNode $\star q = B$;
    while(p&&q){
        if(p->data == q->data){
            p=p->next;
            q=q->next;
        }
        else{
            pre=pre->next;
            p=pre;
            q=B;
        }
    }
    if(q==NULL)
        return 1;
    else
        return 0;

> attention:  
该题其实是字符串模式匹配的链式表示形式，读者应该结合字符串模式匹配的内容重新考虑能否优化该算法。

11.【解答】

- 算法思想
  - 让p从左向右扫描，q从右向左扫描
  - 直到它们指向同一结点($\scriptstyle{\cdot{\bf p}=={\bf q}}$，当循环双链表中结点个数为奇数时)
  - 或相邻(p->next $\mathbf{\lambda}^{=}\mathbf{q}$ 或q->prior $\scriptstyle{\varphi}={\mathtt{p}}$，当循环双链表中结点个数为偶数时)
  - 若它们所指结点值相同，则继续进行
  - 若比较全部相等，则返回1，否则返回0

- 代码实现
int Symmetry(DLinkList L) {
    DNode *p = L->next, *q = L->prior;
    while(p!=q && q->next!=p) {
        if(p->data == q->data) {
            p=p->next; 
            q=q->prior;
        }
        else
            return 0;
    }
    return 1;
}

> attention:  
while循环第二个判断条件易误写成 $\mathtt{p}^{->}$ next $!\!=\!\!\mathrm{q}$，分析这样会产生什么问题。

12.【解答】

- 算法思想
  - 先找到两个链表的尾指针
  - 将第一个链表的尾指针与第二个链表的头结点链接
  - 再使之成为循环的

- 代码实现
LinkList Link(LinkList &h1, LinkList &h2) {
    LNode *p, *q;
    p = h1;
    while(p->next != h1)
        p = p->next;
    q = h2;
    while(q->next != h2)
        q = q->next;
    p->next = h2;
    q->next = h1;
    return h1;
}

13.【解答】

- 算法思想
  - 在双向链表中查找数据值为x的结点
  - 将结点从链表上摘下
  - 顺着结点的前驱链查找插入位置
    - 频度递减
    - 排在同频度的第一个
    - 向前找到第一个比它的频度大的结点
  - 插入到该位置

- 代码实现
DLinkList Locate(DLinkList &L, ElemType x) {
    DNode *p = L->next, *q;
    while(p && p->data != x)
        p = p->next;
    if(!p) 
        exit(0);
    else {
        p->freq++;
        if(p->pre == L || p->pre->freq > p->freq)
            return p;
        if(p->next)
            p->next->pre = p->pre;
        p->pre->next = p->next;
        q = p->pre;
        while(q != L && q->freq <= p->freq)
            q = q->pre;
        p->next = q->next;
        if(q->next)
            q->next->pre = p;
        p->pre = q;
        q->next = p;
        return p;
    }
}

14.【解答】

- 算法思想
  - 遍历链表计算表长n并找到尾结点
  - 将尾结点与首结点相连成循环单链表
  - 找到新链表的尾结点(原链表第n-k个结点)
  - L指向新链表尾结点的下一个结点
  - 断开环得到新链表

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

- 代码实现
LNode* Converse(LNode *L, int k) {
    int n = 1;
    LNode *p = L;
    while(p->next != NULL) {
        p = p->next;
        n++;
    }
    p->next = L;
    for(int i = 1; i <= n-k; i++)
        p = p->next;
    L = p->next;
    p->next = NULL;
    return L;
}

15.【解答】

- 算法思想
  - 设置快慢两指针fast和slow指向链表头
  - slow每次走一步(slow = slow->next)
  - fast每次走两步(fast = fast->next->next)
  - fast先进入环，slow后进入环
  - 两指针在环上相遇判断是否有环

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bdb7d910bfd7dd0ebfecea3a879b39d0c6e32a2b269503dc941ce0503a88e98d.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d933b428b27dfd211713bf5b90ce363d4b59da08263ebc6724f6c84467006dc3.jpg)

- 数学推导
  - ${\sf2}\left({\sf a}\!+\!{\sf x}\right){\sf=}{\sf a}\!+\!{\sf n}^{\star}{\sf x}\!+\!{\sf x}$
  - $\mathsf{a}\!=\!\mathsf{n}\,\mathsf{r}-\mathsf{x}$
  - 从头结点到环入口点距离等于n倍环长减去环入口点到相遇点距离

- 代码实现
LNode* Find_Loop_Start(LNode *head) {
    LNode *fast = head, *slow = head;
    while(fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast)
            break;
    }
    if(fast == NULL || fast->next == NULL)
        return NULL;
    LNode *p1 = head, *p2 = slow;
    while(p1 != p2) {
        p1 = p1->next;
        p2 = p2->next;
    }
    return p1;
}

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

16.【解答】

- 算法思想
  - 设置快慢指针fast和slow
  - slow指向第一个结点，fast指向第二个结点
  - slow每次走一步，fast每次走两步
  - fast到表尾时slow指向中间点
  - 将后半部分逆置
  - 两指针分别指向前后半部分首结点
  - 遍历计算结点元素和并维护最大值

- 代码实现
int PairSum(LinkList L) {
    LNode *fast = L->next, *slow = L;
    while(fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }
    LNode *newHead = NULL, *p = slow->next, *tmp;
    while(p != NULL) {
        tmp = p->next;
        p->next = newHead;
        newHead = p;
        p = tmp;
    }
    int mx = 0;
    p = L;
    LNode *q = newHead;
    while(p != NULL) {
        if((p->data + q->data) > mx)
            mx = p->data + q->data;
        p = p->next;
        q = q->next;
    }
    return mx;
}

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
17.【解答】
- 算法的基本设计思想
  - 问题关键：设计高效算法，通过链表一次遍历找到倒数第k个结点
  - 设计思路：
    - 定义指针p和q初始指向第一个结点
    - p指针先移动k个结点
    - q指针开始与p同步移动
    - p到最后时q指向倒数第k个结点

- 算法详细实现步骤
  - $\textcircled{\scriptsize{1}}$ count $_{:=0}$ ，p和q指向链表表头结点的下一个结点
  - $\circledast$ 若p为空，转 $\circledast$
  - $\textcircled{3}$ 若count等于 $\boldsymbol{\mathrm{k}}$ ，则q指向下一个结点；否则，count $=$ count $^{+1}$
  - $\textcircled{4}$ p指向下一个结点，转 $\mathcal{Q}$
  - $\circledast$ 若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0
  - $^\mathrm{\textregistered}$ 算法结束

- 算法实现代码

typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *link;
} LNode, *LinkList;

int Search_k(LinkList list, int k) {
    LNode *p = list->link, *q = list->link;
    int count = 0;
    while(p != NULL) {
        if(count < k)
            count++;
        else 
            q = q->link;
        p = p->link;
    }
    if(count < k)
        return 0;
    else {
        printf("%d", q->data);
        return 1;
    }
}


- 评分说明
  - 一遍扫描得到正确结果：15分
  - 两遍或多遍扫描得到正确结果：最高10分
  - 递归算法得到正确结果：最高10分
  - 使用大小与k有关的辅助数组：最高10分

18.【解答】
- 问题分析
  - 两个链表长度不同时无法同时到达尾结点
  - 假设长度差为k，先在长链表遍历k个结点
  - 之后同步遍历可保证同时到达公共结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/36d0acc99387087b02e725404b7d4955b6d7521febf196003c5d29f58896cb90.jpg)

- 算法基本设计思想
  - $\textcircled{\scriptsize{1}}$ 求出str1和str2的长度m和n
  - $\circledcirc$ 以表尾对齐：
    - 若 $m \geq n$，p先走m-n+1个结点
    - 若 $m < n$，q先走n-m+1个结点
  - $\textcircled{3}$ p和q同步移动直到指向同一结点

- 算法实现代码

typedef struct Node {
    char data;
    struct Node *next;
} SNode;

int listlen(SNode *head) {
    int len = 0;
    while(head->next != NULL) {
        len++;
        head = head->next;
    }
    return len;
}

SNode* find_list(SNode *str1, SNode *str2) {
    int m, n;
    SNode *p, *q;
    m = listlen(str1);
    n = listlen(str2);
    
    for(p = str1; m > n; m--)
        p = p->next;
    for(q = str2; m < n; n--)
        q = q->next;
        
    while(p->next != NULL && p->next != q->next) {
        p = p->next;
        q = q->next;
    }
    return p->next;
}


- 时间复杂度：$O(\mathrm{len1} + \mathrm{len2})$ 或 $O(\max(\mathrm{len1}, \mathrm{len2}))$

19.【解答】
- 算法基本设计思想
  - 用空间换时间，使用辅助数组记录出现的数值
  - 数组大小为n+1，初值为0
  - 扫描链表检查q[|data|]：
    - 为0则保留并置1
    - 非0则删除结点

- 数据类型定义

typedef struct node {
    int data;
    struct node *link;
} NODE;
typedef NODE *PNODE;


- 算法实现代码

void func(PNODE h, int n) {
    PNODE p = h, r;
    int *q, m;
    q = (int *)malloc(sizeof(int)*(n+1));
    for(int i = 0; i < n+1; i++)
        *(q+i) = 0;
    
    while(p->link != NULL) {
        m = p->link->data > 0 ? p->link->data : -p->link->data;
        if(*(q+m) == 0) {
            *(q+m) = 1;
            p = p->link;
        } else {
            r = p->link;
            p->link = r->link;
            free(r);
        }
    }
    free(q);
}


- 时间复杂度：$O(m)$，空间复杂度：$O(n)$

20.【解答】
- 算法基本设计思想
  - 观察规律：$L'$ 由L交替取首尾元素组成
  - 步骤：
    - 找到中间结点
    - 后半段原地逆置
    - 依次取前后两段结点重排

- 算法实现代码

void change_list(NODE *h) {
    NODE *p, *q, *r, *s;
    p = q = h;
    
    while(q->next != NULL) {
        p = p->next;
        q = q->next;
        if(q->next != NULL)
            q = q->next;
    }
    
    q = p->next;
    p->next = NULL;
    
    while(q != NULL) {
        r = q->next;
        q->next = p->next;
        p->next = q;
        q = r;
    }
    
    s = h->next;
    q = p->next;
    p->next = NULL;
    
    while(q != NULL) {
        r = q->next;
        q->next = s->next;
        s->next = q;
        s = q->next;
        q = r;
    }
}


- 时间复杂度分析
  - 找中间结点：$O(n)$
  - 逆置：$O(n)$
  - 合并链表：$O(n)$
  - 总时间复杂度：$O(n)$


# 3.1.5 答案与解析  

# 一、单项选择题  

- 栈和队列的基本概念
  01.B
  - 栈和队列的逻辑结构相同，都属于线性结构，只是对数据的运算不同

  02.C
  - 栈是线性表，可分为顺序栈和链栈
  - 栈和队列都是限制存取点的线性结构

  03.B
  - 基本操作是最核心、最基本的运算
  - 删除栈底元素不属于栈的基本运算，可通过基本运算实现

- 顺序栈的实现
  04.C
  - 数组下标范围为 $0 \sim n-1$
  - 初始top为1，第一个元素入栈后top为0
  - 栈向高地址方向增长，入栈时先top+1再存入元素

  05.B
  - 数组下标范围为 $1 \sim n$
  - 初始top为1，指向栈顶元素的下一个元素
  - 栈向高地址方向增长，入栈时先存入元素再top+1

  06.A
  - 数组下标范围为 $1 \sim n$
  - 初始top为 $n+1$，指向栈顶元素
  - 栈向低地址方向增长，入栈时先top-1再存入元素

  07.A
  - 每个元素需要1个存储单元
  - 入栈top+1，出栈top-1
  - top值变化:1001H→1002H→1001H→1002H→1001H→1002H→1001H→1002H

  08.A
  - 顺序栈用数组存储，大小固定
  - 链栈优势在于可动态分配存储空间

- 链表结构
  09.C
  - 双向循环链表:表头/尾指针都可方便找到表头结点
  - 单循环链表:尾指针可方便找表头，头指针找尾需遍历
  - 插入删除后找尾结点时间复杂度为 $O(n)$

- 链栈操作
  10.C
  - 不带头结点的链栈进栈:首部插入结点x
  - x->next = top，top指向x

  11.D
  - 栈顶指针指向栈顶元素

  12.A
  - 前3句执行后:栈内为a,b(b为栈顶)
  - 第4句:b出栈，x=b
  - 最后一句:读取栈顶元素a，x=a

- 栈的应用
  13.B
  - n个不同元素进栈，出栈序列个数:
  $\frac{1}{n+1}C_{2n}^{n}=\frac{1}{n+1}\frac{(2n)!}{n! \times n!}=\frac{6 \times 5 \times 4}{4 \times 3 \times 2 \times 1}=5$

  14.D
  - c最先出栈时，栈内必为a和b
  - a先进栈必晚出栈
  - 先进栈晚出栈的元素按逆序出栈

  15.A
  - 出栈序列为cd时的操作序列:
    - a进栈→b进栈→c进栈→c出栈→d进栈→d出栈→b出栈→a出栈
  - 唯一可能序列为cdba

  16.D
  - A,B,C出栈序列分别为1243,3241,1324
  - 1234得到1342的进出栈序列:
    1进→1出→2进→3进→3出→4进→4出→2出

  17.D
  - 第n个元素第一个出栈
  - 前n-1个元素按序入栈
  - 输出序列为输入序列的逆序

  18.D
  - 第i个元素第一个出栈
  - i之前元素可依次排在i后出栈
  - 剩余元素可进栈并排在i之前元素出栈
  - 第j个出栈元素不确定

  19.C
  - A可能顺序:a入→a出→b入→b出→c入→c出→d入→d出
  - B可能顺序:a入→b入→c入→c出→b出→d入→d出→a出
  - D可能顺序:a入→a出→b入→c入→c出→b出→d入→d出
  - C无对应序列

【另解】若出栈序列的第一个元素为 $d$ ，则出栈序列只能是dcba。该思想通常也适用于出栈序列的局部分析：如12345入栈，问出栈序列34152是否正确？如何分析？若第一个出栈元素是3，则此时12必停留在栈中，它们出栈的相对顺序只能是21，所以34152错误。  

20. C
- 入栈序列分析
  - 由于 $P_3 = 1$，$P_1,P_2,P_3$ 连续入栈后，第一个出栈元素是 $P_3$
  - $P_1,P_2$ 已按序进栈，$P_2$ 必定在 $P_1$ 之前出栈
  - 第二个出栈元素是2，而此时 $P_1$ 不是栈顶元素，因此 $P_1$ 不可能是2

21. A
- $P_1$ 取值可能性分析
  - 情况1：$P_1=1$
    - $P_1$ 进栈后立即出栈
    - $P_2=2$，进栈后立即出栈
    - $P_3=3$，进栈后立即出栈
  - 情况2：$P_1=2$
    - $P_2=1$
    - $P_1,P_2$ 依次进栈后全部出栈
    - $P_3=3$，进栈后立即出栈
  - 结论：$P_1$ 既可能是1，又可能是2

22. C
- 入栈出栈序列分析
  - A序列可能：1入→1出→2入→2出→3入→3出→4入→4出
  - B序列可能：1入→2入→3入→3出→2出→4入→4出→1出
  - D序列可能：1入→1出→2入→3入→3出→2出→4入→4出
  - C序列不可能：
    - 4在栈中时，前面元素(1,2,3)都已入过栈
    - 若4第二个出栈，栈中剩余两个有序元素
    - 可能组合为(1,2)(1,3)(2,3)均不满足条件

23. C
- 标识符组合分析
  - 合法组合：n1_、n_1、_1n
  - 操作序列：
    - n1_：n进出→1进出→_进出
    - n_1：n进出→1进→_进出→1出
    - _1n：n进→1进→_进出→1出→n出
  - _n1不可能出现

24. B
- 共享栈特点
  - 上溢：存储器满还往里写
  - 下溢：存储器空还往外读
  - 共享栈优点：
    - 解决上溢问题
    - 节省存储空间
    - 一个栈可使用另一个栈空闲空间

25. A
- 共享栈实现
  - 详见考点精析部分
  - 思考：top1=0，top2=n-1时栈满条件

26. C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/35ffdfafa42c62ee1e16c8b3b0996e73456b35e4a5e684971cc464ac9d7b353b.jpg)
- 栈操作分析
  - 栈内最大深度为3
  - 栈S容量至少为3
  - 出入栈次序详见表格

27. D
- 出入栈序列分析
  - A序列：a进→b进→c进→d进→d出→c出→e进→e出→b出→f进→f出→a出
  - B序列：a进→b进→c进→c出→b出→d进→d出→a出→e进→e出→f进→f出
  - C序列：a进→b进→b出→c进→c出→a出→d进→e进→e出→f进→f出→d出
  - D序列不符合要求：连续3次退栈操作

28. B
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c2253c260f2e0f7135a64146ae00064f87c4da832ac52d12ec6e8a1b1eeb82a.jpg)
- d首出栈后可能操作
  - e进出：decba
  - c出→e进出：dceba
  - cb出→e进出：dcbea
  - cba出→e进出：dcbae

29. C
- $P_3$ 取值分析
  - 3之后的数都可取
  - $P_1=1$时，$P_3$可取2
  - $P_1=2$时，$P_3$可取1
  - $P_3$可取除3外所有数，共n-1个

30. D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a24554276770537a27b7d0060d2e31cdbf6fd3201a21910e3e6471df3d8ae76b.jpg)
- 出栈序列为b,c,e

31. D
- 入栈出栈序列关系
  - 可通过模拟判断序列合法性
  - 立即出栈：in序列=out序列
  - 全部入栈后出栈：in序列与out序列互为倒序

# 二、综合应用题  

01.【解答】

- CD出栈后状态分析
  - 三种可能操作：
    - E进栈后出栈：CDEBA
    - B出栈，E进栈后出栈：CDBEA  
    - B出栈，A出栈，E进栈后出栈：CDBAE
  - 最终得到三种序列：CDEBA、CDBEA、CDBAE

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ccd4891f31b158fdad1290f9d184806b217185ca59cf2f16deb3c9d5016a2f96.jpg)

02.【解答】

- 出栈序列分析
  - 可得到序列BCAED
    - 操作序列：A进→B进→B出→C进→C出→A出→D进→E进→E出→D出
  - 不能得到序列DBACE
    - 原因：D开头要求ABC先入栈，C在栈顶，BA不可能早于C出栈

03.【解答】

- 合法性判断
  - A、D合法
  - B、C不合法
    - B错误：连续出栈2次
    - C错误：入栈出栈次数不一致
  - 判断原则
    - 过程中入栈次数≥出栈次数
    - 结束时栈为空

- 算法实现
  - 基本思想
    - 扫描序列检查条件
    - 出栈次数不超过入栈次数
    - 最终入栈出栈次数相等

bool Judge(char A[ ]）( 
    int $\scriptstyle{\dot{\mathbf{z}}}=0$ int $\scriptstyle{\dot{\boldsymbol{\mathrm{\omega}}}}={\boldsymbol{\mathrm{k}}}=0$ 
    while（A[i]!='\0'）{
        switch(A[i]){ 
            case'I': $\gimel^{++}$ ;break;
            case'o': $\kappa++$ 
                if（k>j）{
                    printf（"序列非法\n"）;
                    exit（0）;
                }
        }
        $\mathrm{i++}$
    }
    if（j $!\!=\!\!\kappa!,$ printf（"序列非法\n"）; 
    return false; 
    else{ 
        printf（"序列合法\n"）;
        return true;
    }
}

04.【解答】

- 中心对称判断算法
  - 基本思想
    - 前半部分入栈
    - 后半部分逐一比较
    - 栈空则对称
  - 实现细节
    - 奇数长度跳过中心节点
    - 不等时立即退出

int dc（LinkList L,int n）{
    int i; 
    chars[n/2];
    LNode $\star_{\mathsf{P}}\!\!=\!\!\mathtt{L}->$ next;
    for( $\scriptstyle{\dot{\mathbf{z}}}=0$ ;i<n/2; $\dot{\mathbf{i}}^{++}$ ){
        s[i] $\tt=p$ ->data;
        p=p->next;
    }
    i--;
    if $\mathfrak{n}\mathfrak{s}\mathfrak{2}\mathrm{==}\mathtt{1}$ 
        $\tt p\mathrm{=}\tt p$ ->next;
    while(p!$=$ NULL&&S[i]$\scriptstyle==_{\mathtt{P}}$ ->data){
        $\mathrm{i--}$
        $\scriptstyle{\mathtt{p}}={\mathtt{p}}$ ->next;
    }
    if（$\scriptstyle{\dot{\mathbf{i}}}\;==-1$ )
        return 1;
    else 
        return 0;
}

05.【解答】

- 共享栈实现
  - 基本结构
    - 两端为栈底
    - S1栈顶指针初始-1
    - S2栈顶指针初始maxsize
  - 栈操作特点
    - S1常规操作
    - S2反向操作
    - 栈满条件：指针相邻

#define maxsize 100
#define elemtpint 
typedef struct{ 
    elemtp stack[maxsize];
    int top[2];
}stk;
stk S;

- 入栈操作实现
int push（int i,elemtp x）{
    if（i<0li>1){
        printf（"栈号输入不对"）；
        exit(0);
    }
    if(s.top[1]-s.top[0] $==1$ ){
        printf（"栈已满\n"）；
        return 0;
    }
    switch（i）{
        case 0:
            s.stack[$++s$.top[0]]=x;
            return 1；
            break;
        case1:
            s.stack[--s.top[1]]$\!=\!\mathrm{x}$;
            return 1:
    }
}

- 出栈操作实现
if（i<01li>1){
    printf（"栈号输入错误\n"）;
    exit（0);
}
switch(i){
    case0:
        if(s.top[0] $==-1$ ){
            printf（"栈空\n"）;
            return -1;
        }
        else 
            return s.stack[s.top[o]--];
        break;
    case 1:
        if(s.top[1] $==$ maxsize){
            printf（"栈空\n"）；
            return -1;
        }
        else 
            return s.stack[s.top$[1]++]$;
        break;
}

# 3.2.6 答案与解析  

# 一、单项选择题  

01.D
- 栈和队列的区别
  - 都是线性结构
  - 都可采用顺序存储或链式存储
  - 本质区别在于限定表中插入和删除操作位置的不同

02.B
- 队列"先进先出"特性
  - 先进队列的元素先出队列
  - 后进队列的元素后出队列
  - 进队列对应插入操作
  - 出队列对应删除操作
  - I和IV正确

03.D
- 删除队头元素即出队是队列的基本操作之一

04.B

05.D
- 循环队列操作
  - 数组下标范围 $0 \sim n$，容量为 $n+1$
  - 入队操作为 $\text{rear} \leftarrow (\text{rear}+1) \bmod (n+1)$

06.C
- 队列长度计算
  - 公式：$(\text{rear}-\text{front}+\text{maxsize}) \bmod \text{maxsize} = (21-16) \bmod 21 = 16$

> attention:  
数组A[n]的下标范围为 $0 \sim n-1$。若写成A[0..n]，则说明下标范围为 $0 \sim n$

07.B
- 循环队列指针操作
  - 删除元素：$\text{front} = (\text{front}+1) \bmod 6$
  - 插入元素：$\text{rear} = (\text{rear}+1) \bmod 6$
  - 操作后：$\text{front}=0$，$\text{rear}=3$

08.D
- 队列一个元素时的指针状态
  - front指向该元素前一位置
  - rear指向该元素
  - 队空时队首指针等于队尾指针

09.C
- 队空队满判断
  - 采用牺牲一个存储单元的方法
  - 队满标志：队列头指针在队尾指针的下一位置

10.A
- 队空队满判断条件
  - 队满：$(\text{rear}+1) \bmod (n+1) = \text{front}$
  - 队空：$\text{front} = \text{rear}$

11.D
- 链式队列特点
  - 长度受内存空间限制
  - 进队出队时间为 $O(1)$
  - 可顺序访问
  - 不能直接计算元素个数

12.B
- 链队实现选择
  - 需双端操作
  - 首尾指针结构最适合
  - 便于首结点删除和尾结点插入

13.A
- 非循环双链表队列操作
  - 入队需修改队尾结点指针域
  - 查找队尾结点时间为 $O(n)$

14.A
- 链头作为队头便于出队操作

15.D
- 链式队列删除操作
  - 通常仅需修改头指针
  - 仅一个元素时需同时修改尾指针
  - 删除后队空时：$\text{rear} = \text{front}$
16.D
- 链式队列插入操作
  - 结点 $x$ 插入链表尾部
  - rear指向结点 $x$
  - 队尾 $x\text{->next}$ 必须置空

17.A
- 循环单链表进队分析
  - 队尾在链表表头
  - 只设头指针无头结点和尾指针
  - 寻找表尾结点时间复杂度 $O(n)$
  - 进队时间复杂度 $O(n)$

18.B
- 队列序列模拟分析
  - $Q_1$ 和 $Q_2$ 两个队列
  - 5最先出队情况
    - $1,2,3,4$ 入队 $Q_1$
    - 5入队 $Q_2$
    - 得到序列5,1,2,3,4

19.C
- 双端队列序列分析
  - 右端输入受限情况
    - 左入得4,3,2,1
    - 左右交替出得4,1,3,2
  - 右端输出受限情况
    - 左右交替入得4,2,1,3

20.C
- 输出受限双端队列分析
  - 元素进队顺序限制
  - $a,b$ 必须相邻
  - 选项C中 $a,b$ 不相邻不合题意

21.B
- 循环队列指针分析
  - 首元素存储在A[0]
  - front和rear初值为0
  - 入队执行 $(\text{rear}+1)\bmod n$
  - front保持为0不变

> attention:  
$\textcircled{\scriptsize{1}}$ 循环队列是指顺序存储的队列，而不是指逻辑上的循环，如循环单链表表示的队列不能称为循环队列。 $\textcircled{2}$ front和rear的初值并不是固定的。  

22.A
- 队列指针状态分析
  - end1指向队头元素
  - end2指向队尾后一位置
  - 队空条件：$\text{end1}=\text{end2}$
  - 队满条件：$\text{end1}=(\text{end2}+1)\bmod M$

23.C
- 操作序列分析
  - 输出3要求1,2先入栈
  - 2必须比1先出栈
  - 无法得到要求的1,2输出顺序

24.D
- 双端队列入队限制
  - 左端允许入队出队
  - 右端只允许入队
  - 序列验证分析
    - A：右入1,2，左入3,4,5
    - B：右入1,2，左入3，右入4，左入5
    - C：左入1,2，右入3，左入4，右入5
    - D：无法验证

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/787d203e22b7fec4520a4cca00193f260c6a167c436c780f9efc73cfd1809866.jpg)
二、综合应用题  

01.【解答】
- 循环队列类型结构设计
  - 增设tag整型变量
    - 进队置tag为1
    - 出队置tag为0
  - 初始状态
    - tag = 0
    - front = rear = 0
  - 队列4要素
    - 队空条件：Q.front == Q.rear && Q.tag == 0
    - 队满条件：Q.front == Q.rear && Q.tag == 1
    - 进队操作：Q.data[Q.rear] = x; Q.rear = (Q.rear + 1) % MaxSize; Q.tag = 1
    - 出队操作：x = Q.data[Q.front]; Q.front = (Q.front + 1) % MaxSize; Q.tag = 0
  - 入队算法实现
    int EnQueuel(SqQueue &Q,ElemType x){
      if(Q.front == Q.rear && Q.tag == 1) return 0;
      Q.data[Q.rear] = x;
      Q.rear = (Q.rear + 1) % MaxSize;
      Q.tag = 1;
      return 1;
    }
  - 出队算法实现
    int DeQueuel(SqQueue &Q,ElemType &x){
      if(Q.front == Q.rear && Q.tag == 0) return 0;
      x = Q.data[Q.front];
      Q.front = (Q.front + 1) % MaxSize;
      Q.tag = 0;
      return 1;
    }

02.【解答】
- 队列元素逆置算法
  - 基本思路
    - 队列元素无法直接逆置
    - 利用栈实现元素逆序
  - 算法实现步骤
    - 队列元素依次出队入栈
    - 栈中元素依次出栈入队
  - 代码实现
    void Inverser(Stack &S,Queue &Q){
      while(!QueueEmpty(Q)){
        x = DeQueue(Q);
        Push(S,x);
      }
      while(!StackEmpty(S)){
        Pop(S,x);
        EnQueue(Q,x);
      }
    }

03.【解答】
- 用两个栈模拟队列
  - 基本原理
    - S1用于入队操作
    - S2用于出队操作
  - 关键操作规则
    - S2为空时将S1元素全部转移到S2
    - S1满时需确保S2为空
  - 算法实现
    - 入队算法
      int EnQueue(Stack &S1,Stack &S2,ElemType e){
        if(!StackOverflow(S1)) {
          Push(S1,e);
          return 1;
        }
        if(StackOverflow(S1) && !StackEmpty(S2)) {
          printf("队列满");
          return 0;
        }
        if(StackOverflow(S1) && StackEmpty(S2)) {
          while(!StackEmpty(S1)) {
            Pop(S1,x);
            Push(S2,x);
          }
          Push(S1,e);
          return 1;
        }
      }
    - 出队算法
      void DeQueue(Stack &S1,Stack &S2,ElemType &x) {
        if(!StackEmpty(S2)) {
          Pop(S2,x);
        }
        else if(StackEmpty(S1)) {
          printf("队列为空");
        }
        else {
          while(!StackEmpty(S1)) {
            Pop(S1,x);
            Push(S2,x);
          }
          Pop(S2,x);
        }
      }
    - 判空算法
      int QueueEmpty(Stack S1,Stack S2) {
        if(StackEmpty(S1) && StackEmpty(S2)) return 1;
        else return 0;
      }

04.【解答】
- 循环链式队列设计
  - 存储结构选择
    - 采用链式存储
    - 设计为首尾相接的循环单链表
  - 指针设置
    - 队头指针front
    - 队尾指针rear
  - 状态判断
    - 队空条件：front == rear
    - 队满条件：front == rear->next

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/380c264a1128fdb1df6ed7dfb1ef3d1684cd6e6ab71433fa1d3a19bf35a7a8c7.jpg)

- 队列操作状态
  - 插入第一个元素后状态

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ebe831b2e73eb16d67dd91c3dbb644c74e082a79f54dc9de8725737ab0d7f2b2.jpg)

- 基本操作过程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7a08ad28343bc900eb3c7413b361bbc507540302fc355d120f096827603aceb.jpg)

# 3.3.7 答案与解析  

# 一、单项选择题  

01.D
- 缓冲区实现
  - 使用队列实现
  - A、B、C都是典型应用

02.B
- 后缀表达式转换
  - 基本原理
    - 计算符号位于两个操作数后面
    - 按计算优先级进行变换
  - 转换方法
    - 将直接操作数用括号括起
    - 将操作符提到括号后
    - 去掉括号
    - 例如: $\left(\mathfrak{O}\left(\mathfrak{O}^{\mathfrak{a}^{\star}}\left(\mathfrak{O}^{\mathfrak{b}+\mathfrak{c}}\right)\ \right)-\mathfrak{d}\right)$ 转换为 abc+*d-
  - 补充说明
    - 学完第5章后可用二叉树
    - 通过后序遍历求得后缀表达式

03.D
- 算法应用比较
  - FIFO页面替换算法使用队列
  - 其他算法使用栈

04.B
- 栈的应用分析
  - 运算过程
    - A入栈,B入栈,计算R1
    - C入栈,计算R2
    - D入栈,计算R3
    - 最大栈深为2
  - 技巧说明
    - 根据算符优先级统计
    - 计算未参与运算的运算符个数
    - 以选项C为例分析运算符栈变化

05.B
- 递归计算过程
  - 递归模型组成
    - 递归出口
    - 递归体
  - 计算过程
    - f$(0)=2$
    - f$(1)=1*f(0)=2$
    - $\textsf{f}(\textsf{f}(1))=6$

06.C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/748a9385d350d2b15e01cd71af324a050e09a739feb1950922e64d938adba8c6.jpg)
- 递归调用分析
  - 根据递归调用树
  - F()函数调用9次

07.C
- 递归执行顺序
  - 内层参数计算
    - func(5) = func(3) + func(1) = 4
    - 共执行3次func函数
  - 外层函数执行
    - func(func(5)) = func(4) = func(2) + func(0) = 4
    - 第4个执行的是func(4)

08.B
- 递归算法特点
  - 存在重复计算
  - 效率较低

09.C
- 函数调用机制
  - 系统构造活动记录
    - 包含参数表
    - 包含返回地址
  - 压栈过程
    - 活动记录入栈
    - 局部变量入栈

10.B
- 算法实现特点
  - 涉及第5章和第6章内容
  - 图的广度优先搜索类似树的层序遍历
  - 都需要队列辅助实现
11.A
- 栈与递归的关系
  - 栈可模拟递归过程消除递归
  - 单向递归和尾递归可用迭代方式消除
  - 栈用于处理函数/过程调用
  - 栈只允许在栈顶操作，队列允许两端操作

12.B
- 缓冲区特性
  - 数据提取需保持原顺序
  - 具有先进先出特性

13.A
- 中缀转后缀表达式规则
  - 操作数处理
    - 扫描到操作数直接输出
  - 操作符处理规则
    - 遇到"("直接入栈
    - 遇到")"弹出栈顶运算符直到"("并删除"("
    - 当前运算符优先级高于栈顶或遇到"("时直接入栈
    - 当前运算符优先级低于等于栈顶时依次弹出直到遇到高优先级或"("

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/78d512e78db05c1a412424d4c4cc766b5e1e1194fb52e210182b3de3f31dd898.jpg)

14.B
- 中缀表达式转换过程
  - 表达式: $a/b+(c*d-e*f)/g$
  - 扫描到f时栈中元素为+(-*

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e075fb533b14cf49d93eac009ae1901b31b1e028be2a6e81c37f79b6306778e.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/38d9c0ad26a5ef626d629d8777642f355830d0424202669aaea4c5abc6992a02.jpg)

15.A
- 递归调用栈分析
  - 系统栈信息保存顺序
    - 栈底到栈顶: main(), S(1), S(0)
  - 注意事项
    - 系统为每层递归开辟工作栈
    - 存储返回点、局部变量、传入实参

16.C
- 队列入队出队分析
  - 入队顺序: $8,4,2,5,3,9,1,6,7$
  - 出队顺序: $1\sim9$
  - 队列使用规则
    - 后入队元素必须大于前面元素
    - 需确保使用最少队列数
  - 最优解需要4个队列

17.C
- 命题分析
  - 命题I反例
    - 斐波那契数列迭代实现只需一个循环
  - 命题III反例
    - 不同入栈出栈操作可产生不同序列
  - 命题IV
    - 栈只允许一端操作
  - 命题II正确

18.B
- 栈操作过程分析
  - 第一次调用
    - S1弹出2和3
    - S2弹出+
    - 计算3+2=5
    - 5压入S1
  - 第二次调用
    - S1弹出5和8
    - S2弹出-
    - 计算8-5=3
    - 3压入S1
  - 第三次调用
    - S1弹出3和5
    - S2弹出*
    - 计算5*3=15
    - 15压入S1
# 二、综合应用题  

01.【解答】

- 括号匹配算法思想
  - 栈的典型应用
  - 基本思路
    - 扫描每个字符
    - 遇左括号(花、中、圆)进栈
    - 遇右括号检查栈顶是否匹配
      - 匹配则退栈
      - 不匹配则配对错误
    - 最后栈非空则错误

- 代码实现

bool BracketsCheck(char *str) {
    InitStack(S);  // 初始化栈
    int i = 0;
    while(str[i] != '\0') {
        switch(str[i]) {
            // 左括号入栈
            case '(': Push(S, '('); break;
            case '[': Push(S, '['); break; 
            case '{': Push(S, '{'); break;
            // 右括号检测栈顶
            case ')': 
                Pop(S, e);
                if(e != '(') return false;
                break;
            case ']':
                Pop(S, e);
                if(e != '[') return false;
                break;
            case '}':
                Pop(S, e);
                if(e != '{') return false;
                break;
            default: break;
        }
        i++;
    }
    
    if(!IsEmpty(S)) {
        printf("括号不匹配\n");
        return false;
    } else {
        printf("括号匹配\n");
        return true;
    }
}

# 3.4.6 答案与解析  

# 一、单项选择题  

01.D
- 特殊矩阵压缩存储
  - 含有很多相同元素或零元素
  - 可采用压缩存储节省空间

02.C
- 三角矩阵存储
  - 只需存储上三角或下三角部分(含对角线)
  - 元素个数为 $n+(n-1)+\cdots+1=n(n+1)/2$

03.A
- 矩阵存储细节
  - 注意事项
    - 矩阵最小下标为0
    - 数组下标从0开始
    - 矩阵按行优先存储
  - 解题技巧
    - 特殊值代入法求解
    - "平移"搬动思想
    - 结合草图理解
    - 注意起始下标

04.D
- 二维数组地址计算
  - 按行优先顺序公式
    - $\mathrm{LOC}(i,j)=\mathrm{LOC}(0,0)+(\,i\times m+j)\times L$
    - $\mathrm{LOC}(0,\,0)=\mathrm{SA}$ (数组首地址)
    - $L=3$ (元素长度)
    - $m=9-0\,+\,1=10$ (数组列数)
  - 计算结果
    - $\mathrm{LOC}(8,5)=\mathrm{SA}+(8{\times}10+5){\times}3=\mathrm{SA}+255$

05.A
- 二维数组推理
  - 已知条件
    - 按行优先存储
    - A[3][3]地址为446
    - A[3][1]地址为444
    - A[1][1]地址为420
  - 推理过程
    - A[1][1]和A[3][1]相差2行
    - 矩阵列数为12
    - A[5][5]地址计算: $446+24+2=472$

06.B
- 三对角矩阵压缩存储
  - 压缩规则
    - A[1..n][1..n]压缩至B[1...3n-2]
    - $a_{i,j}$ 与 $b_{k}$ 对应关系: $k\!=\!2i+j\!-2$
  - A[66][65]在数组B中位置计算
    - $k=2{\times}66+65-2=195$

07.C
- 按列优先存储计算
  - 元素 $a_{i j}$ 前面有
    - $j-1$ 列
    - $1+2+3+\cdots+j-1=j(j-1)/2$ 个元素
  - 位置计算
    - 第 $j$ 列上第 $i$ 个元素
    - 数组B下标从1开始
    - $k\!=\!j(j\!-\!1)/2+i$

08.B
- 列优先存储详细计算
  - 元素 $a_{i,j}$ 之前有
    - $j-1$ 列
    - $(j-1)(2n-j+2)/2$ 个元素
  - 位置确定
    - 第j列上第 $i-j+1$ 个元素
    - 数组B下标从1开始
    - $k\!=\!(j\!-\!1)(2n\!-\!j+2)/2+i\!-\!j\!+1$

09.B
- 稀疏矩阵存储特点
  - 采用三元组压缩存储
  - 存储内容
    - 矩阵元素的行列下标
    - 相应的值
  - 局限性
    - 不能快速定位矩阵元素
    - 失去随机存取特性

10.D
- 三对角矩阵特征
  - 非零元分布
    - 第1行和最后1行有2个非零元
    - 其余各行有3个非零元
  - 稀疏矩阵特点
    - 非零元个数较少
11.B
- 三对角矩阵压缩存储
  - 存储方式
    - 3条对角线上元素按行优先存放在一维数组B中
    - $a_{1,1}$ 存放于B[0]

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa3ea5f7260fe17e292865159b0d1cf5053f88bb67bd6ff07d67a0253a39a290.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4a30b3705b2457b9d0660a6c5cea4144340219f749e3e8965305d2cd9bc62523.jpg)  

  - 元素位置计算
    - 公式法: $k = 2i + j - 3$ 
    - 观察法
      - 第一行有2个元素
      - 中间28行每行3个元素
      - $m_{30,30}$ 前有一个元素 $m_{30,29}$
      - 计算: $2 + 28 \times 3 + 2 - 1 = 87$

> attention:  
- 下标起始问题
  - 矩阵可能从 $a_{0,0}$ 或 $a_{1,1}$ 开始
  - 数组可能从B[0]或B[1]开始
  - 需要适时调整计算方法

12.A
- 稀疏矩阵存储结构比较
  - 三元组表
    - 存储行、列、值三种信息
    - 主要用于稀疏矩阵
  - 十字链表
    - 结合行列单链表存储
  - 邻接矩阵
    - 空间复杂度 $O(n^2)$
    - 不适合稀疏矩阵
  - 二叉链表
    - 又名左孩子右兄弟表示法
    - 用于表示树或森林

13.A
- 数组下标计算
  - C语言数组N下标从0开始
  - $m_{1,1}$ 对应 $n_0$
  - 各行元素数: 12,11,10,9,8
  - $m_{6,6}$ 位置: $12+11+10+9+8+1=51$
  - 实际下标为50

14.C
- 上三角矩阵列优先存储
  - 存储顺序
    - 第1列: 1个元素
    - 第2列: 2个元素
    - 第6列: 6个元素
    - 第7列: 1个元素
  - $m_{7,2}$ 位置计算
    - 前面共 $1+2+3+4+5+6+1=22$ 个元素
    - 数组下标范围 $0\sim21$
    - $m_{2,7}$ 下标为22

15.B
- 二维数组行优先存储
  - 已知条件
    - 每个元素占1个存储单元
    - A[3][3]是第121个元素
  - 计算过程
    - 设每行n个元素
    - $n \times 3 + 4 = 121$
    - 求得 $n = 39$
    - A[5][5]地址: $100+39 \times 5+6-1=300$

16.A
- 稀疏矩阵三元组表存储
  - 存储内容
    - 非零元素的行标、列标、关键字值
    - 矩阵的行数和列数
    - 非零元素个数
  - 重要性说明
    - 仅通过三元组无法判断矩阵大小
    - 需要额外存储矩阵维度信息

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a54777d3f203e604cf3c0c26607b75871ce9c9e6b44ee665c9ba64b1b45637a6.jpg)

# 4.2.5 答案与解析  

# 一、单项选择题  

01.C
- 子串操作分析
  - 从串S中截取第i个字符起长度为l的子串
  - A错误，B、D明显错误

02.B
- KMP算法特点
  - 主串不会回溯
  - 主串指针不会变小

03.C、D
- 时间复杂度分析
  - 简单模式匹配算法
    - 实际应用时间复杂度约为 $O(m+n)$
    - 理论时间复杂度为 $O(mn)$
  - KMP算法时间复杂度为 $O(m+n)$

04.D
- KMP匹配规则
  - 当主串第i个字符和模式串第j个字符不匹配时
    - 主串位指针i不变
    - 将主串第i个字符与模式串第next[j]个字符比较
    - 即 $j = \text{next}[j]$

05.B
- KMP匹配特点
  - 主串第i个字符和模式串第j个字符不匹配时
  - 主串位i不回溯

06.A
1）设next $[1] = 0$, next $[2] = 1$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/324e552c289ad685020a346e6c10b4da169a93c653a6a302719332def4a9e9ae.jpg)

- next数组计算过程
  - j=3时
    - k = next[j-1] = next[2] = 1
    - 比较S[2]与S[1]: S[2] = a, S[1] = a
    - S[2] = S[1]，所以next[j] = k + 1 = 2
  - j=4时
    - k = next[j-1] = next[3] = 2
    - 比较S[3]与S[2]: S[3] = a, S[2] = a
    - S[3] = S[2]，所以next[j] = k + 1 = 3

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fd25b926cb0b642929e708ed40c60eb724b8877345e33bc310a47d3bb1eccf02.jpg)

07.C
- 手工求next数组方法
  - 串s = ababa a ababa a分析
    - a: 前后缀为空，最长相等前后缀长度为0
    - ab: 前缀{a}∩后缀{b} = ∅，长度为0
    - aba: 前缀{a,ab}∩后缀{a,ba} = {a}，长度为1
    - abab: 前缀{a,ab,aba}∩后缀{b,ab,bab} = {ab}，长度为2

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6bea1d1bb4e3b00ee7431d4358ab0208321daf0a7f67dc8347bec33eabce6564.jpg)

08.C
- 解析同上题
- next数组调整说明
  - 是否整体加1需根据题意分析
  - 位序从1开始时需要整体加1
  - 位序从0开始时不需要加1

> attention:  
实际KMP算法中，串的位序从1开始则next数组需整体加1，从0开始则不需要加1。

09.C
- nextval数组计算
  - 从0开始，串位序从1开始
  - 第一步：nextval[1] = next[1] = 0

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0723a252b86c7588ad313efb041b992a9eea1625ac727c4fc5d1fef9bfcac637.jpg)

- 计算步骤详解
  - 从j开始，判断pj是否等于pnext[j]
  - 相等则修正为next[next[j]]
  - 直至两者不相等为止

10.C
- 失配分析
  - 主串和模式串位序从0开始
  - 失配时s[i]≠t[j]，i=5

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7419483a1e17abfc50c7bc83070a668a57165a793d61316e9e9988e89083dc7.jpg)

11.B
- 匹配过程分析
  - 位序从0开始
  - next数组生成

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c41bfc001746badce009efd4560a1d524fa970b8f563698660ab33b0c2137932.jpg)

- 比较过程
  - 第一趟：连续比较6次，5号位失配
  - 第二趟：从模式串2号位开始，比较4次成功
  - 总比较次数：10次

# 二、综合应用题  

01.【解答】
- KMP算法失配情况分析
  - 情况1：模式串第1个字符与主串当前字符不相等
    - next $[1] = 0$，表示模式串右移一位
    - 主串当前指针后移一位，继续比较
  - 情况2：主串第i个字符与模式串第j个字符失配
    - 主串i不回溯
    - 模式串第k个字符与主串第i个字符比较
    - k值满足条件: $1 < k < j$ 且 $p_1\cdots p_{k-1} = p_{j-k+1}\cdots p_{j-1}$
    - k为模式串下次比较位置
    - 取最大k值以最小化右移距离
  - 情况3：其他失配情况
    - 主串指针i不回溯
    - 最坏情况下模式串从第1个字符开始比较

02.【解答】
- 模式串P='aabaac'的next数组生成过程
  - 初始化
    - next $[1] = 0$
    - next $[2] = 1$
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33da1e25addb096029df22cc29324ca13eb7c1919006d88596b1badec99ab2c3.jpg)
  - j=3时计算
    - k = next[2] = 1
    - 比较S[2]与S[1]均为'a'
    - next[3] = k + 1 = 2
  - j=4时计算
    - k = next[3] = 2
    - 比较S[3]='b'与S[2]='a'不相等
    - k = next[k] = 1
    - 比较S[3]='b'与S[1]='a'不相等
    - k = next[k] = 0
    - next[4] = 1
  - j=5时计算
    - k = next[4] = 1
    - 比较S[4]与S[1]均为'a'
    - next[5] = k + 1 = 2
  - j=6时计算
    - k = next[5] = 2
    - 比较S[5]与S[2]均为'a'
    - next[6] = k + 1 = 3

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/68a30a346398668800b6915c5bbde3ac4b6c3572d849990bcfa280d328ccda81.jpg)

- KMP算法匹配过程
  - 第一趟
    - 从首字符开始比较
    - i=6,j=6时失配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f97f6994a195ed7e0d5c402153422ba83cbe971d14bee5c7d07b5dc42e00979.jpg)
  - 第二趟
    - next[6]=3,从模式串第3个字符继续比较
    - i=9,j=6时失配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/901777c03628ada8b4fed4ed18c04a2a23d27eb6f0e1f59d3b77eb6e68401b87.jpg)
  - 第三趟
    - next[6]=3,从模式串第3个字符继续比较
    - 匹配成功
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dc3881603a934d8d91d42a98e822344d4f2057e15d15fe8a255a756e8e4e8e98.jpg)



# 5.1.5 答案与解析  

# 一、单项选择题  

01.D
- 树是一种分层结构，它特别适合组织那些具有分支层次关系的数据。

02.A
- 树的基本性质
  - 除根结点外，其他每个结点都是某个结点的孩子
  - 所有结点的度数加1等于结点数
  - 所有结点的度数之和等于总结点数减1

03.A
- 树的路径长度
  - 树根到每个结点的路径长的总和
  - 根到每个结点的路径长度的最大值是树的高度减1
  - 与哈夫曼树的带权路径长度不同

04.A
- 度为4的树的最大高度
  - 每层结点数尽可能少
  - 除最后一层外，每层结点数为1
  - 最终树高度为 $n-3$
  - 树的度为4只表示存在结点最多有4个孩子结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c2acf0a7da6dab9b867bdeee644276bab169f8a3ce9c55f42f055efbe2d40898.jpg)

05.A
- 度为4、高度为 $h$ 的树
  - 最少结点数条件
    - 至少有一个结点有4个分支
    - 每层结点数尽可能少
    - 结点个数为 $h+3$
  - 最多结点数条件
    - 每个非叶结点度为4
    - 为满树
    - 总结点数最多为 $1+4+4^2+...+4^{h-1}$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/319130282b8c21b7aad8111328893a19cc0d7390c7079f8ec405a0db31354fb8.jpg)

06.C
- 完全三叉树的层次分布
  - 第1层：1个结点
  - 第2层：$3^1 = 3$个结点
  - 第3层：$3^2 = 9$个结点
  - 第4层：$3^3 = 27$个结点
  - 结点总和：$1+3+9+27=40$
  - 第5层：$50-40=10$个结点
  - 最小高度为5

07.B
- 结点度数关系
  - 总结点数：$n=n_0+n_1+n_2+n_3=6+n_1+1+2=n_1+9$
  - 总度数：$n-1=n_1+2n_2+3n_3=n_1+2+6=n_1+8$
  - $n_1$为大于等于9的任意整数

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d3f8afcf3229449d56c1d3a158ee20af4df2bc26b4b7044ed548cbd0e4ab56a7.jpg)

08.D
- 叶结点数计算
  - 设叶结点数为 $N_0$，总结点数为 $N$
  - $N=N_1+2N_2+3N_3+...+mN_m+1$
  - $N=N_0+N_1+N_2+N_3+...+N_m$
  - $N_0=N_2+2N_3+...+(m-1)N_m+1=\sum_{i=2}^m(i-1)N_i+1$

09.B
- 结点度数分析
  - 设度为 $i(i=0,1,2,3,4)$ 的结点数为 $n_i$
  - $n=1+n_1+2n_2+3n_3+4n_4=n_0+n_1+n_2+n_3+n_4$
  - $n_1+2n_2+3n_3+4n_4=122$
  - $n_1+n_2+n_3+n_4=41$
  - 得出 $n_0=82$

10.C
- 解法1：树的边数性质
  - $n$个结点的树有$n-1$条边
  - 结点数比边数多10 $(25-15=10)$
  - 共有10棵树

- 解法2：图的生成树性质
  - 顶点数为$n$的生成树含有$n-1$条边
  - 结点数比边数多1
  - 分析同解法1

# 二、综合应用题

01.【解答】
- 三叉树最小高度计算
  - 完全三叉树性质
    - 高度为$h$
    - 第$h$层至少1个结点
    - 最多有$3^{h-1}$个结点
  - 结点数关系
    - $1+3^1+3^2+...+3^{h-2}<n\leq1+3^1+3^2+...+3^{h-2}+3^{h-1}$
    - $(3^{h-1}-1)/2<n\leq(3^h-1)/2$
    - $3^{h-1}<2n+1\leq3^h$
  - 最小高度
    - $h<\log_3(2n+1)+1$
    - $h\geq\log_3(2n+1)$
    - $h=\lceil\log_3(2n+1)\rceil$

02.【解答】
- 树的结点度数分析
  - 设度为$i(i=0,1,2,3,4)$的结点数为$n_i$
  - 结点总数：$n=n_0+n_1+n_2+n_3+n_4=23+n_4$
  - 度数关系：$n=0+n_1+2n_2+3n_3+4n_4+1=17+4n_4$
  - 解得：$n_4=2$，$n=25$

03.【解答】
- 树的结点与度数关系
  - 结点数等于度数加1：$n=\sum_{i=0}^m in_i+1=n_1+2n_2+3n_3+...+mn_m+1$
  - 总结点数：$n=n_0+n_1+n_2+...+n_m$
  - 叶结点数：$n_0=n_2+2n_3+...+(m-1)n_m+1=1+\sum_{i=2}^m(i-1)n_i$

> attention:
- 常用结点与度数关系
  - 总结点数：$n_0+n_1+n_2+...+n_m$
  - 总分支数：$1n_1+2n_2+...+mn_m$
  - 总结点数=总分支数+1



# 5.2.4 答案与解析  

# 一、单项选择题  

01.C
- 二叉树与度为2的有序树比较
  - 孩子左右次序区分
    - 二叉树单孩子有确定左右次序
    - 度为2有序树单孩子无需区分左右
  - 完全二叉树性质
    - 度为1的结点最多一个且只有左孩子
    - 高度为 $\lceil\log_2(n+1)\rceil$ 或 $\lfloor\log_2n\rfloor+1$

02.C
- 空二叉树概念
  - 无结点不等于不存在
  - 类比空线性表、空树
  - 图不能为空

03.A
- 完全二叉树性质
  - 叶结点双亲的左兄弟必有孩子且在前
  - 叶结点数满足 $n_0=n_2+1$
  - 可采用顺序存储结构
  - 第i个结点左孩子不一定存在

04.B
- 度为2的结点数计算
  - 由 $n_0=n_2+1$ 得 $n_2=n_0-1=10-1=9$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ad1577274eda3fe97eb16978d4605b1c956728b5379cd66531918fc961d2062d.jpg)

05.B
- 最少结点数计算
  - 根结点层1个结点
  - 其他h-1层各2个结点
  - 总结点数 $=2(h-1)+1=2h-1$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/95a4c13d0ab9c34fb84df72c99b09f011ea9575976fd46e6202394347e746ca6.jpg)

06.D
- 二叉树形态数计算
  - n-1个结点各有左右两种可能
  - 共有 $2^{n-1}$ 种组合形态

07.C
- 最小高度计算
  - 完全二叉树高度最小
  - $h=\lfloor\log_2n\rfloor+1=\lfloor\log_250\rfloor+1=6$

08.C
- 度为1的结点数性质
  - 由 $n_0=n_2+1$ 和 $n=n_0+n_1+n_2$
  - 得 $n_1=2(n-n_2)-1$ 为奇数
  - 不可能有 $2m$ 个度为1的结点

09.C
- 二叉树高度范围
  - 单支树最大高度1025
  - 完全二叉树最小高度 $\lfloor\log_2n\rfloor+1=11$

10.C
- 总结点数与高度关系
  - 第一层1个结点
  - 其余h-1层各2个结点
  - 总结点数 $=1+2(h-1)=15$，得 $h=8$

11.C
- 完全二叉树最少结点数
  - 前h-1层为满二叉树，有 $2^{h-1}-1$ 个结点
  - 第h层至少1个结点
  - 最少结点数 $=2^{h-1}-1+1=2^{h-1}$

12.A
- 完全二叉树最少结点数
  - 第6层有8个叶结点
  - 前5层为满二叉树
  - 最少结点数 $=2^5-1+8=39$

13.A
- 叶结点数计算
  - 第5层16个结点
  - 第6层3个叶结点
  - 第5层剩余14个叶结点
  - 总叶结点数17个

14.D
- 叶结点数计算
  - 最后分支结点序号 $\lfloor1001/2\rfloor=500$
  - 叶结点数501

15.C
- 第7层最多结点数
  - 7层满二叉树127个结点
  - 第7层最多 $2^6-1=63$ 个结点

16.B
- 最大结点数计算
  - $n_0=n_2+1$ 得 $n_2=123$
  - $n=n_0+n_1+n_2=247+n_1$
  - 当 $n_1=1$ 时最大值248

17.B
- 空指针数计算
  - 非空指针数 $=n-1$
  - 总指针数 $=2n$
  - 空指针数 $=2n-(n-1)=n+1$

18.A
- 二叉链表和三叉链表空指针数量比较
  - 二叉链表空指针数为 $n+1$
  - 三叉链表空指针数为 $n+2$
  - 根结点度为2时只有左右孩子指向它
  - 单根结点树无指针指向根结点

19.A
- 完全二叉树结点层次关系
  - 编号为 $i$ 的结点所在层次为 $\lfloor\log_2i\rfloor+1$
  - 同层结点满足 $\lfloor\log_2p\rfloor=\lfloor\log_2q\rfloor$

20.C
- 完全二叉树祖先结点查找
  - 结点17的祖先下标:8,4,2,1
  - 结点19的祖先下标:9,4,2,1
  - 最近公共祖先下标为4

21.C
- 三叉树高度计算
  - 第 $i$ 层最多 $3^{i-1}$ 个结点
  - 总结点数上限 $(3^h-1)/2$
  - 求解 $50\leq(3^h-1)/2$
  - $h=\lceil\log_3101\rceil=5$

22.B
- 三叉链表空指针计算
  - 总指针域数 $3n$
  - 非空指针数 $n-1$
  - 空指针数 $2n+1$

23.D
- 满二叉树结点数关系
  - 总结点数 $n=2^0+2^1+\cdots+2^{h-1}=2^h-1$
  - 叶结点数 $m=2^{h-1}$

24.C
- 完全二叉树最大结点数
  - 第6层有8个叶结点
  - 第7层缺失16个叶结点
  - 最大结点数 $2^7-1-16=111$

25.C
- 叶结点数计算
  - 最后分支结点编号 $\lfloor768/2\rfloor=384$
  - 叶结点数 $768-384=384$
  - 另解:由 $n=2n_0+n_1-1$ 且 $n_1=1$ 得 $n_0=384$

26.A
- 满二叉树结点数关系
  - 高度为 $h$ 的满二叉树
  - 最后一层叶结点数 $2^{h-1}=k$
  - 总结点数 $2^h-1=2k-1$

27.A
- 顺序存储空间需求
  - 高度为5的二叉树
  - 需存储1~5层所有结点
  - 总存储单元数 $1+2+4+8+16=31$

28.C
- 三叉树高度分析
  - 高度5的满三叉树结点数121
  - 高度6的满三叉树结点数364
  - 结点数244介于两者之间
  - 最小高度为6
# 二、综合应用题  

01.【解答】
- 二叉树中度为0和度为2的结点关系
  - 基本关系: $n_0 = n_2 + 1$
  - 总结点数: $n = n_0 + n_1 + n_2 = 2n_0 + n_1 - 1$
  - 两种情况分析:
    - 当 $n_1 = 1$ 时
      - $n = 2n_0$
      - $h = \lceil\log_2(n+1)\rceil = \lceil\log_2(2n_0+1)\rceil$
    - 当 $n_1 = 0$ 时
      - $n = 2n_0 - 1$
      - $h = \lceil\log_2(n+1)\rceil = \lceil\log_2(2n_0)\rceil = \lceil\log_2(n_0)\rceil + 1$

02.【解答】
- 满二叉树特性分析
  - 基本关系
    - $n_1 = 0$
    - $n_0 = n_2 + 1$
    - $n_2 = n_0 - 1$
  - 结点数关系
    - $n = n_0 + n_1 + n_2 = 2n_0 - 1$
    - $n_0 = (n+1)/2$
    - 分支结点数: $n_2 = (n-1)/2$
  - 高度关系
    - 结点总数: $n = 2^h - 1$
    - 高度: $h = \log_2(n+1)$

03.【解答】
- 完全二叉树结点分析
  - 层次结构
    - 第9层有240个结点(未满)
    - 1~8层是满的
  - 结点数计算
    - 总结点数: $2^8 - 1 + 240 = 495$
    - 第8层叶结点: $2^{8-1} - 120 = 8$
    - 总叶结点数: $8 + 240 = 248$
  - 另解
    - 总结点关系: $n = n_0 + n_1 + n_2 = 2n_0 + n_1 - 1$
    - 当 $n_1 = 0$ 时: $2n_0 - 1 = 495$, 得 $n_0 = 248$

> attention:  
完全二叉树特点：只有最底层结点不满，其他层结点都是满的（第 $i$ 层有 $2^{i-1}$ 个结点）

04.【解答】
- m叉树的层次特性
  - 各层结点数
    - 第1层: $m^0 = 1$
    - 第2层: $m^1$
    - 第3层: $m^2$
    - 第i层: $m^{i-1}$ $(1 \leq i \leq h)$
  - 结点编号关系
    - 第1个子女编号: $j = (i-1)m + 2$
    - 双亲编号: $(i-2)/m + 1$ (i > 1)
    - 第k个子女编号: $(i-1)m + k + 1$ $(1 \leq k \leq m)$
  - 右兄弟判定
    - 条件: $i \leq \lfloor(i+m-2)/m\rfloor m$
    - 右兄弟编号: $i + 1$
    - 另一判定方法: $(i-1)\%m \neq 0$

05.【解答】
- 二叉树最近公共祖先查找
  - 基本原理
    - 任意两结点必有公共祖先
    - 结点i的双亲编号为i/2
  - 算法步骤
    - 当i > j时
      - 若i/2 = j，则j为最近公共祖先
      - 否则令i = i/2继续查找
    - 当j > i时
      - 若j/2 = i，则i为最近公共祖先
      - 否则令j = j/2继续查找

ElemType Comm Ancestor(SqTree T,int i,int j){
if(T[i] != '#'&&T[j]!='#'){
while(i != j){
if(i > j) i = i/2
else j = j/2;
return T[i];

06.【解答】
- 正则k叉树特性
  - 结点类型关系
    - 叶结点数: $n_0$
    - 度为k的分支结点数: $n_k = m$
    - 总结点数: $n = n_0 + m$
    - 边数关系: $e = mk = n - 1$
    - 叶结点数公式: $n_0 = (k-1)m + 1$
  - 最大最小结点数
    - 最大结点数
      - 除最后一层外都是分支结点
      - 总结点数: $M_1 = \frac{k^h-1}{k-1}$
    - 最小结点数
      - 每层(除根外)只有k个结点
      - 总结点数: $M_2 = 1 + (h-1)k$

# 5.3.4 答案与解析  

# 一、单项选择题  

01.C
- 二叉树中序遍历最后结点特性
  - 从根沿右子女指针到底
  - 若结点p不是叶结点
    - 前序遍历最后结点在左子树中
  - 若结点p是叶结点
    - 前序与中序遍历最后结点相同
  - 若p有左子女q且q为叶结点
    - q为前序遍历最后结点
    - q不是中序遍历最后结点

02.C
- 三种遍历方式特点
  - 都先遍历左子树再遍历右子树
  - b一定在c前访问

03.C
- 中序遍历n在m前的情况分析
  - 遍历顺序：左子树→根结点→右子树
  - n总在m的左方

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c8dfbbbff6ae56c3a36e875776bcce647d64015dd0dfcf999e8fb6318c9484c.jpg)

- 最近公共祖先p的情况
  - m和n在p的左右分支
  - m为祖先且n在左分支
  - n为祖先且m在右分支

04.D
- 后序遍历LRN的特点
  - n在N左子树、m在N右子树时n先访问
  - n是m子孙时n先访问
  - 需同层条件才能确定访问顺序

05.C
- 后序遍历查找路径方法
  - 递归方式
    - 退回时访问根结点
    - 自下向上输出路径结点
  - 非递归方式
    - 访问n时栈记录父指针路径
    - 可找到m到n路径

06.C
- 二叉树数组存储特点
  - 下标i结点的左孩子：$2i+1$
  - 下标i结点的右孩子：$2i+2$
  - 后序遍历序列：gdbhefca

07.B
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa6d8f24cab5aa92b27438714e0ea552714791a720fe2eaeba68cc0233a247df.jpg)
- 三种遍历方式特点
  - 左右子树访问顺序不变
  - 只是根结点访问顺序不同
  - 叶结点访问顺序相同

08.C
- 结点编号规则
  - 从1开始按序编号
  - 结点编号大于左右孩子编号
  - 左孩子编号小于右孩子编号
  - 符合后序遍历特点

09.B
- 结点编号特点分析
  - v编号小于左子树最小编号
  - 右子树最小编号大于左子树最大编号
  - v编号最小，符合先序遍历

10.D
- ABC前序遍历二叉树分析
  - 共5种不同二叉树
  - 后序为CBA的有4种单支树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/34221acdbf2a5f9f21856b9d382d537e9e3cd45d327be8acda64e2f8ee90de74.jpg)

11.C
- 7结点完全二叉树特点
  - 3层满二叉树
  - 根据后序序列填充
  - 先序遍历序列：ABCDEFG

12.C
- 二义树遍历序列分析
  - 前序NLR中X在Y前
  - 后序LRN中X在Y后
  - X在根位置满足要求

13.C
- 先序中序序列关系分析
  - 先序：$\cdots a\cdots b\cdots$
  - 中序：$\cdots b\cdots a\cdots$
  - b在a左子树中

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/642d1f563463bd5539d46487993763c0b724a04aebd2be9103fc251eb80649bb.jpg)

14.B
- 解法分析
  - 解法1：根据树的结构分析
  - 解法2：栈的入栈出栈分析
  - 解法3：序列构造二叉树验证

15.D
- 先序后序序列特点
  - 可确定根结点
  - 无法划分左右子树
  - 存在多种可能结构

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e27b68d581f4fb471640e3280e713e72c68fa75cf61242e5f7209e4566ed3e8.jpg)
16.B  

中序遍历是“左根右”，后序遍历是“左右根”，当任一结点没有右子树时，两种遍历都是“左根”。显然，当二叉树为空树或只有根结点时，其中序序列和后序序列也相同。  

17.D  

根据后序序列与中序序列可构造出二叉树，如下图所示。由图可知先序序列为CEDBA。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4cefbbc82ac6fc9969c3dc3c587dee80b1f5fed7de8b40713c50310eb0bf5f3a.jpg)  
(a）确定根结点  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e8e141edfda28a636a0ce51573db02149bc3834aba03d4804069d134cff26df.jpg)  
(b）确定左子树根结点  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e109474afccc6679b8deb8740d93ca9e330ffc6dbe8718246d392440feb056a.jpg)  
（c）确定剩下的子树  
18.A  

对于这种遍历序列问题，先根据遍历的性质排除若干项，若还无法确定答案，则再根据遍历结果得到二义树，找到对应遍历序列。例如，在本题中，已知先序和中序遍历结果，可知本树的根结点为 $A$ ，左子树有 $C$ 和 $B$ ，其余为右子树，则后序遍历结果中， $A$ 一定在最后，并且 $C$ 和 $B$ 一定在前面，排除答案B和D。又因先序中有DEF，中序中有EDF，则 $D$ 为这个子树的根，所以 $D$ 在后序中排在 $E F$ 之后。  

根据二叉树的递归定义，要确定二叉树，就要分别我到根结点和左、右子树。因此，根据遍历结果，必定要确定根结点位置和如何划分左、右子树，才可以确定最终的二叉树。因此，仅有先序和后序遍历不能唯一确定一棵二叉树，而二者之一加上中序遍历都可以唯一确定一棵二叉树。如在本题中，根据先序和中序遍历的结果确定二叉树的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1aead16498b6de7d7cbdaa3c6d01338f073d72817739dd6eedbd644395296825.jpg)  

19.B  

可构造出二叉树如下图所示。因此，先序序列为ABCDEF。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/27df33368b083839eedf3b0514ca7af88ed07bfe2a1949644c0aaa80fab81cc6.jpg)  

20.B  

若a是b的祖先，则后序遍历时一定先遍历b后遍历a，所以B错误。  

21.C  

删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。  

22.A  

线索是前驱结点和后继结点的指针，引入线索的目的是加快对二叉树的遍历。  

23.C  

二义树是一种逻辑结构，但线索二叉树是加上线索后的链表结构，即它是二叉树在计算机内部的一种存储结构，所以是一种物理结构。  

24.C  

$n$ 个结点共有链域指针 $2n$ 个，其中，除根结点外，每个结点都被一个指针指向。剩余的链域建立线索，共 $2n\!-\!(n\!-\!1)\!=\!n+1$ 个线索。  

25.C  

线索二叉树中用1tag/rtag标识结点的左/右指针域是否为线索，其值为1时，对应指针域为线索，其值为0时，对应指针域为左/右孩子。  

26.D  
对左子树为空的二叉树进行先序线索化，根结点的左子树为空并且也没有前驱结点（先遍历根结点），先序遍历的最后一个元素为叶结点，左、右子树均为空且有前驱无后继结点，所以线索化后，树中空链域有2个。  

27.D  

不是每个结点通过线索都可以直接找到它的前驱和后继。在先序线索二叉树中查找一个结点的先序后继很简单，而查找先序前驱必须知道该结点的双亲结点。同样，在后序线索二叉树中查找一个结点的后序前驱也很简单，而查找后序后继也必须知道该结点的双亲结点，二叉链表中没有存放双亲的指针。  

28.D  

后序线索二叉树不能有效解决求后序后继的问题。如下图所示，结点 $E$ 的右指针指向右孩子，而在后序序列中 $E$ 的后继结点为 $B$ ，在查找 $E$ 的后继时仍然只能按常规方法来查找。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9318f19145a8c0b4a573067e58e6f8d3647d9167959521a6ffd703d20ded8ee3.jpg)  

29.C  

在二叉中序线索树中，某结点若有左孩子，则按照中序“左根右”的顺序，该结点的前驱结点为左子树中最右的一个结点（注意，并不一定是最右叶结点）。  

30.A  

在二义树的后序遍历中，叶结点 $X$ 的后继是其双亲，因此 $X$ 的右线索应指向该结点。  

31.C  

后序线索树遍历时，最后访问根结点，若从右孩子 $x$ 返回访问父结点，则由于结点 $x$ 的右孩子不一定为空（右指针无法指向其后继），因此通过指针可能无法遍历整棵树。如下图所示，结点中的数字表示遍历的顺序，图（c）中结点6的右指针指向其右孩子5，而不指向其后序后继结点 7，因此后序遍历还需要栈的支持，而图（a）和图（b）均可遍历。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f01e1f5c6bfa0ab8bd3496477988e32b56646f62f9a9f0dfb01b87aa9c670ced.jpg)  

32.B  

非空二叉树的先序序列和后序序列相反，即“根左右”与“左右根”顺序相反，因此树只有根结点，或根结点只有左子树或右子树，其子树也有同样的性质，任意结点只有一个孩子，才能满足先序序列和后序序列正好相反。此时树形应为一个长链，树中仅有一个叶结点。  

33.D  

分析遍历后的结点序列，可以看出根结点是在中间被访问的，而且右子树结点在左子树之前，则遍历的方法是RNL。本题考查的遍历方法并不是二叉树遍历的3种基本遍历方法，对于考生而言，重要的是掌握遍历的思想。  

34.D  
题中所给二叉树的后序序列为dbca。结点  $d$  无前驱和左子树，左链域空，无右子树，右链域 指向其后继结点  $^b$  ：结点  $^b$  无左子树，左链域指向其前驱结点d：结点c无左子树，左链域指向其 前驱结点 $b$ ，无右子树，右链域指向其后继结点a。  

35.C  

前序序列为NLR，后序序列为LRN，由于前序序列和后序序列刚好相反，所以不可能存在一个结点同时有左右孩子，即二叉树的高度为4。1为根结点，由于根结点只能有左孩子（或右孩子），因此在中序序列中，1或在序列首或在序列尾，选项A、B、C、D皆满足要求。仅考虑以1的孩子结点2为根结点的子树，它也只能有左孩子（或右孩子），因此在中序序列中，2或在序列首或在序列尾，选项A、B、D皆满足要求。  

【另解】画出各选项与题干信息所对应的二叉树如下，所以A、B、D均满足。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d099fc600e15293c0170714c6edf949b02c8780239cab62e97f4a5e96d748617.jpg)  

36.A  

前序序列和后序序列不能唯一确定一棵二叉树，但可以确定二叉树中结点的祖先关系：当两个结点的前序序列为  $X Y$  与后序序列为  $Y X$  时，则  $X$  为Y的祖先。考虑前序序列  $a,e,b,d,c.$  、后序 序列 $b,c,d,e,a$ ，可知 $a$ 为根结点， $e$ 为 $a$ 的孩子结点：此外，由 $^a$ 的孩子结点的前序序列 $e,b,d,$  $c$ 、后序序列 $b,c,d,e$ ，可知 $e$ 是bcd的祖先，所以根结点的孩子结点只有 $e$ 。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e13cc912f00d28b8c5a3bec288939e86c8cb0b0754b83808c75780f6542f39f.jpg)  

排除法：显然 $a$ 为根结点，且确定 $e$ 为 $a$ 的孩子结点，排除D。各种遍历算法中左右子树的遍历次序是固定的，若 $^b$ 也为 $a$ 的孩子结点，则在前序序列和后序序列中e、 $^b$ 的相对次序应是不变的，所以排除B，同理排除C。  

特殊法：前序序列和后序序列对应多棵不同的二叉树树形，我们只需画出满足该条件的任意一棵二叉树即可，任意一棵二叉树必定满足正确选项的要求。  

显然选择A，最终得到的二叉树满足题设中前序序列和后序序列的要求。  

37.A。  

根据后序线索二叉树的定义， $X$ 结点为叶结点且有左兄弟，因此这个结点为右孩子结点，利用后序遍历的方式可知 $X$ 结点的后序后继是其父结点，即其右线索指向的是父结点。为了更加形象，在解题的过程中可以画出如下所示的草图。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fbb372f30cb32518e9b3df19e5081a39269c66488b4aed85f920e92b2381459.jpg)  
38.D  

线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写 出二叉树的中序遍历序列debxac，中序遍历中在 $x$ 左边和右边的字符，就是它在中序线索化的左、右线索，即 $b,a$  

39.B  

根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列 $a$ b,C, $d$ 为入栈次序，则出栈序列的个数为？”，对于 $n$ 个不同元素进栈，出栈序列的个数为 $\frac{1}{n+1}C_{2n}^{n}=14$  

40.B  

后序序列先访问左子树，接着访问右子树，最后访问父结点，递归进行。根结点左子树的叶结点首先被访问，它是e。接下来是它的父结点  $a$  ，然后是  $a$  的父结点  $c$  。接着访问根结点的右子树。它 的叶结点 $^b$ 首先被访问，然后是 $b$ 的父结点 $d$ ，再后是 $d$ 的父结点 $g$ ，最后是根结点f，如下图所示。因此 $d$ 与 $a$ 同层，B正确。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/310cd850ebe2a0f810b9d0c1fede865efc5ef4c10f8c6920b4d153dd4a92a79c.jpg)  

41.B  

先序序列先访问父结点，接着访问左子树，然后访问右子树。中序序列先访问左子树，接着 访问父结点，然后访问右子树，递归进行。若所有非叶结点只有右子树，则先序序列和中序序列都先访问父结点，后访问右子树，递归进行。  

42.B  

对于此类题，每种情况只需举出一个反例即可。如图1所示， $q$ 是 $p$ 的双亲，中序遍历序列为 $\{p,\,q\}$ ，选项1可能。如图2所示， $q$ 是 $p$ 的右孩子，中序遍历序列为 $\{p,\,q\}$ ，选项ⅡI可能。如图4所示， $q$ 是 $p$ 的双亲的双亲，中序遍历序列为 $\{x,\,p,\,q\}$ ，选项IV可能。如图3所示， $q$ 是 $p$ 的右兄弟， $F$ 是 $q$ 和 $p$ 的父结点，中序遍历要求先遍历左子树，再访问根结点，最后遍历右子树，因此一定先访问 $p$ ，再访问 $F$ ，最后访问 $q$ ， $p$ 和 $q$ 不可能相邻出现，选项IⅢI不可能。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c591f62273d2efdf988f7bd9a8243e35fdfd2e0d1d0a44899a8560f7f7e740ab.jpg)  

43.A  

根据二叉树的树形和后序遍历序列，可以轻松地将各字母填入结点中，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0629617052231773263820303ba41813a70ec33b531926ab0f20663456bbcf6.jpg)  

然后对该二叉树进行先序遍历，得到序列aedfbc。  

# 二、综合应用题  

01.【解答】  

二义树的先序序列是NLR，后序序列是LRN。要使 $\mathrm{NLR}=\mathrm{NRL}$ （后序序列反序）成立，L或R应为空，这样的二叉树每层只有一个结点，即二叉树的形态是其高度等于结点个数。以3个结点 $a,b,c$ 为例，其形态如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/15e666d30bf5cb8d01e1ef955c018597ec9fe12c9f7ec6b39d30b712a5cb21cc.jpg)  

02.【解答】  

二叉树的先序序列是NLR，后序序列是LRN。要使NLR $=$ LRN成立，L和R应均为空，所以满足条件的二叉树只有一个根结点。  

# 03.【解答】  

算法思想如下：后序非递归遍历二叉树先访问左子树，再访问右子树，最后访问根结点。结合图5.10来分析： $\textcircled{\scriptsize{1}}$ 沿着根的左孩子，依次入栈，直到左孩子为空。此时栈内元素依次为 $A B D$  $\circledcirc$ 读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行 $\circledcirc$ ；否则，栈顶元素出栈并访问。栈顶 $D$ 的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶 $B$ 的右孩子不空且未被访问过， $E$ 入栈，栈顶 $E$ 的左右孩子均为空，出栈并访问：栈顶 $B$ 的右孩子不空但已被访问， $B$ 出栈并访问：栈顶 $A$ 的右孩子不空且未被访问过， $C$ 入栈，栈顶 $C$ 的左右孩子均为空，出栈并访问：栈顶 $A$ 的右孩子不空但已被访问，A出栈并访问。由此得到后序序列DEBCA。  

在上述思想的第 $\mathcal{Q}$ 步中，必须分清返回时是从左子树返回的还是从右子树返回的，因此设定一个辅助指针r，用于指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问。  

void PostOrder（BiTree T){ InitStack(S);BiTNode  $\scriptstyle{^{\star}\!\mathrm{p}=\mathrm{T}}$  BiTNode \*r=NULL; while(pll!IsEmpty(S))( if（p）{ //走到最左边 push(S,p);p=p->lchild; elsef /向右 GetTop(S,p);//读栈顶结点（非出栈）if(p->rchild&&p->rchild $!\!=\!\!\tau$ ）//若右子树存在，且未被访问过p=p->rchild; /转向右  
elsel //否则，弹出结点并访问 pop(s,p);/将结点弹出visit(p->data);/访问该结点 $\scriptstyle{\mathfrak{T}}={\mathfrak{P}}$  //记录最近访问过的结点  ${\mathfrak{p}}{=}$ NULL;l/结点访问完后，重置p指针}//else j//while  

> attention:  

每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将P置NULL  

04.【解答】  

一般的二叉树层次遍历是自上而下、从左到右，这里的遍历顺序恰好相反。算法思想：利用原有的层次遍历算法，出队的同时将各结点指针入栈，在所有结点入栈后再从栈顶开始依次访问即为所求的算法。具体实现如下：  

1）把根结点入队列。  

2）把一个元素出队列，遍历这个元素。3）依次把这个元素的左孩子、右孩子入队列。4）若队列不空，则跳到2），否则结束。  

算法实现如下：  

void Invert Level(BiTree bt){Stack s; QueueQ; if(bt  $!=$  NULL)( InitStack(s);/栈初始化，栈中存放二叉树结点的指针InitQueue（Q);//队列初始化，队列中存放二叉树结点的指针EnQueue（Q,bt);while(IsEmpty(Q)  $==$  false)( 川从上而下层次遍历 DeQueue（Q,p）;Push(s,p); /出队，入栈 if（p->lchild) EnQueue（Q，p->lchild）；//若左子女不空，则入队列if（p->rchild) EnQueue（Q，p->rchild）；//若右子女不空，则入队列while(IsEmpty(s)  $==$  false){ Pop(s,p); visit(p->data); /自下而上、从右到左的层次遍历}//if结束  

05.【解答】  

采用层次遍历的算法，设置变量1evel记录当前结点所在的层数，设置变量1ast指向当前层的最右结点，每次层次遍历出队时与1ast指针比较，若两者相等，则层数加1，并让1ast 指向下一层的最右结点，直到遍历完成。1eve1的值即为二叉树的高度。  

算法实现如下：  
int Btdepth（BiTree T)( 1/采用层次遍历的非递归方法求解二叉树的高度  

if（!T) return 0;//树空，高度为0int front  $\scriptstyle{\c=-1}$  ,rear  ${\scriptstyle{\ =-1}}$  int last  $=\!0$  ,leve  $_{1=0}$  //1ast指向当前层的最右结点 BiTree Q[MaxSize]; //设置队列Q，元素是二叉树结点指针且容量足够 Q[++rear] $\mathbf{\mu=}\mathbb{T}$ /将根结点入队BiTree p; while(front<rear)( //队不空，则循环 p=Q[++front];/队列元素出队，即正在访问的结点if(p->lchild) Q[++rear]=p->lchild;//左孩子入队if(p->rchild) Q[++rear]=p->rchild；//右孩子入队if（front $==$ last){//处理该层的最右结点level++; /层数增1 last=rear; //last指向下层 } return level;  

求某层的结点个数、每层的结点个数、树的最大宽度等，都可采用与此题类似的思想。当然此题可编写为递归算法，其实现如下：  

int Btdepth2（BiTree T){ if  $\scriptstyle{\mathrm{T}}=$  NULL) return0;/空树，高度为0ldep $\scriptstyle{\mathrm{~\textemdash~}}$ Btdepth2(T->lchild);/左子树高度rdep $\scriptstyle{\mathrm{~\!~\!~\!~\!~}}=$ Btdepth2(T->rchild);//右子树高度if(ldep>rdep) return ldep $^{+1}$ 八//树的高度为子树最大高度加根结点else return rdep  $^{+1}$  

06.【解答】  

根据完全二叉树的定义，具有 $n$ 个结点的完全二叉树与满二叉树中编号从 $1\!\sim\!n$ 的结点一一对应。算法思想：采用层次遍历算法，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。  

算法实现如下：  

bool IsComplete（BiTree T){1/本算法判断给定二叉树是否为完全二叉树InitQueue(Q）; if(!T) return true; /空树为满二叉树 EnQueue（Q,T）;while(!IsEmpty(Q)){ DeQueue(Q,p）; if(p）{ 结点非空，将其左、右子树入队列 EnQueue(Q,p->lchild);  
EnQueue(Q,p->rchild); else/结点为空，检查其后是否有非空结点while(!IsEmpty(Q)){ DeQueue（Q,p);if(p)/结点非空，则二叉树为非完全二叉树return false; return true;  

07.【解答】  

计算一棵二叉树b中所有双分支结点个数的递归模型f（b）如下：  

$\pounds_{\mathbf{\alpha}}(\mathfrak{b})=\!0$ 若 $_\mathrm{b}=$ NULLf(b) $\scriptstyle{={\frac{\epsilon}{2}}}$ (b->1child)+f(b->rchild)+1若 $\star_{\mathrm{b}}$ 为双分支结点f(b） $\scriptstyle{={\underline{{\boldsymbol{\mathsf{F}}}}}}$ (b->lchild) $+\mathbb{E}$ (b->rchild)其他情况（ $\star_{\mathrm{b}}$ 为单分支结点或叶结点）  

具体算法实现如下：  

in tD son Nodes(BiTree b)if  $\scriptstyle{\mathrm{b}}=$  NULL) return0; elseif(b->lchild!  $=$  NULL&&b->rchild!  $=$  NULL）/双分支结点 return DSonNodes(b->lchild)+DsonNodes(b->rchild)  $^{+1}$  else return DSonNodes（b->lchild)+DsonNodes(b->rchild);  

当然，本题也可以设置一个全局变量Num，每遍历到一个结点时，判断每个结点是否为分支结点（左、右结点都不为空，注意是双分支），若是则 $\mathtt{N u m++}$  

08.【解答】  

采用递归算法实现交换二义树的左、右子树，首先交换b结点的左孩子的左、右子树，然后交换b结点的右孩子的左、右子树，最后交换b结点的左、右孩子，当结点为空时递归结束（后序遍历的思想）。算法实现如下：  

void swap(BiTreeb){ 川本算法递归地交换二叉树的左、右子树if(b){ swap(b->lchild); /递归地交换左子树 swap(b->rchild); /递归地交换右子树 temp=b->lchild;I/交换左、右孩子结点b->lchild=b->rchild; b->rchild=temp;  

09.【解答】  

设置一个全局变量1（初值为1）来表示进行先序遍历时，当前访问的是第几个结点。然后可以借用先序遍历的代码模型，先序遍历二叉树。当二叉树b为空时，返回特殊字符#：当 $\tt k\mathrm{=}\mathrm{i}$ 时，该结点即为要找的结点，返回b->data；当 $\ k\not=1$ 时，递归地在左子树中查找，若找到则返回该值，否则继续递归地在右子树中查找，并返回其结果。对应的递归模型如下：  
f $(\mathtt{b}\,,\mathtt{k})="\,\#$ 当 $\mathbf{b}=$ NULL时f(b,k)=b->data当 $\scriptstyle{\dot{\Sigma}}={\dot{K}}$ 时f $({\mathfrak{b}},{\mathfrak{k}})=($  $\scriptstyle{\mathrm{ch}}=\mathbb{E}$ (b->lchild,k)） $,==$ '#'?f（b->rchild,k):ch)其他情况  

算法的实现如下：  

ElemType PreNode（BiTree b,int k){1/本算法查找二叉树先序遍历序列中第  $\kappa$  个结点的值 if  $\scriptstyle(\mathbf{b}=\mathbf{\alpha}$  NULL) /空结点，则返回特殊字符 return '# if（ $\scriptstyle{\dot{x}}=={\dot{\kappa}}$ 1/相等，则当前结点即为第 $\kappa$ 个结点return b->data;  $\ \ \dot{\mathbf{i}}_{++}$ //下一个结点ch  $\scriptstyle=$  PreNode(b->lchild,k); 左子树中递归寻找 if（ch!='#') /在左子树中，则返回该值 return ch; ch  $\scriptstyle\cdot^{=}$  PreNode(b->rchild,k); //在右子树中递归寻找 return ch;  

本题实质上就是一个遍历算法的实现，只不过用一个全局变量来记录访问的序号，求其他遍历序列的第 $\mathtt{k}$ 个结点也采用相似的方法。二叉树的遍历算法可以引申出大量的算法题，因此考生务必要熟练掌握二叉树的遍历算法。  

10.【解答】  

删除以元素值 $_\mathrm{x}$ 为根的子树，只要能删除其左、右子树，就可以释放值为 $_\mathrm{x}$ 的根结点，因此宜采用后序遍历。算法思想：删除值为x的结点，意味着应将其父结点的左（右）子女指针置空，用层次遍历易于找到某结点的父结点。本题要求删除树中每个元素值为 $_\mathrm{x}$ 的结点的子树，因此要遍历完整棵二叉树。算法实现如下：  

void Delete X Tree（BiTree&bt)(//删除以bt为根的子树if(bt）Delete x Tree(bt->lchild); Delete X Tree(bt->rchild); //删除bt的左子树、右子树 free(bt); //释放被删结点所占的存储空间 /在二叉树上查找所有以 $_\mathrm{x}$ 为元素值的结点，并删除以其为根的子树void Search（BiTree bt,ElemType x){ BiTree Q[];IIQ是存放二叉树结点指针的队列，容量足够大if(bt){ if(bt->data  $==$  /若根结点值为x，则删除整棵树 Delete x Tree(bt); exit(0); InitQueue（Q);EnQueue(Q,bt); while(!IsEmpty(Q)){ DeQueue(Q,p); if（p->lchild）/若左子女非空  
if(p->lchild->data  $==$  川左子树符合则删除左子树 Delete X Tree(p->lchild); p->lchild=NULL; //父结点的左子女置空else EnQueue(Q,p->lchild);川左子树入队列if(p->rchild)/若右子女非空if(p->rchild->data  $==$  II右子女符合则删除右子树 Delete X Tree(p->rchild); p->rchild  $\bar{-}$  NULL; II父结点的右子女置空else EnQueue(Q,p->rchild);川右子女入队列  

11.【解答】  

算法思想：采用非递归后序遍历，最后访问根结点，访问到值为 $_\mathrm{x}$ 的结点时，栈中所有元素均为该结点的祖先，依次出栈打印即可。算法实现如下：  

typedef struct{ BiTreet; int tag; )stack;//tag $=\!0$ 表示左子女被访问，tag $^{=1}$ 表示右子女被访问void Search（BiTree bt,ElemTypex){ /在二叉树bt中，查找值为 $\mathbf{x}$ 的结点，并打印其所有祖先stack s[];//栈容量足够大top  $_{i=0}$  while(bt!  $=$  NULLIItop  ${>}0$  while(bt  $:=$  NULL&&bt->data  $|=\times$  结点入栈 sD  $^{++}$  top].t=bt; s[top].tag  $=\!0$  bt=bt->lchild;/沿左分支向下if(bt!  $=$  NULL&&bt->data  $==$  printf（"所查结点的所有祖先结点的值为：\n"）；//找到xfor(  $\scriptstyle{\dot{\boldsymbol{\perp}}}={\boldsymbol{\perp}}$   $\scriptstyle{\dot{\mathbf{1}}}\,<=$  top;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  printf("od",s[i].t->data); //输出祖先值后结束 exit(1); while(top!=0&&s[top].tag  $==1$  top--;/退栈（空遍历）if(top  $!\!=\!\!0$  s[top].tag  $^{=1}$  bt=s[top].t->rchild; /沿右分支向下遍历 )//while(bt!  $=$  NULLIItop>0)  

因为查找的过程就是后序遍历的过程，所以使用的栈的深度不超过树的深度  

12.【解答】  

后序遍历最后访问根结点，即在递归算法中，根是压在栈底的。本题要找p和g的最近公共祖先结点r，不失一般性，设p在g的左边。算法思想：采用后序非递归算法，栈中存放二叉树结点的指针，当访问到某结点时，栈中所有元素均为该结点的祖先。后序遍历必然先遍历到结点p，栈中元素均为p的祖先。先将栈复制到另一辅助栈中。继续遍历到结点g时，将栈中元素从栈顶开始逐个到辅助栈中去匹配，第一个匹配（即相等）的元素就是结点p和g的最近公共祖先。算法实现如下：  
typedef struct BiTree t; int tag; //tag $:=0$ 表示左子女已被访问，tag $\scriptstyle{\mathfrak{z}}$ 表示右子女已被访问)stack; stack s[],sl[];//栈，容量足够大BiTree Ancestor(BiTree ROoT,BiTNode  $\star_{\mathbb{P}}$  ,BiTNode \*q）[ l/本算法求二叉树中p和g指向结点的最近公共结点top  $\scriptstyle{i=0}$  ;bt  $=$  ROOT; while(bt!  $=$  NULLl|top>0)( while(bt!  $=$  NULL){ s[  ${++}$  top].t=bt; s[top].tag  $=\!0$  bt=bt->lchild; //沿左分支向下while(top  $!\!=\!\!0$  &&s[top].tag  $==1$  //假定p在g的左侧，遇到p时，栈中元素均为p的祖先 if(s[top].  $\scriptstyle{\mathrm{tree=p}}$  for(  $_\mathrm{i}\!=\!\!1$   $\scriptstyle{\dot{\mathbf{1}}}\,<=$  top;  $\ \ \ \mathrm{i++}$  sl[i]  $=s$  [i]; topl  $=$  top; //将栈s的元素转入辅助栈s1保存 if(s[top]. $\scriptstyle{\mathrm{t==q}}$ //找到g结点for(  $\dot{\ }^{\dot{\ }\dot{\ }}$  top;  $\scriptstyle\dot{\Sigma}\,>\,0$  ；i--）（//将栈中元素的树结点到s1中去匹配 for(  ${\dot{\jmath}}=$  topl;j>0;j--) if(sl[j]. $\scriptstyle{\mathrm{t}}=={\mathrm{s}}$ [i].t)returns[i].t；//p和g的最近公共祖先已找到top--;/退栈}l/while if(top  $!\!=\!\!0$  s[top].tag  $^{=1}$  bt  $=_{S}$  [top].t->rchild; /沿右分支向下遍历 )//while return NULL; //p和g无公共祖先  

13.【解答】  

采用层次遍历的方法求出所有结点的层次，并将所有结点和对应的层次放在一个队列中。然后通过扫描队列求出各层的结点总数，最大的层结点总数即为二叉树的宽度。算法实现如下：  

typedef struct{ BiTree data[MaxSize];//保存队列中的结点指针int level[MaxSize];//保存data中相同下标结点的层次int front,rear;  
intBTWidth（BiTree b){ BiTree p; int k,max,i,n; Qu.front  $=$  Qu.rear  $\scriptstyle{\cdots}=-1$  /队列为空 Qu.rear++; Qu.data[Qu.rear] $\mathbf{\Sigma}=\mathbf{b}$ /根结点指针入队Qu.level[Qu.rear]  $^{=1}$  7根结点层次为1 while(Qu.front<Qu.rear){ Qu.front++;//出队 $\scriptstyle{\mathfrak{p}}=\mathtt{Q u}$ .data[Qu.front];//出队结点 $\kappa=$ Qu.level[Qu.front];//出队结点的层次if(p->lchild! $=$ NULL){1左孩子进队列Qu.rear++; Qu.data[Qu.rear]=p->lchild; Qu.level[Qu.rear]  $\mathbf{\lambda=}\mathbf{k}\mathbf{+}\mathbf{1}$  if(p->rchild! $=$ NULL){/右孩子进队列Qu.rear++; Qu.data[Qu.rear]=p->rchild; Qu.level[Qu.rear]  $=\!\kappa\!+\!1$  )//while max $=\!0$  $\scriptstyle{\dot{\mathbf{z}}}=0$ //max保存同一层最多的结点个数 $\kappa{=}1$  $//\kappa$ 表示从第一层开始查找while( $\scriptstyle{\dot{\mathbf{\rho}}}_{\dot{\mathbf{\rho}}}<=\left|\mathsf{Q u}\right|$ .rear){l/i扫描队中所有元素 $_{\mathrm{n}=0}$ 八 $/\mathrm{n}$ 统计第 $\kappa$ 层的结点个数while(  $\scriptstyle{\dot{\mathbf{1}}}<=\left|Q{\boldsymbol{\mathsf{u}}}\right|$  .rear&&Qu.level[i]  $\scriptstyle{==}k$   $\mathrm{n++}$   $\ \ \dot{\Sigma}^{++}$  k=Qu.level[i]; if(n>max)max $\tt=m$ //保存最大的nreturn max;  

> attention:  

本题队列中的结点，在出队后仍需要保留在队列中，以便求二叉树的宽度，所以设置的队列采用非环形队列，否则在出队后可能被其他结点覆盖，无法再求二叉树的宽度。  

14.【解答】  

对一般二叉树，仅根据先序或后序序列，不能确定另一个遍历序列。但对满二叉树，任意一个结点的左、右子树均含有相等的结点数，同时，先序序列的第一个结点作为后序序列的最后一个结点，由此得到将先序序列pre[l1..h1]转换为后序序列post[l2..h2]的递归模型如下：  

f（pre,11,h1,post,12,h2） $=$ 不做任何事情h1<11时f（pre,11,h1,post,12，h2） $=$ post[h2] $=$ pre[l1]其他情况  

取中间位置half $=$ (h1-11)/2;将pre[11+1，11+half]左子树转换为post[12，l2+half-1]，即f（pre)  $^{11+1}$   $^{11+}$  half,post,l2,12+half-1);  
将pre[11+half+1，h1]右子树转换为post[l2+half，h2-1]，即f（pre,11+half+1,h1,post,12+half,h2-1)。  

其中，post[h2] $=$ pre[11]表示后序序列的最后一个结点（根结点）等于先序序列的第一个结点（根结点）。相应的算法实现如下：  

void PreToPost（ElemType pre[],int11,inth1,ElemType post[],int12,inth2）{int half; if  $\stackrel{_{,\mathrm{h}1>=11}}{_{,\mathrm{h}2>=11}}$  post[h2]  $=$  pre[l1]; half  $=$  (h1-11)/2; PreToPost(pre,11+1,11+half,post,12,12+half-1); /转换左子树 PreToPost(pre,l1+half+l,h1,post,l2+half,h2-1); /转换右子树  

例如，有以下代码：  

ElemType \*pre $=$ "ABCDEFG";ElemType post[MaxSize]; PreToPost（pre,0,6,post,0,6）; printf（"后序序列："）；for(int  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\mathrm{i}}<=6$   $\ \ \mathrm{i++}$  printf（"c",post[i]）; printf（"\n");  

执行结果如下：  

后序序列：CDBFGEA  

15.【解答】  

通常使用的先序、中序和后序遍历对于叶结点的访问顺序都是从左到右，这里选择中序递归遍历。算法思想：设置前驱结点指针pre，初始为空。第一个叶结点由指针head指向，遍历到叶结点时，就将它前驱的rchild指针指向它，最后一个叶结点的rchild为空。算法实现如下：  

LinkedList head,pre $=$ NULL;//全局变量LinkedList InOrder(BiTree bt）{if（bt){ InOrder(bt->lchild); //中序遍历左子树 if(bt->lchild= $:=$ NULL&&bt->rchild $==$ NULL)//叶结点if(pre  $==$  NULL){ head=bt; pre  $=$  bt; 1/处理第一个叶结点elser pre->rchild=bt; pre  $=$  bt; //将叶结点链入链表InOrder(bt->rchild); /中序遍历右子树 pre->rchild=NULL; /设置链表尾 return head;  

上述算法的时间复杂度为 $O(n)$ ，辅助变量使用head和pre，栈空间复杂度为 $O(n)$  

16.【解答】  

本题采用递归的思想求解，若 $T_{1}$ 和 $T_{2}$ 都是空树，则相似；若有一个为空另一个不空，则必然不相似；否则递归地比较它们的左、右子树是否相似。递归函数的定义如下：  
1)f（T1, $\mathbb{T}2)=\mathbb{1}$ ；若 $\scriptstyle\mathrm{T}1==\mathrm{T}2=$ NULL。  

2）f（T1, $\mathbb{T}2)=\!0$ ：若T1和T2之一为NULL，另一个不为NULL。  

3)f（T1，  $\mathtt{T2)=f}$  (T1->1child,T2->lchild)&&f（T1->rchi1d,T2->rchild);若T1 和T2均不为NULL。  

因此，算法实现如下  

intsimilar（BiTree T1,BiTreeT2）/采用递归的算法判断两棵二叉树是否相似int lefts,rights; if（ $\scriptstyle\mathbb{T}\,\mathbb{I}\;=\;$ NULL&&T2 $==$ NULL)//两棵树皆空return 1; elseif（ $\scriptstyle{\mathrm{T}}\,\perp\,=$ NULL|IT2 $==$ NULL)/只有一棵树为空returno; elsef //递归判断 lefts  $=$  similar(T1->lchild,T2->lchild); rights  $=$  similar（T1->rchild,T2->rchild); return leftS&&rights;  

17.【解答】  

二义树的带权路径长度有两种常见的计算方法： $\textcircled{\scriptsize{1}}$ 根据二义树的带权路径长度的定义，二叉树的WPL值  $=$  树中全部叶结点的带权路径长度之和。  $\circledcirc$  根据带权二叉树的性质，二义树的WPL 值 $=$ 树中所有非叶结点的权值之和（记住该结论即可，不要求证明）。根据两种常见的计算方法，本题不难写出下列两种解法。  

1）算法的基本设计思想。  

$\textcircled{\scriptsize{1}}$ 本问题可采用递归算法实现。根据定义：  

二叉树的WPL值 $=$ 树中全部叶结点的带权路径长度之和 $=$ 根结点左子树中全部叶结点的带权路径长度之和 $^+$ 根结点右子树中全部叶结点的带权路径长度之和  

叶结点的带权路径长度  $=$  该结点的weight域的值  $\times$  该结点的深度  

设根结点的深度为0，若某结点的深度为 $d$ 时，则其孩子结点的深度为 $d+1$ 在递归遍历二叉树结点的过程中，若遍历到叶结点，则返回该结点的带权路径长度，否则返回其左右子树的带权路径长度之和。  

$\circledcirc$ 若借用非叶结点的weight域保存其孩子结点中weight域值的和，则树的WPL等于树中所有非叶结点weight域值之和。  

采用后序遍历策略，在遍历二叉树 $T$ 时递归计算每个非叶结点的weight域的值，则树 $T$ 的WPL等于根结点左子树的WPL加上右子树的WPL，再加上根结点中weight域的值。在递归遍历二叉树结点的过程中，若遍历到叶结点，则return0并且退出递归，否则递归计算其左右子树的WPL和自身结点的权值。  

2）二叉树结点的数据类型定义如下。  

typedef structnode{ int weight; struct node \*left,\*right; )BTree;  
3）算法的代码如下。  

$\textcircled{\scriptsize{1}}$ 基于方法1的算法实现  

intWPL（BTree\*root） //根据WPL的定义采用递归算法实现 returnWPL1（root,0); int WPLl（BTree \*root,int d)lla为结点深度if(root->left  $==$  NULL&&root->right  $==$  NULL) return(root->weight\*d);else return（WPL1(root->left,d+1)+WPL1（root->right,d+1));  

$\circledcirc$ 基于方法2的算法实现：  

intWPL（BTree\*root） //基于递归的后序遍历算法实现 intwl,wr; if（root->left==NULL&&root->right==NULL) return0; else w_l=WPL（root->left);/计算左子树的WPLw r=WPL（root->right）;/计算右子树的WPLroot->weight  $=$  root->left->weight+root->right->weight; //填写非叶结点的weight域return（w1+wr+root->weight）;/返回WPL值  

> attention:  

上述两种算法为官方标准答案，当遍历到度为1的结点时，会传入空指针，导致空指针异常。但是，作为408考试的算法题，不要求考虑特殊的边界条件，只要算法思想正确，代码逻辑正确，即可得满分。因此，在复习过程中，无须花过多的时间抠代码的各种边界条件。列  

# 18.【解答】  

1）算法的基本设计思想。  

表达式树的中序序列加上必要的括号即为等价的中缀表达式。可以基于二叉树的中序遍历策略得到所需的表达式。  

表达式树中分支结点所对应的子表达式的计算次序，由该分支结点所处的位置决定。为得到正确的中缀表达式，需要在生成遍历序列的同时，在适当位置增加必要的括号。显然，表达式的最外层（对应根结点）和操作数（对应叶结点）不需要添加括号。  

2）算法实现。  

将二叉树的中序遍历递归算法稍加改造即可得本题的答案。除根结点和叶结点外，遍历到其他结点时在遍历其左子树之前加上左括号，遍历完右子树后加上右括号。  

void BtreeToE(BTree \*root){ BtreeToExp（root,l); //根的高度为1 void BtreeToExp（BTree \*root,int deep）{ if(root $==$ NULL) return;/空结点返回elseif(root->left $==$ NULL&&root->right= $:=$ NULL)//若为叶结点  
printf("%s",root->data);//输出操作数，不加括号elser if（deep>l）printf("(");川若有子表达式则加一层括号BtreeToExp(root->left,deep  $^{+1}$  ); printf("os",root->data); /输出操作符 BtreeToExp(root->right,deep+1); if(deep>l)printf(")");若有子表达式则加一层括号  

19.【解答1】  

1）算法的基本设计思想。  

对于采用顺序存储方式保存的二叉树，根结点保存在SgBiTNode[O]中；当某结点保存在SqBiTNode[i]中时，若有左孩子，则其值保存在SqBiTNode[2i+1]中；若有右孩子，则其值保存在SqBiTNode[2i+2]中；若有双亲结点，则其值保存在SqBiTNode[（i-1）/2]中。  

二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。中序遍历二义搜索树得到一个升序序列。  

使用整型变量va1记录中序遍历过程中已遍历结点的最大值，初值为一个负整数。若当前遍历的结点值小于或等于val，则算法返回false，否则，将val的值更新为当前结点的值。  

2）算法实现。  

#define false0 #define true1 typedef int bool; bool judge In Order BST（SgBiTree bt，intk，int\*val）{//初始调用时  $\kappa$  的值是0 if(k<bt.ElemNum&&bt.SqBiTNode[k]  $!=-1$  if(!judge In Order BsT(bt,  $2^{\star}\kappa+1$  ,val)) return false; if(bt.SqBiTNode[k]  $<=\star$  val) return false; \*val  $=$  bt.SqBiTNode[k]; if(!judge In Order BsT(bt,  $2^{\star}\kappa+2$  ,val))return false; return true;  

【解答2】  

1）算法的基本设计思想。  

对于采用顺序存储方式保存的二叉树，根结点保存在SqBiTNode[O]中：当某结点保存在SqBiTNode[i]中时，若有左孩子，则其值保存在SqBiTNode[2i+1]中：若有右孩子，则其值Sq BiT Node $[2\,\dot{\Sigma}\!+\!2\,]$ 中；若有双亲结点，则其值保存在SqBiTNode[（i-1）/2]中。  

二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。设置两个数组pmax和pmin。根据二叉搜索树的定义，SgBiTNode[i]中的值应该大于以SqBiTNode[2i+1]为根的子树中的最大值（保存在pmax[2i+1]中），小于以SqBiTNode[2i+2]为根的子树中的最小值（保存在pmin[2i+1]中）。初始时，用数组Sq BiT Node El em Num p max pm in。  

在数组SqBiTNode中从后向前扫描，扫描过程中逐一验证结点与子树之间是否满足上述的大小关系。  

2）算法实现。  

#define false0 #define true 1  
typedef int bool; bool judgeBsT(SqBiTree bt){ int k,m,\*pmin,\*pmax; pmin $\scriptstyle=$ （int \*)malloc（sizeof（int) $\star$ (bt.ElemNum));pmax  $=$  （int\*)malloc（sizeof（int)\*（bt.ElemNum)); for( $k{=}0$ ;k<bt.ElemNum; $k++$ /辅助数组初始化pmin[k]=pmax[k]  $=$  bt.SqBiTNode[k]; for(  $\kappa=$  bt.ElemNum-1;  $_{k>0}$  ;k--）{ 1/从最后一个叶结点向根遍历 if(bt.SqBiTNode[k]  $!=-1$   $\mathsf{m}\!=\!\left(\mathbb{k}\!-\!\mathbb{1}\right)/2$  //双亲 if $(k82\!=\!\!1$ &&bt.SqBiTNode[m]>pmax[k])/其为左孩子pmin[m]  $=$  pmin[k]; else if（ $k\!\leqslant\!2\!=\!0\,\mathrm{i}$ &bt.SqBiTNode[m]<pmin[k])/其为右孩子pmax[m]  $=$  pmax[k]; else return false; return true;  

# 5.4树、森林  

# 5.4.1树的存储结构  

树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。  

# 1.双亲表示法  

这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。如图5.21所示，根结点下标为0，其伪指针域为-1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2e6b516fbf68e36a6730aff3150c9226473ea4cf4cbe0b6ac46cd04bc5e31e9.jpg)  
图5.21树的双亲表示法  

双亲表示法的存储结构描述如下：  

#define MAX TREE SIZE 100 typedef struct{ ElemType data;  

/树中最多结点数

/树的结点定义

//数据元素  
intparent;I/双亲位置域)PTNode; typedef structr /树的类型定义 PTNode nodes[MAX TREE SIZE];双亲表示intn;/结点数)PTree;  

双亲表示法利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时则需要遍历整个结构。  

> attention:  

区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。  

# 2.孩子表示法  

孩子表示法是将每个结点的孩子结点视为一个线性表，且以单链表作为存储结构，则 $n$ 个结点就有 $n$ 个孩子链表（叶结点的孩子链表为空表）。而 $n$ 个头指针又组成一个线性表，为便于查找，可采用顺序存储结构。图5.22（a）是图5.21（a）中的树的孩子表示法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60e641d5bf1b6a3367c0a715896ea6200c65d1d47f135dad05b2de7cc643bbac.jpg)  
图5.22树的孩子表示法和孩子兄弟表示法  

与双亲表示法相反，孩子表示法寻找孩子的操作非常方便，而寻找双亲的操作则需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。  

3.孩子兄弟表示法  

孩子兄弟表示法又称三叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄第结点的指针（沿此域可以找到结点的所有兄弟结点），如图5.22（b）所示。  

孩子兄弟表示法的存储结构描述如下：  

typedef struct CsNode{ El em Type data;struct CsNode \*firstchild,\*next sibling;  

/数据域川第一个孩子和右兄弟指针)CSNode,\*CSTree;  
孩子兄弟表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。  

# 5.4.2 树、森林与二叉树的转换  

二义树和树都可以用二义链表作为存储结构。从物理结构上看，树的孩子兄第表示法与二义树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。  

# 1.树转换为二叉树  

# 命题追踪树和二叉树的转换及相关性质的推理（2009、2011）  

树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，因此树转换得到的二叉树没有右子树，如图5.23所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c83cdc39d25f3e1591f8d9edaa5c910296cb1e468eeeba38ac072864a44455f.jpg)  
图5.23树与二叉树的对应关系  

树转换为二叉树的画法：  

1）在兄弟结点之间加一连线：2）对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；3）以树根为轴心，顺时针旋转  $45^{\circ}$  

# 2.森林转换为二叉树  

# 命题追踪森林和二叉树的转换及相关性质的推理（2014）  

将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树，以此类推，就可以将森林转换为二叉树。广  

森林转换为二叉树的画法：1）将森林中的每棵树转换成相应的二叉树：  
2）每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线：3）以第一棵树的根为轴心顺时针旋转 $45^{\circ}$  

# 3.二叉树转换为森林  

# 命题追踪  

由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）  

二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，所以将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树依次转换成树，就得到了原森林，如图5.24所示。二叉树转换为树或森林是唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/247436d1c407e375d4ea4ae286dd335ae4bf8469ec4ad1b3014b562aced6dfaa.jpg)  
图5.24森林与二叉树的对应关系  

# 5.4.3树和森林的遍历  

# 1.树的遍历  

# 命题追踪树与二叉树遍历方法的对应关系（2019）  

树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式  

1）先根遍历。若树非空，则按如下规则遍历  

先访问根结点。  

再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。  

其遍历序列与这棵树相应二叉树的先序序列相同  

2）后根遍历。若树非空，则按如下规则遍历：  

先依次遍历根结点的每棵子树，遍历子树时仍遵循先子树后根的规则  

再访问根结点。  

其遍历序列与这棵树相应二叉树的中序序列相同。  

图5.23的树的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。  

# 2.森林的遍历  

按照森林和树相互递归的定义，可得到森林的两种遍历方法。  

1）先序遍历森林。若森林为非空，则按如下规则遍历：访问森林中第一棵树的根结点。先序遍历第一棵树中根结点的子树森林  
先序遍历除去第一棵树之后剩余的树构成的森林。2）中序遍历森林。森林为非空时，按如下规则遍历：中序遍历森林中第一棵树的根结点的子树森林。访问第一棵树的根结点。中序遍历除去第一棵树之后剩余的树构成的森林。图5.24的森林的先序遍历序列为ABCDEFGHI，中序遍历序列为BCDAFEHIG。  

命题追踪森林与二叉树遍历方法的对应关系（2020）  

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为其对应二叉树的先序和中序遍历。  

树和森林的遍历与二叉树的遍历关系见表5.1。  

表5.1树和森林的遍历与二叉树遍历的对应关系
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e09d57af01729d539d610a7b2227fbf31fc318099d9e73cd036ab8262b4e34b.jpg)  

> attention:  

部分教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问的，若遇到这两种称谓，则可理解为同一种遍历方法。  

# 5.4.4 本节试题精选  

# 一、单项选择题  

01.下列关于树的说法中，正确的是（）  

I.对于有 $n$ 个结点的二叉树，其高度为 $\log_{2}\!n$ II.完全二叉树中，若一个结点没有左孩子，则它必是叶结点IⅢl.高度为 h( $h>0$ ）的完全二叉树对应的森林所含的树的个数一定是 $h$ IV.一棵树中的叶子数一定等于与其对应的二叉树的叶子数  

A.I和III B.IV C.I和II D.II 02.利用二叉链表存储森林时，根结点的右指针是（）A.指向最左兄弟B.指向最右兄弟C.一定为空D.不一定为空  

03.设森林 $F$ 中有3棵树，第1、2、3棵树的结点个数分别为 $M_{1},M_{2}$ 和 $M_{3}$ ，与森林 $F$ 对应的二叉树根结点的右子树上的结点个数是（）。  

A.  $M_{1}$  B.  $M_{1}+M_{2}$  C.  $M_{3}$  D.  $M_{2}+M_{3}$  

04.设森林 $F$ 中有4棵树，第1、2、3、4棵树的结点数分别为 $a$  $b$ 、 $c$ 和 $d$ 与森林 $F$ 对应的二叉树的根结点的左子树上的结点数是（）。  

A.a B.  $b+c+d$  C.a-1 D.  $a+b+c$  

05.设森林 $F$ 对应的二叉树为 $B$ ，它有 $m$ 个结点， $B$ 的根为 $p,\ p$ 的右子树结点数为 $n$ ，森林 $F$ 中第一棵树的结点数是（）。  

A. $m\!-\!n$ B. $m\!-\!n\!-\!1$ C. $n+1$ D.条件不足，无法确定  

06.设森林 $F$ 对应的二叉树是一棵具有16个结点的完全二叉树，则森林 $F$ 中树的数目和结点最多的树的结点数分别是（）。  
A.2和8 B.2和9 C.4和8 D.4和9  

07.森林  $T\!=\!(T_{1},\,T_{2},\cdots,\,T_{m}\,)$  转化为二叉树BT的过程为：若  $m=0$  ，则BT为空，若  $m\neq0$  则（）。  

A.将中间子树  $T_{\mathrm{mid}}$  C  $\mathsf{m i d}=(1+m)/2$  ）的根作为BT的根；将  $(T_{1},\,T_{2},\cdots,\,T_{\mathrm{mid-1}})$  转换为BT 的左子树；将 $(T_{\mathrm{mid+1}},\cdots,T_{m})$ 转换为BT的右子树B.将子树  $T_{1}$  的根作为BT的根；将  $T_{1}$  的子树森林转换成BT的左子树；将  $(T_{2},T_{3},\cdots,T_{m})$  转换成BT的右子树 C.将子树 $T_{1}$ 的根作为BT的根；将 $T_{1}$ 的左子树森林转换成BT的左子树；将 $T_{1}$ 的右子树森林转换为BT的右子树；其他以此类推D.将森林 $T$ 的根作为BT的根；将 $(T_{1},\;T_{2},\cdots,\;T_{m})$ 转化为该根下的结点，得到一棵树，然后将这棵树再转化为二叉树BT  

08.设 $F$ 是一个森林， $B$ 是由 $F$ 变换来的二叉树。若 $F$ 中有 $n$ 个非终端结点，则 $B$ 中右指针域为空的结点有（）个。  

A.  $n-1$  B.n C.  $n+1$  D.  $n+2$  

09.设某树的孩子兄弟链表示中共有6个空的左指针域、7个空的右指针域，包括5个结点的左、右指针域都为空，则该树中叶结点的个数是（）。  

A.7B.6C.5D.不能确定

10.若 $T_{\parallel}$ 是由有序树 $T$ 转换而来的二叉树，则 $T$ 中结点的后根序列就是 $T_{1}$ 中结点的（）序列。A.先序 B.中序 C.后序 D.层序  

11.某二叉树结点的中序序列为BDAECF，后序序列为DBEFCA，则该二叉树对应的森林包 括（）棵树。  

A.1 B.2 C.3 D.4  

12.设 $X$ 是树 $T$ 中的一个非根结点， $B$ 是 $T$ 所对应的二叉树。在 $B$ 中， $X$ 是其双亲结点的右孩子，下列结论中正确的是 $(\mathrm{~\,~})_{\circ}$  

A.在树 $T$ 中， $X$ 是其双亲结点的第一个孩子B.在树 $T$ 中， $X$ 一定无右边兄弟C.在树 $T$ 中， $X$ 一定是叶结点D.在树 $T$ 中， $X$ 一定有左边兄弟  

13.在森林的二叉树表示中，结点 $M$ 和结点 $N$ 是同一父结点的左儿子和右儿子，则在该森林中（）。  

A. $M$ 和 $N$ 有同一双亲B. $M$ 和 $N$ 可能无公共祖先C. $M$ 是 $N$ 的儿子D. $M$ 是 $N$ 的左兄弟  

14.【2009统考真题】将森林转换为对应的二叉树，若在二叉树中，结点 $u$ 是结点V的父结点的父结点，则在原来的森林中， $u$ 和V可能具有的关系是（）。  

I.父子关系II.兄弟关系I11. $u$ 的父结点与V的父结点是兄弟关系A.只有ⅡIB.I和IIC.I和IIID.I、ⅡI和ⅢI  

15.【2011统考真题】已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉 树中无右孩子的结点个数是（）。  

A.115 B.116 校C.1895 D.1896

 16.【2014统考真题】将森林 $F$ 转换为对应的二叉树T， $F$ 中叶结点的个数等于（）  

A. $T$ 中叶结点的个数B. $T$ 中度为1的结点个数C. $T$ 中左孩子指针为空的结点个数D.T中右孩子指针为空的结点个数  
17.【2019统考真题】若将一棵树 $T$ 转化为对应的二叉树BT，则下列对BT的遍历中，其遍历序列与 $T$ 的后根遍历序列相同的是（）  

A.先序遍历B.中序遍历C.后序遍历D.按层遍历  

18.【2020统考真题】已知森林  $F$  及与之对应的二叉树T，若  $F$  的先根遍历序列是  $a,b,c,d,e,$   $f,$ 后根遍历序列是 $b,a,d,f,e,c,$ 则 $T$ 的后序遍历序列是（）。  

A.  $b,a,d,f,e,c$  B.  $b,d,f,e,c,a$  C.b,f,e,d,c,a D  $\cdot\ \ f,e,d,c,b,a$  

19.【2021统考真题】某森林  $F$  对应的二叉树为  $T$  ，若  $T$  的先序遍历序列是  $a,b,d,c,e,g,f,$  中序遍历序列是 $b,d,a,e,g,c,f,$ 则 $F$ 中树的棵数是（）。  

A.1 B.2 C.3 D.4  

# 二、综合应用题  

01.给定一棵树的先根遍历序列和后根遍历序列，能否唯一确定一棵树？若能，请举例说明：若不能，请给出反例。  

02.将下面一个由3棵树组成的森林转换为二叉树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/142da67aee6899ce0fbb4e84f46d76715d912ef83261d4a0a5f7e7eddbf32e66.jpg)  

03.ABD EHC FIM GJ KL DB HE A IMF CG KL J， 请画出这棵二叉树，并画出二叉树对应的森林。  

04.编程求以孩子兄弟表示法存储的森林的叶结点数。05.以孩子兄弟链表为存储结构，请设计递归算法求树的深度。  

# 5.4.5 答案与解析  

# 一、单项选择题  

01.D  

若 $n$ 个结点的二叉树是一棵单支树，则其高度为 $n$ 。完全二叉树中最多存在一个度为1的结点且只有左孩子，若不存在左孩子，则一定也不存在右孩子，因此必是叶结点，选项ⅡI正确。只有满二义树才具有性质ⅢI，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e9ab7440fb0ba7ae2568a4d0cb457da7b029a76dee8eaa8d58dd29604f83da53.jpg)  

在树转换为二叉树时，若有几个叶结点具有共同的双亲，则转换成二叉树后只有一个叶结点（最右边的叶结点），如下图所示，选项IV错误。注意，若树中的任意两个叶结点都不存在相同的双亲，则树中的叶子数才有可能与其对应的二叉树中的叶子数相等。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/51b1988df9efa1bd0cfab2790e6a2fbc54938f6a60981ee51d79f38d299ef055.jpg)  

# 02.D  

森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。  

03.D  

与树转换为二叉树不同，森林中的每棵树是独立的，因此先要将每棵树的根结点全部视为兄弟结点的关系。森林转换为二叉树后，树2作为树1的根结点的右子树，树3作为树2的根结点的右子树，因此森林 $F$ 对应的二叉树根结点的右子树上的结点个数是 $M_{2}+M_{3\circ}$  

04.C  

森林转换为二叉树后，二叉树的根结点为第1棵树的根结点，二叉树的根结点的左子树包含第1棵树的所有孩子，因此森林 $F$ 对应的二叉树的根结点的左子树上的结点数是 $a-1$  

05.A  

森林转换成二叉树时采用孩子兄弟表示法，根结点及其左子树为森林中的第一棵树。右子树为其他剩余的树。所以，第一棵树的结点个数为 $m\!-\!n$  

06.D  

森林转换为二叉树后，二叉树的根结点及其左子树由第1棵树转换得到，二叉树的根结点的右子树由剩余的森林转换得到，以此类推，可以划分出第2，3，·棵树的结点。具有16个结点的完全二叉树的形态如下图所示，沿二叉树的根结点往右下遍历，共有4个结点，可知森林中有4棵树，其中第1棵树的结点数最多，有9个。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/038c61a6869824bb604ace6584a47963b2e2b68445265598b34b18b7a4f3b057.jpg)  

07.B  

将森林中每颗树的根结点视为兄弟结点的关系，再按照“左孩子右兄弟”的规则来进行转化。  

08.C  

根据森林与二叉树转换规则“左孩子右兄弟”。二叉树 $B$ 中右指针域为空代表该结点没有兄弟结点。森林中每棵树的根结点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根结点的右指针为空。另外，每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空，所以树  $B$  中右指针域为空的结点有  $n+1$  个。  

09.B  

在树的孩子兄弟表示法中，若一个结点没有孩子（即叶结点），则表现为该结点的左指针域为空，因此本题答案为“6”。至于“5个结点的左、右指针域都为空”，表示树中有5个结点既没有孩子又没有兄弟，约束条件比题中的“求叶结点的个数”要求更严格。  
10.B  

有序树  $T$  转换成二叉树  $T_{1}$  时，  $T$  的后根序列是对应  $T_{1}$  的中序序列还是后序序列呢（显然树 的后根序列不可能对应二叉树的先序序列和层序序列）？看下图所示的例子，在树 $T$ 中，叶结点 $B$ 应最先访问，在 $T_{\parallel}$ 中， $B$ 的右兄弟 $C$ 转换为它的右孩子，若对应 $T_{1}$ 的后序序列，则 $C$ 应在 $B$ 的前面访问，所以 $T$ 的后根序列不可能对应 $T_{1}$ 的后序序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/811d0fe939354b3af51877b3369a3f9485bf59a8f5df68c786751a521cec7be5.jpg)  

11.C  

根据二叉树的前序序列和中序序列可以确定一棵二叉树。根据后序序列， $A$ 是二叉树的根结点。根据中序序列，二叉树的形态如下图（a）所示。对于 $A$ 的左子树，根据后序序列， $B$ 比 $D$ 后被访问，因此 $B$ 必为 $D$ 的父结点，又根据中序序列， $D$ 是 $B$ 的右儿子。对于 $A$ 的右子树，同理可确定结点 $E$ 、 $C$ 、 $F$ 的关系。此二叉树的形态如下图（b）所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/68a02feaff287cc06c72c4994635bd4477104f0c03c73f4070947c9784d370e7.jpg)  

再根据二叉树与森林的对应关系，森林中树的棵数即为其对应二叉树（向右上旋转 $45^{\circ}$ 后）的根结点 $A$ 及其右兄弟数，或解释为：对应二叉树从根结点 $A$ 开始不断往右孩子访问，所访问到的结点数。可知此森林中有3棵树，根结点分别为 $A,C$ 和 $F$  

12.D  

在二叉树 $B$ 中， $X$ 是其双亲的右孩子，因此在树 $T$ 中， $X$ 必是其双亲结点的右兄弟，换句话说， $X$ 在树中必有左兄弟。  

13.B  

在森林的二叉树表示中，当 $M$ 和 $N$ 的父结点是二叉树根结点时， $M$ 和 $N$ 在不同的树上。因此 $M$ 和 $N$ 可能无公共祖先。  

14.B  

森林与二义树的转换规则为“左孩子右兄弟”。在最后生成的二义树中，父子关系在对应森林关系中可能是兄弟关系或者原本就是父子关系。  

情形I：若结点 $v$ 是结点 $u$ 的第二个孩子结点，转换时，结点 $\nu$ 就变成结点 $u$ 第一个孩子的右孩子，符合要求。情形ⅡI：结点 $u$ 和 $v$ 是兄弟结点的关系，但二者之中还有一个兄弟结点 $k$ 则转换后结点 $v$ 就变为结点 $k$ 的右孩子，而结点 $k$ 则是结点 $u$ 的右孩子，符合要求。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/23849acb7f1ad192690272d6eb62d837f5b522b5006188847d23c5a905fe3a8e.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/88e9d8be6c24673678554b626be8d4c64b38ada7141a9eb7d694b3392bfcc18c.jpg)  
图ⅡI  
情形ⅢI：若结点 $u$ 的父结点与 $v$ 的父结点是兄弟关系，则转换后，结点 $u$ 和 $v$ 分别在两者最左父结点的两颗子树中，不可能出现在同一条路径中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bce7723f12689d6f9f179618b6607eb9e0bff9a08fdb9fbfdb37547c7fdf2773.jpg)  
图Ⅲ  

【另解】由题意可知 $u$ 是，的父结点的父结点，如下图所示，有四种情况：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b54bde337c355968b9e84921ef0a04014bff4ff4dfe57b3415c41729abd0277b.jpg)  

根据树与二叉树的转换规则，将这四种情况转换成树中结点的关系。（1）在原来的树中 $u$ 是v的父结点的父结点：（2）在树中 $u$ 是 $\nu$ 的父结点；（3）在树中 $u$ 是 $v$ 的父结点的兄弟；（4）在树中 $u$ 与 $v$ 是兄弟关系。由此可知I和Ⅱ正确。  

15.D  

树转换为二叉树时，树的每个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉树中无右孩子的结点个数 $=$ 分支结点数 ${}+1=2011-116+1=1896.$  

通常本题应采用特殊法求解，设题意中的树是如下图所示的结构，则对应的二叉树中仅有前115个叶结点有右孩子，所以无右孩子的结点个数 $=2011-115=1896$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4a2a09690896ee7a1659e90819cb5a5265875656585a73a5949cce5a22350e9d.jpg)  

16.C  

将森林转化为二义树相当于用孩子兄第表示法来表示森林。在变化过程中，原森林某结点的第一个孩子结点作为它的左子树，它的兄弟作为它的右子树。森林中的叶结点由于没有孩子结点，转化为二叉树时，该结点就没有左结点，因此 $F$ 中叶结点的个数等于 $T$ 中左孩子指针为空的结点个数，。此题还可通过一些特例来排除A、B和 $\mathrm{D}$  

# 17.B  

后根遍历树可分为两步： $\textcircled{\scriptsize{1}}$ 从左到右访问双亲结点的每个孩子（转化为二叉树后，先访问根结点，再访问右子树）； $\circledcirc$ 访问完所有孩子后再访问它们的双亲结点（转化为二叉树后，先访问左子树，再访向根结点），因此树的后根遍历序列与其相应二义树的中序遍历序列相同。对于此类题，采用特殊值法求解通常会更便捷，左下图树 $T$ 转换为二叉树BT的过程如下图所示，树的后序遍历序列显然和其相应二叉树的中序遍历序列相同，均为5.6，7，2，3，4，1。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7259d4cc4818fc1babba24630a5e11bdb2228c4e397ab621f3110ecf2e0b78d.jpg)  

18.C  

森林  $F$  的先根遍历序列对应于其二叉树  $T$  的先序遍历序列，森林  $F$  的后根遍历序列对应于其 二叉树 $T$ 的中序遍历序列。即 $T$ 的先序遍历序列为 $a,b,c,d,e,f,$ 中序遍历序列为b,a,d,fe,c。根据二叉树 $T$ 的先序序列和中序序列可以唯一确定它的结构，构造过程如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7a007c3660bceaf1cbc9774ddce74fc8ec45142d05e7ef96da09fcc94934f9b8.jpg)  

可以得到二叉树 $T$ 的后序序列为 $b,f,e,d,c,a$  

19.C  

由二叉树 $T$ 的先序序列和中序序列可以构造出 $T$ ，如下图所示。由森林转化成二叉树的规则可知，森林中每棵树的根结点以右子树的方式相连，所以 $T$ 中的结点 $a$ 、C、 $f$ 为 $F$ 中树的根结点，森林 $F$ 中有3棵树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8ed6dd003c7f43d5f358dcca7ee0b04e888f8d9087591e61878e8d9c73e2df5e.jpg)  

# 二、综合应用题  

01.【解答】  

一棵树的先根遍历结果与其对应二叉树的先序遍历结果相同，树的后根遍历结果与其对应二叉树表示的中序遍历结果相同。由于二叉树的先序序列和中序序列能够唯一地确定这颗二叉树，因此，根据题自给出的条件，利用树的先根遍历序列和后根遍历序列能够唯一地确定这颗树。例如，对于下图所示的树，对应二叉树的先序序列为 $1,2,3,4,5,6,8,7$ ，中序序列为 $3,4,8,6,7,5,2$ 1。原树的先根遍历序列为 $1,2,3,4,5,6,8,7$ 后根遍历序列为 $3,4,8,6,7,5,2,1.$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/085440873967ec7e8b0b8007f732cdbe14e22837c2beac68619ef756532352cc.jpg)  
> attention:  

树的先根遍历、后根遍历与对应二叉树的前序遍历、中序遍历对应。  

02.【解答】  

根据树与二叉树“左孩子右兄弟”的转换规则，将森林转换为二叉树的过程如下： $\textcircled{\scriptsize{1}}$ 将每棵树的根结点也视为兄弟关系，在兄弟结点之间加一连线。 $\circledcirc$ 对每个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉。 $\textcircled{3}$ 以树根为轴心，顺时针旋转 $45^{\circ}$ 。结果如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8f4237f2bad0581db1b41bc5a56b06d5e6ed1cd4af1cd24fbbd0f3bccb027bb.jpg)  

03.【解答】  

知道二叉树的先序和中序遍历后，可以唯一确定这棵树的结构。然后把二叉树转换到树和森林的方式是，若结点 $x$ 是双亲 $y$ 的左孩子，则把 $x$ 的右孩子、右孩子的右孩子·…··都与 $y$ 用连线连起来，最后去掉所有双亲到右孩子的连线。  

最后得到的二叉树及对应的森林如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bba7755a3db5d37961b23c0e266b087e86f30eadccea04d52b6debd6dac35031.jpg)  

04.【解答】  

当森林（树）以孩子兄弟表示法存储时，若结点没有孩子（fch $\risingdotseq$ NULL），则它必是叶子，总的叶结点个数是孩子子树（fch）上的叶子数和兄弟子树（nsib）上的叶结点个数之和。  

算法代码如下：  

type def struct node ElemTypedata;struct node \*fch,\*nsib; )\*Tree;  

/数据域孩子与兄弟域  
intLeaves（Treet){//计算以孩子兄弟表示法存储的森林的叶子数if(  $\scriptstyle\mathrm{t}==$  NULL) return0; /树空返回0 if(t->fch $==$ NULL)/若结点无孩子，则该结点必是叶子return1+Leaves（t->nsib）；//返回叶结点和其兄弟子树中的叶结点数else/孩子子树和兄弟子树中叶子数之和return Leaves(t->fch)+Leaves（t->nsib);  

# 05.【解答】  

由孩子兄弟链表表示的树，求高度的算法思想如下：采用递归算法，若树为空，高度为零：否则，高度为第一子女树高度加1和兄弟子树高度的大者。其非递归算法使用队列，遂层遍历树，取得树的高度。算法代码如下：  

intHeight（CsTree bt){ 1/递归求以孩子兄弟链表表示的树的深度int hc,hs; if(bt  $==$  NULL) returno; else{//否则，高度取子女高度 $^{+1}$ 和兄弟子树高度的大者hc=Height(bt->firstchild); //第一子女树高 hs  $=$  Height(bt->next sibling); //兄弟树高 if（hc+1>hs) return hc+l; else return hs;  

# 5.5树与二叉树的应用  

# 5.5.1哈夫曼树和哈夫曼编码  

# 1.哈夫曼树的定义  

在介绍哈夫曼树之前，先介绍几个相关的概念：  

从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。路径上的分支数目称为路径长度。  

在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为  

$$
\mathrm{WPL}=\sum_{i=1}^{n}w_{i}l_{i}
$$  

式中， $w_{i}$ 是第 $i$ 个叶结点所带的权值， $l_{i}$ 是该叶结点到根结点的路径长度。  

在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树。例如，图5.25中的3棵二叉树都有4个叶结点 $a,b,c,d,$ 分别带权7，5.2.4，它们的带权路径长度分别为  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2d32313c261c37c12b5a28af99468dcb1c7b5e3580b6b57a99efff0cd38d3e9.jpg)  
图5.25具有不同带权长度的二叉树  

(a)  $\mathrm{WPL}=7\times2+5\times2+2\times2+4\times2=36\,\circ$  (b)  $\mathrm{WPL}=4{\times}2+7{\times}3+5{\times}3+2{\times}1=46{\circ}$  (C)  $\mathrm{WPL}=7\times1+5\times2+2\times3+4\times3=35\,\mathrm{s}$  

其中，图5.25（c）树的WPL最小。可以验证，它恰好为哈夫曼树。  

# 2.哈夫曼树的构造  

给定 $n$ 个权值分别为 $w_{1},w_{2},\cdots,w_{n}$ 的结点，构造哈夫曼树的算法描述如下：1）将这 $n$ 个结点分别作为 $n$ 棵仅含一个结点的二叉树，构成森林 $F$  

# 命题追踪分析哈夫曼树的路径上权值序列的合法性（2010）  

2）构造一个新结点，从 $F$ 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。3从 $F$ 中删除刚才选出的两棵树，同时将新得到的树加入 $F$ 中。4）重复步骤2）和3），直至 $F$ 中只剩下一棵树为止。  

# 命题追踪哈夫曼树的性质（2010、2019）  

从上述构造过程中可以看出哈夫曼树具有如下特点：  

1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。2）构造过程中共新建了 $n\!-\!1$ 个结点（双分支结点），因此哈夫曼树的结点总数为2n-1。3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。例如，权值7.5.2.41的哈夫曼树的构造过程如图5.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9a695e33dd97c1c5ed46237ca55e6881724f902b983ec04e5940d6658f255e.jpg)  
图5.26哈夫曼树的构造过程  

# 3.哈夫曼编码  

在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。若充许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。  
# 命题追踪根据哈夫曼编码对编码序列进行译码（2017）  

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B和C对应的编码0.10和110是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原字符，再对剩余的码串执行同样的解码操作。例如，码串0010110可被唯一地翻译为A，A，B和C。另举反例：若再将字符D的编码设计为11，此时11是110的前缀，则上述码串的后三位就无法唯一翻译。  

# 命题追踪哈夫曼树的构造及相关的分析（2012、2018、2021、2023）  

# 命题追踪前缀编码的分析及应用（2014、2020）  

可以利用二叉树来设计二进制前缀编码。假设为A，B，C，D四个字符设计前缀编码，可以用图5.27所示的二叉树来表示，4个叶结点分别表示4个字符，且约定左分支表示0，右分支表示1，从根到叶结点的路径上用分支标记组成的序列作为该叶结点字符的编码，可以证明如此得到的必为前缀编码。由图5.27得到字符A，B，C，D的前缀编码分别为0,10,110，111。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/530f7170ceac82b45e179b32785be7d95fda0363a9e6cd3d08e5994f85b9d240.jpg)  
图5.27前缀编码示例  

# 命题追踪哈夫曼编码和定长编码的差异（2022）  

哈夫曼编码是一种非常有效的数据压缩编码。由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。然后，将从根到叶结点的路径上分支标记的字符串作为该字符的编码。图5.28所示为一个由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/72a3cdbcb2f74e6a103772e7474ffec4f31c43dfd93f72e47a7066a5d3c31e44.jpg)  
图5.28由哈夫曼树构造哈夫曼编码  

这棵哈夫曼树的WPL为  

$$
\mathrm{WPL}=1\times45+3\times(13+12+16)+4\times(5+9)=224
$$  

此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位，因此哈夫曼编码共压缩了 $25\%$ 的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。  
> attention:  

左分支和右分支究竞是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。  

# 5.5.2并查集  

# 1.并查集的概念  

并查集是一种简单的集合表示，它支持以下3种操作：  

1）Initial（S）：将集合s中的每个元素都初始化为只有一个单元素的子集合。2）Union（S，Rootl，Root2）：s Root 2 Root l。要求Root1和Root2互不相交，否则不执行合并。3）Find $(\mathbf{S},\mathbf{x})$ ：查找集合S中单元素 $_\mathrm{x}$ 所在的子集合，并返回该子集合的根结点。  

# 2.并查集的存储结构  

通常用树的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。  

例如，若设有一个全集合为 $S=\{0,1,2,3,4,5,6,7,8,9\}$ ，初始化时每个元素自成一个单元素子集合，每个子集合的数组值为-1，如图5.29所示。  

$$
s(\odot\odot\odot)\odot(\odot)\odot(\odot)\odot(\odot)\odot(\odot)
$$  

$$
\begin{array}{c c c c c c}{{0}}&{{1}}&{{2}}&{{3}}&{{4}}&{{5}}&{{6}}&{{7}}&{{8}}&{{9}}\\ {{\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid}}\end{array}
$$  

经过一段时间的计算后，这些子集合合并为3个更大的子集合，即 $S_{1}=\{0,6,7,8\},\ S_{2}=\{1,4,9\}$  $S_{3}=\{2,3,5\}$ ，此时并查集的树形和存储结构如图5.30所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/976fcd63eca493385976fd301e1a61e3edcd3c536650dac7f9a30aab44ed41e1.jpg)  
图5.30用树表示并查集  

为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结点。因此， $S_{1}\cup S_{2}$ 可以具有如图5.31所示的表示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aac5c13895f1d4c8124a715052fb3f5ae623c11d1fa4e7e3de6ae02a965ce4c.jpg)  
图5.31 $S_{1}\cup S_{2}$ 可能的表示方法  
在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。其中SIZE是最大元素的个数。  

# 3.并查集的基本实现  

并查集的结构定义如下：  

下面是并查集主要运算的实现  

（1）并查集的初始化操作  

void Initial(int S[l){I/s即为并查集for(int $\scriptstyle{\dot{\mathbf{1}}}=0$ ;i<SIZE; $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ /每个自成单元素集合S  $:[\dot{\mathbf{\Delta}}]=-1$  

（2）并查集的Find操作  

在并查集S中查找并返回包含元素 $_\mathrm{x}$ 的树的根  

int Find（int S[l,int x）{ while( $\mathrm{~S~}[\mathrm{x}]\!>=\!0$ /循环寻找 $_\mathrm{x}$ 的根 $\scriptstyle{\mathrm{z=S}}\,[\mathrm{x}]$  return x; /根的S[]小于0  

判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。  

（3）并查集的Union操作  

求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个元素的根，再令一棵子集树的根指向另一棵子集树的根。  

void Union（int S[],int Rootl，int Root2）{ if（Root1 $==$ Root2)return;//要求Root1与Root2是不同的集合S[Root2] $=$ Rootl;/将根Root2连接到另一根Root1下面  

Find操作和Union操作的时间复杂度分别为 $O(d)$ 和 $O(1)$ ，其中 $d$ 为树的深度。  

# 4.并查集实现的优化  

在极端情况下， $n$ 个元素构成的集合树的深度为 $n$ ，则Find操作的最坏时间复杂度为 $O(n)$ 改进的办法是：在做Union操作之前，首先判别子集中的成员数量，然后令成员少的根指向成员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。  

（1）改进的Union操作  

void Union（int S[],int Rootl,int Root2）{ if(Rootl  $==$  Root2)return; if(S[Root2]>S[Root1]){//Root2结点数更少S[Rootl] $+{=}\mathbb{S}$ [Root2];/累加集合树的结点总数S[Root2] $=$ Rootl;1/小树合并到大树elsel //Root1结点数更少 S[Root2] $\scriptstyle{+=S}$ [Rootl];/累加结点总数S[Root1] $=$ Root2;1小树合并到大树  

$\log_{2}\!n\!\left\rfloor+1$  随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还可进一步对上述Find操作进行优化，当所查元素 $_\mathrm{x}$ 不在树的第二层时，在算法中增加一个“压缩路径”的功能，即将从根到元素 $_\mathrm{x}$ 路径上的所有元素都变成根的孩子。  
（2）改进的Find操作  

int Find（int s[l,int x）int root  $=\times$  while(s[root] $>=0$ //循环找到根root  $=$  s[root]; while（x!=root){//压缩路径int $\scriptstyle{\mathrm{t}}=\mathrm{S}\,[\mathrm{x}\,]$ /指向 $_\mathrm{x}$ 的父结点S[x] $=$ root; $//\mathrm{x}$ 直接挂到根结点下面 $\scriptstyle{\mathrm{x}=\mathrm{t}}$  return root;/返回根结点编号  

通过Find操作的“压缩路径”优化后，可使集合树的深度不超过 $O(\alpha(n))$ ，其中 $\alpha(n)$ 是一个增长极其缓慢的函数，对于常见的正整数 $n$ ，通常 $\alpha(n){\leqslant}4$  

# 5.5.3 本节试题精选  

# 一、单项选择题  

01.在有 $n$ 个叶结点的哈夫曼树中，非叶结点的总数是（）。A.n-1 B.n C.2n-1 D.2n 02.给定整数集合13，5，6，9，121，与之对应的哈夫曼树是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7fb8a0a8ef146e34f1cf1d5819eb82be2c02c844ae91169af4e61d562f7f1132.jpg)  

03.下列编码中，（）不是前缀码。  

A.{00,01,10,11} B.{0, 1,00, 11} C.{0,10,110,111} D.{10,110,1110,1111}  

04.设哈夫曼编码的长度不超过4，若已对两个字符编码为1和01，则还最多可对（）个字符编码。  

A. 2 B.3 C.4 D.5 05.一棵哈夫曼树共有215个结点，对其进行哈夫曼编码，共能得到（）个不同的码字。A.107 B.108 C.214 D.215 06.设某哈夫曼树有5个叶结点，则该哈夫曼树的高度最高可以是（）。A.3 B.4 C.5 D.6 07.以下对于哈夫曼树的说法中，错误的是（）  

A.对应一组权值构造出来的哈夫曼树一般不是唯一的B.哈夫曼树具有最小的带权路径长度C.哈夫曼树中没有度为1的结点D.哈夫曼树中除了度为1的结点，还有度为2的结点和叶结点  

08.下列关于哈夫曼树的说法中，错误的是（）  
1.哈夫曼树的结点总数不能是偶数II.哈夫曼树中度为1的结点数等于度为2和0的结点数之差 II.哈夫曼树的带权路径长度等于其所有分支结点的权值之和  

A.仅IⅢIB.I和IIC.仅ⅡID.I、Ⅱ和Ⅲ

09.若度为 $m$ 的哈夫曼树中，叶结点个数为 $n$ ，则非叶结点的个数为（））  

A.  $n-1$  B.[n/m]-1 C.  $\lceil(n-1)/(m-1)\rceil$  D.  $\lceil n/(m-1)\rceil-1$  

10.并查集的结构是一种（）  

A.二叉链表存储的二叉树B.双亲表示法存储的树C.顺序存储的二叉树D.孩子表示法存储的树  

11.并查集中最核心的两个操作是： $\textcircled{\scriptsize{1}}$ 查找，查找两个元素是否属于同一个集合； $\textcircled{2}$ 合并若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为10（0\~9）的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9的顺序进行查找和合并操作，最终并查集共有（）个集合。  

A.1 B.2 C.3 D.4

 12.下列关于并查集的说法中，正确的是（）（注，本题涉及图的考点）  

A.并查集不能检测图中是否存在环路的问题B.通过路径优化后的并查集在最坏情况下的高度仍是 $O(n)$ C.Find操作返回集合中元素个数的相反数，它用来作为某个集合的标志D.并查集基于树的双亲表示法  

13.下列关于并查集的叙述中，（）是错误的（注，本题涉及图的考点）。  

A.并查集是用双亲表示法存储的树B.并查集可用于实现克鲁斯卡尔算法C.并查集可用于判断无向图的连通性D.在长度为 $n$ 的并查集中进行查找操作的时间复杂度为 $O(\log_{2}n)$  

14.【2010统考真题】n（ $n{\geqslant}2$ ）个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是（）。  

A.该树一定是一棵完全二叉树B.树中一定没有度为1的结点C.树中两个权值最小的结点一定是兄弟结点D.树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值  

15.【2014统考真题】5个字符有如下4种编码方案，不是前缀编码的是（）  

A. 01,0000,0001,001,1 B.011,000,001,010,1 C.000001,010,011,100 D.0,100110,11101100  

16.【2015统考真题】下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是（）。  

A.24.10.5和24,10.7 B.24,10,5和24,12,7 C.24,10,10和24,14,11 D.24,10,5和24,14，6  

17.【2017统考真题】已知字符集{a,b,c,d,e,f,g,h}，若各字符的哈夫曼编码依次是0100,10 0000，0101，001，011，11，0001，则编码序列0100011001001011110101的译码结果是（）。  

A.acgabfh B.adbagbb C.afbeagd D.afeefgd  
18.【2018统考真题】已知字符集{a,b,c,d,e,f}，若各字符出现的次数分别为  $6,3,8,2,10,4$  则对应字符集中各字符的哈夫曼编码可能是（）。  

A.00,1011,01,1010,11,100 B.00,100,110,000,0010,01 C.10,1011,11,0011,00,010 D.0011,10,11,0010,01,000  

19.【2019统考真题】对  $n$  个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115 个结点，则 $n$ 的值是（）。  

A.56 B.57 C.58 D.60  

20.【2021统考真题】若某二叉树有5个叶结点，其权值分别为10,12,16,21,30，则其最小 的带权路径长度（WPL）是（）。  

A.89B.200C.208D.289  

21.【2022统考真题】对任意给定的含 $n$ ( $n>2$ ）个字符的有限集 $S$ ，用二叉树表示 $S$ 的哈夫曼编码集和定长编码集，分别得到二叉树 $T_{1}$ 和 $T_{2\circ}$ 下列叙述中，正确的是（）。  

A. $T_{1}$ 与 $T_{2}$ 的结点数相同B. $T_{1}$ 的高度大于 $T_{2}$ 的高度C.出现频次不同的字符在 $T_{1}$ 中处于不同的层D.出现频次不同的字符在 $T_{2}$ 中处于相同的层  

22.【2023统考真题】在由6个字符组成的字符集  $S$  中，各字符出现的频次分别为3,4,5,6, 8.10，为 $S$ 构造的哈夫曼编码的加权平均长度为（）。  

A. 2.4 B.2.5 C. 2.67 D.2.75  

# 二、综合应用题  

01.设给定权集 $w=\{5,\,7,\,2,\,3,\,6,\,8,\,9\}$ ，试构造关于 $w$ 的一棵哈夫曼树，并求其加权路径长度WPL。  

02.【2012统考真题】设有6个有序表A,B,C，D,E,F，分别含有10,35,40,50,60和200个 数据元素，各表中的元素按升序排列。要求通过5次两两合并，将6个表最终合并为1个升序表，并使最坏情况下比较的总次数达到最小。请回答下列问题：1）给出完整的合并过程，并求出最坏情况下比较的总次数。2）根据你的合并过程，描述 $n$  $n{\geqslant}2$ ）个不等长升序表的合并策略，并说明理由。  

03.【2020统考真题】若任意一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集（字符个数 $_{\geqslant2}$ ）的不等长编码，每个字符的编码均为二进制的0、1序列，最长为 $L$ 位，且具有前缀特性。请回答下列问题：  

1）哪种数据结构适宜保存上述具有前缀特性的不等长编码？2）基于你所设计的数据结构，简述从 $0/1$ 串到字符串的译码过程3）简述判定某字符集的不等长编码是否具有前缀特性的过程  

# 5.5.4 答案与解析  

一、单项选择题  

01.A  

由哈夫曼树的构造过程可知，哈夫曼树中只有度为 $0$ 和2的结点。在非空二叉树中，有 $n_{0}=$  $n_{2}+1$ ，所以 $n_{2}\!=\!n\!-\!1$  

【另解】 $n$ 个结点构造哈夫曼树需要 $n\!-\!1$ 次合并过程，每次合并新建一个分支结点，所以选择选项A。  
02.C  

首先，3和5构造为一棵子树，其根权值为8，然后该子树与6构造为一棵新子树，根权值为14，再后9与12构造为一棵子树，最后两棵子树共同构造为一棵哈夫曼树。  

03.B  

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。在选项B中，0是00的前缀，1是11的前缀。  

04.C  

在哈夫曼编码中，一个编码不能是任何其他编码的前缀。3位编码可能是001，对应的4位编码只能是0000和0001。3位编码也可能是000，对应的4位编码只能是0010和0011。若全采用4位编码，则可以为0000，0001，0010和0011。题中问的是最多，所以选择选项C。  

【另解】若哈夫曼编码的长度只允许小于或等于4，则哈夫曼树的高度最高是5，已知一个字符编码为1，另一个字符编码是01，这说明第二层和第三层各有一个叶结点，为使得该树从第3层起能够对尽可能多的字符编码，余下的二叉树应该是满二叉树，如下图所示，底层可以有4个叶结点，最多可以再对4个字符编码。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9ff6aad7dd82f7a971bba44de0654ac095b92a8281d8f8b32cf08495abc724f8.jpg)  

05.B  

根据上题的结论，叶结点数为 $(215+1)/2=108$ ，所以共有108个不同的码字。  

【另解】在哈夫曼树中只有度为0和2的结点，结点总数 $n=n_{0}+n_{2}$ ，且 $n_{0}\!=\!n_{2}+1$ ，由题知 $n=215,\,\,\,n_{0}=108.$  

06.C  

在哈夫曼树的构造中，每个初始结点最终都成为叶结点，5个初始结点构造的哈夫曼树共新建4个双分支结点，4个双分支结点所构成的高度最高的哈夫曼树如下图所示，其高度是5。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42ca9973d8f18ebba36f6d07629e0d69db90a553d9e4104ad358480307c93f99.jpg)  

07.D  

哈夫曼树通常是指带权路径长度达到最小的扩充二叉树，在其构造过程中每次选根的权值最小的两棵树，一棵作为左子树，一棵作为右子树，生成新的二叉树，新的二叉树根的权值应为其左右两棵子树根结点权值的和。至于谁做左子树，谁做右子树，没有限制，所以构造的哈夫曼树是不唯一的。哈夫曼树只有度为0和2的结点，度为0的结点是外结点，带有权值，没有度为1的结点。  
08.C  

$n$ 个初始结点构造的哈夫曼树共新建 $n-1$ 个双分支结点，因此哈夫曼树的结点总数是 $2n-1$ 是个奇数，1错误。哈夫曼树中没有度为1的结点，ⅡI错误。哈夫曼的带权路径长度有两种计算方法： $\textcircled{\scriptsize{1}}$ 所有叶结点的带权路径长度之和； $\circledcirc$ 所有分支结点的权值之和，ⅢI正确。  

09.C  

一棵度为 $m$ 的哈夫曼树应只有度为 $0$ 和 $m$ 的结点，设度为 $m$ 的结点有 $n_{m}$ 个，度为0的结点有 $n_{0}$ 个，又设结点总数为 $N_{i}$  $N\!=\!n_{0}+n_{m^{\circ}}$ ，因有 $N$ 个结点的哈夫曼树有 $N\!-\!1$ 条分支，则 $m n_{m}\!=\!N\!-\!1\!=$  $n_{m}+n_{0}-1$ ，整理得 $(m\!-\!1)n_{m}\!=\!n_{0}\!-\!1$ ， $n_{m}\!=\!(n_{0}\!-\!1)/(m\!-\!1)\circ$  

10.B  

并查集的存储结构是用双亲表示法存储的树，主要是为了方便两个重要的操作。  

11. C  

初始时， $_{0\sim9}$ 各自成一个集合。查找1-2时，合并{1}和{2}；查找3-4时，合并{3}和{4);查找5-6时，合并{5}和{6}；查找7-8时，合并{7}和{8}；查找8-9时，合并{7，8}和{9}；查找1-8时，合并{1,2}和{7,8,9}；查找0-5时，合并{0}和{5,6}；查找1-9时，它们属于同一个集合。最终的集合为0,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项℃。  

12.D  

依次探测图的各条边，用并查集检查该边依附的两个顶点是否已属于同一集合（两个顶点的根结点是否相同）。若是，则说明图中存在环路，A错误。经过路径优化后，并查集在最坏情况下的高度远小于 $O(n)$ ，B错误。Find操作总返回当前根结点作为集合的标志，C错误。  

13.D  

在用并查集实现Kruskal算法求图的最小生成树时：判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合（即判断加入这条边之后是否形成回路），若形成回路，则继续判断下一条边；若不形成回路，则将该边和边对应的顶点加入最小生成树T，并继续判断下一条边，直到所有顶点都已加入最小生成树 $T_{\circ}$ B正确。用并查集判断无向图连通性的方法：遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中，处理完所有边后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中。C正确。未做路径优化的并查集在最坏情况下的高度为 $n$ ，此时查找操作的时间复杂度为 $O(n)$ ，时间复杂度通常指最坏情况下的时间复杂度。D错误。  

14.A  

哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，选项B正确。构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，选项C正确。哈夫曼树中任意一个非叶结点的权值为其左、右子树根结点的权值之和，可知，哈夫曼树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值。  

15.D  

前缀编码的定义是在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。选项D中的编码110是编码1100的前缀，违反了前缀编码的规则，所以选项D不是前缀编码。  

16.D  

在哈夫曼树中，左右孩子权值之和为父结点权值。仅以分析选项A为例：若两个10分别属于两棵不同的子树，则根的权值不等于其孩子的权值和，不符；若两个10属同棵子树，则其权值不等于其两个孩子（叶结点）的权值和，不符。选项B、C选项的排除方法相同  
17.D  

哈夫曼编码是前缀编码，各个编码的前缀不同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为 $0100\,011\,001\,001\,011\,11\,0101$ ，译码结果是afeefgd。选项D正确。  

18.A  

根据各字符出现的次数构造的哈夫曼树如下图所示。由图可知，a、c和e的编码长度应该相同：a和c的第1个编码应该相同，且与e的第1个编码不同：b和d的前3个编码应该相同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/08e198998117d2d3790a9bc5f2d61fb413ce112cd731b071524be4f85aab49ea.jpg)  

19.C  

$n$ 个符号构造成哈夫曼树的过程中，共新建了 $_{n-1}$ 个结点（双分支结点），因此哈夫曼树的结点总数为 $2n\!-\!1\!=\!115$ ， $n$ 的值为58。  

20.B  

对于带权值的结点，构造出哈夫曼树的带权路径长度（WPL）最小，哈夫曼树的构造过程如 下图所示。求得其 $\mathrm{WPL}=(10+12)\times3+(30+16+21)\times2=200$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5ff281504ec4a9321197204f8297f883689249c454e3e6dccd555e03c6d3d0a.jpg)  

21.D  

可以画一个简单的特例来证明。图1是满足条件的二叉树  $T_{1}$  ，图2是满足条件的二叉树  $T_{2}$  结点中有值表示这个结点是编码字符。 $T_{1}$ 和 $T_{2}$ 的结点数不同，选项A错误。 $T_{1}$ 的高度等于 $T_{2}$ 的高度，选项B错误。出现频次不同的字符在 $T_{1}$ 中也可能处于相同的层，选项C错误。对于定长编码集，所有字符一定都在 $T_{2}$ 中处于相同的层，而且都是叶结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/10a86d2e849b5cca4dd47a358c1652320f8c46a9c7d2e40651769ea94d24c543.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/771c4823fc2fbe4fc51d66319b1fa0c108044a38391b95d0884d9d8ae1b4165e.jpg)  
图2  

22.B  

构建哈夫曼树的过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/149b825d15915e3ac02e787d001e0120d7f228d99a95e03573792a1ff45a0a36.jpg)  

对叶结点的哈夫曼编码，共有4个长度为3的叶结点、2个长度为2的叶结点，编码的加权 平均长度为 $[(3+4+5+6)\times3+(8+10)\times2]/(3+4+5+6+8+10)=2.5\,\mathrm{s}$  

# 二、综合应用题  

01.【解答】  

根据哈夫曼树的构造方法，每次从森林中选取两个根结点值最小的树合并成一棵树，将原先的两棵树作为左、右子树，且新根结点的值为左、右孩子关键字之和。构造过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/82f7046431340ab64837db08b393d12a65df83fad28acb985065875994652c70.jpg)  

由构造出的哈夫曼树可得 $\mathrm{WPL}=(2+3)\times4+(5+6+7)\times3+(8+9)\times2=108.$  

> attention:  

哈夫曼树并不唯一，但带权路径长度一定是相同的。  

02.【解答】  

1）由于最先合并的表中的元素在后续的每次合并中都会再次参与比较，因此求最小合并次数类似于求最小带权路径长度，此时可立即想到哈夫曼树。根据哈夫曼树的构造过程，每次选择表集合中长度最小的两个表进行合并。6个表的合并顺序如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/499ae6c6e4e94c0099ac2c3ffbf5e3e116f5b62142c0e24c0383a6e628cad01d.jpg)  

根据图中的哈夫曼树，6个序列的合并过程如下： $\textcircled{\scriptsize{1}}$ 在表集合{10,35,40,50,60,200}中，选择表A与表B合并，生成含45个元素的表AB。 $\textcircled{2}$ 在表集合{40,45,50,60,200}中，将表AB与表C合并，生成含85个元素的表ABC。 $\textcircled{3}$ 在表集合{50,60,85,200}中，表D与表E合并，生成含110个元素的表DE。 $\textcircled{4})$ 在表集合{85，110,200}中，表ABC与表DE合并，生成含195个元素的表ABCDE。 $\circledast$ 当前表集合为{195,200}，表ABCDE与表F合并，生成含395个元素的表ABCDEF。由于合并两个长度分别为 $m$ 和 $n$ 的有序表，最坏情况下需要比较 $m+n-1$ 次，所以最坏情况下比较的总次数计算如下：  

第1次合并：最多比较次数 $=10+35-1=44$ 第2次合并：最多比较次数 $=40+45-1=84\$ 第3次合并：最多比较次数 $=50+60-1=109$ 第4次合并：最多比较次数 $=85+110-1=194.$ 第5次合并：最多比较次数 $=195+200-1=394$ 比较的总次数最多为 $44+84+109+194+394=825$  

2）各表的合并策略是：对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较次数依赖于表的合并次序。可以借助于哈夫曼树的构造思想，依次选择最短的两个表进行合并，此时可以获得最坏情况下的最佳合并效率。  

# 03.【解答】  

1）使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符。2）从左至右依次扫描0/1串中的各位。从根开始，根据串中当前位沿当前结点的左子指针或 右子指针下移，直到移动到叶结点时为止。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到0/1串结束，译码完成。3）二叉树既可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的过程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。  

依次读入每个编码C，建立/寻找从根开始对应于该编码的一条路径，过程如下：  

对每个编码，从左至右扫描C的各位，根据C的当前位（0或1）沿结点的指针（左子指针或右子指针）向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿指针移动的过程中，可能遇到三种情况：  

$\textcircled{\scriptsize{1}}$ 若遇到了叶结点（非根），则表明不具有前缀特性，返回。 $\circledcirc$ 若在处理C的所有位的过程中，均没有创建新结点，则表明不具有前缀特性，返回。 $\textcircled{3}$ 若在处理C的最后一个编码位时创建了新结点，则继续验证下一个编码。若所有编码均通过验证，则编码具有前缀特性。  
# 归纳总结  

本章的内容较多，其中二叉树是极其重要的考查点。关于二叉树的有关操作，在2014年的统考中首次出现了线性表以外的算法设计题，需要引起读者的注意。  

遍历是二叉树的各种操作的基础，统考时会考查遍历过程中对结点的各种其他操作，而且容易结合递归算法和利用栈或队列的非递归算法。读者需重点掌握各种遍历方法的代码书写，并学会在遍历的基础上，进行一些其他的相关操作。其中递归算法短小精悍，出现的概率较大，请读者不要掉以轻心，要做到对几种遍历方式的程序模板烂熟于心，并结合一定数量的习题，才可以在考试中快速地写出漂亮的代码。  

二叉树遍历算法的递归程序：  

void Track（BiTree \*p）{ if(p!  $=$  NULL)I (1) Track(p->lchild); 1/(2）Track(p->rchild); 1(3)  

访问函数visit（）位于（1）、（2）、（3）的位置，分别对应于先序、中序、后序遍历。但对于具体题目来说，设计算法时要灵活应用。请读者认真练习下面的例题。  

例题：设二叉树的存储结构为二叉链表，编写有关二叉树的递归算法。  

1）统计二叉树中度为1的结点个数。2）统计二叉树中度为2的结点个数。3）统计二叉树中度为0的结点个数。4）统计二叉树的高度。5）统计二叉树的宽度。6）从二叉树中删去所有叶结点。7）计算指定结点 ${}^{\star}\mathtt{P}$ 所在的层次。8）计算二叉树中各结点中的最大元素的值。  

9）交换二叉树中每个结点的两个子女。  

10）以先序次序输出一颗二叉树中所有结点的数据值及结点所在的层次。  

# 思维拓展  

输入一个整数data和一棵二元树。从树的根结点开始往下访问一直到叶结点，所经过的所有结点形成一条路径。打印出路径及与data相等的所有路径。例如，输入整数22和下图所示的二元树，则打印出两条路径1012和10，5，7。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/941f06790d07c3ba3849267e4edafa0ff0976cce9578e4bd627251e1fa3c5cf8.jpg)  

提示：使用数组或栈保存访问的路径，并记录当前路径上所有元素的和Sum。若当前结点为叶结点，且当前结点值与sum的和等于data，则满足条件，打印当前路径。然后递归返回到父结点，注意在递归返回之前要先减去当前结点元素的值。使用前序遍历操作的递归算法模板可以简化程序。  
# 第6章图  

# 【考纲内容】  

图的基本概念  

（二）图的存储及基本操作邻接矩阵：邻接表：邻接多重表；十字链表  

（四）图的基本应用最小（代价）生成树：最短路径；拓扑排序：关键路径  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1736cc1858562584a3b9c75bce02bd73a9deed0a76bcc241d437fa01e41ebb56.jpg)  

【复习提示】  

图算法的难度较大，主要掌握深度优先搜索与广度优先搜索。掌握图的基木概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及特性、存储结构之间的转化、基于存储结构上的各种遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）等。图的相关算法较多，通常只需掌握其基本思想和实现步骤，而实现代码不是重点。  

# 6.1图的基本概念  

6.1.1图的定义  

图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,\,E)$ ，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集； $E(G)$ 表示图 $G$ 中顶点之间的关系（边）集合。若 $V=\{v_{1},\,v_{2},\cdots,\,v_{n}\}$ ，则用IV表示图 $G$ 中顶点的个数， $E=\{(u,v)\mid u{\in}V,v{\in}V\}$ ，用 $|E|$ 表示图 $G$ 中边的条数。  
> attention:  

线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。  

下面是图的一些基本概念及术语。  

1.有向图  

若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 为有向图。弧是顶点的有序对，记为y， $w^{>}$ 其中 $v,w$ 是顶点， $v$ 称为弧尾， $w$ 称为弧头，<v,W>称为从v到 $w$ 的弧，也称v邻接到 $w$ 。  

图6.1（a）所示的有向图 $G_{1}$ 可表示为  

$$
G_{1}\!=\!(V_{1},E_{1})
$$  

$$
E_{1}=\{<\!1,2\!>,<\!2,1\!>,<\!2,3\!>\}
$$  

2.无向图  

若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,\,w)$ 或 $(w,v)$  。可以说  $w$  和  $\nu$  互为邻接点。边  $(v,w)$  依附于  $w$  和  $v$  ，或称边  $(v,w)$  和  $v,w$  相关联。  

图6.1（b）所示的无向图 $G_{2}$ 可表示为  

$$
\begin{array}{c}{G_{2}=\left(V_{2},E_{2}\right)}\\ {V_{2}=\left\{1,2,3,4\right\}}\end{array}
$$  

$$
E_{2}=\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}
$$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5151560dfc0c00af5239183bc6f467e3c9e73df7d8ee3886d9de445058a96358.jpg)  
图6.1图的示例  

3.简单图、多重图  

一个图 $G$ 若满足： $\textcircled{\scriptsize{1}}$ 不存在重复边； $\circledcirc$ 不存在顶点到自身的边，则称图 $G$ 为简单图。图6.1中 $G_{1}$ 和 $G_{2}$ 均为简单图。若图 $G$ 中某两个顶点之间的边数大于1条，又充许顶点通过一条边和自身关联，则称图 $G$ 为多重图。多重图和简单图的定义是相对的。本书中仅讨论简单图。  

# 4.完全图（也称简单完全图）  

对于无向图， $|E|$ 的取值范围为0到 $n(n-1)/2$ ，有 $n(n-1)/2$ 条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。对于有向图， $|E|$ 的取值范围为0到 $n(n-1)$ ，有 $n(n-1)$ 条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图6.1中 $G_{2}$ 为无向完全图，而 $G_{3}$ 为有向完全图。  

5.子图  

设有两个图 $G=(V,E)$ 和 $G^{\prime}=(V,E^{\prime})$ ，若 $V$ 是 $V$ 的子集，且 $E^{\prime}$ 是 $E$ 的子集，则称 $G^{\prime}$ 是 $G$ 的子图。若有满足 $V(G^{\prime})=V(G)$ 的子图 $G^{\prime}$ ，则称其为 $G$ 的生成子图。图6.1中 $G_{3}$ 为 $G_{1}$ 的子图。  
> attention:  

并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。  

6.连通、连通图和连通分量  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/69224036bff123d02b308266e0d7f55e821273fdb4588553d671e49cea7a8c2f.jpg)  

图的连通性与边和顶点的关系（2010、2022）  

在无向图中，若从顶点 $\nu$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量，在图6.2（a)中，图 $G_{4}$ 有3个连通分量如图6.2（b）所示。假设一个图有 $n$ 个顶点，若边数小于 $_{n-1}$ ，则此图必是非连通图；思考，若图是非连通图，则最多可以有多少条边？  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d9d6a37be3c6ce09a5a0aa15355ead14bf7a5a3e352c73cf8d0cb852ebd9b30.jpg)  
图6.2无向图及其连通分量  

# 7.强连通图、强连通分量  

在有向图中，若有一对顶点 $v$ 和 $w$ ，从 $v$ 到 $w$ 和从 $w$ 到 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量，图 $G_{1}$ 的强连通分量如图6.3所示。思考，假设一个有向图有 $n$ 个顶点，若是强连通图，则最少需要有多少条边？?  

> attention:  

在无向图中讨论连通性，在有向图中讨论强连通性。  

8.生成树、生成森林  

连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n\!-\!1$ 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。图 $G_{2}$ 的一个生成树如图6.4所示。  
# 01e 3  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfa9e01aeec1a2c5a3b7b4d36a675036ff24683fc2cf93f63569eaa97879224d.jpg)  
图6.4图 $G_{2}$ 的一个生成树  

> attention:  

区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和边；极小连通子图是既要保持子图连通又要使得边数最少的子图。  

# 9.顶点的度、入度和出度  

无向图中顶点和边的关系（2009、2017）  

在无向图中，顶点 $v$ 的度是指依附于顶点 $v$ 的边的条数，记为 $\operatorname{TD}(\nu)$ 。在图6.1(b中，每个顶点的度均为3。无向图的全部顶点的度之和等于边数的2倍，因为每条边和两个顶点相关联。  

在有向图中，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为ID(v)：而出度是以顶点 $v$ 为起点的有向边的数目，记为 $\mathrm{{OD}}(v)$ 。在图6.1（a中，顶点2的出度为2、入度为1。顶点 $v$ 的度等于其入度与出度之和，即 $\mathrm{TD}(\nu)=\mathrm{ID}(\nu)+\mathrm{OD}(\nu)$ 。有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。  

# 10.边的权和网  

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。  

# 11.稠密图、稀疏图  

边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠 密图常常是相对而言的。一般当图 $G$ 满足 $|E|<|V|\mathrm{log}|V|$ 时，可以将 $G$ 视为稀疏图。  

# 12.路径、路径长度和回路  

顶点 $\boldsymbol{v}_{p}$ 到顶点 $\nu_{q}$ 之间的一条路径是指顶点序列 $v_{p},v_{i_{1}},v_{i_{2}},\cdots,v_{i_{m}},v_{q}$ ，当然关联的边也可理解为路径的构成要素。路径上的边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，且有大于 $n\!-\!1$ 条边，则此图一定有环。  

# 13.简单路径、简单回路  

命题追踪路径、回路、简单路径、简单回路的定义（2011）  

在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。  

14.距离  

从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离。若从 $u$ 到根本不存在路径，则记该距离为无穷（）。  

# 15.有向树  

一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。  
# 6.1.2 本节试题精选  

# 一、单项选择题  

01.图中有关路径的定义是（），  

A.由顶点和相邻顶点序偶构成的边所形成的序列B.由不同顶点所形成的序列C.由不同边所形成的序列D.上述定义都不是  

02.一个有 $n$ 个顶点和 $n$ 条边的无向图一定是（）A.连通的B.不连通的C.无环的D.有环的  

03.若从无向图的任意顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是()。  

A.强连通图 B.连通图 C.有回路 D.一棵树  

04.以下关于图的叙述中，正确的是（）  

A.图与树的区别在于图的边数大于或等于顶点数B.假设有图  $G=\{V,\{E\}\}$  ，顶点集  $V\subseteq V$   $E^{\prime}{\subseteq}E$  则V和  $\{E^{\prime}\}$  构成  $G$  的子图 C.无向图的连通分量是指无向图中的极大连通子图D.图的遍历就是从图中某一顶点出发访遍图中其余顶点  

05.以下关于图的叙述中，正确的是（）。  

A.强连通有向图的任何顶点到其他所有顶点都有弧B.图的任意顶点的入度等于出度C.有向完全图一定是强连通有向图D.有向图的边集的子集和顶点集的子集都构成原有向图的子图  

06.一个有28条边的非连通无向图至少有（）个顶点。A.7 B.8 C. 9 D.10  

07.对于一个有 $n$ 个顶点的图：若是连通无向图，其边的个数至少为（）；若是强连通有向图，则其边的个数至少为（）。  

A.  $n-1,n$  B.  $n-1,\,n(n-1)$  C.n,n D.  $n,n(n-1)$  

08.无向图  $G$  有23条边，度为4的顶点有5个，度为3的顶点有4个，其余都是度为2的 顶点，则图 $G$ 有（）个顶点。  

A.11 B.12 C.15 D.16

 09.在有 $n$ 个顶点的有向图中，顶点的度最大可达（），A.n B.n-1 C.2n D.2n-2

 10.具有6个顶点的无向图，当有（）条边时能确保是一个连通图。A.8 B.9 C.10 D.11

 11.设有无向图 $G=(V,E)$ 和 $G^{\prime}\!=\!(V,E^{\prime})$ ，若 $G^{\prime}$ 是 $G$ 的生成树，则下列不正确的是（）。  

I. $G^{\prime}$ 为 $G$ 的连通分量II. $G^{\prime}$ 为 $G$ 的无环子图m. $G^{\prime}$ 为 $G$ 的极小连通子图且 $V=V$  

A.I、IIB.只有IIC.ⅡI、ⅢID.只有I  

12.具有51个顶点和21条边的无向图的连通分量最多为（）A.33 B.34 C.45 D.32  
13.在如下图所示的有向图中，共有（）个强连通分量。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/737b44aaeaca8aaf610881d5bfd898e6ee3caf965b4027a2d513106de554c59c.jpg)  

A.1 B.2 C.3 D.4 14.若具有 $n$ 个顶点的图是一个环，则它有（）棵生成树。A.  $n^{2}$  B.  $n$  C.  $n-1$  D.1 15.若一个具有 $n$ 个顶点、 $e$ 条边的无向图是一个森林，则该森林中必有（）棵树。A.n B.e C.  $n\!-\!e$  D.1 16.【2009统考真题】下列关于无向连通图特性的叙述中，正确的是（）  

I.所有顶点的度之和为偶数IIL.边数大于顶点个数减1 I1I.至少有一个顶点的度为1  

A.只有IB.只有ⅡIC.I和IID.I和III  

17.【2010统考真题】若无向图  $G=(V,\,E)$  中含有7个顶点，要保证图  $G$  在任何情况下都是 连通的，则需要的边数最少是（）。  

A.6 B.15 C.16 D.21  

18.【2017统考真题】已知无向图 $G$ 含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图 $G$ 所含的顶点个数至少是（）  

A.10 B.11 C.13 D.15 19.【2022统考真题】对于无向图 $G\!=\!(V,E)$ ，下列选项中，正确的是（）  

A.当 $\vert V\vert>\vert E\vert$ 时， $G$ 一定是连通的B.当 $\left|V\right|\!<\!\left|E\right|$ 时， $G$ 一定是连通的C.当 $|V|\!=\!|E|\!-\!1$ 时， $G$ 一定是不连通的D.当 $\left|V\right|>\left|E\right|+1$ 时， $G$ 一定是不连通的  

# 二、综合应用题  

01.图 $G$ 是一个非连通无向图，共有28条边，该图至少有多少个顶点？  

# 6.1.3 答案与解析  

# 一、单项选择题  

01.A  

本题是北京交通大学考研真题，不同教材对路径的定义可能略有不同，顶点之间关联的边也可理解为路径的构成要素。对于B，路径的定义中并没有要求是不同顶点，比如简单回路的第一个顶点和最后一个顶点是可以相同的，此外B也没有说明这些顶点之间有边相联。  

02.D  

若一个无向图有 $n$ 个顶点和 $n\!-\!1$ 条边，可以使它连通但没有环（即生成树），但若再加一条边，在不考虑重边的情形下，则必然会构成环。  
03.B  

强连通图是有向图，与题意矛盾，A错误：对无向连通图做一次深度优先搜索，可以访问到该连通图的所有顶点，B正确；有回路的无向图不一定是连通图，因为回路不一定包含图的所有结点，C错误；连通图可能是树，也可能存在环，D错误。  

04.C  

图与树的区别是逻辑上的区别，而不是边数的区别，图的边数也可能小于树的边数，A错误；若 $E^{\prime}$ 中的边对应的顶点不是V的元素，V"和 $\{E^{\prime}\}$ 无法构成图，B错误；无向图的极大连通子图称为连通分量，C正确：图的遍历要求每个结点只能被访问一次，且若图非连通，则从某一顶点出发无法访问到其他全部顶点，D的说法不准确。  

05.C  

强连通有向图的任何顶点到其他所有顶点都有路径，但未必有弧；无向图任意顶点的入度等于出度，但有向图未必满足；若边集中的某条边对应的某个顶点不在对应的顶点集中，则有向图的边集的子集和顶点集的子集无法构成子图。  

06. C  

考查至少有多少个顶点的情形，我们考虑该非连通图最极端的情况，即它由一个完全图加一个独立的顶点构成，此时若再加一条边，则必然使图变成连通图。在 $28=n(\,n-1\,)/2=\,8{\times}7/2$ 条边的完全无向图中，总共有8个顶点，再加上1个不连通的顶点，共9个顶点。  

07. A  

对于连通无向图，边最少即构成一棵树的情形；对于强连通有向图，边最少即构成一个有向环的情形。  

08.D  

因为在具有 $n$ 个顶点、é条边的无向图中，有 ${\textstyle\sum}_{i=1}^{n}\operatorname{TD}(v_{i})=2e$ ，所以求得度为2的顶点数为7，从而共有16个顶点。  

09.D  

在有向图中，顶点的度等于入度与出度之和。 $n$ 个顶点的有向图中，任意一个顶点最多还可以与其他 $n-1$ 个顶点有一对指向相反的边相连。注意数据结构中仅讨论简单图。  

10.D  

5个顶点构成一个完全无向图，需要 $n(\,n-1\,)/2\,=\,10$ 条边；再加上1条边后，能保证第6个顶点必然与此完全无向图构成一个连通图，所以共需11条边。  

11.D  

一个连通图的生成树是一个极小连通子图，显然它是无环的，所以选项ⅡI、IⅢI正确。极大连通子图称为连通分量， $G^{\prime}$ 连通但非连通分量。这里再补充一下“极大连通子图”：若图本来就不是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。  

12.C  

初始考虑只有51个顶点的无向图 $G$ ，此时 $G$ 中每个顶点都是连通分量，问题转化为向 $G$ 中添加21条边，如何添加这21条边使得连通分量数目最多。若向两个不同的连通分量之间添加边，则连通分量数目会减1，所以应尽可能地将这21条边加入同一个连通分量且让其接近完全图，含有7个顶点的完全图有21条边，所以用7个顶点构成一个含有21条边的连通分量，剩下 $51-7=44$ 个顶点对应44个连通分量，共有45个连通分量。  

13.B  

强连通分量是极大强连通子图，任意两个顶点之间有方向相反的两条路径。由定义不难得出，若一个顶点只有出边或入边，则该顶点必定单独构成一个连通分量。图中，顶点B只有出边，其他所有顶点都不可能有到顶点B的路径，所以顶点B单独构成一个强连通分量。在顶点A、C、D、E中，任意两个顶点之间都有方向相反的两条路径，所以可构成一个强连通分量。  
14.B  

$n$ 个顶点的生成树是具有 $n-1$ 条边的极小连通子图，因为 $n$ 个顶点构成的环共有 $n$ 条边，去掉任意一条边就是一棵生成树，所以共有 $n$ 种情况，所以可以有 $n$ 棵不同的生成树。  

15.C  

$n$ 个结点的树有 $n\!-\!1$ 条边，假设森林中有 $x$ 棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是 $n+1$ ，边数是 $e+x$ ，从而可知 $x=n-e$ 。  

另解：设森林中有 $x$ 棵树，则再用 $x-1$ 条边就可将所有的树连接成一棵树，此时边数 $+1=$ 顶点数，即 $e+(x-1)+1=n,$ ，所以 $x=n-e$  

16.A  

每条边都连接了两个顶点，在计算顶点的度之和时每条边都被计算了两次，所以所有顶点的度之和偶数。无向连通图对应的生成树也是无向连通图，但此时边数等于顶点数减1，ⅡI错误。考虑2个或以上的顶点恰好构成一个环的情况，此时每个顶点的度都是2，1ⅢI错误。  

17. C  

题干要求无论如何分配边，都能使7个顶点连通，这不同于只要6条边两两相连就能构成一个连通图的情形。考虑最极端的情形，即图 $G$ 的某6个顶点构成一个完全无向图，此时若再添加一条边，则都将连通第7个顶点，使该图变成一个连通图。所以最少边数 $=6{\times}5/2+1=16$ 。若边数 $n$ 小于或等于15，可以使这 $n$ 条边仅连接图 $G$ 中的某6个顶点，从而导致第7个顶点无法与这6个顶点构成连通图（不满足“在任何情况下”）。  

为简单起见，以5个顶点为例，左边4个顶点和 $4{\times}3/2\,=\,6$ 条边构成一个完全图，此时若再添加一条边（可以是虚线中的任意一条），则能保证这5个顶点在任何情况下都是连通的，如下图所示。若边数小于7，则不能保证5个顶点在任何情况下都是连通的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6670f866390407030b20e85bbe75f66f8be31f83e401718042801845ef69e03a.jpg)  

18.B  

无向图边数的2倍等于各顶点度数的总和。要求至少的顶点数，应使每个顶点的度取最大，而由于其他顶点的度均小于3，因此可设它们的度都为2，并设它们的数量是 $x_{i}$ ，列出方程 $^{4\times3\ +}$  $3{\times}4+2x=16{\times}2$ ，解得 $x=4$ 。因此至少包含 $4+4+3=11$ 个顶点。  

19.D  

对于此类分析图的边数、顶点数与连通性问题，思路是寻找临界情况，在临界情况下任意增加或减少一条边，都会改变图的连通性。第一种临界情况如图1所示，此时若减少任意一条边，图就由连通变为不连通，即无向图连通的最小边数是 $\left|V\right|\!-\!1$ ，因此，当 $\left|E\right|\!<\!\left|V\right|$ -1时，图一定不连通，C错误，D正确。第二种临界情况如图2所示，此时若增加任意一条边，则图就由不连通变为连通，即无向图不连通的最大边数是 $(\left\lvert V\right\lvert-1)(\left\lvert V\right\lvert-2)/2$ （此时V-1个顶点构成一个完全图)，因此，只有当 $|E|\!\geqslant(\left|V\right|\!-\!1)(\left|V\right|\!-\!2)/2+1$ 时，才能保证无向图一定连通，A、B错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d365d6fe671746d8b7f4d6f9f66c1fb1b3efb171fab922c052fc4c36d4daeeb6.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bb495ae5fd497815ebccdaad25436bee6ad203a9575cfee392daa488c7fe946.jpg)  
图2  
# 二、综合应用题  

01.【解答】  

图 $G$ 是一个非连通无向图，当边数固定时，顶点数最少的情况是该图由两个连通子图构成，且其中之一只含一个顶点，另一个为完全图。其中只含一个顶点的子图没有边，另一个完全图的边数为 $n(\,n-1\,)/2=28$ ，得 $n=8$ 。所以该图至少有 $1+8=9$ 个顶点。  

# 6.2图的存储及基本操作  

图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于待求解的问题。  

# 6.2.1邻接矩阵法  

所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。  

顶点数为 $n$ 的图 $G\!=\!(V,E)$ 的邻接矩阵 $_A$ 是 $_{n\times n}$ 的，将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n},$ 则  

# 命题追踪图的邻接矩阵存储及相互转换（2011、2015、2018）  

对带权图而言，若顶点 $v_{i}$ 和 $\nu_{j}$ 之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点 $V_{i}$ 和 $V_{j}$ 不相连，则通常用0或 $\infty$ 来代表这两个顶点之间不存在边：  

有向图、无向图和网对应的邻接矩阵示例如图6.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/452c3b970dbd32b4453acaa0973977edccafa0e6e194da0812a21b6fe6148c9b.jpg)  
图6.5有向图、无向图及网的邻接矩阵  

# 命题追踪（算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）  

图的邻接矩阵存储结构定义如下：  

#define Max Vertex Num l00typedef char VertexType;  
typedef int EdgeType;//边对应的数据类型typedef struct{ Vertex Type vex[Max Vertex Num];/顶点表Edge Type edge[Max Vertex Num][Max Vertex Num]；//邻接矩阵，边表int vexnum,arcnum;/图的当前顶点数和边数)MGraph;  

> attention:  

$\textcircled{\scriptsize{1}}$ 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。 $\circledcirc$ 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可用值为0和1的枚举类型。 $\textcircled{3}$ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。 $\textcircled{4}$ 邻接矩阵表示法的空间复杂度为 $O(n^{2})$ ，其中 $n$ 为图的顶点数VI  

# 命题追踪邻接矩阵的遍历的时间复杂度（2021）  

图的邻接矩阵存储表示法具有以下特点：  

$\textcircled{\scriptsize{1}}$ 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。  

# 命题追踪基于邻接矩阵的顶点的度的计算（2013、2021、2023）  

$\textcircled{2}$ 对于无向图，邻接矩阵的第i行（或第 $i$ 列）非零元素（或非 $\infty$ 元素）的个数正好是顶点i的度 $\mathrm{TD}(\nu_{i})$  

$\textcircled{3}$ 对于有向图，邻接矩阵的第 $i$ 行非零元素（或非 $\infty$ 元素）的个数正好是顶点i的出度 $\mathrm{{OD}}(v_{i})$ ；第 $i$ 列非零元素（或非 $\infty$ 元素）的个数正好是顶点 $i$ 的入度 $\mathrm{ID}(v_{i})$  

$\textcircled{4}$ 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。  

$\circledast$ 稠密图（即边数较多的图）适合采用邻接矩阵的存储表示。  

# 命题追踪》计算 $A^{2}$ 并说明A"[][/]的含义（2015）  

$\circledcirc$ 设图 $G$ 的邻接矩阵为 $_A$ ， $A^{n}$ 的元素A"[等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。该结论了解即可，证明方法可参考离散数学教材。  

# 6.2.2邻接表法  

当一个图为稀疏图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。  

所谓邻接表，是指对图 $G$ 中的每个顶点 $\nu_{i}$ 建立一个单链表，第i个单链表中的结点表示依附于顶点 $\nu_{i}$ 的边（对于有向图则是以顶点 $v_{i}$ 为尾的弧），这个单链表就称为顶点 $\nu_{i}$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻接表中存在两种结点：顶点表结点和边表结点，如图6.6所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ad0c70c97181ad46888d00bf7d1e1937cfcb142dda79077f20ff660fa09fa94.jpg)  
图6.6顶点表和边表结点结构  
顶点表结点由两个域组成：顶点域（data）存储顶点 $v_{i}$ 的相关信息，边表头指针域（firstarc）指向第一条边的边表结点。边表结点至少由两个域组成：邻接点域（adjvex）存储与头结点顶点  $v_{i}$  邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。  

# 命题追踪图的邻接表存储的应用（2014）  

无向图和有向图的邻接表的实例分别如图6.7和图6.8所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3503c0ddc86c46b037cc84f917b3f4f690516b2cbec074113c67d50a2be472cf.jpg)  
图6.7无向图邻接表表示法实例  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99831cb9adda79d80ce0087a8c64203ed478c2696ff7c44eddc97b0e34c61786.jpg)  
图6.8有向图邻接表表示法实例  

图的邻接表存储结构定义如下：  

#define Max Vertex Num 100/图中顶点数目的最大值typedef struct ArcNode{/边表结点int adjvex;/该弧所指向的顶点的位置struct ArcNode \*nextarc;/指向下一条弧的指针l/InfoType info; //网的边权值  

)ArcNode;  

typedef struct VNode{//顶点表结点Vertex Type data;//顶点信息ArcNode \*firstarc;/指向第一条依附该顶点的弧的指针  

)VNode,AdjList[Max Vertex Num];  

AdiList vertices;川/邻接表int vexnum,arcnum;/图的顶点数和弧数)ALGraph;I/ALGraph是以邻接表存储的图类型  

图的邻接表存储方法具有以下特点：  

$\textcircled{\scriptsize{1}}$  若  $G$  为无向图，则所需的存储空间为  $O(|V|+2|E|)$  ；若  $G$  为有向图，则所需的存储空间为  $O(|V|+|E|)$ 。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。  

# 命题追踪邻接矩阵法和邻接表法的适用性差异（2011）  

$\circledcirc$ 对于稀疏图（即边数较少的图），采用邻接表表示将极大地节省存储空间。  
$\textcircled{3}$ 在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。  

$\textcircled{4}$ 在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点 $x$ 的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为 $x$ 的边表结点个数。  

$\circledast$ 图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。  

# 6.2.3十字链表  

十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧结点）来表示，每个顶点也用一个结点（顶点结点）来表示。两种结点的结构如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74266ee7e563c116de5fb9a491b7ab8fe3ff5c963390bb5cd61fc774107b00af.jpg)  

弧结点中有5个域：tailvex和headvex两个域分别指示弧尾和弧头这两个顶点的编号；头链域hlink指向弧头相同的下一个弧结点；尾链域tlink指向弧尾相同的下一个弧结点；info域存放该弧的相关信息。这样，弧头相同的弧在同一个链表上，弧尾相同的弧也在同一个链表上。  

顶点结点中有3个域：data域存放该顶点的数据信息，如顶点名称；firstin域指向以该顶点为弧头的第一个弧结点；firstout域指向以该顶点为弧尾的第一个弧结点。  

图6.9为有向图的十字链表表示法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22cd3b3c3edea93d459339c492f17aca8da4b3af583a22feddb788230535e18b.jpg)  
图6.9有向图的十字链表表示（弧结点省略info域）  

注意，顶点结点之间是顺序存储的，弧结点省略了info域。  

在十字链表中，既容易找到 $V_{i}$ 为尾的弧，也容易找到 $V_{i}$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。  

# 6.2.4邻接多重表  

邻接多重表是无向图的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca384d2315602e299aa8d39ceb099e8698afb0d7699ccc8d0753379c1c14fd9d.jpg)  

其中，ivex和jvex这两个域指示该边依附的两个顶点的编号；ilink域指向下一条依附于顶点ivex的边；jlink域指向下一条依附于顶点jvex的边，info域存放该边的相关信息。  

每个顶点也用一个结点表示，它由如下所示的两个域组成。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d2235b1c5b4ab153bc8da98b8ef339ac5118bd7a377aa55aa99addf45c45911.jpg)  

其中，data 域存放该顶点的相关信息，firstedge 域指向第一条依附于该顶点的边。  

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。  

图6.10为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/00d0a1988e38e61fac9ff788e80b20481d9c5be4523450b723ae3a32fba6dab2.jpg)  
图6.10无向图的邻接多重表表示（边结点省略info域）  

图的四种存储方式的总结如表6.1所示。  

表6.1图的四种存储方式的总结
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c4a4bbdb4cf810f3765a867f779a8771cbd4a4349fecb05e02ba697baa3b451.jpg)  

# 6.2.5图的基本操作  

图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。  

图的基本操作主要包括（仅抽象地考虑，所以忽略各变量的类型）：  

Adjacent $(G,\mathrm{x},\mathrm{y})$ ：判断图G是否存在边 ${\tt<x}$ y>或 $({\tt x},{\tt y})$ 。·Neighbors $(G,\mathrm{x})$ ：列出图G中与结点 $_\mathrm{x}$ 邻接的边。Insert Vertex  $(G,\mathrm{x})$  ：在图G中插入顶点  $_\mathrm{x}$  。 Delete Vertex  $(G,\mathrm{x})$  ：从图G中删除顶点  $_\mathrm{x}$  

·AddEdge $(\mathtt{G},\mathtt{x},\mathtt{y})$ ：若无向边 $(\mathtt{x},\mathtt{y})$ 或有向边 ${\tt<x}$ ,y>不存在，则向图G中添加该边。  
·RemoveEdge $(\mathtt{G},\mathtt{x},\mathtt{y})$ ：若无向边 $(\mathtt{x},\mathtt{y})$ 或有向边 ${\tt<x}$  $_\mathrm{y}{>}$ 存在，则从图G中册除该边。First Neighbor $(G,\mathrm{x})$ ：求图G中顶点 $_\mathrm{x}$ 的第一个邻接点，若有则返回顶点号。若 $_\mathrm{x}$ 没有邻接点或图中不存在 $_\mathrm{x}$ ，则返回-1。Next Neighbor $(G,\tt x,\tt y)$ ：假设图G中顶点是顶点 $\mathbf{\Deltar}$ 的一个邻接点，返回除外顶点x的下一个邻接点的顶点号，若y是 $_\mathrm{x}$ 的最后一个邻接点，则返回-1。  

Get edge value（G，x，y）：获取图G中边 $(\mathsf{x},\mathsf{y})$ 或 $\ll$  $_\mathrm{y}{>}$ 对应的权值Set edge value（G，x，y，v）：设置图G中边 $({\mathsf{x}}\,,{\mathsf{y}})$ 或 ${\tt C x}$ ，V>对应的权值为V。  

此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历，具体见下一节的内容。  

# 6.2.6 本节试题精选  

# 一、单项选择题  

01.下列关于图的存储结构的说法中，错误的是（）  

A.使用邻接矩阵存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中的顶点数有关，与边数无关B.邻接表只用于有向图的存储，邻接矩阵适用于有向图和无向图C.若一个有向图的邻接矩阵的对角线以下的元素为0，则该图的拓扑序列必定存在D.存储无向图的邻接矩阵是对称的，所以只需存储邻接矩阵的下（或上）三角部分  

02.若图的邻接矩阵中主对角线上的元素皆为0，其余元素全为1，则该图一定（）A.是无向图B.是有向图C.是完全图D.不是带权图03.在含有 $n$ 个顶点和 $e$ 条边的无向图的邻接矩阵中，零元素的个数为（）A. B.2e C.  $n^{2}\!-\!e$  D.  $n^{2}\!-\!2e$  04.带权有向图 $G$ 用邻接矩阵存储，则 $v_{i}$ 的入度等于邻接矩阵中（）  

A.第 $i$ 行非的元素个数B.第i列非o的元素个数C.第 $i$ 行非 $\infty$ 且非0的元素个数D.第 $i$ 列非 $\infty$ 且非0的元素个数  

05.一个有 $n$ 个顶点的图用邻接矩阵 $_A$ 表示，若图为有向图，顶点 $\boldsymbol{v}_{i}$ 的入度是（）；若图为无向图，顶点 $v_{i}$ 的度是（）。  

A. A[i]] B Z A[][] j=1 j=l C A[][] D. ∑A[或A] /=1 j=1  

06.从邻接矩阵 $A\,{=}\,{\left[\begin{array}{l l l}{0}&{1}&{0}\\ {1}&{0}&{1}\\ {0}&{1}&{0}\end{array}\right]}$ 可以看出，该图共有（ $\circledcirc$ ）个顶点；若是有向图，则该图共有 $\circledcirc$ ）条弧；若是无向图，则共有（ $\textcircled{3}$ ）条边。  

$\textcircled{\scriptsize{1}}$ A.9B.3C.6D.1E.以上答案均不正确 $\circledcirc$ A.5B.4C.3D.2E.以上答案均不正确 $\textcircled{3}$ A.5B.4C.3D.2E.以上答案均不正确  

07.以下关于图的存储结构的叙述中，正确的是（）  

A.一个图的邻接矩阵表示唯一，邻接表表示唯一B.一个图的邻接矩阵表示唯一，邻接表表示不唯一  
C.一个图的邻接矩阵表示不唯一，邻接表表示唯一D.一个图的邻接矩阵表示不唯一，邻接表表示不唯一  

08.矩阵 $_A$ 是有向图 $G$ 的邻接矩阵，若矩阵 $A^{2}$ 的某元素 $a_{i,j}^{2}=3$ ，则说明（）  

A.从顶点i到j存在3条长度为2的路径B.从顶点i到 $j$ 存在3条长度不超过2的路径C.从顶点i到 $j$ 存在2条长度为3的路径D.从顶点i到 $j$ 存在2条长度不超过3的路径  

09.用邻接表法存储图所用的空间大小（）  

A.与图的顶点数和边数有关 B.只与图的边数有关 C.只与图的顶点数有关D.与边数的平方有关  

10.若邻接表中有奇数个边表结点，则（）  

A.图中有奇数个结点B.图中有偶数个结点C.图为无向图D.图为有向图  

11.在有向图的邻接表存储结构中，顶点V在边表中出现的次数是（）。  

A.顶点 $v$ 的度B.顶点v的出度C.顶点 $v$ 的入度D.依附于顶点v的边数  

12. $n$ 个顶点的无向图的邻接表最多有（）个边表结点。  

A.  $n^{2}$  B.  $n(n-1)$  C.  $n(n+1)$  D.n(n-1)/2  

13.设某无向图中有 $n$ 个顶点和 $e$ 条边，则建立该图的邻接表的时间复杂度是（）  

A.  $O(n+e)$  B.  $O(n^{2})$  C.O(ne) D. 0(n)  

14.假设有 $n$ 个顶点、 $e$ 条边的有向图用邻接表表示，则删除与某个顶点 $v$ 相关的所有边的时间复杂度为（）。  

A.  $O(n)$  B.O（e) C.  $O(n+e)$  D.O(ne)  

15.对邻接表的叙述中，（）是正确的。  

A.无向图的邻接表中，第 $i$ 个顶点的度为第 $i$ 个链表中结点数的两倍B.邻接表比邻接矩阵的操作更简便 C.邻接矩阵比邻接表的操作更简便 D.求有向图结点的度，必须遍历整个邻接表  

16.邻接多重表是（）的存储结构。  

A.无向图B.有向图C.无向图和有向图D.都不是  

17.十字链表是（）的存储结构。  

A.无向图B.有向图C.无向图和有向图D.都不是  

18.【2013统考真题】设图的邻接矩阵 $_{A}$ 如下所示，各顶点的度依次是（）  

$$
\scriptstyle A\,=\left[{\begin{array}{l l l l}{0}&{1}&{0}&{1}\\ {0}&{0}&{1}&{1}\\ {0}&{1}&{0}&{0}\\ {1}&{0}&{0}&{0}\end{array}}\right]
$$  

A.1,2,1,2 B.2,2,1,1 C.3,4,2,3 D.4,4,2,2  
# 二、综合应用题  

01.已知带权有向图 $G$ 的邻接矩阵如下图所示，请画出该带权有向图 $G_{\circ}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e986200ebffb3e2e847574ec2d8cb2b16cc40309415c468504bedfc290037d2.jpg)  

02.设图 $G\!=\!(V,E)$ 以邻接表存储，如下图所示。画出其邻接矩阵存储及图 $G_{\circ}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d0304ae666b26ec9298d8630abc81094a4702bc792a790f18a2bcd1ef391e7bd.jpg)  

03.对 $n$ 个顶点的无向图和有向图，分别采用邻接矩阵和邻接表表示时，试问：  

1）如何判别图中有多少条边？2）如何判别任意两个顶点 $i$ 和j是否有边相连？3）任意一个顶点的度是多少？  

04.如何对无环有向图中的顶点重新编号，使得该图的邻接矩阵中所有的1都集中到对角线以上？  

05.写出从图的邻接表表示转换成邻接矩阵表示的算法。  

06.【2015统考真题】已知含有5个顶点的图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/871483a033da33ec98320eb30e60f4b8b6ac60df1748890aeea46c36082b2d47.jpg)  

请回答下列问题：  

1）写出图 $G$ 的邻接矩阵 $_A$ （行、列下标从0开始）2）求 $A^{2}$ ，矩阵 $A^{2}$ 中位于 $0$ 行3列元素值的含义是什么？3）若已知具有 $n$ C $n{\geqslant}2$ ）个顶点的图的邻接矩阵为 $\pmb{{\cal B}}$ ，则 $B^{m}$ C $2{\leqslant}m{\leqslant}n$ ）中非零元素的含义是什么？  

07.【2021统考真题】已知无向连通图  $G$  由顶点集V和边集  $E$  组成，  $|{\cal E}|>0$  ，当  $G$  中度为奇 数的顶点个数为不大于2的偶数时， $G$ 存在包含所有边且长度为 $|E|$ 的路径（称为EL路径）。设图 $G$ 采用邻接矩阵存储，类型定义如下：  

type def struct{ /图的定义 intnum Vertices,numEdges;/图中实际的顶点数和边数char Vertices List[MAxV];//顶点表。MAXV为已定义常量int Edge[MAXV][MAXV]: /邻接矩阵 }MGraph;  

请设计算法intIsExistEL（MGraphG），判断G是否存在EL路径，若存在，则返回1，否则返回0。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度和空间复杂度。  
08.【2023统考真题】已知有向图 $G$ 采用邻接矩阵存储，类型定义如下：  

type def struct{ //图的类型定义 int num Vertices,numEdges;/图的顶点数和有向边数char Vertices List[MAxV];//顶点表，MAXV为已定义常量int Edge[MAXV][MAxV];/邻接矩阵MGraph;  

将图中出度大于入度的顶点称为K顶点。例如，在下图中，顶点a和b为K顶点  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c93096aa4fb4bcf746bc336579fe7ba38f5f060f75d0a73d3294bf96a5883907.jpg)  

in t print Vertices（MGraphG），G，输出G中所有的K顶点，并返回K顶点的个数。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。  

# 6.2.7 答案与解析  

# 一、单项选择题  

01.B  

$n$ 个顶点的图，若采用邻接矩阵表示，不考虑压缩存储，则存储空间大小为 $O(n^{2})$ ，A正确。邻接表可用于存储无向图，只是把每条边都视为两条方向相反的有向边，因此需要存储两次，B错误。因为邻接矩阵中对角线以下的元素全为0，所以若存在 ${\scriptscriptstyle<\!i},{\scriptscriptstyle>}$ ，则必有 $i<j$ 由传递性可知图中路径的顶点编号是依次递增的，假设存在环 $k\!\!\to\!\!\dots\!\!\to\!\!j\!\!\to\!\!k$ ，由题设可知 $k<j<k$ ，承盾，所以不存在环，拓扑序列必定存在，C正确。D显然正确。  

> attention:  

若邻接矩阵对角线以下（或以上）的元素全为0，则图中必然不存在环，即拓扑序列一定存在，但这并不能说明拓扑序列是唯一的。  

02.C  

除主对角线上的元素外，其余元素全为1，说明任意两个顶点之间都有边相连，因此该图一定是完全图。  

03.D  

在无向图的邻接矩阵中，矩阵大小为 $n^{2}$ ，非零元素的个数为 $_{2e}$ ，所以零元素的个数为 $n^{2}\!-\!2e$ 。读者应掌握此题的变体，即当无向图变为有向图时，能够求出零的个数和非零的个数。  

04.D  

带权有向图的邻接矩阵中，0和表示的都不是有向边，而入度是由邻接矩阵的列中元素计算出来的：出度是由邻接矩阵的行中元素计算出来的。  

05.B、D  
有向图的入度是其第 $i$ 列的非0元素之和，无向图的度是第 $i$ 行或第 $i$ 列的非 $0$ 元素之和。  

06.B、B、D  

邻接矩阵的顶点数等于矩阵的行（列）数，有向图的边数等于矩阵中非零元素的个数，无向图的边数等于矩阵中非零元素个数的一半。  

> attention:  

本题中所给的矩阵为对称矩阵，若不是对称矩阵，则必然不可能是无向图。  

07.B  

邻接矩阵表示唯一是因为图中边的信息在矩阵中有确定的位置，邻接表不唯一是因为邻接表的建立取决于读入边的顺序和边表中的插入算法。  

08. A  

设图 $G$ 的邻接矩阵为 $_A$ ， $A^{n}$ 的元素 ${a^{n}}_{i,j}$ 等于从顶点 $i$ 到 $j$ 的长度为 $n$ 的路径的数目，因此 $a_{i,j}^{2}=3$ 表示从顶点 $i$ 到 $j$ 存在3条长度为2的路径。该结论记住即可。  

09. A  

邻接表存储时，顶点数 $n$ 决定了顶点表的大小，边数 $e$ 决定了边表结点的个数，且无向图的每条边存储两次，总存储空间为 $O(n+2e)$ 。而邻接矩阵只与图的顶点数有关，为 $O(n^{2})$  

10.D  

无向图采用邻接表表示时，每条边存储两次，所以其边表结点的个数为偶数。题中边表结点为奇数个，所以必然是有向图，且有奇数条边。  

11.C  

题中的边表是不包括顶点表的。因为任何顶点 $u$ 对应的边表中存放的都是以 $u$ 为起点的边所对应的另一个顶点v。从而 $v$ 在边表中出现的次数也就是它的入度。  

12.B 最多有 $n(\,n\!-\!1\,)/2$ 条边，每条边在邻接表中存储两次，因此边表结点最多为 $n(\,n\!-\!1$ ）个。  

13.A  

建立图的邻接表需要遍历所有的顶点和边，每个顶点有一个顶点表结点，每条边需要创建一个边表结点并插入到相应的链表中。因此，共需 $n+2e$ 次操作，时间复杂度为 $O(n+e)$  

14.C  

与顶点 $\nu$ 相关的边包括出边和入边，对于出边，只需遍历 $v$ 的顶点表结点和其指向的边表：对于入边，则需遍历整个边表。先删除出边：删除 $v$ 的顶点表结点的单链表，出边数最多为 $n\!-\!1$ ，时间复杂度为 $O(n)$ ：再删除入边：扫描整个边表（即扫描剩余全部顶点表结点及其指向的边表），删除所有的顶点 $\nu$ 的入边，时间复杂度为 $O(n+e)$ 。所以总时间复杂度为 $O(n+e)$ 。  

15.D  

无向图的邻接表中，第 $i$ 个顶点的度为第 $i$ 个链表中的结点数，所以选项A错。邻接表和邻接矩阵对于不同的操作各有优势，选项B和C都不准确。有向图结点的度包括出度和入度，对于出度，需要遍历顶点表结点所对应的边表：对于入度，则需要遍历剩下的至部边表。  

16.A 邻接多重表是无向图的存储结构。  

17.B 十字链表是有向图的存储结构。  
18.C  

邻接矩阵A为非对称矩阵，说明图是有向图，度为入度与出度之和。各顶点的度是矩阵中此结点对应的行（对应出度）和列（对应入度）的非零元素之和。  

# 二、综合应用题  

01.【解答】  

带权有向图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/df6e89b4cefa3f7daaf65b0fe56116fb237590d91c96f58515fb459c056f2809.jpg)  

02.【解答】  

其邻接矩阵存储如下所示。  

在邻接表中，每条边存储了2次，在没有特殊说明时，通常默认其为无向图（当然，无向图也可视为具有对边的有向图）。该邻接表对应的图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e95de7c80d4299d3ee308bcfe57663e3fa6e77953b19f1d83e51f5bc4d4d4be.jpg)  

03.【解答】  

1）对于邻接矩阵表示的无向图，边数等于矩阵中1的个数除以2：对于邻接表表示的无向图，边数等于边结点的个数除以2。对于邻接矩阵表示的有向图，边数等于矩阵中1的个数；对于邻接表表示的有向图，边数等于边结点的个数。  

2）在邻接矩阵表示的无向图或有向图中，对于任意两个顶点 $i$ 和 $j$ ，邻接矩阵中arcs[i][j]或arcs[j][i]为1表示有边相连，否则表示无边相连。在邻接表表示的无向图或有向图中，对于任意两个顶点 $i$ 和 $j$ ，若从顶点表结点 $i$ 出发找到编号为 $j$ 的边表结点或从顶点表结点出发找到编号为 $i$ 的边表结点，表示有边相连；否则为无边相连。  

3）对于邻接矩阵表示的无向图，顶点 $i$ 的度等于第 $i$ 行中1的个数：对于邻接矩阵表示的有向图，顶点 $i$ 的出度等于第 $i$ 行中1的个数；入度等于第 $i$ 列中1的个数；度数等于它  
们的和。对于邻接表表示的无向图，顶点 $i$ 的度等于顶点表结点 $i$ 的单链表中边表结点的个数：对于邻接表表示的有向图，顶点 $i$ 的出度等于顶点表结点 $i$ 的单链表中边表结点的个数，顶点 $i$ 的入度等于邻接表中所有编号为i的边表结点数；度数等于入度与出度之和。  

04.【解答】  

按各顶点的出度进行排序。 $n$ 个顶点的有向图，其顶点的最大出度是 $_{n-1}$ ，最小出度为0。这样排序后，出度最大的顶点编号为1，出度最小的顶点编号为 $n$ 。之后，进行调整，即只要存在弧<i，>，就不管顶点 $j$ 的出度是否大于顶点 $i$ 的出度，都把 $i$ 编号在顶点 $j$ 的编号之前，因为只有 $i{\leqslant}j$ ，弧 $<\!i,j\!>$ 对应的1才能出现在邻接矩阵的上三角。  

通过后面小节的学习，会发现采用拓扑排序并依次编号是一种更为简便的方法。  

05.【解答】  

算法思想：设图的顶点分别存储在数组 $\upsigma[\mathrm{n}]$ 中。首先初始化邻接矩阵。遍历邻接表，在依次遍历顶点v[i]的边链表时，修改邻接矩阵的第i行的元素值。若链表边结点的值为j，则置arcs[i][j] $^{=1}$ 。遍历完邻接表时，整个转换过程结束。此算法对于无向图、有向图均适用。  

算法的实现如下：  

void Convert（ALGraph &G,int arcs[M][N])//此算法将邻接表方式表示的图G转换为邻接矩阵arcsfor $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$ ;i<n; $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ {//依次遍历各顶点表结点为头的边链表 $\mathsf{p}\mathrm{=\pi}\left(\mathsf{G}\mathrm{-}\mathrm{>}\mathsf{v}\left[\mathrm{i}\right]\right.$ ).firstarc;/取出顶点i的第一条出边while（p!=NULL){//遍历边链表arcs[i][p->adjvex]  $^{=1}$  p=p->nextarc; //取下一条出边 //while llfor  

06.【解答】  

考查图的邻接矩阵的性质。  

1）图 $G$ 的邻接矩阵 $\pmb{A}$ 如下  

$A={\left[\begin{array}{l l l l}{0}&{1}&{1}&{0}&{1}\\ {1}&{0}&{0}&{1}&{1}\\ {1}&{0}&{0}&{1}&{0}\\ {0}&{1}&{1}&{0}&{1}\\ {1}&{1}&{0}&{1}&{0}\end{array}\right]}$  

2) $A^{2}$ 如下：  

$$
A^{2}={\left[\begin{array}{l l l l}{3}&{1}&{0}&{3}&{1}\\ {1}&{3}&{2}&{1}&{2}\\ {0}&{2}&{2}&{0}&{2}\\ {3}&{1}&{0}&{3}&{1}\\ {1}&{2}&{2}&{1}&{3}\end{array}\right]}
$$  

0行3列的元素值3表示从顶点0到顶点3之间长度为2的路径共有3条。  
3) $B^{m}$  $2{\leqslant}m{\leqslant}n!$ ）中位于 $i$ 行 $j$ 列（ $\scriptstyle0\leqslant i,$  $j\!\leqslant\!n\!-\!1$ ）的非零元素的含义是，图中从顶点i到顶点 $j$ 的长度为 $m$ 的路径条数。  

07.【解答】  

1）算法的基本设计思想  

本算法题属于送分题，题干已经告诉我们算法的思想。对于采用邻接矩阵存储的无向图，在邻接矩阵的每一行（列）中，非零元素的个数为本行（列）对应顶点的度。可以依次计算连通图 $G$ 中各顶点的度，并记录度为奇数的顶点个数，若个数为0或2，则返回1，否则返回0。  

2）算法实现  

int IsExistEL(MGraph G){/采用邻接矩阵存储，判断图是否存在EL路径int degree,i,j,count  $=\!0$  for( $\scriptstyle{\dot{\boldsymbol{\perp}}}=0$  $_{\perp<G}$ .num Vertices; $\ \ \mathrm{i}_{++}$ ）degree  $=\!0$  for(  $\scriptstyle{\dot{\mathbf{\rho}}}=0$   $\gimel G$  .num Vertices;j++) degree $\scriptstyle+=G$ .Edge[i][j];/依次计算各个顶点的度if(degree%2  $!\!=\!\!0$  count++;/对度为奇数的顶点计数if(count  $==0$  lcount  $==2$  1 return1;//存在EL路径，返回1else return 0;/不存在EL路径，返回0  

3）时间复杂度和空间复杂度  

算法需要遍历整个邻接矩阵，所以时间复杂度是 $O(n^{2})$ ，空间复杂度是 $O(1)$  

08.【解答】  

1）算法的基本设计思想  

采用邻接矩阵表示有向图时，一行中1的个数为该行对应顶点的出度，一列中1的个数为该列对应顶点的入度。使用一个初值为零的计数器记录K顶点的个数。对图G的每个顶点，根out degree in degree。若outdegree-indegree>0，则输 出该顶点且计数器加1。最后返回计数器的值。  

2）用C语言描述的算法：  

int print Vertices(MGraph G){ /采用邻接矩阵存储，输出K顶点，返回个数int indegree,outdegree,k,m,count  $=\!0$  for $\kappa{=}0$  $\kappa{<}G$ .num Vertices; $\kappa++$ ）indegree  $=$  outdegree  $=\!0$  for $\scriptstyle{\mathrm{im}}=0$  $\mathtt{m c}_{\mathrm{G}}$ .num Vertices; $\mathtt{m}{\mathrel{+{+}}}$ /计算顶点的出度outdegreet  $\scriptstyle\cdot=G$  .Edge[k][m]; for $\scriptstyle{\mathrm{m}}=0$  $\mathtt{m c}_{\mathrm{G}}$ .num Vertices; $\mathrm{m++}$ //计算顶点的入度indegree  $\scriptstyle+=G$  .Edge[m][k]; if(outdegree>indegree){ printf("&c",G.Vertices List[k]); count  ${++}$  
# 6.3图的遍历  

图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次，且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。  

图的遍历比树的遍历要复杂得多，因为图的任意一个顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组visited[门]来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。  

# 6.3.1 广度优先搜索  

广度优先搜索（Breadth-First-Search，BFS）类似于二叉树的层序遍历算法。基本思想是：首 先访问起始顶点 $v$ ，接着由 $\nu$ 出发，依次访问v的各个未访问过的邻接顶点 $w_{1},\,w_{2},\cdots,\,w_{i}$ ，然后依次访问  $w_{1},$   $w_{2},\cdots$   $w_{i}$  的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所 有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra单源最短路径算法和 $\operatorname{Prim}$ 最小生成树算法也应用了类似的思想。  

换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和 $\nu$ 有路径相通且路径长度为12，的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。  

广度优先搜索算法的伪代码如下：  

bool visited[MAX VERTEX NUM];//访问标记数组void BF S Traverse（Graph G){//对图G进行广度优先遍历for(  $\scriptstyle{\mathrm{~i}}=0$  ;i<G.vexnum;  ${++}\,{\mathrm{i}}$  visited[i] $=$ FALSE;//访问标记数组初始化InitQueue(Q); //初始化辅助队列Q for( $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$ ;i<G.vexnum; ${++}\,{\mathrm{i}}$ //从0号顶点开始遍历if(!visited[i])//对每个连通分量调用一次BFS（）BFS(G,i);/诺 $v_{i}$ 未访问过，从v开始调用BFS（)  

用邻接表实现广度优先搜索的算法如下：  

void BFS（ALGraph G,int i){ //访问初始顶点ivisit（i); visited[i] $=$ TRUE;//对i做已访问标记EnQueue（Q,i);//顶点i入队while(!IsEmpty(Q)){ DeQueue(Q,v);/队首顶点v出队  
$w=\mathtt{p}->$  adjvex; if(visited  $[w]==$  FALSE){ visit（w); l/w为  $\triangledown$  的尚未访问的邻接点，访问w visited[w] $=$ TRUE;//对w做已访问标记EnQueue $(Q,w)$ ”//顶点 $\mathbf{w}$ 入队  

用邻接矩阵实现广度优先搜索的算法如下：  

void BFS（MGraph G,int i)(visit（i);//访问初始顶点ivisited[i]  $=$  TRUE; 对1做已访问标记 EnQueue（Q,i）;//顶点i入队while(!IsEmpty(Q)){ DeQueue(Q,v);/队首顶点v出队for $w\!=\!0$  $w\!<\!G$ .vexnum; $w++$ 1//检测 $\mathtt{v}$ 的所有邻接点if(visited  $[w]==$  FALSE&&G.edge[v][w]  $==1$  visit(w); /w为  $\mathbf{v}$  的尚未访问的邻接点，访问  $w$  visited[w]  $=$  TRUE; 1对  $w$  做已访问标记 EnQueue $(Q,w)$ //顶点 $\mathbf{w}$ 入队  

辅助数组visited[]标志顶点是否被访问过，其初始状态为FALSE。在图的遍历过程中，一旦某个顶点 $\nu_{i}$ 被访问，就立即置visited[i]为TRUE，防止它被多次访问。  

# 命题追踪广度优先遍历的过程（2013）  

下面通过实例演示广度优先搜索的过程，给定图 $G$ 如图6.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42543e3cbbf650ee51abdafe55648cf488f5a427608b8a1e32178060c28985aa.jpg)  
图6.11一个无向图 $G$  

假设从顶点 $a$ 开始访问， $a$ 先入队。此时队列非空，取出队头元素 $a$ ，因为 $^b$  $c$ 与 $a$ 邻接且未被访问过，于是依次访问 $b,\,c$ ，并将 $^b$  $c$ 依次入队。队列非空，取出队头元素 $^b$ ，依次访问与 $b$ 邻接且未被访问的顶点 $d,e$ ，并将 $d,e$ 入队（注意： $a$ 与 $^b$ 也邻接，但 $a$ 已置访问标记，所以不再重复访问）。此时队列非空，取出队头元素 $c$ ，访问与 $c$ 邻接且未被访问的顶点 $f,\,g$ ，并将 $f,g$ 入队。此时，取出队头元素 $d$ ，但与 $d$ 邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素 $e$ ，将 $h$ 入队列最终取出队头元素 $h$ 后，队列为空，从而循环自动跳出。遍历abcde f gh  

从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。  
# 1.BFS算法的性能分析  

无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列 $\mathcal{Q}$  $n$ 个顶点均需入队一次，在最坏的情况下，空间复杂度为 $O(|V|)$  

# 命题追踪基于邻接表存储的BFS的效率（2012）  

遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结 构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为 $O(|V|)$ ，在搜索每个顶点的邻接点时，每条边至少访问一次，时间复杂度为 $O(|E|)$ ，总的时间复杂度为 $O(|V|+|E|)$ 。采用邻接矩阵存储时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，总时间复杂度为 $O(|V|^{2})$  

# 2.BFS算法求解单源最短路径问题  

若图 $G=(V,\,E)$ 为非带权图，定义从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u,\,v)$ 为从 $u$ 到 $\nu$ 的任何路径中最少的边数；若从  $u$  到  $\nu$  没有通路，则  $d(u,v)=\infty$  6  

使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。  

BFS算法求解单源最短路径问题的算法如下：  

void BFS MIN Distance（Graph G,int u){ /ld[i]表示从u到i结点的最短路径 for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<G.vexnum;  ${++i}$   ${\sf d}\left[\dot{\Sigma}\right]\!=\!\infty$ //初始化路径长度visited[u]  $=$  TRUE;d[u]  $=\!0$  EnQueue（Q,u）;while(!isEmpty(Q)){/BFS算法主过程DeQueue(Q,u);/队头元素u出队for  $w=$  First Neighbor(G,u);  $w\!>\!=\!0$   $w=$  Next Neighbor（G,u,w)) if(!visited[w]){//为u的尚未访问的邻接顶点visited[w]  $=$  TRUE; //设已访问标记 d[w]  $\scriptstyle=\operatorname{d}$  [u]  $^{+1}$  /路径长度加1 EnQueue(Q,w);/顶点w入队  

# 3.广度优先生成树  

在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a558e1e1aab5256ec092199096715091d9fd2bed801b23092ca6ae4ea150bdf2.jpg)  
图6.12图的广度优先生成树  
# 6.3.2 深度优先搜索  

与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。  

它的基本思想如下：首先访问图中某一起始顶点 $v$ ，然后由 $v$ 出发，访问与 $v$ 邻接且未被访问的任意一个顶点 $w_{1}$ ，再访问与 $w_{1}$ 邻接且未被访问的任意一个顶点 $w_{2}$ …重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该 点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。  

一般情况下，其递归形式的算法十分简洁，算法过程如下：  

bool visited[MAX VERTEX NUM];/访问标记数组void DF S Traverse(Graph G){I/对图G进行深度优先遍历for  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\dot{\mathbf{z}}}<G$  .vexnum;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  visited[i] $=$ FALSE;//初始化已访问标记数组for $\scriptstyle{\dot{\mathbf{1}}}=0$  $\scriptstyle{\mathrm{~i}}<G$ .vexnum; $\dot{\mathbf{x}}_{++}$ 川本代码中是从 $v_{0}$ 开始遍历if(!visited[i])/对尚未访问的顶点调用DFS（）DFS(G,i);  

用邻接表实现深度优先搜索的算法如下：  

void DFS（ALGraph G,int i）{visit(i);/访问初始顶点ivisited[i]  $=$  TRUE; /对1做已访问标记 for $\scriptstyle{\mathfrak{p}}=G$ .vertices[i].firstarc;p; $\scriptstyle{\mathbb{P}}^{=}\mathbb{P}$ ->nextarc）（/检测i的所有邻接点j=p->adjvex; if（visited[j]  $==$  FALSE) DES(G,j）;为i的尚未访问的邻接点，递归访问  

用邻接矩阵实现深度优先搜索的算法如下：  

void DFS（MGraph G,int i）{visit（i);//访问初始顶点ivisited[i]  $=$  TRUE; /对1做已访问标记 for $(\stackrel{.}{\mathrm{j}}=\stackrel{0}{0}$ j<G.vexnum; $\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\$ //检测i的所有邻接点if(visited[j]  $==$  FALSE&&G.edge[i][j]  $==1$  DFS(G,j);j为i的尚未访问的邻接点，递归访问  

# 命题追踪深度优先遍历的过程（2015、2016）  

以图6.11的无向图为例，深度优先搜索的过程：首先访问 $a$ ，并置 $a$ 访问标记：然后访问与 $a$ 邻接且未被访问的顶点 $b$ ，置 $^b$ 访问标记：然后访问与 $^b$ 邻接且未被访问的顶点 $d$ ，置 $d$ 访问标记。此时 $d$ 已没有未被访问过的邻接点，所以返回上一个访问的顶点 $^b$ ，访问与其邻接且未被访问的顶点 $e$ ，置 $e$ 访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。  

> attention:  

图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得到的DFS序列和BFS序列是不唯一的。  
1.DFS算法的性能分析  

DFS算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为 $O(|V|)$  

遍历图的过程实质上是通过边查找邻接点的过程，因此两种遍历方式的时间复杂度都相同，不同之处仅在于对顶点访问顺序的不同。采用邻接矩阵存储时，总时间复杂度为 $O(|V|^{2})$ 采用邻接表存储时，总的时间复杂度为 $O(|V|+|E|)$  

# 2.深度优先的生成树和生成森林  

与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林，如图6.13所示。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80ef10fc4c40d90faf1f0f3f8503446a41b03c6ef2278ea05623bcbf8a932ea2.jpg)  
图6.13图的深度优先生成森林  

# 6.3.3图的遍历与图的连通性  

图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。  

因此，在BFSTraverse（)或DFSTraverse（）中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS(G，i)或DFS（G，i）的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS（G，i)或DFS（G，i)无法访问到该连通分量的所有顶点，如图6.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/823fee21850cd372fbc2f6401fff35ce59784df00323e94b4176edf7aeec0711.jpg)  
图6.14有向图的非强连通分量  

# 6.3.4 本节试题精选  

# 一、单项选择题  

01.下列关于广度优先算法的说法中，正确的是（）  

1.当各边的权值相等时，广度优先算法可以解决单源最短路径问题II.当各边的权值不等时，广度优先算法可用来解决单源最短路径问题I11.广度优先遍历算法类似于树中的后序遍历算法IV.实现图的广度优先算法时，使用的数据结构是队列  

A. 1、IVB.ⅡI、III、IVC. II、IVD.I、II、IV  

02.下列关于图的说法中，错误的是（）  
1.对一个无向图进行深度优先遍历时，得到的深度优先遍历序列是唯一的I1.若有向图不存在回路，即使不用访问标志位，同一结点也不会被访问两次I1I.采用深度优先遍历或拓扑排序算法可以判断一个有向图中是否有环（回路）IV.对任何非强连通图必须2次或以上调用广度优先遍历算法才可访问所有的顶点  

A.I、II、ⅢIB.II、ⅢIC.I、1ID.I、II、IV  

03.对于一个非连通无向图 $G$ ，采用深度优先遍历访问所有顶点，在DFSTraVerSe函数（见考点讲解DFS部分）中调用DFS的次数正好等于（）。  

A.顶点数B.边数C.连通分量数D.不确定  

04.对一个有 $n$ 个顶点、é条边的图采用邻接表表示时，进行DFS遍历的时间复杂度为（），空间复杂度为（）；进行BFS遍历的时间复杂度为（），空间复杂度为（）。  

A.O(n)N B.O(e) C.  $O(n+e)$  D. 0(1)  

05.图的广度优先遍历算法中使用队列作为其辅助数据结构，那么在算法执行过程中，每个顶点的入队次数最多为（）  

A.1 B.2 C.3 D.4  

06.对有 $n$ 个顶点、 $e$ 条边的图采用邻接矩阵表示时，进行DFS遍历的时间复杂度为（）进行BFS遍历的时间复杂度为（）  

A.  $O(n^{2})$  B.O(e) C.  $O(n+e)$  D. 0(e²)  

07.无向图 $G=(V,E)$ 其中 $V\!=\!\{a,b,c,d,e,f\},\ E\!=\!\{(a,b),(a,e),(a,c),(b,e),(c,f),(f,d),$  $(e,d)\}$ ，对该图从 $a$ 开始进行深度优先遍历，得到的顶点序列正确的是（）。  

A.  $a,b,e,c,d,f$  B.a,c,fe,b,d C.  $a,e,b,c,f,d\quad\mathrm{~\textbf~{~D.~}~}a,e,d,f,c,b$  

08.如下图所示，在下面的5个序列中，符合深度优先遍历的序列个数是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/44feda8b1aa3d8aab31277757357b31360ad290a2d8cb5d8cba5423222cc9546.jpg)  

1.aebfdc2.acfdeb3.aedfcb4.aefdbc5.aecfdb A.5 B.4 C.3 D.2  

09.用邻接表存储的图的深度优先遍历算法类似于树的（），而其广度优先遍历算法类似于树的（）。  

A.中序遍历B.先序遍历C.后序遍历D.按层次遍历  

10.一个有向图 $G$ 的邻接表存储如下图所示，从顶点1出发，对图 $G$ 调用深度优先遍历所得顶点序列是（）；按广度优先遍历所得顶点序列是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa54efd57e1847db85b66dd13f01c92df1fd836e2b6a4c7a561460758249fc82.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1378e07fd052f29e8d3a2e8502fcc2a602778972a3c472f13540ecc08e1ed28d.jpg)  

A.125436 B.124536 C.124563 D.362514 11.无向图 $G=(V,E)$ ，其中 $V\!=\{a,b,c,d,e,f\}\,,\,\,\,E\!=\{(a,b),(a,e),(a,c),(b,e),(c,f),(f,d\,),$  $(e,d)\}$ 。对该图进行深度优先遍历，不能得到的序列是（）。  
A.acfdeb B.aebdfc C.aedfcb D.abecdf

 12.判断有向图中是否存在回路，除拓扑排序外，还可以利用（）。（注：涉及下节内容）  

A.求关键路径的方法B.DijkstraC.深度优先遍历算法D.广度优先遍历算法  

13.设无向图 $G=(V,E)$ 和 $G^{\prime}\!=\!(V^{\prime},E^{\prime})$ ，若 $G$ 是 $G$ 的生成树，则下列说法错误的是（）。  

A. $G^{\prime}$ 为 $G$ 的子图B. $G$ 为 $G$ 的连通分量C. $G$ 为 $G$ 的极小连通子图且 $V=V^{\prime}$ D. $G$ 是 $G$ 的一个无环子图  

14.图的广度优先生成树的树高比深度优先生成树的树高（）A.小或相等B.小C.大或相等D.大  

15.【2012统考真题】对有 $n$ 个顶点、 $e$ 条边且使用邻接表存储的有向图进行广度优先遍历，其算法的时间复杂度是（）。  

A. O(n) B.O(e) C.  $O(n+e)$  D. O(ne)  

16.【2013统考真题】下列选项中，不是如下无向图的广度优先遍历序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6768e2608ce1d308810cf41988a3ce6d07c37df1af797f413dbf4552ed798a05.jpg)  

A.h,c,a,b,d,e,  $g,f$  B.  $e,a,f,g,b,h,c,d$  C.d,  $b,c,a,h,e,f,f$  8 D.  $a,b,c,d,h,e,f,g$  

17.【2015统考真题】设有向图 $G=(V,\,E)$ ，顶点集 $V=\{V_{0},V_{1},V_{2},V_{3}\}$ ，边集 $E=\{<\!v_{0},\!v_{1}\!>,$  $\scriptstyle<v_{0},v_{2}>$  $\scriptstyle<v_{0},v_{3}>$  $\scriptstyle<v_{1},v_{3}>\}$ 。若从顶点 $V_{0}$ 开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是（）。  

A.2B.3C.4D.5

18.【2016统考真题】下列选项中，不是下图深度优先搜索序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6600f6d8f778a8a8607d53cc3c724ca876a139f2bc76a586ee3dd95e1cc3947.jpg)  

A.  $V_{1},V_{5},V_{4},V_{3},V_{2}$  B.V,V3，V2,Vs,V4 C.  $V_{1},V_{2},V_{5},V_{4},V_{3}$  D.V,V2,V3,V4,Vs  

# 二、综合应用题  

01.图 $G=(V,E)\nu\lambda$ 邻接表存储，如下图所示，试画出图 $G$ 的深度优先生成树和广度优先生成树（假设从结点1开始遍历）  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9281127c00acc39cf80753b14f738dfdb37f868fc5af8189586b225d8aa842e.jpg)  

02.给定一个连通无向图，采用邻接表存储，将图的所有顶点分别染成红色或蓝色，若存在一种染色方法使图中每条边的两个顶点的颜色都不相同，则称这个图能被二分。人  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0256308912671fb20ed8ddf6ff060f059b41d84952ba77a570473f97f4b16870.jpg)  

1）判断上面两个无向图是否能被二分，若能被二分，则请标出每个顶点的颜色。2）请设计一种算法用来判断图是否能被二分，仅用语言描述算法的思想即可。3）给出你设计的算法的时间复杂度和空间复杂度。  

03.试设计一个算法，判断一个无向图 $G$ 是否为一棵树。若是一棵树，则算法返回true，否则返回false。  

04.分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表方式存储的有向图中是否存在由顶点 $v_{\mathrm{i}}$ 到顶点 $v_{j}$ 的路径( $i\neq j$ ）。注意，算法中涉及的图的基本操作必须在此存储结构上实现。  

05.假设图用邻接表表示，设计一个算法，输出从顶点 $V_{i}$ 到顶点 $V_{j}$ 的所有简单路径  

# 6.3.5 答案与解析  

# 一、单项选择题  

01.A  

广度优先搜索以起始结点为中心，一层一层地向外层扩展遍历图的顶点，因此无法考虑到边权值，只适合求边权值相等的图的单源最短路径。广度优先搜索相当于树的层序遍历，选项 mI错误。广度优先搜索需要用到队列，深度优先搜索需要用到栈，选项IV正确。  

02.D  

图的深度优先遍历序列通常是不唯一的，1错误。图1是一个不存在回路的有向图，从顶点1开始执行广度优先遍历，若不设置访问标志位，则会重复访问顶点3，Ⅱ错误。深度优先遍历（见本节后面习题的解析）或拓扑排序算法可以判断有向图中是否有环，ⅢI正确。图2是一个非强连通图，但从顶点1开始调用一次广度优先遍历算法就可访问所有顶点，IV错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f18c9a9794241285abda35d9f051dd1b73b91191764e70668e41b5b17d47e38d.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33905d8575f91778c1644bbae05c138467d530c5a20818bc8bdc73d29d996ee7.jpg)  
图2  

03.C  

DFS（或BFS）可用来计算无向图的连通分量数，因为一次遍历必然会将一个连通图中的所有顶点都访问到，所以计算图的连通分量数正好是DFSTraverSe（)中DFS被调用的次数。  
04.C、A、C、A  

深度优先遍历时，每个顶点表结点和每个边表结点均查找一次，每个顶点递归调用一次，需要借助一个递归工作栈：而广度优先遍历时，也是每个顶点表结点和每个边表结点均查找一次，需要借助一个辅助队列。因此，时间复杂度都是 $O(n+e)$ ，空间复杂度都是 $O(n)$  

05. A  

在图的广度优先遍历算法中，每个顶点被访问后立即做访问标记并入队。若队列不空，则队首顶点出队，若该顶点的邻接顶点未被访问，则访问之，做访问标记并入队：若被访问过，则跳过，如此反复，直至队空。因此，在厂度优先遍历过程中，每个顶点最多入队一次。  

06.A、A  

采用邻接矩阵表示时，查找一个顶点所有出边的时间复杂度为 $O(n)$ ，共有 $n$ 个顶点，所以时间复杂度均为 $O(n^{2})$  

07.D  

画出草图后，此类题可以根据边的邻接关系快速排除错误选项。以A为例，在遍历到é之后，应该访问与 $e$ 邻接但未被访问的结点， $(e,c)$ 显然不在边集中。  

08. D  

仅1和4正确。以2为例，遍历到 $c$ 之后，与 $c$ 邻接且未被访问的结点为空集，所以应为 $^a$ 的邻接点 $b$ 或 $e$ 入栈。以3为例，因为遍历要按栈退回，所以是先 $b$ 后 $c$ ，而不能先 $c$ 后 $b_{\circ}$  

09.B、D  

图的深度优先搜索类似于树的先根遍历，即先访问结点，再递归向外层结点遍历，都采用回浏算法。图的广度优先搜索类似于树的层序遍历，即一层一层向外层扩展遍历，都需要采用队列来辅助算法的实现。  

10.A、B  

DFS序列产生的路径为  ${\vartriangle}1$   $2^{>}$   $^{<2}$   $5\mathrm{>}$   ${<}5$   $4{>}$   $^{<3}$  ，  $6{>}$  ；BFS序列产生的路径为  $\leftrightharpoons$   $^{2>}$  <1,4>  $<2,5>,<3,6>_{\circ}$  

11.D  

画出 $V$ 和 $E$ 对应的图 $G$ ，然后根据搜索算法求解。  

这里应注意：为什么本题序列是不唯一的，而上题序列却是唯一的呢？  

因为上题给出了具体的存储结构，此时就必须按照算法的过程来执行，每个顶点的邻接点的顺序已固定，但本题中每个顶点的邻接点的顺序是非固定的。  

12. C  

利用深度优先遍历可以判断图 $G$ 中是否存在回路。  

对于无向图来说，若深度优先遍历过程中遇到了回边，则必定存在环：对于有向图来说，这条回边可能是指向深度优先森林中另一棵生成树上的顶点的弧；但是，从有向图的某个顶点v出发进行深度优先遍历时，若在DFS(v)结束之前出现一条从顶点 $u$ 到顶点 $v$ 的回边，且 $u$ 在生成树上是的子孙，则有向图必定存在包含顶点 $\nu$ 和顶点 $u$ 的环。  

13.B  

连通分量是无向图的极大连通子图，其中极大的含义是将依附于连通分量中顶点的所有边都加上，所以连通分量中可能存在回路，这样就不是生成树了。  
> attention:  

极大连通子图是无向图（不一定连通）的连通分量，极小连通子图是连通无向图的生成树。极小和极大是在满足连通的前提下，针对边的数目而言的。极大连通子图包含连通分量的全部边；极小连通子图（生成树）包含连通图的全部顶点，且使其连通的边数最少。  

14.A  

对于无向图的广度优先搜索生成树，起点到其他顶点的路径是图中对应的最短路径，即所有生成树中树高最小。此外，深度优先总是尽可能“深”地搜索图，因此其路径也尽可能长，所以深度优先生成树的树高总是大于或等于广度优先生成树的树高。  

15.C  

广度优先遍历需要借助队列实现。采用邻接表存储方式对图进行广度优先遍历时，每个顶点均需入队一次（顶点表遍历），所以时间复杂度为 $O(n)$ ，在搜索所有顶点的邻接点的过程中，每条边至少访问一次（出边表遍历），所以时间复杂度为 $O(e)$ ，算法总的时间复杂度为 $O(n+e)$  

16.D  

只要掌握DFS和BFS的遍历过程，便能轻易解决。逐个代入，手工模拟，选项D是深度优先遍历，而不是广度优先遍历。  

17.D  

画出该有向图，如下图所示。采用图的深度优先遍历，共有5种可能： $<\!\nu_{0},\,\nu_{1},\,\nu_{3},\,\nu_{2}\!>,\,<\!\nu_{0},\,\nu_{2},$ V3, $\nu_{1}{>}$ <Vo,V2,V1,V3>,<Vo,V3,V2, $\nu_{1}\!>$ <V0,V3,V1,V2>。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b9810bad37c4e0283dff2dff1d7d2f28cfc25a750e9d9a33849ff61e54acba7d.jpg)  

18.D  

按深度优先遍历的策略进行遍历。对于A：先访问  $V_{1}$  ，然后访问与  $V_{1}$  邻接且未被访问的任 意一个顶点（满足的有 $V_{2},$  $V_{3}$ 和 $V_{5}.$ ），此时访问 $V_{5}$ ，然后从 $V_{5}$ 出发，访问与 $V_{5}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{4}$ ），然后从 $V_{4}$ 出发，访问与 $V_{4}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{3}$ ），然后从！ $V_{3}$ 出发，访问与 $V_{3}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{2})$ ，结束遍历。B和C的分析方法与A相同。对于D，首先访问 $V_{1}$ ，然后从 $V_{1}$ 出发，访问与 $V_{1}$ 邻接且未被访问的任意一个顶点（满足的有 $V_{2},\,V_{3}$ 和 $V_{5}$ ），然后从 $V_{2}$ 出发，访问与 $V_{2}$ 邻接且未被访问的任意一个顶点（满足的只有 $V_{5}$ ），按规则本应该访问 $V_{5}$ ，但D却访问了 $V_{3}$ ，错误。  

# 二、综合应用题  

01.【解答】  

根据  $G$  的邻接表不难画出图（a)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0dacc0ce4ff245995248b13b690c879ad955fc670205a8e52e25d706a090489f.jpg)  
(a)图G  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/65f684d2ae2fb3fba8211e9c60166480082d9063630a5647c81376dbdf577b35.jpg)  
(b）深度优先生成树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2f2910ae8ec451afa1d4dc85b66487877920c98d80f03f76acf52c48c20e424b.jpg)  
（c）广度优先生成树  
1）采用深度优先遍历。深度优先搜索总是尽可能“深”地搜索图，根据存储结构可知深度优先搜索的路径次序为 $(1,2),(2,3),(3,4),(4,5)$ ，深度优先生成树如图（b）所示。需要注意的是，当存储结构固定时，生成树的树形也就固定了，比如不能先搜索（1，3)。2）采用广度优先遍历。广度优先搜索总是尽可能“广”地搜索图，一层一层地向外扩展，根据存储结构可知广度优先搜索的路径次序为（1，2)， $(1,3),$ (1，4)（2.5)，广度优先生成树如图（c）所示。  

# 02.【解答】  

1）右图不能被二分，左图能被二分，染色情况如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40f9e1b96b4abbe71caac80ffad2c2c25d33eeea6ebdb2e2a7ae6ddcbe75020c.jpg)  

2）从任意一个结点开始，将其染成红色，并从该结点开始对整个图进行遍历，在遍历过程中，若当前遍历的结点 $a$ 有一条边指向 $^b$ ，则可能出现三种情况： $@b$ 未被染色，将它染成与结点 $a$ 不同的颜色，并且继续遍历与 $b$ 相连的结点： $@a$ 与 $b$ 的颜色相同，说明该图不能被二分，直接返回： $^{(3)}\footnote{C o r r e s p o n d i n g a u t h o r.T e l:~+86-1088236256.E-m a i l a d d r e s s:g i v e n@i h e c.e d u.c r o s c.e d u.c r i l.a c.e d u.c r o s c u.a n t h e r e s s:g i v e n.e d u.c r i s c u.e d u.c r i l a u.c r.e d u.c r i l a u.c r.e d u.c r i l a u.c r.e d u.c r i l i n e v e n v e r:t h e v e n.c d i s c u.c r i l i n e v e n.c d i t i o n.a c u.c r i l i n e v e n.c d i f i r e n t h e s t:g i v e n.e d u.c r i l i n e v e n.c d i t i o n.a c u.c r i l i n e v e n.c d i f i r e n t:t h e v e n.c d i s c u.c r i l i n e v e n.c d i f i r e n t:t h e s t:g i v e n.c d i f i r e n t:t h e s t:g i v e n.c n a n t h i c u.c r i l i n g a u.c r i l i n g a u.c r.c h i l i n g a u.c r i l i n g a u.c h i l i n g a u.c h i f i r e n t:t h e v e n.c d i f i r e n t:t h e s t:g i v e n.c d i f i r e n t h e s t:h a n i c u.c r i l i n g a u.c r i l i n e v e n u.c d i n t h i c u.c o n t i n i c u.c o n t i n i n g a c u.c o m i n t i n i n i n e v e r.c d i n c u.c d i n t i n g a c u.c o m i n t i n t i n e v e r.c o m i n c u.c o m a n t i n i n i n i n t i n e v e r.c o m i n c u.c o m a n c u.c o m i n t i n i n t i n t i n t i n e v e r.c o m i n c u.c o m i n c u.c o m i n c u.c o m i n c c u.c o m i n t i n t i n t i n t i n t i n e r.c o m i n t i n t i n e r.c o m i n c$ 与 $b$ 的颜色不同，跳过 $b$ 点。3）上述遍历无论是使用深度优先还是使用广度优先，时间复杂度都为 $O(n+m)$ ，其中的 $n$ 和 $m$ 分别是顶点数和边数。需要一个数组来存储各结点的颜色及是否已访问，空间复杂度为 $O(n)$ 。  

03.【解答】  

一个无向图 $G$ 是一棵树的条件是， $G$ 必须是无回路的连通图或有 $_{n-1}$ 条边的连通图。这里采用后者作为判断条件。对连通的判定，可以用能否一次遍历全部顶点来实现。可以采用深度优先搜索算法在遍历图的过程中统计可能访问到的顶点个数和边的条数，若一次遍历就能访问到 $n$ 个顶点和 $n\!-\!1$ 条边，则可断定此图是一棵树。算法实现如下：  

boolisTree（Graph& G)(for  $\scriptstyle{\dot{\Sigma}}=1$   $\scriptstyle{\dot{\mathbf{1}}}<={\mathsf{G}}$  .vexnum;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  visited[i] $=$ FALSE;//访问标记visited[l初始化int Vnum $\scriptstyle{1=0}$ ,Enu $_{:=0}$ //记录顶点数和边数DFS（G,1,Vnum,Enum,visited);if（Vnum $\scriptstyle{|=G}$ .vexnum&&Enum $==Z^{\star}$ (G.vexnum-1))returntrue;/符合树的条件else return//不符合树的条件void DFS（Graph& G,int v,int& Vnum,int& Enum,int visited[]){//深度优先遍历图G，统计访问过的顶点数和边数，通过Vnum和Enum返回 visited[v] $=$ TRUE; $\mathrm{Vnum++}$ 八/作访问标记，顶点计数int $w=$ First Neighbor $(G,v)$ /取v的第一个邻接顶点while $(w:=-1$ //当邻接顶点存在Enum ${++}$ /边存在，边计数if(!visited[w]) /当该邻接顶点未访问过 DFS（G,w,Vnum,Enum,visited); $w=$  Next Neighbor（G,v,W);  
04.【解答】  

两个不同的遍历算法都采用从顶点 $\nu_{i}$ 出发，依次遍历图中每个顶点，直到搜索到顶点v，若能够搜索到 $v_{j}$ ，则说明存在由顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径。  

深度优先遍历算法的实现如下：  

intvisited[MAxsIzE] $\mathbf{\Gamma}=\left\{\,0\,\right\}$ /访问标记数组void DFS（ALGraph G,int i,int j,bool &can reach)//深度优先判断有向图G中顶点  $\boldsymbol{v}_{i}$  到顶点  $v_{j}$  是否有路径，用canreach来标识 if(  $\scriptstyle{\dot{\Sigma}}=={\dot{\bar{\jmath}}}$  can reach  $\bar{}$  true; return;lli就是jvisited[i] $^{=1}$ /置访问标记for(int  ${\tt p}^{=}$  First Neighbor(G,i);  $_{\mathrm{p}>=0}$   ${\tt p}^{=}$  Next Neighbor（G,i,p)) if(!visited[p]&&!can reach)//递归检测邻接点DFS（G，p，j，can_reach）;  

广度优先遍历算法的实现如下：  

int visited[MAxSIZE] $\mathbf{\Gamma}=\left\{\,0\,\right\}$ /访问标记数组int BFS（ALGraphG,inti,intj）{//广度优先判断有向图G中顶点 $v_{i}$ 到顶点v是否有路径，是则返回1，否则返回0InitQueue（Q）；EnQueue（Q，i）；I/顶点i入队while(!isEmpty(Q)){ /非空循环 DeQueue（Q,i）;/队头顶点出队visited $[\dot{\mathbf{x}}]\!=\!\!1$ 八//置访问标记if  $\scriptstyle{\dot{\mathbf{i}}}=={\dot{\mathbf{j}}}$  return1; for(int  ${\tt p}^{=}$  First Neighbor(G,i);p;  ${\tt p}^{=}$  Next Neighbor（G,i,p））（ //检查所有邻接点if  $\tt{p==j}$  川若  $\mathtt{p}{=}{\dot{\mathtt{j}}}$  ，则查找成功 return1; if(!visited[p]){l/否则，顶点p入队EnQueue(Q,p）; visited[p]  $^{=1}$  return 0;  

本题也可以这样解答：调用以 $i$ 为参数的DFS（G，i）或BFS（G，i），执行结束后判断visited[j]是否为TRUE，若是则说明 $v_{j}$ 已被遍历，图中必存在由 $\boldsymbol{v}_{i}$ 到 $v_{j}$ 的路径。但此种解法每次都耗费最坏时间复杂度对应的时间，需要遍历与 $\nu_{i}$ 连通的所有顶点。  

# 05.【解答】  

本题采用基于递归的深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。查找从顶点u到 $\mathtt{v}$ 的简单路径过程说明如下（假设查找Find Path（））：  
1)FindPath(G,u,V,path,d): ${\mathsf{d++}}$ ;path[d] $=\!\upalpha$ ；若找到u的未访问过的相邻结点ul，则继续下去，否则置visited[u] $=\!0$ 并返回。  

2)FindPath(G,ul,  $\mathtt{v}$  ,path,d):  $\mathrm{d++}$  ;path[d]  $\mathbf{\mu\sigma}=\mathbf{\mu\sigma}\mathbf{\bot}$  ：若找到ul的未访问过的相邻结 点u2，则继续下去，否则置visited[ul]  $=\!0$  

3）以此类推，继续上述递归过程，直到  $\scriptstyle{\mathrm{u}}\,{\mathrm{i}}={\mathrm{v}}$  ，输出path  

算法实现如下：  

void FindPath（AGraph \*G,int u,int v,int path[],int d）intw; ArcNode \*p;  $\mathrm{d++}$  /路径长度增1 path[d] $=\!\upalpha$ //将当前顶点添加到路径中visited[u]  $^{=1}$  //置已访问标记 if $\scriptstyle{\mathrm{==}}$ //找到一条路径则输出/输出路径上的结点print(path[]);  $\scriptstyle\mathtt{p}=\mathtt{G}->$ adjlist[u].firstarc;/p指向u的第一个相邻点while（p!=NULL){ w=p->adjvex;//若顶点w未访问，递归访问它if(visited[w] $==0$ 一FindPath(G,w,v,path,d);p=p->nextarc;/lp指向u的下一个相邻点visited[u] $=\!0$ //恢复环境，使该顶点可重新使用  

# 6.4图的应用  

本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性极小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。  

# 6.4.1 最小生成树  

一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。  

对于一个带权连通无向图 $G$ ，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。权值之和最小的那棵生成树称为 $G$ 的最小生成树（Minimum-Spanning-Tree,MST）。  

# 命题追踪最小生成树的性质（2012、2017）  

不难看出，最小生成树具有如下性质  

1）若图 $G$ 中存在权值相同的边，则 $G$ 的最小生成树可能不唯一，即最小生成树的树形不唯一。当图 $G$ 中的各边权值互不相等时， $G$ 的最小生成树是唯一的：若无向连通图G的边数比顶点数少1，即 $G$ 本身是一棵树时，则 $G$ 的最小生成树就是它本身。  

2）虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。  
3）最小生成树的边数为顶点数减1。  

命题追踪最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）  

> attention:  

最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。如下图所示，最小生成树中A到C的路径长度为5，但原图中C到D的最短路径长度为4。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/02e492777fdd70471f99a72a7ca8d6237b0cbdc152f003539de53616c1664f55.jpg)  

构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $G=(V,E)$ 是一个带权连通无向图， $U$ 是顶点集 $V$ 的一个非空子集。若 $(u,\,v)$ 是一条具有最小权值的边，其中 $u{\in}U$  $v{\in}V{-}\,U$ ，则必存在一棵包含边 $(u,v)$ 的最小生成树。  

基于该性质的最小生成树算法主要有 $\operatorname{Prim}$ 算法和Kruskal算法，它们都基于贪心算法的策略。对这两种算法应主要掌握算法的本质含义和基本思想，并能够手工模拟算法的实现步骤。  

下面介绍一个通用的最小生成树算法：  

GENERICMST(G)( $\scriptstyle{\mathrm{T}}=$  NULL; whileT未形成一棵生成树；do找到一条最小代价边 $(\boldsymbol{\mathrm{u}},\boldsymbol{\mathrm{v}})$ 并且加入T后不会产生回路 $\scriptstyle{\mathrm{T}=\mathrm{T}\cup\left(\mathrm{u},\,\mathrm{v}\right)}$  ”  

通用算法每次加入一条边以逐渐形成一棵生成树，下面介绍两种实现上述通用算法的途径。  

1.Prim算法  

Prim（普里姆）算法的执行非常类似于寻找图的最短路径的Dijkstra算法（见下一节）。  

命题追踪Prim算法构造最小生成树的实例（2015、2017、2018）  

Prim算法构造最小生成树的过程如图6.15所示。初始时从图中任取一顶点（如顶点1）加 入树 $T$ ，此时树中只含有一个顶点，之后选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点和相应的边加入 $T$ ，每次操作后 $T$ 中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入 $T$ ，得到的 $T$ 就是最小生成树。此时 $T$ 中必然有 $n\!-\!1$ 条边。  

Prim算法的步骤如下：  

假设 $G=\{V,E\}$ 是连通图，其最小生成树 $T\!=\!(U,E_{T})$ ， $E_{T}$ 是最小生成树中边的集合。  

初始化：向空树 $T\!=\!(U,E_{T})$ 中添加图 $G=(V,E)$ 的任意一个顶点 $u_{0}$ ，使 $U=\{u_{0}\}$ ， $E_{T}\!=\!\emptyset$  

循环（重复下列操作直至 $U=V)$ ：从图 $G$ 中选择满足 $\{(u,\,v)|u{\in}U,\,v{\in}V{-}\,U\}$ 且具有最小权值的边 $(u,v)$ ，加入树 $T$ 置 $U\!=\!U\!\cup\{\nu\},\:\:E_{T}\!=\!E_{T}\!\cup\{(u,\nu)\}$  

Prim算法的简单实现如下：  

void Prim（G,T） $\scriptstyle{\mathrm{T}}=\varnothing$  /初始化空树  $\scriptstyle{\mathrm{U}=\{w\}}$ /添加任意一个顶点 $w$ while((V-U) $!\!=\!\!\bigcirc\!,$ //若树中不含全部顶点  
设 $(\boldsymbol{\mathrm{u}},\boldsymbol{\mathrm{v}})$ 是使ueU与 $\forall{\in}\left(\mathrm{V}{-}\mathrm{U}\right)$ ，且权值最小的边； $\scriptstyle{\mathbb{T}=\mathbb{T}\cup\{\ (\mathfrak{u},\mathfrak{v})\ \}}$  /边归入树  $\scriptstyle{\mathrm{U}=\mathrm{U}\cup\{\mathrm{v}\}}$  //顶点归入树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/413704bf3253c2671855c3395ee5f1027e23761bf8da66bca7df35e4ef0ebc82.jpg)  
图6.15Prim算法构造最小生成树的过程  

Prim算法的时间复杂度为 $O(|V|^{2})$ ，不依赖于 $\cdot|E|$ ，因此它适用于求解边稠密的图的最小生成树。虽然采用其他方法能改进 $\operatorname{Prim}$ 算法的时间复杂度，但增加了实现的复杂性。  

# 2.Kruskal算法  

与 $\operatorname{Prim}$ 算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。  

# 命题追踪Kruskal算法构造最小生成树的实例（2015、2018、2020）  

Kruskal算法构造最小生成树的过程如图6.16所示。初始时为只有  $n$  个顶点而无边的非连 通图 $T=\{V,\,\{\}\}$ ，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在 $T$ 中不同的连通分量上（使用并查集判断这两个顶点是否属于同一棵集合树），则将此边加入T，杏则舍弃此边而选择下一条权值最小的边。以此类推，直至 $T$ 中所有顶点都在一个连通分量上。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfb9edf9b314446b65731e53e39a987ef76f3a653992a0d176bd51f77fe01337.jpg)  
图6.16Kruskal算法构造最小生成树的过程  
Kruskal算法的步骤如下：  

假设 $G=(V,E)$ 是连通图，其最小生成树 $T\!=\!(U,E_{T})$  

初始化： $\begin{array}{r}{U\!=\!V,E_{T}\!=\!\emptyset_{\circ}}\end{array}$ ，即每个顶点构成一棵独立的树， $T$ 此时是一个仅含IV个顶点的森林。  

循环（重复直至 $T$ 是一棵树)：按 $G$ 的边的权值递增顺序依次从 $E\!-\!E_{T}$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入 $E_{T}$ ，否则舍弃，直到 $E_{T}$ 中含有 $n-1$ 条边。  

Kruskal算法的简单实现如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2b5891ebe5b470c06be5813e03e210a476a10eb80e5ae811e0df366ecf210561.jpg)  

根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。  

在Kruskal算法中，最坏情况需要对 $|E|$ 条边各扫描一次。通常采用堆（见第7章）来存放边的集合，每次选择最小权值的边需要 $O(\log_{2}\lvert E\rvert)$ 的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为 $O(\alpha(|V|))$ ， $\alpha(V)$ 的增长极其缓慢，可视为常数。算法的总时间复杂度为 $O(|E|\log_{2}\lvert E\rvert)$ ，不依赖于 $|V|$ ，因此Kruskal算法适合于边稀疏而顶点较多的图。  

# 6.4.2最短路径  

# 命题追踪最短路径的分析与举例以及相关的算法（2009、2023）  

6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点 $v_{0}$ 到图中其余任意一个顶点 $\nu_{i}$ 的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。  

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。  

# 1.Dijkstra算法求单源最短路径问题  

Dijkstra $S$ 记录已求得的最短路径的顶点，初始时把源点 $\nu_{0}$ 放入 $S$ ，集合 $S$ 每并入一个新顶点 $\nu_{i}$ ，都要修改源点 $v_{0}$ 到集合 $V\!-\!S$ 中顶点当前的最短路径长度值（这里可能不太好理解？没关系，继续往下看，相信会逐步理解）。  

在构造的过程中还设置了三个辅助数组：  

·final[]：标记各顶点是否已找到最短路径，即是否归入集合 $S_{\circ}$ ·dist[]：记录从源点 $v_{0}$ 到其他各顶点当前的最短路径长度，它的初始值为：若从 $v_{0}$ 到 $v_{i}$ 有弧，则dist[i]为弧上的权值；否则置dist[i]为oo。path[]：path[i]表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 $\nu_{0}$ 到顶点 $v_{i}$ 的最短路径。  
假设从顶点0出发，即 $v_{0}\,{=}\,0$ ，集合 $S$ 最初只包含顶点O，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边 ${<\!i,j\!>}$ 的权值，若不存在有向边 $\mid<\!i,j>$ ，则arcs[i][j]为o。  

Dijkstra算法的步骤如下（不考虑对path[的操作）：  

1）初始化：集合 $S$ 初始为 $\{0\}$ ，dist[]的初始值dist[i] $=$ arcs[0][i],i=1,2,.,n-1。2）从顶点集合  $V{-}S$  中选出  $v_{j}$  ，满足dist[j]  $=$  Min(dist[i]l  $\scriptstyle v_{i}\in V-S\}$   $\nu_{j}$  就是当前求得 的一条从 $\nu_{0}$ 出发的最短路径的终点，令 $S\!=\!S\cup\{j\}$ 。3）修改从 $v_{0}$ 出发到集合 $V\!-\!S$ 上任意一个顶点 $v_{k}$ 可达的最短路径长度：若dist[j]+arcs[j][k]  $<$  dist[k]，则更新dist[k]  $=$  dist[j]  $^+$  arcs[j][k]。  

4）重复 $2)\sim\!3)$ 操作共 $_{n-1}$ 次，直到所有的顶点都包含在集合 $S$ 中  

步骤3）也就是开头留下的疑问，每当一个顶点加入集合 $S$ 后，可能需要修改源点 $\nu_{0}$ 到集合 $V{-}S$ 中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为 $v_{0}$ ，初始时 $S=\{v_{0}\}$ ，dist $[1]\!=\!3$ ,dist $[2]=7$ ，当将 $\nu_{1}$ 并入集合 $S$ 后，dist[2]需要更新为4。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8cd3f126d0f9f02af5404cbc8a5301d32f89543ad84684ca594dafd871d7647.jpg)  

思考：Dijkstra  $\operatorname{Prim}$  算法有何异同之处？ 命题追踪Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）  

例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如表6.2所示。算法执行过程的说明如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c7090950bb73763feef7e1ea4c3e3ea318d642815621a4657605a0e98585dbdc.jpg)  
图6.17应用Dijkstra算法图  

表6.2从 $\nu_{1}$ 到各终点的dist值和最短路径的求解过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f8939ca7029cd3a8d7e5c73314b7488664116e02a550898bfbcd99d295b6878.jpg)  
初始化：集合 $S$ 初始为 $\{v_{1}\}$ ， $v_{1}$ 可达 $v_{2}$ 和 $v_{5}$  $v_{1}$ 不可达 $\nu_{3}$ 和 $v_{4}$ ，因此dist[]数组各元素的初始值依次设置为dist  $[2]\!=\!10$  ，dist  $\left[\,3\,\right]\mathrm{=}\infty$  , dist  $\left[\,4\,\right]\mathrm{=}\infty$  ,dist  $[\,5\,]\!=\!5$  

第1轮：选出最小值dist[5]，将顶点 $v_{5}$ 并入集合 $S$ ，即此时已找到 $\nu_{1}$ 到 $v_{5}$ 的最短路径。当 $v_{5}$ 加入 $S$ 后，从 $\nu_{1}$ 到集合 $V\!-\!S$ 中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]数组。 $v_{5}$ 可达 $\nu_{2}$ ，因 $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{2}$ 的距离8比dist $[2]\!=\!10$ 小，更新 dist $[2]\!=\!8$  $v_{5}$ 可达 $v_{3}$ ， $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{3}$ 的距离14，更新dist $[3]\!=\!14$ .. $v_{5}$ 可达 $v_{4}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{4}$ 的距离7，更新dist $[\,4\,]\,{=}7$ 。  

第2轮：选出最小值dist[4]，将顶点 $v_{4}$ 并入集合 $S_{\circ}$ 继续更新dist[]数组。 $v_{4}$ 不可达 $v_{2}$ ，dist[2]不变； $v_{4}$ 可达 $v_{3}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{4}{\rightarrow}v_{3}$ 的距离13比dist[3]小，故更新dist[3]=13。  

第3轮：选出最小值dist[2]，将顶点 $v_{2}$ 并入集合 $S_{\circ}$ 继续更新 dist[]数组。 $v_{2}$ 可达 $\nu_{3}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{2}{\rightarrow}v_{3}$ 的距离9比dist[3]小，更新dist $\left[\,3\,\right]\,=\,9.$  

第4轮：选出唯一最小值dist[3]，将顶点 $v_{3}$ 并入集合 $S_{i}$ ，此时全部顶点都已包含在 $S$ 中。  

显然，Dijkstra算法也是基于贪心策略的。  

使用邻接矩阵表示时，时间复杂度为 $O(|V|^{2})$ 。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[中选择最小分量的时间不变，所以时间复杂度仍为 $O(|V|^{2})$  

人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为 $O(|V|^{2})$  

注意，边上带有负权值时，Dikstra算法并不适用。若充许边上带有负权值，则在与集合S（已求得最短路径的顶点集，归入 $S$ 内的顶点的最短路径不再变更）内某顶点（记为 $a$ ）以负边相连的顶点（记为6）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于 $a$ 原先确定的最短路径长度，而此时 $a$ 在Dijkstra算法下是无法更新的。例如，对于图6.18所示的带权有向图，利用Dijkstra算法不一定能得到正确的结果。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/354061dd6653c1cf7d28647835680430baf780d8a8c6da4925a50828c972315d.jpg)  
图6.18边上带有负权值的有向带权图  

# 2.Floyd算法求各顶点之间最短路径问题  

求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对任意两个顶点 $v_{i}\not=v_{j}$ ，要求求出 $\nu_{i}$ 与 $v_{j}$ 之间的最短路径和最短路径长度。  

Floyd算法的基本思想是：递推产生一个 $n$ 阶方阵序列 $A^{(-1)}$  $A^{(0)},\cdots,\,A^{(k)},\cdots,\,A^{(n-1)}$ ，其中 $A^{(k)}[i][j]$ 表示从顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径长度， $k$ 表示绕行第 $k$ 个顶点的运算步骤。初始时，对于任意两个顶点 $v_{j}$ 和 $v_{j}$ ，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k$  $\textit{k}(k=0,\,1,\cdots,n-1\,)$ 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法描述如下：  

定义一个 $n$ 阶方阵序列 $A^{(-1)},A^{(0)},\cdots,A^{(n-1)}$ ，其中，  

$$
A^{(-1)}[i][j]=\arcsin[i][j]
$$  

$$
\begin{array}{r}{A^{(k)}[i][j]=\operatorname{Min}\{A^{(k-1)}[i][j],\quad A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},\ k=0,1,\cdots,n-1}\end{array}
$$  

式中， $A^{(0)}[i][j]$ 是从顶点 $v_{i}$ 到 $\nu_{j\setminus}$ 中间顶点是 $\nu_{0}$ 的最短路径的长度， $A^{(k)}[i][j]$ 是从顶点 $\nu_{i}$ 到 $v_{j\setminus}$ 中间顶点的序号不大于 $k$ 的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从 $\nu_{i}$ 到 $\nu_{j}$ 的最短路径上就多考虑了一个顶点；经过 $n$ 次迭代后，所得到的 $A^{(n-1)}[i][j]$ 就是 $v_{i}$ 到 $\nu_{j}$ 的最短路径长度，即方阵 $A^{(n-1)}$ 中就保存了任意一对顶点之间的最短路径长度。  
图6.19所示为带权有向图 $G$ 及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长度的过程如表6.3所示。算法执行过程的说明如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9563eb9adc4d1c1bbd123557953338f0013fcf037d3a58a2bb15403ac38ae2a2.jpg)  
图6.19带权有向图 $G$ 及其邻接矩阵  

初始化：方阵 $A^{(-1)}[i][j]=$ arcs[][]  

第1轮：将 $v_{0}$ 作为中间顶点，对于所有顶点对 $\{i,j\}$ ，若有 $\boldsymbol{A}^{-1}[i][j]>\boldsymbol{A}^{-1}[i][0]+\boldsymbol{A}^{-1}[0][j]$ ，则将 $A^{-1}[i][j]$  更新为  $\begin{array}{r}{\boldsymbol{A}^{-1}[i][0]+\boldsymbol{A}^{-1}[0][j].}\end{array}$  有  $\begin{array}{r}{\boldsymbol{A}^{-1}[2][1]>\boldsymbol{A}^{-1}[2][0]+\boldsymbol{A}^{-1}[0][1]=11}\end{array}$  ，更新  $A^{-1}[2][1]=11$  ，更 新后的方阵标记为 $A^{0}$  

第2轮：将 $\nu_{1}$ 作为中间顶点，继续检测全部顶点对 $\{i,j\}$ 。有 $A^{0}[0][2]>A^{0}[0][1]+A^{0}[1][2]=$ 10，更新 $A^{0}[0][2]=10$ ，更新后的方阵标记为 $A^{1}$  

第3轮：将 $\nu_{2}$ 作为中间顶点，继续检测全部顶点对i,}。有 $\begin{array}{r}{\boldsymbol{A}^{1}[1][0]>\boldsymbol{A}^{1}[1][2]+\boldsymbol{A}^{1}[2][0]=\boldsymbol{9},}\end{array}$ 更新 $A^{1}[1][0]=9$ ，更新后的方阵标记为 $A^{2}$ 。此时 $A^{2}$ 中保存的就是任意顶点对的最短路径长度。  

表6.3Floyd算法的执行过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91b9d670ed390741ce41fa7fada27f7a43fe887b80c64666880ba9353d11e80f.jpg)  

Floyd算法的时间复杂度为 $O(|V|^{3})$ 。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。  

Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。  

也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为 $O(|V|^{2}){\cdot}|V|\!=\!O(|V|^{3})$  

BFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。  

表6.4BFS算法、Dijkstra算法和Floyd算法求最短路径的总结 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7c367d52e0336cc1a989ce844941cf5beff18d63452f540edc3163d0104266fc.jpg)  
6.4.3有向无环图描述表达式  

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。  

命题追踪构建表达式的有向无环图（2019）  

有向无环图是描述含有公共子式的表达式的有效工具。例如表达式 $((a+b)^{*}(b^{*}(c+d))+(c+d)^{*}e)^{*}((c+d)^{*}e)$  

可以用上一章描述的二义树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的子表达式 $(c+d$ )和 $(c+d)^{*}e$ ，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e1ae982871a34fb5119dda6581088409768da4bd88e8d177af012108a5f7ae4.jpg)  
图6.20二叉树描述表达式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e4c2332ba4acd478e43e4a2865dff8a8e7911989ffb9daa949ca81a074232194.jpg)  
图6.21有向无环图描述表达式  

> attention:  

在表达式的有向无环图表示中，不可能出现重复的操作数顶点。  

# 6.4.4 拓扑排序  

AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边 $\begin{array}{r}{{<}V_{i},}\end{array}$  $V_{j}>$ 表示活动 $V_{i}$ 必须先于活动 $V_{j}$ 进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网。在AOV网中，活动 $V_{i}$ 是活动 $V_{j}$ 的直接前驱， $V_{j}$ 是 $V_{i}$ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 $V_{i}$ 不能以它自己作为自己的前驱或后继。  

拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：  

1）每个顶点出现且只出现一次。  

2）若顶点A在序列中排在顶点 $B$ 的前面，则在图中不存在从 $B$ 到 $A$ 的路径。  

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点 $B$ 的路径，则在排序中 $B$ 出现在 $A$ 的后面。每个AOV网都有一个或多个拓扑排序序列。  

# 命题追踪拓扑排序和回路的关系（2011）  

对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤 $\textcircled{\scriptsize{1}}$ 从AOV网中选择一个没有前驱（入度为0）的顶点并输出。 $\circledcirc$ 从网中删除该顶点和所有以它为起点的有向边。  

$\textcircled{3}$ 重复 $\circledcirc$ 和 $^{(\mathcal{Q})}$ 直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。  
命题追踪拓扑排序的实例（2010、2014、2018、2021）  

图6.22所示为拓扑排序过程的示例。每轮选择一个入度为0的顶点并输出，然后删除该顶点和所有以它为起点的有向边，最后得到拓扑排序的结果为 $\{1,2,4,3,5\}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8810ace9ff20c9670d0e1272ddf371bd248455d387e1a48022dfcfc7f025d42a.jpg)  
图6.22有向无环图的拓扑排序过程  

拓扑排序算法的实现如下：  

o ol Topological Sort(Graph G){ InitStack(S);/初始化栈，存储入度为0的顶点int i; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<G.vexnum;  $\ \ \dot{\mathbf{1}}_{++}$  if（indegree[i] $==0$ 一Push(S,i); //将所有入度为0的顶点进栈 int count $=\!0$ //计数，记录当前已经输出的顶点数while(!IsEmpty(S)){//栈不空，则存在入度为0的顶点Pop(S,i); /栈顶元素出栈 print[count ${\bf++}]\!=\!\mathrm{i}$ /输出顶点for  $\scriptstyle{\mathrm{sp}}=G$  .vertices[i].firstarc;p;p=p->nextarc)( //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S $\scriptstyle{\mathrm{~v=p~}}$  ->adjvex; if(!(--indegree[v]))Push(S,v); 11入度为0，则入栈 if（count<G.vexnum)returnfalse;/排序失败，有向图中有回路else return true; /拓扑排序成功  
# 命题追踪不同存储方式下的拓扑排序的效率（2016）  

因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时间复杂度为 $O(|V|+|E|)$ ，采用邻接矩阵存储时拓扑排序的时间复杂度为 $O(|V|^{2})$  

# 命题追踪》DFS实现拓扑排序的思想（2020）  

此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码见本节后的习题。对于有向无环图 $G$ 中的任意结点 $u,v$ ，它们之间的关系必然是下列三种之一：  

1）若  $u$  是  $\nu$  的祖先，则在调用DFS访问  $u$  之前，必然已对  $v$  进行了DFS访问，即v的DFS 结束时间先于 $u$ 的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。  

2）若 $u$ 是 $v$ 的子孙，则v为 $u$ 的祖先，按上述思路，v的结束时间大于 $u$ 的结束时间。  

3）若 $u$ 和 $v$ 没有路径关系，则 $u$ 和 $\nu$ 在拓扑序列的关系任意。  

于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。  

对一个AOV网，若采用下列步骤进行排序，则称之为逆拓扑排序：  

$\textcircled{\scriptsize{1}}$ 从AOV网中选择一个没有后继（出度为0）的顶点并输出。  

$\textcircled{2}$ 从网中删除该顶点和所有以它为终点的有向边。  

$\textcircled{3}$ 重复 $\textcircled{\scriptsize{1}}$ 和 $\textcircled{2}$ 直到当前的AOV网为空。  

用拓扑排序算法处理AOV网时，应注意以下问题：  

1）入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。  

# 命题追踪分析给定图的拓扑序列的存在性和唯一性（2011）  

2）若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。  

3）由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。  

# 6.4.5关键路径  

在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。  

AOE网具有以下两个性质：  

$\textcircled{\scriptsize{1}}$ 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始； $\circledcirc$ 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。  

在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。  

# 命题追踪关键路径的性质（2020）  

在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。  
完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。  

下面给出在寻找关键活动时所用到的几个参量的定义。  

# 1．事件 $\nu_{k}$ 的最早发生时间 $\nu_{e}(k)$  

它是指从源点 $\nu_{1}$ 到顶点 $v_{k}$ 的最长路径长度。事件 $v_{k}$ 的最早发生时间决定了所有从 $v_{k}$ 开始的活动能够并工的最早时间。可用下面的递推公式来计算：  

v.(源点)  $=0$  

$\nu_{e}(k)=\operatorname{Max}\{\nu_{e}(j)+\operatorname{Weibht}(\nu_{j},\nu_{k})\},\nu_{k}$ 为 $v_{j}$ 的任意后继，Weight $(v_{j},v_{k})$ 表示 $\begin{array}{r}{\negthickspace\negthickspace\negthickspace<\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\neg\negthickspace\neg\!\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!$ v>上的权值  

> attention:  

计算 $\nu_{e}()$ 值时，按从前往后的顺序进行，可以在拓扑排序的基础上计算：  

$\textcircled{\scriptsize{1}}$ 初始时，令 $\nu_{e}[1...n]=0$  

$\circledcirc$ 输出一个入度为 $0$ 的顶点 $\nu_{j}$ 时，计算它所有直接后继顶点 $\nu_{k}$ 的最早发生时间，若ve[] $\mathrm{Weibt}(\nu_{j},\nu_{k})>\nu_{e}[k],$ 则 $\nu_{e}[k]=\nu_{e}[j]+\mathrm{Weibt}(\nu_{j},\nu_{k})$ 。以此类推，直至输出全部顶点。  

# 2.事件 $\nu_{k}$ 的最迟发生时间 $\nu_{l}(k)$  

它是指在不推迟整个工程完成的前提下，即保证它的后继事件 $v_{j}$ 在其最迟发生时间 $v(j)$ 能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：  

$v_{I}($  汇点)  $=$  v(汇点)  

$\nu_{l}(k)=\mathrm{Min}\{\nu_{l}(j)-\mathrm{Weibh}(\nu_{k},\nu_{j})\},\nu_{k}$  为  $\nu_{j}$  的任意前驱  

> attention:  

计算 $v_{l}(k)$ 值时，按从后往前的顺序进行，可以在逆拓扑排序的基础上计算。增设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：  

$\textcircled{\scriptsize{1}}$ 初始时，令 $\nu_{l}[1...n]=\nu_{e}[n].$  

$\circledcirc$ 栈顶顶点 $v_{j}$ 出栈，计算其所有直接前驱顶点 $v_{k}$ 的最迟发生时间，若 $v_{l}[j]-\mathsf{W e i g h t}(v_{k},\,v_{j})<$  $\displaystyle{\nu_{l}[k]}$ ，则 $\nu_{l}[k]=\nu_{l}[j]-\mathrm{Weigint}(\nu_{k},\nu_{j}).$ ，以此类推，直至输出全部栈中顶点。  

# 3.活动 $\pmb{a}_{i}$ 的最早开始时间 $e(i)$  

它是指该活动弧的起点所表示的事件的最早发生时间。若边 $\begin{array}{r}{\sqrt{\!\!\mathrm{\Sigma}_{k}^{\mathrm{}}\!\!},}\end{array}$ v>表示活动 $a_{i}$ ，则有 $e(i)=$  $\nu_{e}(k)$  

# 4.活动 $\mathbf{\delta}_{\mathbf{\alpha}_{i}}$ 的最迟开始时间I(i)  

它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边 $\begin{array}{r}{{\mathbf{\mu}}^{<\nu_{k},}}\end{array}$ V>表示活动 $a_{i}$ ，则有 $l(i)=\nu_{i}(j)-\mathrm{Weibull}(\nu_{k},\nu_{j})\,.$  

# 5.一个活动 $\mathbf{\delta}a_{i}$ 的最迟开始时间 $\iota(i)$ 和其最早开始时间 $e(i)$ 的差额 $\begin{array}{r}{d(i)=l(i)-e(i)}\end{array}$  

它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动 $a_{i}$ 可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工程的进度，所以称 $l\!(i)\!-\!e(i)\!=\!0$ 即 $l(i)=e(i)$ 的活动 $a_{i}$ 是关键活动。  
# 命题追踪求关键路径的实例（2019、2022）  

求关键路径的算法步骤如下：  

$\textcircled{\scriptsize{1}}$ 从源点出发，令v(源点) $=0$ ，按拓扑有序求其余顶点的最早发生时间 $\nu_{e}(0)_{\circ}$  

$\textcircled{2}$ 从汇点出发，令 $v_{l}($ 汇点） $=v_{e}$ (汇点)，按逆拓扑有序求其余顶点的最迟发生时间 $\nu(0)$  

$\textcircled{3}$ 根据各顶点的 $\nu_{e}()$ 值求所有弧的最早开始时间 $e()$  

$\textcircled{4}$ 根据各顶点的 $v_{I}()$ 值求所有弧的最迟开始时间 $l().$  

$\circledast$ 求AOE网中所有活动的差额 $d()$ ，找出所有 $d()=0$ 的活动构成关键路径。  

图6.23所示为求解关键路径的过程，简单说明如下：  

$\textcircled{\scriptsize{1}}$ 求 $\nu_{e}()$ ：初始 $\nu_{e}(1)=0$ ，在拓扑排序输出顶点过程中，求得 $\nu_{e}(2)=3\,,\,\,\nu_{e}(3)=2\,,\,\,\nu_{e}(4)=$  $\operatorname*{max}\left\{\nu_{e}(2)+2,\nu_{e}(3)+4\right\}=\operatorname*{max}\left\{5,6\right\}=6,\;\;\nu_{e}(5)=6,\;\;\nu_{e}(6)=\operatorname*{max}\left\{\nu_{e}(5)+1,\nu_{e}(4)+2,\nu_{e}(3)+4\right\}=2.$   $3\}=\operatorname*{max}\{7,8,5\}=8.$  

若这是一道选择题，根据上述求 $\nu_{e}()$ 的过程就已经能知道关键路径。  

$\circledcirc$ 求 $v()$ ：初始 $\nu(6)\!=\!8$ ，在逆拓扑排序出栈过程中，求得 $\nu(5)\!=\!7$ ， $v(4)\!=\!6$ ， $\begin{array}{r}{v_{i}(3)\!=\!\operatorname*{min}\{v_{i}(4)\!-\!4,}\end{array}$  $\nu_{\ell}(6)-3\}=\operatorname*{min}\{2,\,5\}=2,\,\,\,\nu_{\ell}(2)=\operatorname*{min}\{\nu_{\ell}(5)-3,\,\nu_{\ell}(4)-2\}=\operatorname*{min}\{4,\,4\}=4,$   $v_{l}(1)$  必然为  $0$  而无 须再求。  

$\textcircled{3}$ 弧的最早开始时间e(等于该弧的起点的顶点的 $\nu_{e}(\r)$ ，结果如下表。  

$\textcircled{4}$ 弧的最迟开始时间 $l(i)$ 等于该弧的终点的顶点的 $v_{\Lambda}()$ 减去该弧持续的时间，结果如下表。 $\circledast$ 根据 $l(i)\,-\,e(i)=0$ 的关键活动，得到的关键路径为 $(v_{1},v_{3},v_{4},v_{6}).$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3c83283a75649b4d8c5c2d0548388cadf2a7ab0f11784d1e7fa5d35976e5c5b2.jpg)  
图6.23求解关键路径的过程  

# 命题追踪缩短工期的相关分析（2013）  

对于关键路径，需要注意以下几点：  

1）关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。  

2）网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。  

各种图算法在采用邻接矩阵或邻接表存储时的时间复杂度如表6.5所示。  
表6.5采用不同存储结构时各种图算法的时间复杂度
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0cd28f07c2726861bd6847070ff8c2ca1109e478a5a69b4406f36d63f04ed47e.jpg)  

# 6.4.6 本节试题精选  

# 一、单项选择题  

01.任何一个无向连通图的最小生成树（）  

A.有一棵或多棵B.只有一棵C.一定有多棵D.可能不存在  

02.用Prim算法和Kruskal算法构造图的最小生成树，所得到的最小生成树（）。  

A.相同 B.不相同 C.可能相同，可能不同D.无法比较  

03.以下叙述中，正确的是（）。  

A.只要无向连通图中没有权值相同的边，则其最小生成树唯一B.只要无向图中有权值相同的边，则其最小生成树一定不唯一 C.从 $n$ 个顶点的连通图中选取 $n^{-1}$ 条权值最小的边，即可构成最小生成树D.设连通图  $G$  含有  $n$  个顶点，则含有  $n$  个顶点、  $n^{-1}$  条边的子图一定是  $G$  的生成树  

04.设有 $n$ 个顶点的无向连通图的最小生成树不唯一，则下列说法中正确的是（）  

A.图的边数一定大于  $n-1$  B.图的权值最小的边一定有多条 C.图的最小生成树的代价不一定相等D.图的各条边的权值不相等  

05.用Prim算法求一个带权连通图的最小生成树，在算法执行的某个时刻，已选取的顶点集合 $U=\{1,2,3\}$ ，已选取的边集合 $\mathrm{TE}=\{(1,2),(2,3)\}$ ，要选取下一条权值最小的边，应当从（）组中选取。  

A.  $\{(1,4),(3,4),(3,5),(2,5)\}$  B.  $\{(3,4),(3,5),(4,5),(1,4)\}$  C.  $\{(1,2),(2,3),(3,5)\}$  D. {(4, 5), (1, 3), (3, 5)}  

06.用Kruskal算法求一个带权连通图的最小生成树，在算法执行的某个时刻，已选取的边集合 $\mathrm{TE}=\{(1,2),(2,3),(3,5)\}$ ，要选取下一条权值最小的边，不可能选取的边是（）。  

A. (3,6) B. (2,4) C. (1,3) D. (1,4)  

07．下列关于图的最短路径的相关叙述中，正确的是（）。  

A.最短路径一定是简单路径B.Dikstra算法不适合求有回路的带权图的最短路径C.Dijkstra算法不适合求任意两个顶点的最短路径 D.Floyd算法求两个顶点的最短路径时， $\mathrm{\Delta}\mathrm{path}_{k-1}$ 一定是pathk的子集  

08.下列关于图的最短路径的相关叙述中，正确的是（）  

I.Dijkstra算法求单源最短路径不允许边的权为负 II.Dijkstra算法求每对顶点间的最短路径的时间复杂度是  $O(n^{2})$  Ill.Floyd算法求每对顶点间的最短路径允许边的权为负，但不允许含有负边的回路  

A.I、ⅡI和IⅢIB.仅IC.I和ⅢID.ⅡI和IⅢI  

09.已知带权连通无向图 $G\!=\!(V,E)$ ，其中 $\scriptstyle V=\{v_{1},\,v_{2},\,v_{3},\,v_{4},\,v_{5},\,v_{6},\,v_{7}\},\ E=\{(v_{1},\,v_{2})10,\,(v_{1},\,v_{3})2,$  $(v_{3},v_{4})2$ (v3,v)11, $(v_{2},\,v_{5})1$  $(v_{4},\,v_{5})4$  $(v_{4},\,v_{6})6$  $(v_{5},\,v_{7})7,$  $(v_{6},\,v_{7})3\}$ （注：顶点偶对括号外的数据表示边上的权值），从源点 $\nu_{1}$ 到顶点 $v_{7}$ 的最短路径上经过的顶点序列是（）  
A.  $v_{1},v_{2},v_{5},v_{7}$  B.  $v_{1},v_{3},v_{4},v_{6},v_{7}\quad\mathrm{~\textit~{~C~}~}$   $v_{1},v_{3},v_{4},v_{5},v_{7}$  D.  $v_{1},v_{2},v_{5},v_{4},v_{6},v_{7}$  

10.用Dijkstra算法求一个带权有向图的从顶点0出发的最短路径，在算法执行的某个时刻，已求得的最短路径的顶点集合 $S=\{0,2,3,4\}$ ，下一个选取的目标顶点是顶点1，则可能修改的最短路径是（）。  

A.从顶点0到顶点3的最短路径B.从顶点0到顶点2的最短路径C.从顶点2到顶点4的最短路径D.从顶点0到顶点1的最短路径  

11.下面的（）方法可以判断出一个有向图是否有环（回路）I.深度优先遍历II.拓扑排序III.求最短路径IV.求关键路径 A.I、II、IVB.I、III、IVC.I、II、IIID.全部可以

12.在有向图 $G$ 的拓扑序列中，若顶点 $\boldsymbol{v}_{i}$ 在顶点 $\boldsymbol{v}_{j}$ 之前，则不可能出现的情形是（）  

A.G中有弧<v,V>B. $G$ 中有一条从 $\boldsymbol{v}_{i}$ 到V的路径C. $G$ 中没有弧<v,V>D. $G$ 中有一条从v到 $\nu_{i}$ 的路径  

13.下列关于拓扑排序的说法中，错误的是（）  

I.若某有向图存在环路，则该有向图一定不存在拓扑排序 I1.在拓扑排序算法中为暂存入度为零的顶点，可以使用栈，也可以使用队列III.若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为1 IV.若有向图的拓扑有序序列唯一，则图中入度为0和出度为0的顶点都仅有1个  

A.I、III、IVB.III、IVC. II、IVD.III

14.下列关于拓扑排序的说法中，正确的是（）。  

1.强连通图不能进行拓扑排序 IL.在一个有向图的拓扑序列中，若顶点 $^a$ 在顶点 $^b$ 之前，则图中必有一条弧<a， $b\!\!>$  

A.仅I B.仅ⅡI C.I和ⅡI D.都不正确

 15.若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图（）。  

A.含有多个出度为0的顶点B.是个强连通图C.含有多个入度为0的顶点 D.含有顶点数大于1的强连通分量  

16.下图所示有向图的所有拓扑序列共有（）个。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9ca3103c401d528df9d58fe2474167e5ea629c2b87da7e543bc79bed3e790bd.jpg)  

A.4 B.6 C.5 D.7  

17.已知有向图 $G\!=\!(V,E)$ ，其中 $V=\{\nu_{1},\,\nu_{2},\,\nu_{3},\,\nu_{4},\,\nu_{5},\,\nu_{6},\,\nu_{7}\},\;\;E=\{<\nu_{1},\,\nu_{2}>,\,<\nu_{1},\,\nu_{3}>,\,<\nu_{1},\,\nu_{4}>,$  $\scriptstyle<\nu_{2},\,\nu_{5}>,\,<\nu_{3},\,\nu_{5}>,\,<\nu_{3},\,\nu_{6}>,\,<\nu_{5},\,\nu_{7}>,\,<\nu_{6},\,\nu_{7}>,\,<\nu_{4},\,\nu_{6}>\}\,.$  $G$ 的拓扑序列是（）。  

A.  $\{v_{1},v_{3},v_{4},v_{6},v_{2},v_{5},v_{7}\}$  B.{V1,V3,V2,V6,V4,V5,V7} C.  $\{v_{1},v_{3},v_{4},v_{5},v_{2},v_{6},v_{7}\}$   $\begin{array}{r l}{\mathrm{D}.}&{{}\{v_{1},v_{2},v_{5},v_{3},v_{4},v_{6},v_{7}\}}\end{array}$  

18.下列哪种图的邻接矩阵是对称矩阵？（  

A.有向网B.无向图C.AOV网D.AOE网  

19.若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为（）。  

A.对称B.稀疏C.三角D.一般  
20.用DFS算法遍历一个无环有向图，并在DFS算法退栈返回时输出相应的顶点，则输出的顶点序列是（）。  

A.逆拓扑有序B.拓扑有序C.无序的D.无法确定  

21.下列关于图的说法中，正确的是（）。  

I.有向图中顶点 $V$ 的度等于其邻接矩阵中第V行中1的个数I1.无向图的邻接矩阵一定是对称矩阵，有向图的邻接矩阵一定是非对称矩阵 IⅢI.在带权图 $G$ 的最小生成树 $G_{1}$ 中，某条边的权值可能会超过未选边的权值IV.若有向无环图的拓扑序列唯一，则可以唯一确定该图  

A.I、ⅡI和ⅢIB.II和IVC.IID.IV

22.下图所示的AOE网中，关键路径长度为（）A.16N B.17 C.18 D.19  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d099e858da2fc2199eba6cb56222df8890c62095826023f01ddf3db438acac17.jpg)  

23.若某带权图为 $G\!=\!(V,E)$ ，其中 $V=\{\nu_{1},\,\nu_{2},\,\nu_{3},\,\nu_{4},\,\nu_{5},\,\nu_{6},\,\nu_{7},\,\nu_{8},\,\nu_{9},\,\nu_{10}\}\,,\,\,\,E=\{<\nu_{1},\,\nu_{2}>5,\,<\nu_{1},\,\nu_{3}>5,\,\}\,\,,$  $\nu_{3}{>}6,\,\lnot v_{2},\,\nu_{5}{>}3,$   $\begin{array}{r}{<\!v_{3},}\end{array}$   $v_{5}{>}6,$   $\begin{array}{r}{<\!v_{3},}\end{array}$   $v_{4}{>}3$   ${\mathfrak{c}}v_{4},$   $v_{5}{>}3$   ${\mathfrak{c}}v_{4}$   $\scriptstyle{\nu_{7}>1}$   ${\mathfrak{c}}v_{4},$   $v_{8}{>}4$  <V5,V6>4,<V5,  $_{v_{7}>2}$   ${\displaystyle<}v_{6},$   $\scriptstyle{v_{10}>4}$  $\scriptstyle<v_{7}$  $v{>}5$  ${\mathfrak{c}}v_{8}$  $v_{9}{>}2$  ${<}v_{9}$  $_{v_{10}>2\}$ （注：边括号外的数据表示边上的权值），则 $G$ 的关键路径的长度为（）。  

A.19 B.20 C.21 D.22

 24.下面关于求关键路径的说法中，不正确的是（）  

A.求关键路径是以拓扑排序为基础的 B.一个事件的最早发生时间与以该事件为始的弧的活动的最早开始时间相同C.一个事件的最迟发生时间是以该事件为尾的弧的活动的最迟开始时间与该活动的持续时间的差D.任何一个活动的持续时间的改变可能会影响关键路径的改变  

25.下列关于关键路径的说法中，正确的是（）  

I.改变网上某一关键路径上的任意一个关键活动后，必将产生不同的关键路径II1.在AOE图中，关键路径上活动的时间延长多少，整个工期也就随之延长多少I1I.缩短关键路径上任意一个关键活动的持续时间可缩短关键路径长度IV.缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度V.缩短多条关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度  

A.II和V B.I、II和IV C.ⅡI和IV D.I和IV

 26.在求AOE网的关键路径时，若该有向图用邻接矩阵表示且第 $i$ 列值全为0，则（）  

A.若关键路径存在，第i个顶点一定是起点B.若关键路径存在，第 $i$ 个顶点一定是终点C.关键路径不存在D.该有向图对应的无向图存在多个连通分量  
27.【2010统考真题】对下图进行拓扑排序，可得不同拓扑序列的个数是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74c4f116ee4b445eea68d6bb91cfd68b14e3d92e15c718388000e6ca4abd5260.jpg)  

A.4 B.3 C.2 D.1

 28.【2012统考真题】下列关于最小生成树的叙述中，正确的是（）  

I.最小生成树的代价唯一II.所有权值最小的边一定会出现在所有的最小生成树中IIl.使用Prim算法从不同顶点开始得到的最小生成树一定相同IV.使用Prim算法和Kruskal算法得到的最小生成树总不相同  

A.仅IB.仅ⅡIC.仅I、IIID.仅II、IV  

29.【2012统考真题】对下图所示的有向带权图，若采用Dijkstra算法求从源点a到其他各 顶点的最短路径，则得到的第一条最短路径的目标顶点是b，第二条最短路径的目标顶点是C，后续得到的其余各最短路径的目标顶点依次是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e51b0ff7037ed9c7341eccbe53ac22573729b78d30574754bf1ae9be5c2f50bc.jpg)  

A.d,e,f B.e,d,f C. f,d,e D.f,e,d  

30.【2012统考真题】若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关 于该图拓扑序列的结论是（）。  

A.存在，且唯一B.存在，且不唯一C.存在，可能不唯一D.无法确定是否存在  

31.【2013统考真题】下列A0E网表示一项包含8个活动的工程。通过同时加快若千活动的进度可缩短整个工程的工期。在下列选项中，加快其进度就可缩短工程工期的是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/555327f861e1f54543ce1a6eddf5f448b59f5b56af36c10f09fe15de38c6f841.jpg)  

A.c和e B.d和c C.f和d D.f和h  

32.【2014统考真题】对下图所示的有向图进行拓扑排序，得到的拓扑序列可能是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc9f75c48ff3399db23e602c80e2ed08a2ff8e1c23e8c20f5931aea0296c4b5e.jpg)  
A.3,1,2,4,5,6 B.3,1,2,4,6,5 C.3,1,4,2,5,6 D.3,1,4,2,6,5  

33.【2015统考真题】求下面的带权图的最小（代价）生成树时，可能是Kruskal算法第2次选中但不是Prim算法（从 $V_{4}$ 开始）第2次选中的边是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7bc1c643c392a258847895435132bb49539f365b46fddce96625366a41807a9a.jpg)  

A.  $(V_{1},V_{3})$  A2KXB.  $(V_{1},V_{4})$  C.  $(V_{2},V_{3})$  D.  $(V_{3},V_{4})$  34.【2011统考真题】下列关于图的叙述中，正确的是（）  

I.回路是简单路径II.存储稀疏图：用邻接矩阵比邻接表更省空间III.若有向图中存在拓扑序列，则该图不存在回路  

A.仅ⅡIB.仅I、ⅡC.仅IⅢID.仅I、ⅢII  

35.【2016统考真题】使用Dijkstra算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/be32bd20b2f8a905e67b9417f3d50ad3a849d4b8be5ee730c9bf81ebc5c4fcda.jpg)  

A.5,2,3,4,6 B.5,2,3,6,4 C.5,2,4,3,6 D.5,2,6,3,4  

36.【2016统考真题】若对  $n$  个顶点、  $e$  条弧的有向图采用邻接表存储，则拓扑排序算法的 时间复杂度是（）。  

A.O(n) B.  $O(n+e)$  C. 0(n²) D. O(ne)  

37.【2018统考真题】下列选项中，不是如下有向图的拓扑序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c29e48fc49d17b97665df356416a9a2f574ad441bc2385a9fed6b304d5f02429.jpg)  

A.1,5,2,3,6,4 B.5,1,2,6,3,4 C.5,1,2,3,6,4 D.5,2,1,6,3,4  

38.【2019统考真题】下图所示的A0E网表示一项包含8个活动的工程。活动 $d$ 的最早开始时间和最迟开始时间分别是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/11525bea64034c7313bb695917c15b81c8eae73290a43e17219c71fdcbcfb633.jpg)  

A.3和7 B.12和12 C.12和14 D.15和15  
39.【2019统考真题】用有向无环图描述表达式  $(x+y)((x+y)/x)$  ，需要的顶点个数至少是 ()。  

A.5 B.6 C.8 D.9  

40.【2020统考真题】已知无向图 $G$ 如下所示，使用Kruskal算法求图 $G$ 的最小生成树，加到最小生成树中的边依次是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ef0855a857307e59286bd4bdc96983ef25e4bc8c68087d83c43acdde61f391ad.jpg)  

A.  $(b,f),(b,d),(a,e),(c,e),(b,e)$  B.  $(b,f),(b,d),(b,e),(a,e),(c,e)$  C. (a, e)  $,(b,e),(c,e),(b,d),(b,f)$  D.  $(a,e),(c,e),(b,e),(b,f),(b,d)$  

41.【2020统考真题】修改递归方式实现的图的深度优先搜索（DFS）算法，将输出（访 问）顶点信息的语句移到退出递归前（即执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图 $G$ 若输出结果中包含 $G$ 中的全部顶点，则输出的顶点序列是 $G$ 的()。  

A.拓扑有序序列 B.逆拓扑有序序列 C.广度优先搜索序列D.深度优先搜索序列  

42.【2020统考真题】若使用AOE网估算工程进度，则下列叙述中正确的是（）  

A.关键路径是从源点到汇点边数最多的一条路径B.关键路径是从源点到汇点路径长度最长的路径 C.增加任意一个关键活动的时间不会延长工程的工期D.缩短任意一个关键活动的时间将会缩短工程的工期  

43.【2021统考真题】给定如下有向图，该图的拓扑有序序列的个数是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2d50b3307056ac82a041fda9f7d3985b66158930285467f3081961d8fd931032.jpg)  

A. 1 B.2 C.3 D.4  

44.【2021统考真题】使用Dijkstra算法求下图中从顶点1到其余各顶点的最短路径，将当前找到的从顶点1到顶点2，3，4，5的最短路径长度保存在数组dist中，求出第二条最短路径后，dist中的内容更新为（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/996ae4f1f0c45c43bc5dded69c4a7b24e5f827a8491d273831a39cc129358279.jpg)  
A.26,3,14,6 B.25,3,14,6 C.21,3,14,6 D.15,3,14,6

 45.【2022统考真题】下图是一个有10个活动的AOE网，时间余量最大的活动是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/37ab5adcd9e888f760e755ef5d2f8f04b20b24796ffb38dbf9bc2d0f2ade3d36.jpg)  

A. B. g C.h D.j  

46.【2023统考真题】已知无向连通图 $G$ 中各边的权值均为1。在下列算法中，一定能够求出图 $G$ 中从某顶点到其余各顶点最短路径的是（）。I.Prim算法ⅡI.Kruskal算法IⅢl.图的广度优先搜索算法  

A.仅1B.仅IⅢIC.仅I、ⅡID.I、ⅡⅢ  

# 二、综合应用题  

01.下面是一种称为“破圈法”的求解最小生成树的方法：所谓“破圈法”，是指“任取一圈，去掉圈上权最大的边”，反复执行这一步骤，直到没有圈为止。试判断这种方法是否正确。若正确，说明理由；若不正确，举出反例（注：圈就是回路）。  

02.已知有向图如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ef70ec28a49b39c3070800aac78b1636854ebd3eeefab3623c019d84e3a61c74.jpg)  

1）写出该图的邻接矩阵表示并据此给出从顶点1出发的深度优先遍历序列2）求该有向图的强连通分量的数目。3）给出该图的任意两个拓扑序列。4）若将该图视为无向图，分别用  $\operatorname{Prim}$  算法和Kruskal算法求最小生成树。  

03.对下图所示的无向图，按照Dijkstra算法，写出从顶点1到其他各个顶点的最短路径和 最短路径长度（顺序不能颠倒）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8b2b7b88251e8ace2fda8f31679349033203f4be1d534cff7bcbf088cd6deb8.jpg)  

04.下图所示为一个用AOE网表示的工程。1）画出此图的邻接表表示。2）完成此工程至少需要多少时间？3）指出关键路径。4）哪些活动加速可以缩短完成工程所需的时间？  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/448a57f09817d564fd9e4ec59ab42c92ff4b5902d6d3b6bad19391a42a80076c.jpg)  

05.下表给出了某工程各工序之间的优先关系和各工序所需的时间（其中“一”表示无先驱工序）请完成以下各题：  

1）画出相应的AOE网。 2）列出各事件的最早发生时间和最迟发生时间。3）求出关键路径并指明完成该工程所需的最短时间  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea11a7dacb5c1a689e0bdc974ba7fe6ee8736332d0eecd50fc2447ee5981a831.jpg)  

06.一连通无向图，边非负权值，问用Dikstra最短路径算法能否给出一棵生成树，该树是 否一定是最小生成树？说明理由。  

07.试编写利用DFS实现有向无环图拓扑排序的算法  

08.【2009统考真题】带权图（权值非负，表示边连接的两顶点间的距离）的最短路径问题是找出从初始顶点到自标顶点之间的一条最短路径。假设从初始顶点到自标顶点之间存在路径，现有一种解决该问题的方法：  

$\textcircled{\scriptsize{1}}$ 设最短路径初始时仅包含初始顶点，令当前顶点 $u$ 为初始顶点。 $\circledcirc$ 选择离 $u$ 最近且尚未在最短路径中的一个顶点V，加入最短路径，修改当前顶点 $u=v_{\circ}$   $\textcircled{3}$ 重复步骤 $\circledcirc$ ，直到 $u$ 是目标顶点时为止。请问上述方法能否求得最短路径？若该方法可行，请证明：否则，请举例说明。  

09.【2011统考真题】已知有6个顶点（顶点编号为0\~5）的有向带权图 $G$ ，其邻接矩阵 $_A$ 为上三角矩阵，按行为主序（行优先）保存在如下的一维数组中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a899324565b460c6402ce1bdfc632930ad352b09f4536c9ed4b61e30794e10d8.jpg)  

要求：  

1）写出图 $G$ 的邻接矩阵A。2）画出有向带权图 $G_{c}$ 3）求图 $G$ 的关键路径，并计算该关键路径的长度。  

10.【2014统考真题】某网络中的路由器运行OSPF路由协议，下表是路由器R1维护的主要链路状态信息（LSI），RI构造的网络拓扑图（见下图）是根据题下表及RI的接口名构造出来的网络拓扑。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c610e648dc04ce4bd0e6f700e12ab6689bea0e516bbc618f11a3b14271b1baa.jpg)  

请回答下列问题。  

1）本题中的网络可抽象为数据结构中的哪种逻辑结构？2）针对表中的内容，设计合理的链式存储结构，以保存表中的链路状态信息（LSI）要求给出链式存储结构的数据类型定义，并画出对应表的链式存储结构示意图（示意图中可仅以ID标识结点）。3）按照Dijkstra算法的策略，依次给出R1到达子网 $192.1._{\mathrm{X.X}}$ 的最短路径及费用。  

11.【2017统考真题】使用Prim算法求带权连通图的最小（代价）生成树（MST）。请回答下列问题：  

1）对下列图 $G$ 从顶点 $A$ 开始求 $G$ 的MST，依次给出按算法选出的边2）图 $G$ 的MST是唯一的吗？3）对任意的带权连通图，满足什么条件时，其MST是唯一的？  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5866f5cef4574297162726e3c74198cfa8f0e74f09e67cfe3ae4861a78db497a.jpg)  

12.【2018统考真题】拟建设一个光通信骨干网络连通BJ、CS、XA、QD、JN、NJ、TL和WH等8个城市，下图中无向边上的权值表示两个城市之间备选光缆的铺设费用。请回答下列问题：  

1）仅从铺设费用角度出发，给出所有可能的最经济的光缆铺设方案（用带权图表示），并计算相应方案的总费用。2）该图可采用图的哪种存储结构？给出求解问题1）所用的算法名称。3）假设每个城市采用一个路由器按1）中得到的最经济方案组网，主机H1直接连接TL的路由器，主机H2直接连接BJ的路由器。若H1向H2发送一个 $\mathrm{TTL}=5$ 的 IP分组，则H2是否可以收到该IP分组？  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/988db1d95e7e87273cd82c0b6880528e120fddd6e4b66b528fb9dca3d4037c2d.jpg)  

# 6.4.7 答案与解析  

# 一、单项选择题  

01. A  

当无向连通图存在权值相同的多条边时，最小生成树可能是不唯一的；另外，由于这是一个无向连通图，因此最小生成树必定存在，从而选A。  

02.C  

因为无向连通图的最小生成树不一定唯一，所以用不同算法生成的最小生成树可能不同，但当无向连通图的最小生成树唯一时，不同算法生成的最小生成树必定是相同的。  

03.A  

最小生成树算法是基于贪心策略的，每次总是选取权值最小且满足条件的边，若各边权值不同，则每次选择的新顶点也是唯一的，因此最小生成树唯一，A正确。对于B，若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。对于C，选取的 $n\!-\!1$ 条边可能构成回路。对于D，含有 $n$ 个顶点、 $n\!-\!1$ 条边的子图可能构成回路，也可能不连通。  

04.A  

若图的边数小于 $n-1$ ，则图不存在最小生成树：若无向连通图的边数等于 $n-1$ ，则最小生成树唯一，即为图本身，所以图的边数一定大于 $n-1$ ，A正确。若最小生成树不唯一，则一定存在权值相等的边，但未必是权值最小的边，如下图所示，B错误。最小生成树可能不唯一，但代价一定相同，C错误。当图的各边的权值互不相等时，图的最小生成树是唯一的，D错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f966785a56f7219b92bd3159fa9a6fdbd71ca4e605ed551f492e5391121c04e6.jpg)  

05.A  

$U{=}\left\{1,2,3\right\}$ ， $V-U=\{4,5,\cdots\}$ ，候选边只能是这两个顶点集之间的边，只有A符合题意。  

06.C  

若选取边（1，3）则会构成回路。  

07.A  

A正确，见严蔚敏撰写的教材《数据结构》。Dijkstra算法适合求解有回路的带权图的最短 路径，也可以求任意两个顶点的最短路径，不适合求带负权值的最短路径问题。在用Floyd算法求两个顶点的最短路径时，当最短路径发生更改时， $\mathrm{\Delta}\mathrm{\mathfrak{h}}_{k-1}$ 就不是path的子集。  

08.C  

在负权图中，Dijkstra算法既不能保证每次选出的顶点都是真正的最近顶点，又不能保证已确定的最短路径不再被改变，因此Dikstra算法不允许边的权为负，I正确。求每对顶点间的最短路径需要调用Dijkstra算法 $n$ 次，时间复杂度为 $O(n^{3})$ ，ⅡI错误。Floyd算法求每对顶点间的最短路径充许有负边存在，但不充许有包含负边组成的回路，Ⅲ正确。  
09.B  

题目所描述的图 $G$ 如下图所示。A,B,C，D对应的路径长度分别为18，13，15,24。应用Dijkstra算法不难求出最短路径为  $\nu_{1}{\rightarrow}\nu_{3}{\rightarrow}\nu_{4}{\rightarrow}\nu_{6}{\rightarrow}\nu_{7}{\circ}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a12b8ef9ce0cdc2861a92c1c431f04efa89d5bbf617e04da0ef1c4278817060.jpg)  

10.D  

在Dijkstra算法的执行过程中，只可能修改从源点O到集合 $V\!-\!S$ 中某个顶点的最短路径  

11.A  

使用深度优先遍历，若从有向图上的某个顶点 $u$ 出发，在DFS $(u)$ 结束之前出现一条从顶点v到 $u$ 的边，由于 $v$ 在生成树上是 $u$ 的子孙，图中必定存在包含 $u$ 和 $v$ 的环，因此深度优先遍历可以检测一个有向图是否有环。拓扑排序时，当某顶点不为任何边的头时才能加入序列，存在环时环中的顶点一直是某条边的头，不能加入拓扑序列。也就是说，还存在无法找到下一个可以加入拓扑序列的顶点，则说明此图存在回路。求最短路径是充许图有环的。至于关键路径能否判断一个图有环，则存在一些争议。关键路径本身虽然不充许有环，但求关键路径的算法本身无法判断是否有环，判断是否有环是求关键路径的第一步一一拓扑排序。  

12.D  

若图 $G$ 中存在一条从v到 $v_{i}$ 的路径，说明 $V_{j}$ 是 $V_{i}$ 的前驱，则要把 $V_{j}$ 消去以后才能消去 $V_{i},$ 从而拓扑序列中必然先输出 $v_{j}$ ，再输出 $v_{i}$ ，这显然与题意矛盾。  

13.D  

对于I，若有向图中存在环，运行拓扑排序算法后，肯定会剩下有环的子图，在此环中无法再找到入度为0的顶点，拓扑排序也就无法再运行。对于ⅡI，若两个顶点之间不存在祖先或子孙关系，则它们在拓扑序列中的前后关系是任意的，因此使用栈和队列都可以，因为进栈或队列的都是入度为0的顶点。IⅢI是难点，若拓扑序列唯一，则很自然联想到一个线性的有向图，下图的拓扑序列也唯一，但却不满足该条件。对于IV，若入度为0的顶点不唯一，则这些顶点均可作为拓扑序列的起点：若出度为0的顶点不唯一，则这些顶点均可作为拓扑序列的终点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ff4dc41e511401c95eac50d846e8847e107fe68c249b561958cb51d3e3b7d84.jpg)  

14.A  

强连通图是指有向图中任意顶点对之间都存在两条相反的路径，这意味着强连通图中一定存在环，因此不能进行拓扑排序，1正确。假设顶点 $a$ 和 $^b$ 的入度均为0，且分别有两条孤从 $a$ 和 $b$ 指向同一顶点 $c$ ，则产生的拓扑序列可以是abc，但是此时并无一条弧<a, $b\!>$ ，Ⅱ错误。  

15.D  

一个有向图中的顶点不能排成一个拓扑序列，表明其中存在一个顶点数目大于1的回路（环），该回路构成一个强连通分量，从而答案选D。  
16. C  

A BCF DEG，ABCDFEG，ABCDEFG，ABD CF EG ABD CEF G。读者应能把这一类经典习题的拓扑序列全部写出来。  

17.A  

拓扑序列的过程：找到入度为0的顶点，删除该顶点及其所有出边，并将顶点加入拓扑序列，重复直至所有顶点都加入拓扑序列。选择入度为0的顶点 $\nu_{1}$ ，删除与 $\nu_{1}$ 有关的边；此时顶点 $v_{3}$ 的入度为0，选择 $v_{3}$ ，删除与 $v_{3}$ 有关的边；以此类推，得出 $G$ 的拓扑序列。  

18.B  

无向图的邻接矩阵存储中，每条边存储两次，且 $A[i][j]=A[j][i]$  

19.C  

此题一直以来争议较大，因为有些书中漏掉了“有序”二字。可以证明，对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元素全为零的充分必要条件是，该有向图可以进行拓扑排序。若这个题目把“有序”二字去掉，显然应选D。但此题题干中已经指出是“有序的拓扑序列”，因此应选C。需要注意的是，若一个有向图的邻接矩阵为三角矩阵（对角线以上或以下的元素为0），则图中必不存在环，因此其拓扑序列必然存在。  

20. A  

设图中有顶点 $v_{i}$ ，它有后继顶点 $v_{j}$ ，即存在边 $\begin{array}{r}{{\mathbf{\rho}}^{<}\mathbf{v}_{i},}\end{array}$  $v_{f}$ 。根据DFS 的规则， $v_{i}$ 入栈后，必先遍历完其后继顶点后 $\boldsymbol{v}_{i}$ 才会出栈，也就是说 $v_{i}$ 会在 $v_{j}$ 之后出栈，在如题所指的过程中， $v_{i}$ 在 $v_{j}$ 后打印。由于 $v_{i}$ 和 $v_{j}$ 具有任意性，因此由上面的规律看出，输出顶点的序列是逆拓扑有序序列。  

对有向无环图利用深度优先搜索进行拓扑排序的例子如下：如下图所示，退出DFS栈的顺序为efgdcahb，此图的一个拓扑序列为bhacdgfe。该方法的每一步均是先输出当前无后继的结点，即对每个结点 $v$ ，先递归地求出 $v$ 的每个后继的拓扑序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/95e2e823926f924b2589d0b7dfdd674f5f69af8575edf6919732ef5b2aebcfa4.jpg)  

21.C  

有向图邻接矩阵的第 $V$ 行中1的个数是顶点 $V$ 的出度，而有向图中顶点的度为入度与出度之和，1错。无向图的邻接矩阵一定是对称矩阵，但当有向图中任意两个顶点之间有边相连，且是两条方向相反的有向边时，有向图的邻接矩阵也是一个对称矩阵，Ⅱ错。最小生成树中的 $n\!-\!1$ 条边不能保证是图中权值最小的 $n\!-\!1$ 条边，因为权值最小的 $n\!-\!1$ 条边并不一定能使图连通。在下图中，左图的最小生成树如下图所示，权值为3的边不在其最小生成树中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b6edd2859df37c19f7a2db2bcc1addfd745b18f3c239b4dbcb5403f6e13b2b2.jpg)  

有向无环图的拓扑序列唯一并不能唯一确定该图。在下图所示的两个有向无环图中，拓扑序列都为 $V_{1},V_{2},V_{3},V_{4}$ ，IV错。注意，很多辅导书对该命题的判断是错误的。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba51729bd44321dd54583c4635c03ee9d8f3f509ea27ba9fa4af6069b7a12074.jpg)  

22.C  

观察题图，从 $V_{0}$ 到 $V_{8}$ 的最长路径为 $V_{0}{\rightarrow}V_{1}{\rightarrow}V_{4}{\rightarrow}V_{6}{\rightarrow}V_{8}$ ，长度为 $6+1+9+2=18$  

23.C  

题目描述的图如下，得到关键路径的长度为21，图中画出的两条路径都是关键路径。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0339099fc2887d3db0ba13f94595ebdf8256da86fabd6b3f2a3fbddd434a4046.jpg)  

24.C  

一个事件的最迟发生时间 $=$ min{以该事件为尾的弧的活动的最迟开始时间}），或min{以该事件为尾的弧所指事件的最迟发生时间与该弧的活动的持续时间之差）。改变AOE网中任何一个活动的持续时间，需要重新计算关键活动，可能导致关键路径的改变。  

25.C  

若改变的是所有关键路径上的公共活动，则不一定会产生不同的关键路径（延长必然不会导致，只有缩短才有可能导致）。根据关键路径的定义，可知选项ⅡI正确。关键路径是源点到终点的最长路径，只有所有关键路径的长度都缩短时，整个图的关键路径才能有效缩短，但也不能任意缩短，一旦缩短到一定程度，该关键活动就可能变成非关键活动。  

26.A  

邻接矩阵第i列值全为o，说明顶点 $i$ 没有入边，为整个工程的开始，若关键路径存在，则该顶点一定是起点。不能确定关键路径是否存在，也不能确定其对应的无向图的连通分量个数。  

27.B  

拓扑排序的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2fd17cb74237decb87b55ddb35fbe175806e2fdd5c49585e7e01c1047e081f09.jpg)  

可以得到3种不同的拓扑序列，即abced，abecd和aebcd。  
28.A  

最小生成树的树形可能不唯一（因为可能存在权值相同的边），但代价一定是唯一的，选项I正确。若权值最小的边有多条并且构成环状，则总有权值最小的边将不出现在某棵最小生成树 中，选项Ⅱ错误。设 $N$ 个结点构成环， $N-1$ 条边权值相等，另一条边权值较小，则从不同的顶点开始 $\operatorname{Prim}$ 算法会得到 $N-1$ 种不同的最小生成树，选项Ⅲ错误。当最小生成树唯一时（各边的权值不同）， $\operatorname{Prim}$ 算法和Kruskal算法得到的最小生成树相同，选项IV错误。  

29.C  

从 $a$ 到各顶点的最短路径的求解过程下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e1d083369e54075c281c4d4de6652df149becbf1ef0a3e632872be29db82818.jpg)  

后续目标顶点依次为f.d, $e$  

本题也可用排除法：对于A，若下一个顶点为 $d$ ，路径 $a_{i}$  $^b$  $d$ 的长度为5，而a,b,c,f的长度仅为4，显然错误。同理可排除选项B。将 $f$ 加入集合 $S$ 后，采用上述方法也可排除选项D。  

# 30. C  

对角线以下元素均为零，表明只有顶点 $i$ 到 $j$ C $i<j)$ 可能有边，而顶点 $j$ 到i一定没有边，即有向图是一个无环图，因此一定存在拓扑序列。对于拓扑序列是否唯一，试举一例：设有向图的邻接矩阵 $\left[\begin{array}{l l l}{0}&{1}&{1}\\ {0}&{0}&{0}\\ {0}&{0}&{0}\end{array}\right]$ 存在两个拓扑序列，因此该图存在可能不唯一的拓扑序列。  

结论：对于任一有向图，若它的邻接矩阵中对角线以下（或以上）的元素均为零，则存在拓扑序列（可能不唯一）。反止，若图存在拓扑序列，却不一定能满足邻接矩阵中主对角线以下的元素均为零，但是可以通过适当地调整结点编号，使其邻接矩阵满足前述性质。  

31.C  

找出AOE网的全部关键路径为bdcg、bdeh和bfh。根据性质，只有当所有关键路径的活动时间同时减少时，才能缩短工期。即正确选项中的路径必须能涵盖所有的关键路径。选项A和B不能涵盖bfh这条路径，选项C不能涵盖bdcg和bdeh这两条路径，只有选项C能涵盖所有关键路径，因此只有加快 $f$ 和 $d$ 的进度才能缩短工期（建议在图中检验）。  

# 32. D  

按照拓扑排序的算法，每次都选择入度为0的结点从图中删除，此图中一开始只有结点3的入度为0；删除结点3后，只有结点1的入度为0；删除结点1后，只有结点4的入度为0；删除结点4后，结点2和结点6的入度都为0，此时选择删除不同的结点，会得出不同的拓扑序列，分别处理完毕后可知可能的拓扑序列为 $3,1,4,2,6,5$ 和 $3,1,4,6,2,5$ ，选 D。  

# 33.C  

从 $V_{4}$ 开始，Kruskal算法选中的第一条边一定是权值最小的( $(V_{1},\,V_{4})$ ，选项B错误。由于 $V_{1}$ 和 $V_{4}$ 已经可达，因此含有 $V_{1}$ 和 $V_{4}$ 的权值为8的第二条边一定符合 $\operatorname{Prim}$ 算法，排除A、D。  

34.C  
第一个顶点和最后一个顶点相同的路径称为回路：序列中顶点不重复出现的路径称为简单路径；回路显然不是简单路径，I错误。稀疏图是边比较少的情况，邻接矩阵存储的空间复杂度为 $O(n^{2})$ ，必将浪费大量的空间，而邻接表存储的空间复杂度为 $O(\,n+e\,)$ ，所以应选用邻接表，ⅡI错误。存在回路的有向图不存在拓扑序列，若拓扑排序输出结束后所余下的顶点都有前驱，则说明只得到了部分顶点的拓扑有序序列，图中存在回路，Ⅲ正确。  

35.B  

根据Dijkstra算法，从顶点1到其余各顶点的最短路径如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b1ee570975fd06919866d013d958d6995eba2e2c6d77d5c3c78ac13ff8afc28.jpg)  

快速解法。依次观察从顶点1到其他顶点的最短路径长度：顶点1到顶点2的最短路径长度为5；顶点1到顶点3的最短路径长度为 $5+2=7$ ：顶点1到顶点4的最短路径长度为11：顶点1到顶点5的最短路径长度为4；顶点1到顶点6的最短路径长度为 $4\,+\,5\,=\,9$ ；最终dist  $[\mathbf{\Lambda}]\!=\!\!\{0,5,7,11,4,9\}$  ，根据dist数组值从小到大选择顶点顺序为  $1,5,2,3,6,4$  

# 36.B  

采用邻接表作为AOV网的存储结构进行拓扑排序，需要对 $n$ 个顶点做进栈、出栈、输出各一次，当处理 $e$ 条边时，需要检测这 $n$ 个顶点的边链表结点，共需要的时间为 $O(n+e)$ 。若采用邻接矩阵作为AOV网的存储结构进行拓扑排序，在处理 $e$ 条边时需对每个顶点检测相应矩阵中的某一行，寻找与它相关联的边，以便对这些边的入度减1，需要的时间代价为 $O(n^{2})$  

【补充】有两种常用的拓扑排序算法：基于BFS的算法和基于DFS的算法。本题未指明采用哪种算法，因此只需验证一种算法即可（说明两种算法在对应条件下的时间复杂度相同）。  

基于BFS的算法的思想：首先找到所有入度为0的结点，将它们加入一个队列，并将它们作为拓扑序列的起始部分：然后依次从队列中取出结点，并删除它们与后继结点的所有边。若某个后继结点的入度变为0，则将它也加入队列，并将它加入拓扑序列，重复这个过程。  

基于DFS的算法的思想：在DFS调用过程中设定一个时间标记，当DFS调用结束时，对各结点计时，进而按结束时间从大到小排序，可以得到一个拓扑序列。  

# 37.D  

拓扑排序每次选取入度为0的结点输出，经观察不难发现拓扑序列前两位一定是1，5或5，1（因为只有1和5的入度均为0，且其他结点都不满足仅有1或仅有5作为前驱）。  

# 38.C  

活动 $d$ 的最早开始时间等于该活动弧的起点所表示的事件的最早发生时间，活动 $d$ 的最早开始时间等于事件2的最早发生时间 $\operatorname*{max}\{a,b+c\}=\operatorname*{max}\{3,12\}=12$ 。活动 $d$ 的最迟开始时间等于该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差，先算出图中关键路径长度为27（对于不复杂的选择题，找出所有路径计算长度），那么事件4的最退发生时间为 $\operatorname*{min}\{27-g\}=\operatorname*{min}\{27-6\}=21$ ，活动 $d$ 的最迟开始时间为 $21\!-\!d=21\!-\!7=\!14$ 一。  
常规方法：按照关键路径算法算得到下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56bcc4f1f6756aaa5f9bd67269099b3a7f259e69c3a75559927b7d70f954a8c3.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f199d1399a50e953a7cf84fb0ada7c0eaf51aac09de82269325351cdd811b855.jpg)  

从表中可知，活动 $d$ 的最早开始时间和最迟开始时间分别为12和14，所以选C。  

# 39.A  

先将该表达式转换成有向二叉树，该二叉树中有些顶点是重复的，为了节省存储空间，去除重复的顶点，将有向二义树去重转换成有向无环图，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/212b218462bd3c21cb929472cb9866503e42aa62e53ef58d89185e96da6a061f.jpg)  

40.A  

Kruskal算法：按权值递增顺序依次选取 $_{n-1}$ 条边，并保证这 $_{n-1}$ 条边不构成回路。初始构造一个仅含 $n$ 个顶点的森林；第一步，选取权值最小的边 $(b,f$ ）加入最小生成树；第二步，剩余边中权值最小的边为 $(b,d$ ），加入最小生成树，第二步操作后权值最小的边 $(d,f$ ）不能选，因为会与之前已选取的边形成回路：接下来依次选取权值9、10、11对应的边加入最小生成树，此时6个顶点形成了一棵树，最小生成树构造完成。按照上述过程，加到最小生成树的边依次为 $(b,f$  $(b,d),(a,e),(c,e),(b,e)$ 。其生成过程如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d92c0bb4e1010180cfab5498139f19295844da3cfdbe11ea5bae0493f511335d.jpg)  
41.B  

根据题干所提供的信息可知：  

$\textcircled{\scriptsize{1}}$ 图 $G$ 为有向无环图，因此一定存在拓扑序列和逆拓扑序列。  

$\circledcirc$ DFS的性质是顶点 $v_{i}$ 的所有后继顶点 $\nu_{j}$ 出栈后， $\nu_{i}$ 才会出栈。  

$\textcircled{3}$ 本题要求执行输出语句后立刻退出递归，即执行完输出语句后立即出栈，因此后进栈的顶点先输出，结合 $\circledcirc$ 不难得出只有输出顶点 $v_{i}$ 的所有后继顶点 $v_{j}$ 后， $v_{i}$ 才会输出。  

综合上述分析，输出的顶点序列是逆拓扑有序序列。  

42.B  

关键路径是指权值之和最大而非边数最多的路径，A错误。选项B是关键路径的概念。无 论是存在一条还是存在多条关键路径，增加任意一个关键活动的时间都会延长工程的工期，因为关键路径始终是权值之和最大的那条路径，C错误。仅有一条关键路径时，减少关键活动的时间会缩短工程的工期；存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径，D错误。  

43. A  

求拓扑序列的过程：从图中选择无入边的结点，输出该结点并删除该结点的所有出边，重复上述过程，直至全部结点都已输出，这样求得的拓扑序列为ABCDEF。每次输出一个结点并删除该结点的所有出边后，都发现有且仅有一个结点无入边，因此该拓扑序列唯一。  

44.C  

在执行Dijkstra算法时，首先初始化dist』，若顶点1到顶点 $i\ (i=2,\,3,\,4,\,5)$ ）有边，就初始化为边的权值；若无边，就初始化为；初始化顶点集  $S$  只含顶点1。Dijkstra算法每次选择一个 到顶点1距离最近的顶点 $j$ 加入顶点集 $S$ ，并判断由顶点1绕行顶点 $j$ 后到任意一个顶点 $k$ 是否距离更短，若距离更短（即 $\mathrm{dist}[j]+\arcs[j][k]<\mathrm{dist}[k]\,)$ ，则将 dist[x]更新为 dist[] $^+$ arcs[][k]；重复该过程，直至所有顶点都加入顶点集 $S_{\circ}$ 数组dist的变化过程如下图所示，可知将第二个顶点5加入顶点集S后，数组dist更新为21,3,14,6。  

45.B  

在AOE网中，活动的时间余量 $=$ 结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的持续时间。根据关键路径算法得到下表：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cf2196f56af2eb2bcc141ea6e9394b99733c7f9d6e445cc9dad0be542fd517b0.jpg)  

c的时间余量 $=\!\nu(3)\!-\!\nu_{e}(2)-1\!=\!5-2-1\!=\!2$ ，g的时间余量 $=\!\nu(6)-\nu_{e}(3)-1=12-5-1=6$ ，h的时间余量 $=\!\nu(5)-\nu_{e}(4)-1=11-8-1=2$ ，j的时间余量 $=\!\nu(6)-\nu_{e}(5)-1=12\!-9-1=2$ 8  

46.B  

$\operatorname{Prim}$ 算法和Kruskal算法用于求解最小生成树，最小生成树中某顶点到其余各顶点的路径不一定具有最短路径的性质。例如，在下图所求得的最小生成树中，a到c的路径长度为2，但原图中a到c的最短路径长度为1。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/45e267869ed4acc552bd57cfb251c668895d9d327d24bba63cf807414b310f12.jpg)  

图的广度优先搜索算法总按距离由近到远来遍历图中的每个顶点，因此可用来求解非带权图（或各边权值均相同）的单源最短路径问题。  

# 二、综合应用题  

01.【解答】  

这种方法是正确的。  

由于经过“破圈法”之后，最终没有回路，因此一定可以构造出一棵生成树。下面证明这棵生成树是最小生成树。记“破圈法”生成的树为T，假设 $T$ 不是最小生成树，则必然存在最小生成树 $T_{0}$ ，使得它与 $T$ 的公共边尽可能多，则将 $T_{0}$ 与 $T$ 取并集，得到一个图，此图中必然存在回路，由于“破圈法”的定义就是从回路中去除权最大的边，因此此时生成的 $T$ 的权必然是最小的，这与原假设矛盾，从而 $T$ 是最小生成树。下图说明了“破圈法”的过程：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28e65480b50c412183861db54ef5344d3a80d792ce5d605b2212227b797687b2.jpg)  

# 02.【解答】  

1）该图的邻接矩阵为  

$$
A={\frac{3}{4}}{\left[\begin{array}{l l l l l l}{1}&{2}&{3}&{4}&{5}&{6}&{7}\\ {0}&{3}&{3}&{6}&{\infty}&{\infty}&{\infty}\\ {\infty}&{0}&{4}&{\infty}&{5}&{\infty}&{\infty}\\ {\infty}&{\infty}&{0}&{\infty}&{4}&{\infty}&{\infty}\\ {\infty}&{\infty}&{\infty}&{0}&{\infty}&{5}&{\infty}\\ {5}&{\infty}&{\infty}&{\infty}&{0}&{\infty}&{3}\\ {6}&{\infty}&{3}&{\infty}&{\infty}&{0}&{7}\\ {7}&{\infty}&{\infty}&{\infty}&{\infty}&{\infty}&{0}\end{array}\right]}
$$  

得到的深度优先遍历序列为 $1,2,3,5,7,4,6,$  

2）解题思路：当某个顶点只有出弧而没有入弧时，其他顶点无法到达这个顶点，不可能与其他顶点和边构成强连通分量（这个单独的顶点构成一个强连通分量）。  

$\textcircled{\scriptsize{1}}$ 顶点1无入弧构成第一个强连通分量。删除顶点1及所有以之为尾的弧。 $\circledcirc$ 顶点2无入弧构成一个强连通分量。删除顶点2及所有以之为尾的弧。  
$\textcircled{3}$  

以此类推，最后得到每个顶点都是一个强连通分量，所以强连通分量数目为7。  

3）该图的两个拓扑序列如下：  

$\textcircled{\scriptsize{1}}$  1,2,4,6,3,5,7 ②1,4,2,6,3,5,7  

4）若视该图为无向图：  

用 $\operatorname{Prim}$ 算法生成最小生成树的过程如下：1—2，1-3，3-6，3-5，5-7，6-4（图略）。用Kruskal算法生成最小生成树的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a88b5f3b18dfebf298354e38e440539a4b0bf43f1d0de9271086610afad2432.jpg)  

# 03.【解答】  

根据Dikstra算法，求从顶点1到其余各顶点的最短路径如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cc7c36b9797f2479b1cb2e54568d40f440bd2bedaca99c55c0b29d9983a46ed.jpg)  

# 04.【解答】  

1）该图的邻接表表示如下图所示  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6d98cfa9ca142c73dc51d838d72012d3fb06dd226c39d7db95fbc1573275f36.jpg)  

求关键路径的算法如下：  

$\textcircled{\scriptsize{1}}$ 输入 $e$ 条弧<i $k^{>}$ ，建立AOE网的存储结构。 $\textcircled{2}$ 从源点 $v_{1}$ 出发，令 $v_{e}(1)\,{=}\,0$ ，求 $v_{e}(j)$ ， $2{\leqslant}j{\leqslant}n$  $\textcircled{3}$ 从汇点 $v_{n}$ 出发，令 $v_{1}(n)=v_{e}(n)$ ，求 $\nu_{\mathrm{l}}(i)$ ， $1\!\leqslant\!i\!\leqslant n\!-\!1$ 。 $\textcircled{4}$ 根据各顶点的 $\nu_{e}$ 和 $v_{1}$ 值，求每条弧 $s$ （活动）的最早开始时间 $e(s)$ 和最晚开始时间I(s)，其中 $e(s)=l(s)$ 为关键活动。  

2）根据以上算法可以得到至少需要时间16。  

3）关键路径为  $(V_{1},V_{3},V_{5},V_{7},V_{9})_{\circ}$  

4）活动 $a_{2},a_{6},a_{9},a_{12}$ 加速，可以缩短工程所需的时间。  

# 05.【解答】  

1）根据题表可以画出AOE网如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/53237128e29e41fb7ef6db32656b88abe417f5a32bf28f732f659e4dbb6cf861.jpg)  

求解各事件和活动的最早发生时间与最迟发生时间公式分别如下：  

$\textcircled{\scriptsize{1}}$ V（源点） $=0$ ，ve（k)=Max{v(）+Weight（y,v)）}，Weight $(v_{j},v_{k})$ 表示从 $v_{j}$ 指向 $v_{k}$ 的弧的权值。  

$\circledcirc$   $\nu_{1}$   $={\nu_{e}}($   $v_{1}(j)=\mathrm{Min}\{v_{1}(k)-\mathrm{Weibt}(v_{j},\,v_{k})\}$   $(v_{j},v_{k})$   $v_{j}$   $v_{k}$  弧的权值。 $\textcircled{3}$ 若边 $\begin{array}{r l}{\lefteqn{<\!\nu_{k},}}&{{}}\end{array}$ v>表示活动 $a_{i}$ ，则有 $e(i)=v_{e}(k)$ 0 $\textcircled{4}$ 若边 $\begin{array}{r}{\mathrm{\Sigma}^{<\nu_{k},~}}\end{array}$ v>表示活动 $a_{i}$ ，则有 $l(i)=v_{1}(j)-\mathrm{Weibull}(v_{k},v_{j})$  $\circledast$   $)~d(i)=l(i)-e(i)\circ$  关键路径即由 $\boldsymbol d(i)=0$ 的 $i$ 构成。  

2）根据上述公式，各事件的最早发生时间 $\boldsymbol{v}_{e}$ 和最迟发生时间 $v_{l}$ 如下表所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/da5c6d62cde32e87b40744b1f6b1a2ec0688fc76c844bc7aedc0fc23cee86a35.jpg)  

3）根据上述公式，各活动最早发生时间e、最迟发生时间 $l$ 和时间余量 $d(i)=l(i)\,{-}\,e(i)$ 如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3a3ea7bca2ef34fc4c5ad1c4d740fe8dd33a2f795ea6fe1d1e0ee828ba4cc8d6.jpg)  

所以关键路径为 $B$ 、 $E$ 、 $G$ ，完成该工程最少需要8（单位依题意而定）。  

06.【解答】  

Diikstra算法每一步都会贪婪地选择与源点 $\nu_{0}$ 最近的下一条边，直到 $v_{0}$ 连接到图中所有顶点。 $\operatorname{Prim}$ 算法（已知是最小生成树算法）与Diikstra算法高度相似，但是在每个阶段，它贪婪地选择与该阶段已加入MST中任意一个顶点最近的下一条边。显然，Dikstra算法可以产生一棵生成树，但该树不一定是最小生成树，只需举出一个反例即可，以下图 $G$ 为例（将a作为源点）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d05a1566d1c8da4ef8df224254808eba76adf3d3deb612f894419835c7831327.jpg)  
(a）图G  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/64f33a9fef4a712f10af18ec2c7de356f42cb82d00698f14af96048d200fa482.jpg)  
(b）两种算法产生的生成树  

Dijkstra算法得到的路径集合为{（a,b).（a,c)，（a,d)}，该生成树的总权值为 $5+5+5=15$  $\operatorname{Prim}$ 算法得到的边集合为{（ad)），（b，d)，（c，d）}，该最小生成树的总权值为 $5+1+1=7.$ 显然，Dijkstra算法得到的生成树不一定是最小生成树。  

# 07.【解答】  

本节前面给出了DFS实现拓扑排序的思想，下面是利用DFS求各顶点结束时间的代码（在DFS的基础上加入了time变量）。将结束时间从大到小排序，即可得到拓扑序列。  

bool visited[MAX VERTEX NUM];/访问标记数组void DF S Traverse(Graph G){ for  $|\mathrm{v}{=}0\rrangle$   $\scriptstyle{\mathrm{~v}}<G$  .vexnum;  $++\mathbf{v}$  1 visited[v] $=$ FALSE;//初始化访问标记数组time  $_{;=0}$  for $\scriptstyle{\sqrt{=}0}$  $\mathrm{w}{<}G$ .vexnum; $++\uptau$ 川/本代码从 $\scriptstyle{\mathrm{~v=0~}}$ 开始遍历if(!visited[v]） DFS(G,v）;void DFS（Graph G,int v)  

visited[v]  $=$  TRUE; visit $(\upnu)$ ；for  $w=$  First Neighbor(G,v);  $w\!>\!=\!0$   $w=$  Next Neighbor（G,V,w))  
if(!visited[w]){ J/w为  $\triangledown$  的尚未访问的邻接点 DFS(G,W);  

time  $=$  time+l;finishTime[v]  $=$  time;  

08.【解答】  

该方法不一定能（或不能）求得最短路径。  

例如，对于下图所示的带权图，若按照题中的原则，从 $A$ 到 $C$ 的最短路径是 $A{\rightarrow}B{\rightarrow}C,$ 事实上其最短路径是  $A{\rightarrow}D{\rightarrow}C$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5b9bdc22e89cd4a2703d5bc77424463c6ccdebc588048a0ec21ea6108cdbda72.jpg)  

09.【解答】  

1）在上三角矩阵A[6][6]中，第1行至第5行主对角线上方的元素个数分别为5，4，3，2,1，由此可以画出压缩存储数组中的元素所属行的情况，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc242faacbd5ff2a4bbb0b3163909ea560bb24dc7d59e94a53c316898cec1c7c.jpg)  

可以用“平移”的思想，将前5个、后4个、后3个、后2个、后1个元素，分别移动到矩阵对角线（“0"）右边的行上。图 $G$ 的邻接矩阵 $_A$ 为  

$$
A\,{=}\,{\left[\begin{array}{l l l l l l}{0}&{4}&{6}&{\infty}&{\infty}&{\infty}\\ {\infty}&{0}&{5}&{\infty}&{\infty}&{\infty}\\ {\infty}&{\infty}&{0}&{4}&{3}&{\infty}\\ {\infty}&{\infty}&{\infty}&{0}&{\infty}&{3}\\ {\infty}&{\infty}&{\infty}&{\infty}&{0}&{3}\\ {\infty}&{\infty}&{\infty}&{\infty}&{\infty}&{0}\end{array}\right]}
$$  

2）有向带权图 $G$ 如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f246a1a9ffa3bac2b4e025337a668ae5b8bb0813a2554b1107fa9fe436c02729.jpg)  

3）先计算各个事件的最早发生时间，得到 $\nu_{e}()$ 和 $v_{I}()$ 数组如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71c45a3721ff64c0c43703c8a63f9a52859a3f6e0ed933bad6dc2f29ddff5454.jpg)  

接下来计算所有活动的最早和最迟发生时间 $e()$ 和70，如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4706f54e80dcf9cfb473b8312eaac94ee44d65b57604d08ac7a8e1aef5852690.jpg)  
满足 $l()\!-\!e()=0$ 的路径就是关键路径，所以关键路径为 $a_{0^{-}1},\,a_{1^{-}2},\,a_{2^{-}3},\,a_{3^{-}5}$ ，如下图所示（双线箭头表示），长度为 $4+5+4+3=16$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d2937832e7c5f605c93a412e766a82ebc26ac38bfd25625b580d09da03b76fa.jpg)  

按求关键路径的公式计算较为复杂，建议考生面临此类题时直接穷举各条路径即可，  

10.【解答】  

本题初看起来感觉难度较大，但仔细分析就可发现考查的其实是邻接表的数据结构  

1）图题中给出的是一个简单的网络拓扑图，可以抽象为无向图。  

2）图的常用存储结构有邻接矩阵法和邻接表法，其中邻接表法属于链式存储结构，因此本题的基本思路就是写出邻接表的数据类型定义，并根据题意调整相应的边表结点和顶点表结点的成员变量。具体分析如下：邻接表由表头顶点和弧顶点组成。根据题目给出的图和表，可将顶点分为三类：路由器、网络和链路。路由器是连接网络和链路的载体，因此可将它作为表头顶点。网络和链路则是连接路由器的边，因此可将它们作为弧顶点。为了简化代码，可将网络和链路的结构合并为一个，用一个标志位来区分它们，这样就可用邻接表来实现图的存储。链式存储结构的如下图所示。  

弧结点的两种基本形态
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7dbfc41c69dca1bf179b1e180bb9e86403e3bda1ff588de297ff127505faa9b7.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bde19f77b71d686ba2f71be0c25d9ec98bd668550d671d4f6d77b054380aac90.jpg)  

其数据类型定义如下：  

typedef struct{ unsigned int ID, IP; )LinkNode;/Link的结构typedef struct{ unsigned int Prefix, Mask; )NetNode;//Net的结构typedef struct Node{ int Flag; //Flag  $^{=1}$  为Link;Flag  $_{=2}$  为Net unionl LinkNode Lnode; NetNode Nnode )LinkORNet; Unsigned int Metric; struct Node \*next; )ArcNode;//弧结点typedef struct hNode unsigned int RouterID; ArcNode \*LN link; Struct hNode \*next; )HNODE; //表头结点  

对应表的链式存储结构示意图如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0011931a93d019337cf4a954057bb753baf0694837d72912f8f90dbba5458bca.jpg)  

3）计算结果如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d329691b5cbd2906f23e4dfc9f6de81c302a8208ade214142e41f4c8799511e.jpg)  

# 11.【解答】  

1）Prim算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中的所有顶点为止。算法的每一步在连接树集合 $S$ 的顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合 $S_{\circ}$ 当算法终止时， $S$ 就是最小生成树。  

$\circledcirc S$ 中顶点为 $A$ ，候选边为 $(A,D),(A,B),(A,E)$ ，选择 ${\mathcal{\mathbf{\ell}}}(A,D)$ 加入 $S$  $({\small\mathscr{Q}})\,S$ 中顶点为 $A,D$ ，候选边为 $(A,B)$  $(A,E),(D,E)$  $(C,D)$ ，选择 $(D,E)$ ，加入 $S$  $\circledcirc S$ 中顶点为 $A,D,E$ ，候选边 $\mathfrak{g}(A,B),(C,D),(C,E)$ ，选择 $(C,E)$ 加入S。 $(\!4\!)\,S$ 中顶点为 $A,D,E,C$ ，候选边为 $(A,B),(B,C)$ ，选择 $(B,C)$ 加入 $S_{\circ}$  $({\mathfrak{S}})\,S$ 就是最小生成树。  

依次选出的边为  

$$
(A,D),(D,E),(C,E),(B,C)
$$  

2）图 $G$ 的MST是唯一的。第一小题的最小生成树包括了图中权值最小的4条边，其他边除 $(A,E)$ 外都比这4条边大，但若用 $(A,E)$ 替换同权值的 $(C,E)$  $A,D,E$ 三个顶点构成了回路，因此不能替换，所以此图的MST唯一。  

3）当带权连通图的任意一个环中所包含的边的权值均不相同时，其MST是唯一的。此题不要求回答充分必要条件，所以回答一个限制边权值的充分条件即可。  

12.【解答】  

1）为了求解最经济的方案，可把问题抽象为求无向带权图的最小生成树。可以采用手动Prim算法或Kruskal算法作图。注意本题的最小生成树有两种构造，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f49f52813183cca54fe6fb810601191af11c959eb18194de436e554832930a1a.jpg)  

方案的总费用为16。  

2）存储题中的图可采用邻接矩阵（或邻接表）。构造最小生成树采用 $\operatorname{Prim}$ 算法（或Kruskal算法）。  

3） $\mathrm{TTL}=5$ ，即IP分组的生存时间（最大传递距离）为5，方案1中TL和BJ的距离过远 $\mathrm{TTL}=5$ 不足以让IP分组从H1传送到H2，因此H2不能收到IP分组。而方案2中TL和BJ邻近，H2可以收到IP分组。  

# 归纳总结  

1.关于图的基本操作  

本章中的很多程序对采用邻接表或邻接矩阵的存储结构都适用，主要原因是在图的基本操作函数中保持了相同的参数和返回值，而封闭了内部实现细节。  

例如，取 $_\mathrm{x}$ 邻接顶点y的下一个邻接顶点的函数NextNeighbor（G，x,y）。  

1）用邻接矩阵作为存储结构  

int Next Neighbor（MGraph& G,int x,int y）{ if  $(\mathbf{x}!=-1$  &&  $\mathsf{y}!\!=\!\!-1$  for(int col=y+l;col<G.vexnum;col++) if（G.Edge[x][col]  ${>}0$  &&G.Edge[x][col]<maxWeight) return col; /max Weight oo return-1;  

2）用邻接表作为存储结构  

int Next Neighbor（ALGraph& G，int x,int y){ if $(\mathbf{x}!=-1)$ /顶点 $_\mathrm{x}$ 存在ArcNode $\star_{\mathsf{P}=\mathsf{G}}$ .vertices[x].first;//对应边链表第一个边结点while（p!=NULL&& p->data!=y)/寻找邻接顶点y $\mathtt{p}^{=}\mathtt{p}^{->}$  next; if（p!=NULL&& p->next！  $=$  NULL) return p->next->data;1/返回下一个邻接顶点return-l;  

2.关于图的遍历、连通性、生成树、关键路径的几个要点  

1）在执行图的遍历时，因为图中可能存在回路，且图的任意一个顶点都可能与其他顶点相连，所以在访问完某个顶点后可能会沿某些边又回到了曾经访问过的顶点。因此，需要设置一个辅助数组visited[]标记顶点是否已被访问过，避免重复访问。  
2）深度优先搜索时利用回溯法对图遍历，一般利用递归方法实现，每当向前递归查找某一邻接结点之前，必须判断该结点是否访问过。另外，递归算法均可借助栈来实现非递归算法，深度优先搜索也不例外，具体程序见6.3.4节的综合应用题03。3）广度优先搜索是一种分层的遍历过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。因此，它不是一个递归的过程。4）一个给定的图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入先后次序不同，则生成的邻接表表示也不同。5）图的最小生成树首先必须是带权连通图，其次要在 $n$ 个顶点的图中选择 $n\!-\!1$ 条边将其连通，使得其权值总和达到最小，且不出现回路。6）加速某一关键活动不一定能缩短整个工程的工期，因为AOE网中可能存在多条关键路径。可能存在称为“桥”的一种特殊关键活动，它位于所有的关键路径上，只有它加速才会缩短整个工期。  

# 思维拓展  

【网易有道笔试题】求一个无向连通图的割点。割点的定义是，若除去此结点和与其相关的边，无向图不再连通，描述算法。  

提示：要判断一个点是否为割点，最简单直接的方法是，先把这个点和所有与它相关的边从图中去掉，再用深搜或广搜来判断剩下的图的连通性，这种方法适合判断给定结点是否为割点；还有一种比较复杂的方法可以快速找出所有割点，有兴趣的读者可自行搜索相关资料。  
# 第7章查找  

# 【考纲内容】  

（一）查找的基本概念（二）顺序查找法（三）分块查找法（四）折半查找法（五）树形查找二叉搜索树：平衡二叉树：红黑树（六）B树及其基本操作、 $^{\mathrm{B+}}$ 树的基本概念（七）散列（Hash）表（八）查找算法的分析及应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/04bba28557f8de0f60708124edff3cf56401157743f882b68284dea1f7097c04.jpg)  

【复习提示】  

本章是考研命题的重点。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找长度等。对于二叉排序树、二叉平衡树和红黑树，要了解它们的概念、性质和相关操作等。B树 和 $^{\mathrm{B+}}$ 树是本章的难点。对于B树，考研大纲要求掌握插入、删除和查找的操作过程；对于 $^{\mathrm{B+}}$ 树仅要求了解其基本概念和性质。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。  

# 7.1查找的基本概念  

1）查我。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分  
为两种：一是查我成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。  

2）查找表。用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。对查找表的常见操作有： $\textcircled{\scriptsize{1}}$ 查询符合条件的数据元素： $\circledcirc$ 插入、删除数据元素。  

3）静态查找表。若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地插入或删除的查找表称为动态查找表。适合静态查我表的查我方法有顺序查找、折半查找、散列查我等：适合动态查找表的查我方法有二叉排序树的查找、散列查找等。  

4）关键字。数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。  

5）平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查我长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为  

$$
\mathrm{ASL}=\sum_{i=1}^{n}P_{i}C_{i}
$$  

式中， $n$ 是查找表的长度； $P_{j}$ 是查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_{i}=1/n$ ； $C_{i}$ 是找到第 $i$ 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。  

# 7.2 顺序查找和折半查找  

# 7.2.1 顺序查找  

顺序查找又称线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素：对于链表，可通过指针next来依次扫描每个元素。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。下面分别进行讨论。  

# 1.一般线性表的顺序查找  

作为一种最直观的查找方法，其基本思想： $\textcircled{\scriptsize{1}}$ 从线性表的一端开始，逐个检查关键字是否满足给定的条件； $\circledcirc$ 若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置； $\textcircled{3}$ 若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。下面给出其算法，后面说明了算法中引入的“哨兵”的作用。  

typedef struct{//查找表的数据结构（顺序表）ElemType \*elem;/动态数组基址int TableLen;/表的长度)SSTable; int Search_Seq(SSTable ST,ElemType key){ ST.elem[0]=key; Ⅱ“哨兵” for(int  $\scriptstyle{\mathrm{i}}={\mathrm{ST}}$  .TableLen;ST.elem[i]  $!=\!\kappa$  ey;--i); //从后往前找 returni；//若查找成功，则返回元素下标；若查找失败，则返回0  

上述算法中，将ST.elem[O]称为哨兵，引入它的目的是使得Search_Seq内的循环不必判断数组是否会越界。算法从尾部开始查找，若找到ST.elem[i] $==$ key则返回i值，查找成功。否则一定在查找到sT.elem $\left[\,0\,\right]=$ key时跳出循环，此时返回的是0，查找失败。在程序中引入“哨兵”，可以避免很多不必要的判断语句，从而提高程序效率。  
对于有 $n$ 个元素的表，给定值key与表中第 $i$ 个元素相等，即定位第 $i$ 个元素时，需进行 $n\!-\!i\!+\!1$ 次关键字的比较，即 $C_{i}\!=\!n\!-\!i\!+\!1$ 。查找成功时，顺序查找的平均长度为  

$$
\operatorname{ASL}_{\mathfrak{h}(n;i)}=\sum_{i=1}^{n}P_{i}(n-i+1)
$$  

当每个元素的查找概率相等，即 $P_{i}=1/n$ 时，有  

$$
\operatorname{PSL}_{n|k\rangle n|}{=}{\sum_{i=1}^{n}P_{i}(n-i+1)}={\frac{n+1}{2}}
$$  

查找不成功时，与表中各关键字的比较次数显然是 $n+1$ 次，即ASL $\kappa_{\hat{\imath}\hat{\imath}\hat{\jmath}}=n+1$  

通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由大至小重新排列。  

综上所述，顺序查找的缺点是当 $n$ 较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对链表只能进行顺序查找。  

# 2.有序线性表的顺序查找  

若在查找之前就已知表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低查找失败的平均查找长度。假设表 $L$ 是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key，当查找到第 $i$ 个元素时，发现第 $i$ 个元素的关键字小于key，但第 $i+1$ 个元素的关键字大于key，这时就可返回查找失败的信息，因为第 $i$ 个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。  

# 命题追踪有序线性表的顺序查找的应用（2013）  

可以用如图7.1所示的判定树来描述有序线性表的查找过程。树中的圆形结点表示有序线性表中存在的元素；矩形结点称为失败结点（若有 $n$ 个结点，则相应地有 $n+1$ 个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到矩形结点，则说明查找失败。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b9a556e5c788039f2fe0a08be26af8476e380c1fcd30a762adcbe9951bfa13c7.jpg)  
图7.1有序顺序表上的顺序查找判定树  

在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为  

$$
\operatorname{ASL}_{\mathcal{K}:n\times l}=\!\!\sum_{j=1}^{n}q_{j}(l_{j}-1)\!=\!\frac{1\!+2\!+\!\cdots\!+n\!+\!n}{n\!+\!1}\!=\!\frac{n}{2}\!+\!\frac{n}{n\!+\!1}
$$  
式中， $q_{j}$ 是到达第 $j$ 个失败结点的概率，在相等查找概率的情形下，它为 $1/(n+1)$  $l_{j}$ 是第 $j$ 个失败结点所在的层数。当 $n=6$ 时，ASL $\kappa_{i i k x h}=6/2+6/7=3.86$ ，比一般的顺序查找好一些。  

注意，有序线性表的顺序查找和后面的折半查找的思想是不一样的，且有序线性表的顺序查找中的线性表可以是链式存储结构，而折半查找中的线性表只能是顺序存储结构。  

# 7.2.2 折半查找  

折半查找又称二分查找，它仅适用于有序的顺序表。  

# 分析对比给定查找算法与折半查找的效率（2016）  

折半查找的基本思想： $\textcircled{\scriptsize{1}}$ 首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置； $\circledcirc$ 若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若key大于中间元素，则所查找的元素只可能在后半部分），然后在缩小的范围内继续进行同样的查找。重复上述步骤，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。算法如下：  

int Binary Search(SSTable L,ElemType key){ int low  $=\!0$  ,high  $\mathbf{\mu=}\mathbb{L}$  .TableLen-l,mid; while(low  $<=$  high){ mid=（low+high)/2;/取中间位置if(L.elem[mid]  $\scriptstyle==\mathrm{kg}$  return mid;//查找成功则返回所在位置elseif(L.elem[mid]>key) high=mid-1;I/从前半部分继续查找else low=mid+1;//从后半部分继续查找return //查找失败，返回-1  

当折半查找算法选取中间结点时，既可以采用向下取整，又可以采用向上取整。但每次查找的取整方式必须相同，这部分内容请读者结合本题部分习题来理解。  

# 命题追踪折半查找的查找路径的判断（2015）  

例如，已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}，要查找值为11和32的元素，指针1ow和high分别指向表的下界和上界，mid则指向表的中间位置L（low+high）/2」。  

下面来说明查找11的过程（查找32的过程请读者自行分析）  

710 13 16 19 2932 3337 41 43 ↑low ↑mid ↑high  

第一次查找时，将中间位置元素与key比较。因为 $11<29$ ，说明待查元素若存在，则必在范围[low,mid-1]内，high mid-1，high=mid- $\cdot{}^{1}{=}5$ ，mid=(1+5)/ $^{\prime}2{=}3$ ，第二次查找范围为[1,5] 。  

7 10 13 16 1929 32 33 3741 43 ↑low ↑mid ↑high  

第二次查找时，将中间位置元素与key比较。因为 $11<13$ ，说明待查元素若存在，则必在范围[low,mid-1]内，high mid-1，high=mid- $^{\cdot1=2}$ ，mid $\scriptstyle=$ (1+2) $^{\prime}2{=}1$ ，第三次查找范围为[1,2]。  

7 10 13 16 19 29 32 33 3741 43 low↑ ↑high mid↑  
第三次查找时，将中间位置元素与key比较。因为 $11>7$ ，说明待查元素若存在，则必在范围[mid $^{+1}$ ,high]内。令low=mid $_{+1=2}$ ,mid $=\left(2\!+\!2\right)/2\!=\!2$ ，第四次查找范围为[2，2]。  

第四次查找，此时子表只含有一个元素，且 $10\neq11$ ，所以表中不存在待查元素。  

# 命题追踪分析给定二叉树树形能否构成折半查找判定树（2017）  

折半查找的过程可用图7.2所示的二叉树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值：树中最下面的叶结点都是方形的，它表示查找失败的区间。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查我失败时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左子结点值，且均小于其右子结点值。若有序序列有 $n$ 个元素，则对应的判定树有 $n$ 个圆形的非叶结点和 $n+1$ 个方形的叶结点。显然，判定树是一棵平衡二叉树（见7.3.2节）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a3c13d8b6e09e2161cf91b26befcb36e69ca849ba58fb230483c6eaa214215f5.jpg)  
图7.2描述折半查找过程的判定树  

# 命题追踪折半查找的最多比较次数的分析（2010、2023）  

由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为  

$$
\mathrm{ASL}={\frac{1}{n}}\sum_{i=1}^{n}l_{i}={\frac{1}{n}}(1\times1+2\times2+\cdots+h\times2^{h-1})={\frac{n+1}{n}}\log_{2}(n+1)-1\approx\log_{2}(n+1)-1
$$  

式中， $h$ 是树的高度，并且元素个数为 $n$ 时树高 $h=\lceil\log_{2}(n+1)\rceil,$ 。所以，折半查找的时间复杂度为 $O(\log_{2}n)$ ，平均情况下比顺序查找的效率高。  

在图7.2所示的判定树中，在等概率情况下，查找成功（圆形结点）的 $\mathrm{ASL}=(1{\times}1+2{\times}2+3{\times}4+$  $4{\times}4)/11=3$ ，查找失败（方形结点）的 $\mathrm{ASL}=(3{\times}4+4{\times}8)/12=11/3.$  

因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。  

# 7.2.3 分块查找  

分块查我又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。  

分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找。 例如，关键码集合为88,24,72,61,21,6,32,11，8,31,22,83,78,54}，按照关键码值24,54,7888，分为4个块和索引表，如图7.3所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76ded7a7f7a5d8bfa95e7e4f016ef281090b1deb3b0fa15e348952f286083f80.jpg)  
图7.3分块查找示意图  

分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为 $L_{1}$ 和 $L_{S}$ ，则分块查找的平均查找长度为  

$$
\mathrm{ASL}=L_{1}+L_{S}
$$  

将长度为 $n$ 的查找表均匀地分为 $^b$ 块，每块有 $s$ 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为  

$$
{\mathrm{ASL}}=L_{1}+L_{s}={\frac{b+1}{2}}+{\frac{s+1}{2}}={\frac{s^{2}+2s+n}{2s}}
$$  

此时，若  $s={\sqrt{n}}$  ，则平均查找长度取最小值  ${\sqrt{n}}+1$  

虽然索引表占用了额外的存储空间，索引查找也增加了一定的系统开销，但由于其分块结构，使得在块内查找时的范围较小，因此与顺序查找相比，分块查找的总体效率提升了不少。  

# 7.2.4 本节试题精选  

# 一、单项选择题  

01.顺序查找适合于存储结构为（）的线性表。  

A.顺序存储结构或链式存储结构B.散列存储结构C.索引存储结构D.压缩存储结构  

02.由 $n$ 个数据元素组成的两个表：一个递增有序，一个无序。采用顺序查找算法，对有序表从头开始查找，发现当前元素已不小于待查元素时，停止查找，确定查找不成功，已知查找任意一个元素的概率是相同的，则在两种表中成功查找（）  

A.平均时间后者小B.平均时间两者相同C.平均时间前者小D.无法确定  

03.对长度为 $n$ 的有序单链表，若查找每个元素的概率相等，则顺序查找表中任意一个元素的查找成功的平均查找长度为（）  

A.n/2 B.  $(n+1)/2$  C.  $(n-1)/2$  D.n/4  

04.对长度为3的顺序表进行查找，若查找第一个元素的概率为1/2，查找第二个元素的概率为1/3，查找第三个元素的概率为1/6，则查找任意一个元素的平均查找长度为（）。  

A.5/3 B.2 C.7/3 D.4/3 05.下列关于二分查找的叙述中，正确的是（）  
A.表必须有序，表可以顺序方式存储，也可以链表方式存储B.表必须有序且表中数据必须是整型、实型或字符型C.表必须有序，而且只能从小到大排列D.表必须有序，且表只能以顺序方式存储  

06.在一个顺序存储的有序线性表上查找一个数据时，既可以采用折半查找，也可以采用顺序查找，但前者比后者的查找速度（）。  

A.必然快 B.取决于表是递增还是递减 C.在大部分情况下要快D.必然不快  

07.折半查找过程所对应的判定树是一棵（）  

A.最小生成树 B.平衡二叉树 C.完全二叉树 D.满二叉树  

08.折半查找和二叉排序树的时间性能（）  

A.相同B.有时不相同C.完全不同D.无法比较  

09.在有11个元素的有序表 $\mathbb{A}\left[1,2,\cdots,11\right]$ 中进行折半查找（L（low+high）/2），查找元素A[11]时，被比较的元素下标依次是（）。  

A.6,8,10,11 B.6,9,10,11 C.6,7,9,11 D.6,8,9,11  

10.已知有序表（13,18,24,35，47,50,62，83,90,115，134），当二分查找值为90的元素时，查找成功的元素比较次数为（）。  

A.1 B.2 C.4T D.6  

11.若有序表的关键字序列为 $\{b,c,d,e,f,g,q,r,s,t\}$ ，则在二分查找关键字 $b$ 的过程中，进行比较的关键字依次为（）。  

A.  $f,c,b$  B.  $f,d,b$  C.  $g,c,b$  D. g,d, b

 12.对表长为 $n$ 的有序表进行折半查找，其判定树的高度为（）A.  $\lceil\log_{2}(n+1)\rceil$  B.  $\lfloor\log_{2}(n+1)\rfloor-1$  C.[log2n] D.[log2n]-1  

13.已知一个长度为16的顺序表，其元素按关键字有序排列，若采用折半查找算法查找一个不存在的元素，则比较的次数至少是（），至多是（）  

A.4 B.5 C.6 D.7  

14.具有12个关键字的有序表中，对每个关键字的查找概率相同，折半查找算法查找成功的平均查找长度为（），折半查找查找失败的平均查找长度为（）。  

A.37/12 B.35/12 C.39/13 D.49/13

 15.下列关于查找的说法中，正确的是（）。（注，涉及下节内容）  

A.若数据元素保持有序，则查找时就可以采用折半查找法B.折半查找与二叉查找树的时间性能在最坏情况下是相同的C.折半查找法的平均查找长度一定小于顺序查找法D.折半查找法查找一个元素大约需要 $O(\log_{2}\!n)$ 次关键字比较  

16.采用分块查找时，数据的组织方式为（）  

A.数据分成若干块，每块内数据有序B.数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块C.数据分成若干块，每块内数据有序，每块内最大（或最小）的数据组成索引块D.数据分成若干块，每块（除最后一块外）中数据个数需相同  
17.对有2500个记录的索引顺序表（分块表）进行查找，最理想的块长为（）  

A.50 B.125 C.500 D.  $\lceil\log_{2}2500\rceil$  

18.设顺序存储的某线性表共有123个元素，按分块查找的要求等分为3块。若对索引表采 用顺序查找法来确定子块，且在确定的子块中也采用顺序查找法，则在等概率情况下，分块查找成功的平均查找长度为（）  

A.21 B.23 C.41 D.62  

19.为提高查找效率，对有65025个元素的有序顺序表建立索引顺序结构，在最好情况下查找到表中已有元素最多需要执行（）次关键字比较。  

A.10 B.14 C.16 D.21  

20.【2010统考真题】已知一个长度为16的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个 $L$ 中不存在的元素，则关键字的比较次数最多是（）。  

A.4 B.5 C. 6 D.7

 21.【2015统考真题】下列选项中，不能构成折半查找中关键字比较序列的是（）  

A.500,200,450,180 B.500,450,200,180 C.180,500,200,450 D.180,200,500,450  

22.【2016统考真题】在有 $n$  $n>1000$ ）个元素的升序数组A中查找关键字X。查找算法的伪代码如下所示。  

$\kappa{=}0$  while  $(\kappa{<}\mathrm{n}$  且  $\mathbb{A}\left[\mathbb{k}\right]\!<\!\mathrm{x}$   $\scriptstyle{k=k+3}$  if $\mathrm{/}\kappa\mathrm{<}\mathrm{n}$ 且 $\mathtt{A}\left[\mathtt{k}\right]==\mathtt{x},$ ）查找成功；elseif $\uparrow\downarrow\!\!k\!-\!\!1\!<\!\!\mathrm n$ 且 $\mathbb{A}\left[k{-}1\right]==$ ）查找成功：elseif $\gamma_{\kappa-2<n}$ 且 $\mathtt{A}\left[\mathtt{k}\!-\!2\right]\mathrm{==}\mathtt{x}$ ）查找成功；else查找失败；  

本算法与折半查找算法相比，有可能具有更少比较次数的情形是（）。  

A.当x不在数组中 B.当  $_\mathrm{x}$  接近数组开头处 C.当 $_\mathrm{x}$ 接近数组结尾处D.当 $_\mathrm{x}$ 位于数组中间位置  

23.【2017统考真题】下列二叉树中，可能成为折半查找判定树（不含外部结点）的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c13950ab9fd4df6cf068579f50b852ff0a022f97e4be3f907048e120b0626ebc.jpg)  

24.【2023统考真题】对含600个元素的有序顺序表进行折半查找，关键字间的比较次数最 多是（）。  

A.9 B.10 C.30 D.300  

# 二、综合应用题  

01.若对有 $n$ 个元素的有序顺序表和无序顺序表进行顺序查找，试就下列三种情况分别讨论两者在相等查找概率时的平均查找长度是否相同。  

1）查找失败。2）查找成功，且表中只有一个关键字等于给定值k的元素。3）查找成功，且表中有若干关键字等于给定值 $\boldsymbol{\mathrm{k}}$ 的元素，要求一次查找能找出所有元素。  
02.有序顺序表中的元素依次为017,094,154,170,275,503,509,512,553,612,677,765,897,908。1）试画出对其进行折半查找的判定树。2）若查找275或684的元素，将依次与表中的哪些元素比较？3）计算查找成功的平均查找长度和查找不成功的平均查找长度。  

03.已知一个有序顺序表A[0...8n-1]的表长为8n，并且表中没有关键字相同的数据元素。假设按下述方法查找一个关键字值等于给定值X的数据元素：首先在 $\mathtt{A}\left[\,7\,\right],\mathtt{A}\left[\,15\,\right],\mathtt{A}\left[\,23\,\right],\cdots,\mathtt{A}\left[\,8\,\mathtt{k}{-1}\,\right],\cdots,\mathtt{A}\left[\,8\,\mathtt{n}{-1}\,\right]$ 中进行顺序查找，若查找成功，则算法报告成功位置并返回；若不成功，则当 $\mathbb{A}\left[8\,\mathsf{k}\!-\!\mathbb{1}\right]\!<\!\!\mathsf{X}\!\!<\!\!\mathbb{A}\left[8\times\left(\mathsf{k}\!+\!\mathbb{1}\right)-\!\mathbb{1}\right]$ 时，可确定一个缩小的查找范围 $\mathbb{A}\left[8\,\mathtt{k}\right]{\sim}\mathbb{A}\left[8\times\left(\mathtt{k}\!+\!1\right)\!-\!2\right]$ ，然后可在这个范围内执行折半查找。特殊情况：若 $\mathrm{X}{>}\mathtt{A}\left[\,8\mathrm{n}{-}1\,\right]$ 的关键字，则查找失败。1）画出描述上述查找过程的判定树。2）计算相等查找概率下查找成功的平均查找长度。  

04.写出折半查找的递归算法。初始调用时，1ow为1，high为ST.length  

05.线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱结点（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。  

06.已知一个 $n$ 阶矩阵 $_A$ 和一个目标值 $k_{\circ}$ 该矩阵无重复元素，每行从左到右升序排列，每列从上到下升序排列。请设计一个在时间上尽可能高效的算法，判断矩阵中是否存在目标值 $k_{\circ}$ 例如，矩阵为 $\begin{array}{r}{\left[\begin{array}{l l l}{1}&{4}&{7}\\ {2}&{5}&{8}\\ {3}&{6}&{9}\end{array}\right]}\end{array}$ ，目标值为8，判断存在。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明你的算法的时间复杂度和空间复杂度。  

07.【2013统考真题】设包含4个数据元素的集合 $S=\{\mathrm{d}\mathrm{o}^{\prime}$ ,'for','repeat'，'while'}，各元素的查找概率依次为 $p_{1}=0.35,p_{2}=0.15,p_{3}=0.15,p_{4}=0.35.$ 将 $S$ 保存在一个长度为4的顺序表中，采用折半查找法，查找成功时的平均查找长度为2.2。  

1）若采用顺序存储结构保存 $S$ ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？  

2）若采用链式存储结构保存 $S$ ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？  

# 7.2.5 答案与解析  

# 一、单项选择题  

01.A  

顺序查找是指从表的一端开始向另一端查找。它不要求查找表具有随机存取的特性，可以是顺序存储结构或链式存储结构。  

02.B 对于顺序查找，不管线性表是有序的还是无序的，成功查找第一个元素的比较次数为1，成功查找第二个元素的比较次数为2，以此类推，即每个元素查找成功的比较次数只与其位置有关（与是否有序无关），因此查找成功的平均时间两者相同。  
03.B  

在有序单链表上做顺序查找，查找成功的平均查找长度与在无序顺序表或有序顺序表上做顺序查找的平均查找长度相同，都是 $(n+1)/2$  

04.A  

在长度为3的顺序表中，查找第一个元素的查找长度为1，查找第二个元素的查找长度为2，查找第三个元素的查找长度为3，所以有  

$$
\operatorname{PSL}_{\vec{n}\times\vec{n}}{=}\frac{1}{2}{\times}1{+}\frac{1}{3}{\times}2{+}\frac{1}{6}{\times}3=\frac{5}{3}
$$  

05.D  

二分查找通过下标来定位中间位置元素，所以应采用顺序存储，且二分查找能够进行的前提是查找表是有序的，但具体是从大到小还是从小到大的顺序则不做要求。  

06. C  

折半查找的快体现在一般情况下，在大部分情况下要快，但是对于某些特殊情况，顺序查找可能会快于折半查找。例如，查找一个含1000个元素的有序表中的第一个元素时，顺序查找的比较次数为1次，而折半查找的比较次数却将近10次。  

07.B  

A显然排除。对于选项C，考点精析示例中的判定树就不是完全二叉树。由选项C也可排除选项D，且满二叉树对结点数有要求。只可能选B。事实上，由折半查找的定义不难看出，每次把一个数组从中间结点分割时，总是把数组分为结点数相差最多不超过1的两个子数组，从而使得对应的判定树的两棵子树高度差的绝对值不超过1，所以应是平衡二义树。  

08.B  

折半查找的性能分析可以用二叉判定树来衡量，平均查找长度和最大查找长度都是 $O(\log_{2}n)$ 二叉排序树的查找性能与数据的输入顺序有关，最好情况下的平均查找长度与折半查找相同，但最坏情况即形成单支树时，其查找长度为 $O(n)$  

09.B  

依据折半查找算法的思想，第一次mid=L（ $_{1+11}$ )/2 ${\it\Delta\phi}=6{\it\Delta\Psi}$ ，第二次 $\begin{array}{r}{\mathrm{mid}\;\mathrm{mid}=\left\lfloor\left(6\!+\!1\right)\!+\!11\right\rfloor/2\right\rfloor=\!9}\end{array}$ 第三次 $\mathsf{m i d}\!=\!\!\big\lfloor\,\left(\,9\!+\!1\right)\!+\!11\,\big\rceil\,/2\,\big\big\rfloor\!\!=\!\!\!10$ ，第四次mid $=\mathbb{1}$  

10.B  

开始时1ow指向13，high指向134，mid指向50，比较第一次 $90>50$ ，所以将1ow指向62，high指向134，mid指向90，第二次比较找到90。  

11. A  

在折半查找算法中，mid取值的方式是确定的，要么采用向上取整，要么采用向下取整，而不能出现两种情况。对于A，第1次比较的元素是f，为向下取整；第2次比较的元素是 $c$ ，为向下取整；第3次比较的元素是 $b$ ，为向下取整，查找成功，符合二分查找。对于B，第1次比较的元素是f为向下取整；第2次比较的元素是 $d$ ，为向上取整，两次mid取值的方式不同，不符合二分查找。对于C，第1次比较的元素是 $g$ ，为向上取整；第2次比较的元素是 $^c$ ，为向下取整，不符合二分查找。对于D，第1次比较的元素是 $g$ ，为向上取整；第2次比较的元素是 $d$ 为正中间元素；第3次比较的元素为 $b$ ，为向下取整，不符合二分查找。  

12.A  

对  $n$  个结点的判定树，设结点总数  $n=2^{h}-1$  ，则  $h=\lceil\log_{2}(n+1)\rceil_{\circ}$  
另解：特殊值代入法。直接将 $n=1$ 和 $n=2$ 的情况代入，仅有A满足要求。  

13.A、B  

对于此类题，有两种做法：一种方法是，画出查找过程中构成的判定树，让最小的分支高度对应于最少的比较次数，让最大的分支高度对应于最多的比较次数，出现类似于长度为15的顺序表时，判定树刚好是一棵满树，此时最多比较次数与最少比较次数相等；另一种方法是，直接用公式求出最小的分支高度和最大分支高度，从前面的讲解不难看出最大分支高度为 $H\!=\!\!\lceil\log_{2}(n+1)\rceil\!\!=\!5$ ，这对应的就是最多比较次数，然后由于判定树不是一棵满树，所以至少应该是4（由判定树的各分支高度最多相差1得出）。  

注意，若是求查找成功或查找失败的平均查找长度，则需要画出判定树进行求解。此外，对长度为 $n$ 的有序表，采用折半查找时，查找成功和查找失败的最多比较次数相同，均为 $\lceil\log_{2}(n+1)\rceil,$  

14.A、D  

假设有序表中元素为A[0...11]，不难画出对它进行折半查找的判定树如下图所示，圆圈是查找成功结点，方形是虚构的查找失败结点。从而可以求出查找成功的 $\mathrm{ASL}=(1+2{\times}2+3{\times}4+4{\times}5)/12=$ 37/12，查找失败的 $\mathrm{ASL}=(3{\times}3+4{\times}10)/13$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d62638414a41c9d2f61f21d04880497f33ac6a96f5789b84f1a19767ff1dbd1.jpg)  

> attention:  

对于本类题目，应先根据所给 $n$ 的值，画出如上图所示的折半查找判定树。另外，查找失败结点的ASL不是到图中的方形结点，而是到方形结点上一层的圆形结点。  

15.D  

折半查找法不仅要求数据元素有序，而且要求必须为顺序存储，A错误。折半查找法在最坏情况下的时间性能为 $O(\log_{2}n)$ ，二叉查找树在最坏情况下的时间性能为 $O(n)$ ，B错误。在每个元素查找概率不同的情况下，折半查找法的平均查找长度可能大于顺序查找法， $\mathrm{^C}$ 错误。  

16.B  

通常情况下，在分块查找的结构中，不要求每个索引块中的元素个数都相等。  

17. A  

设块长为 $b$ ，索引表包含 $n/b$ 项，索引表的 $\mathrm{ASL}=(n/b+1)/2$ ，块内的 $\mathrm{ASL}\,{=}\,(b+1)/2$ ，总 $\mathrm{{SL}}=$ 索引表的ASL $^+$ 块内的 $\mathrm{ASL}=(b+n/b+2)/2$ ，其中对于 $b+n/b$ ，由均值不等式知 $b=n/b$ 时有最小值，此时 $b\!=\!\sqrt{n}$ 。则最理想块长为 $\sqrt{2500}=50$ 。  

18.B  

根据公式 ${\mathrm{ASL}}=L_{1}+L_{s}={\frac{b+1}{2}}+{\frac{s+1}{2}}={\frac{s^{2}+2s+n}{2s}}$ ，其中 $b=n/s,s=123/3,n=123$ ，代入不难得出ASL为23。所以选B。另一方面，可根据穷举法来一步步模拟。对于A块中的元素，查找过程的第一步是先找到A块，由于是顺序查找，找到A块只需一步，然后在A块中顺序查找。因此，A块内各元素查找长度分别为 $2,3,4,\cdots,42$ 。对于B块，采用类似的方法，但查找到B块要比查找到A块多一步，因此B块内各元素查找长度为 $3,4,5,\cdots,43$ 。同理，C块中各个元素查找长度为 $4,5,6,\cdots$ 44。所以平均查找长度为（2+3+4+...+42+3+4+5+..+43+4+5+6+..+44）/123=23。  
19.C  

为使查找效率最高，每个索引块的大小应是 $\sqrt{65025}{=}255$ ，为每个块建立索引，则索引表中索引项的个数为255。若对索引项和索引块内部都采用折半查找，则查找效率最高，为 $\left\lceil\log_{2}(255\!+\!1)\right\rceil+$  $\left\lceil\log_{2}(255\!+\!1)\right\rceil\!=\!16\,\mathrm{.}$  

20.B  

折半查找法在查找不成功时和给定值进行关键字的比较次数最多为树的高度，即 $\scriptstyle\log_{2}n\rfloor+1$ 或 $\mathrm{log}_{2}(n+1)\lceil,$ 在本题中， $n=16$ ，所以比较次数最多为5。  

> attention:  

在折半查找判定树中的方形结点是虚构的，它不计入比较的次数。  

21.A  

画出查找路径图，因为折半查找判定树是一棵二叉排序树，看其是否满足二叉排序树的要求。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/208fba8f531d9f042b4bb575f0d21b6def06133281f5bff8ae5b6d8e47a0c4e4.jpg)  

显然，选项A的查找路径不满足。  

22.B  

本题为送分题。该程序采用跳跃式的顺序查找法查找升序数组中的x。显然， $_\mathrm{x}$ 越靠前，比较次数越少。  

23.A  

对于给定的一个有序查找表，其对应的折半查找判定树是确定且唯一的。7.2.2节描述的折半查找算法中，mid $\bar{-}$ L（low+high）/2]，因此若表中初始有 $2n+1$ 个元素，则mid分割后，左右子树各有 $n$ 个元素；若表中初始有 $2n$ 个元素，则mid分割后，左子树有 $n-1$ 个元素，右子树有 $n$ 个元素。即左子树的元素个数或者与右子树的元素个数相等，或者比右子树少一个。若令mid $\bar{=}$ 1（low+high）/2|，不难理解，左子树的元素个数或者与右子树的元素个数相等，或者比右子树多一个。选项A，树中每个左子树都与右子树的结点个数相等，或者多一个结点，符合向上取整的规则。选项B、C、D，存在有的左子树比右子树多一个结点，有的左子树比右子树少一个结点，不符合折半查找的规则。  

24.B  

用折半查找法查找给定值的比较次数最多不超过折半查找判定树的高度。折半查找判定树 的树高 $h=\lceil\log_{2}(n+1)\rceil$ ，将 $n=600$ 代入，结果为10。  
# 二、综合应用题  

01.【解答】  

1）平均查找长度不同。因为有序顺序表查找到其关键字值比要查找值大的元素时就停止查找，并报告失败信息，不必查找到表尾：而无序顺序表必须查找到表尾才能确定查找失败。  

2）平均查找长度相同。两者查找到表中元素的关键字值等于给定值时就停止查找  

3）平均查找长度不同。有序顺序表中关键字相等的元素相继排列在一起，只要查找到第一个就可以连续查找到其他关键字相同的元素。而无序顺序表必须查找全部表中的元素才能找出相同关键字的元素，因此所需的时间不同。  

02.【解答】  

1）判定树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76e322a28944433e37007a894880a99a516312625dc2efc436b3c5c8f3b0d2f6.jpg)  

2）若查找275，依次与表中元素509.154.275进行比较，共比较3次。若查找684，依次与 表中元素509，677，897，765进行比较，共比较4次。  

3）在查找成功时，会找到图中的某个圆形结点，其平均查找长度为  

$$
\operatorname{PSL}_{n\!\!k\!\times\!\!j_{l}}=\frac{1}{14}\sum_{i=1}^{14}C_{i}=\frac{1}{14}(1+2\times2+3\times4+4\times7)=\frac{45}{14}
$$  

在查找失败时，会找到图中的某个方形结点，但这个结点是虚构的，最后一次的比较元素为其父结点（圆形结点），所以其平均查找长度为  

$$
\mathrm{ASL}_{\mathbb{K}^{n}\mathbb{K}^{n}}={\frac{1}{15}}\sum_{i=0}^{14}C_{i}^{\prime}={\frac{1}{15}}(3\times1+4\times14)={\frac{59}{15}}
$$  

03.【解答】  

1）先在A[7]，A[15]，"，A[8n-1]内顺序查找，再在区间内折半查找。相应的判定树如 下图所示。其中，每个关键字下的数字为其查找成功时的关键学比较次数。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31eafbd9a8e3949e9c8b697dc72a887a69869cf17a7452141a76ea81a84f6ceb.jpg)  

2）等查找概率下，平均每个关键字查找成功的概率为 $1/8n$ ； $_{0\sim7}$ 之间的关键字，顺序比较1次后，进行折半查找，查找成功的平均查找长度为 $2\mathrm{~+~}3{\times}2\mathrm{~+~}4{\times}4$  $8\!\sim\!15$ 之  
间的关键字，先顺序比较2次后，再进入折半查找：以此类推， $8(n-1){\sim}8n-1$ 之间的关键字，先顺序比较 $n$ 次，再进入折半查找，如上图所示。因此，查找成功的平均查找长度为  

$$
\begin{array}{l c l}{{\operatorname{PSL}_{\scriptscriptstyle{\tilde{n}}\scriptscriptstyle{\tilde{k}};\scriptscriptstyle{\tilde{n}}}=\displaystyle\frac{1}{8n}\sum_{i=0}^{8n-1}C_{i}=\displaystyle\frac{1}{8n}\biggl(\sum_{i=1}^{n}i+\sum_{i=2}^{n+1}i+2\sum_{i=3}^{n+2}i+4\sum_{i=4}^{n+3}i\biggr)}}\\ {{}}\\ {{}}&{{=\displaystyle\frac{1}{8n}\biggl(\sum_{i=1}^{n}(i+(i+1)+2(i+2)+4(i+3))\biggr)}}\\ {{}}&{{=\displaystyle\frac{1}{8n}\sum_{i=1}^{n}(8i+17)=\frac{1}{n}\sum_{i=1}^{n}i+\frac{17}{8}\!=\!\frac{n+1}{2}\!+\!\frac{17}{8}}}\end{array}
$$  

04.【解答】  

算法的基本思想：根据查找的起始位置和终止位置，将查找序列一分为二，判断所查找的关键字在哪一部分，然后用新的序列的起始位置和终止位置递归求解。  

算法代码如下：  

typedef struct{川查找表的数据结构ElemType\*elem;存储空间基址，建表时按实际长度分配，0号留空intlength;//表的长度}SSTable; int Bin Search Rec（SSTable ST,ElemType key,int low,int high){if(low>high) return0; mid $=$ (low+high)/2;//取中间位置if(key>ST.elem[mid])//向后半部分查找Bin Search Rec（ST,key,mid+l,high);elseif（key<ST.elem[mid]）//向前半部分查找Bin Search Rec(ST,key,low,mid-1); else //查找成功 returnmid;  

算法把规模为 $n$ 的复杂问题经过多次递归调用转化为规模减半的子问题求解。时间复杂度为 $O(\log_{2}\!n)$ ，算法中用到了一个递归工作栈，其规模与递归深度有关，也是 $O(\log_{2}n)$  

# 05.【解答】  

算法的基本思想：检索时可先从表头开始向后顺序扫描，若找到指定的结点，则将该结点和其前趋结点（若存在）交换。采用顺序表存储结构的算法实现如下：  

int SeqSrch（RcdType R[],ElemType k){ //顺序查找线性表，找到后和其前面的元素交换int  $\scriptstyle{\dot{\mathbf{1}}}=0$  while((R[i].key $!\!=\!\!k$ && $\mathrm{(\vec{\tau})}$ ） $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ 川/从前向后顺序查找指定结点if（i<n&&i>0){ I/若找到，则交换 temp  $\scriptstyle{\varepsilon=\mathbb{R}}$  [i];R[i]  $\scriptstyle=\mathbb{R}$  [i-1];R[i-1]=temp; return--i;交换成功，返回交换后的位置elsereturn -1; 交换失败  

链表的实现方式请读者自行思考。注意，链表方式实现的基本思想与上述思想相似，但要注意用链表实现时，在交换两个结点之前需要保存指向前一结点的指针。  
06.【解析】  

1）算法的基本设计思想：  

从矩阵 $_{A}$ 的右上角（最右列）开始比较，若当前元素小于自标值，则向下寻找下一个更大的元素：若当前元素大于自标值，则从右往左依次比较，若自标值存在，则只可能在该行中。  

2）算法的实现：  

bool findkey（int A[][],intn,int k){ int  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\frac{1}{1}}=\mathbf{n}-1$  while(  $\mathtt{i}\!<\!\mathtt{n}\!\;\delta\delta\,\mathtt{i}\!>=\!0$  //离开边界时查找结束 if(A[i][j]  $==k$  ）returntrue；l/查找成功 else if(A[i][j]>k)j--;/向左移动，在该行内寻找目标值else $\dot{\mathbf{1}}_{++}$ /向下移动，查我下一个更大的元素return false; //查找失败  

3）比较次数不超过 $2n$ 次，时间复杂度为 $O(n)$ ：空间复杂度为 $O(1)$  

07.【解答】  

1）折半查找要求元素有序顺序存储，字符串默认按字典序排序（字典序是一种比较两个字符串大小的方法，它按字母顺序从左到右逐个比较对应的字符，若某一位可比较出大小，则不再继续比较后面的字符，如abd<acd、abc<abcd等），对本题来说do<for<repeat<while。若各个元素的查找概率不同，折半查找的性能不一定优于顺序查找。采用顺序查找时，元素按其查找概率的降序排列时查找长度最小。采用顺序存储结构，数据元素按其查找概率降序排列。采用顺序查找方法。查找成功时的平均查找长度 $=\!0.35\!\times\!1+0.35\!\times\!2+0.15\!\times\!3+0.15\!\times\!4=2.1$ 此时，显然查找长度比折半查找的更短。  

2）答案1：采用链式存储结构时，只能采用顺序查找，其性能和顺序表一样，类似于上题。数据元素按其查找概率降序排列，构成单链表。采用顺序查找方法。查找成功时的平均查找长度 $=\!0.35\!\times\!1+0.35\!\times\!2+0.15\!\times\!3+0.15\!\times\!4=2.1.$ 答案2：还可以构造成二叉排序树的形式。采用二叉链表的存储结构，构造二叉排序树，元素的存储方式见下图。采用二叉排序树的查找方法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/afb63decb05cee9e2bed3e965980387378416316eb46074679f198ad328a9aa8.jpg)  

查找成功时的平均查找长度 $=0.15\times1+0.35\times2+0.35\times2+0.15\times3=2.0.6$  

# 7.3 树形查找  

# 7.3.1二叉排序树（BST）  

构造一棵二叉排序树的目的并不是排序，而是提高查找、插入和删除关键字的速度，二叉排序树这种非线性结构也有利于插入和删除的实现。  
# 1.二叉排序树的定义  

# 命题追踪二叉排序树的应用（2013）  

二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：  

1）若左子树非空，则左子树上所有结点的值均小于根结点的值。2）若右子树非空，则右子树上所有结点的值均大于根结点的值。3）左、右子树也分别是一棵二叉排序树。  

# 命题追踪二叉排序树中结点值之间的关系（2015、2018）  

根据二叉排序树的定义，左子树结点值 $<$ 根结点值 $<$ 右子树结点值，因此对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，图7.4所示二叉排序树的中序遍历序列为123468。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ce5699f8e763d0cb3b6dbd0974980ca0913f135c1e27622016155408d0e469aa.jpg)  
图7.4一棵二叉排序树  

# 2.二叉排序树的查找  

二义排序树的查找是从根结点开始，沿某个分支遂层向下比较的过程。若二义排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，若小于根结点的关键字，则 在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。  

二叉排序树的非递归查找算法：  

BSTNode \*BST Search(BiTree T,ElemType key)( while(T!=NULL&&key  $!=$  T->data){ I/若树空或等于根结点值，则结束循环 if（key<T->data）T=T->1child；//小于，则在左子树上查找 elseT=T->rchild; //大于，则在右子树上查找 returnT;  

例如，在图7.4中查找值为4的结点。首先4与根结点6比较。由于4小于6，所以在根结点6的左子树中继续查找。由于4大于2，所以在结点2的右子树中查找，查找成功。  

同样，二叉排序树的查找也可用递归算法实现，递归算法比较简单，但执行效率较低。具体的代码实现，留给读者思考。  

# 3.二叉排序树的插入  

二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。  

插入结点的过程如下：若原二义排序树为空，则直接插入：否则，若关键字 $\boldsymbol{\mathrm{k}}$ 小于根结点值则插入到左子树，若关键字k大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。如图7.5所示在一棵二叉排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e89e6ea7f4ada4a4c481bc8b1e0ce1cafabd2e67868cbf3cc6ccf9d77c30fc9c.jpg)  
图7.5向二叉排序树中插入结点  

二叉排序树插入操作的算法描述如下：  

int BST Insert（BiTree &T，KeyType k）( if（ $\scriptstyle\mathrm{T}==$ NULL)(//原树为空，新插入的记录为根结点 $\scriptstyle{\mathrm{T}}=$  (BiTree)malloc（sizeof（BSTNode)); T->data  $=\kappa$  T->lchild  $=$  T->rchild  $\equiv$  NULL; return1; /返回1，插入成功 elseif( $\scriptstyle{k=T^{*}}$ ->data)//树中存在相同关键字的结点，插入失败return 0; elseif(k<T->data) /插入T的左子树 return BST Insert(T->lchild,k); else /插入T的右子树 return BST Insert（T->rchild,k);  

# 4.二叉排序树的构造  

命题追踪 构造二叉排序树的过程（2020）  

从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设查找的关键字序列为{45，24，53，45，12.24}，则生成的二叉排序树如图7.6所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/359f08371aa754ac430fc9f29a85302372b2b4d9718c8e692c96b4d3a2472bf0.jpg)  
图7.6二叉排序树的构造过程  

构造二叉排序树的算法描述如下：  

void Creat BST（BiTree &T，KeyType str[],int n){  $\scriptstyle{\mathrm{T}}=$  NULL; //初始时T为空树 int  $_\mathrm{i}\!=\!0$  while $\mathrm{\ddot{z}}\mathrm{<}\mathrm{n}_{i}$ //依次将每个关键字插入二叉排序树BSTInsert(T,str[i]);  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  
# 5.二叉排序树的删除  

在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都册除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：  

$\textcircled{\scriptsize{1}}$ 若被删除结点：是叶结点，则直接删除，不会破坏二叉排序树的性质。 $\circledcirc$ 若结点z只有一棵左子树或右子树，则让：的子树成为z父结点的子树，替代z的位置。 $\textcircled{3}$ 若结点 $z$ 有左、右两棵子树，则令：的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。  

图7.7显示了在3种情况下分别删除结点45.78.78的过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/337a0835918349dc03e9c616897783190facdb482e06740c2ec450fd4cfe8a1b.jpg)  
图7.73种情况下的删除过程  

# 命题追踪二叉排序树中删除并插入某结点的分析（2013）  

思考：若在二叉排序树中删除并插入某结点，得到的二叉排序树是否和原来的相同？  

# 6.二叉排序树的查找效率分析  

二义排序树的查找效率，主要取决于树的高度。若二义排序树的左、右子树的高度之差的绝对值不超过1（平衡二叉树，下一节），它的平均查找长度为 $O(\log_{2}n)$ 。若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为 $O(n)$  

在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数 $n$ ，如图7.8（b）所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54dd73fa59f89a754e5fd4e7dce8cf7124f8fa9db15eeeafeb8140073840c7bf.jpg)  
图7.8相同关键字组成的不同二叉排序树  

在等概率情况下，图7.8（a）查找成功的平均查找长度为  

$$
\mathrm{ASL_{a}}\!=(1+2\!\times\!2+3\!\times\!4+4\!\times\!3)/10=2.9
$$  

而图7.8（b）查找成功的平均查找长度为  

$$
\mathrm{ASL}_{b}=(1+2+3+4+5+6+7+8+9+10)/10=5.5
$$  

从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，如图7.8所示。  

就维护表的有序性而言，二义排序树无须移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为 $O(\log_{2}n)$ 。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是 $O(n)$ 。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。  

# 7.3.2 平衡二叉树  

# 1.平衡二叉树的定义  

为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树（Balanced BinaryTree），也称AVL树。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。  

# 命题追踪平衡二叉树的定义（2009）  

因此，平衡二叉树可定义为或是一棵空树，或是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。图7.9（a）所示是平衡二叉树，图7.9（b）所示是不平衡的二叉树。结点中的数字为该结点的平衡因子。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42460a711e8a2a7bcbc0a975d83fd52c42972810cdf1ff0354c8c9d9ea7aa463.jpg)  
图7.9平衡二叉树和不平衡的二叉树  
# 2.平衡二叉树的插入  

二叉排序树保证平衡的基本思想如下：每当在二义排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以 $A$ 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。  

# 命题追踪平衡二叉树中插入操作的特点（2015）  

> attention:  

每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。图7.10中的虚线框内为最小不平衡子树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2209bb6cb24b8548ca118f9d5f40aa8899f7ed2e20e83c7fe0c0621ee7b842db.jpg)  
图7.10最小不平衡子树示意  

# 命题追踪平衡二叉树的插入及调整操作的实例（2010、2019、2021）  

平衡二义树的插人过程的前半部分与二义排序树相同，但在新结点插人后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：  

1）LL平衡旋转（右单旋转）。由于在结点 $A$ 的左孩子（L）的左子树（L）上插入了新结点， $A$ 的平衡因子由1增至2，导致以 $A$ 为根的子树失去平衡，需要一次向右的旋转操作。将 $A$ 的左孩子 $B$ 向右上旋转代替 $A$ 成为根结点，将 $A$ 向右下旋转成为 $B$ 的右孩子，而 $B$ 的原右子树则作为 $A$ 的左子树。如图7.11所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b95eff2c046b43bb6a18bc9a41beacc9de133dbf00206769ee68eb40f6d13e7.jpg)  
图7.11LL平衡旋转  

2）RR平衡旋转（左单旋转）。由于在结点 $A$ 的右孩子（R）的右子树（R）上插入了新结点 $A$ 的平衡因子由-1减至-2，导致以4为根的子树失去平衡，需要一次向左的旋转操作。  
将 $A$ 的右孩子 $B$ 向左上旋转代替 $A$ 成为根结点，将 $A$ 向左下旋转成为 $B$ 的左孩子，而 $B$ 的原左子树则作为 $A$ 的右子树，如图7.12所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5619c6d8436c1be38b63d259dcc65e0d4dfdd684c7e61b46edda1f39de83300f.jpg)  
图7.12RR平衡旋转  

3）LR平衡旋转（先左后右双旋转）。由于在 $A$ 的左孩子（L）的右子树（R）上插入新结点， $A$ 的平衡因子由1增至2，导致以 $A$ 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将 $A$ 的左孩子 $B$ 的右子树的根结点 $C$ 向左上旋转提升到 $B$ 的位置，然后把结点 $C$ 向右上旋转提升到 $A$ 的位置，如图7.13所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e7462a89cd7274f34abe2309c0d8eedb6ed3d046096c03916695558689e50a9f.jpg)  
图7.13LR平衡旋转  

4）RL平衡旋转（先右后左双旋转）。由于在 $A$ 的右孩子（R）的左子树（L）上插入新结点， $A$ 的平衡因子由-1减至-2，导致以 $A$ 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 $A$ 的右孩子 $B$ 的左子树的根结点 $C$ 向右上旋转提升到 $B$ 的位置然后把结点 $C$ 向左上旋转提升到 $A$ 的位置，如图7.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/044e9dac3e9118af06383caa4ab6770b19e9168a05e12eabac22b4702037505f.jpg)  
图7.14RL平衡旋转  

> attention:  

LR和RL旋转时，新结点究竟是插入 $C$ 的左子树还是插入 $C$ 的右子树不影响旋转过程，而图7.13和图7.14中以插入 $C$ 的左子树中为例。  
# 命题追踪构造平衡二叉树的过程（2013）  

以关键字序列：15，3，7，10，9，8）构造一棵平衡二叉树的过程为例，图7.15（d插入7后导致不平衡，最小不平衡子树的根为15，插入位置为其左孩子的右子树，所以执行LR旋转，先左后右双旋转，调整后的结果如图7.15（e）所示。图7.15（g）插入9后导致不平衡，最小不平衡子树的根为15，插入位置为其左孩子的左子树，所以执行LL旋转，右单旋转，调整后的结果如图7.15（h）所示。图7.15（1插入8后导致不平衡，最小不平衡子树的根为7，插入位置为其右孩子的左子树，所以执行RL旋转，先右后左双旋转，调整后的结果如图7.15（所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/093f0bfc9d39ea0cacad9cfef59f6edf59790e2ed7a6692f2ea8792f99c3b8bf.jpg)  
图7.15平衡二叉树的生成过程  

3.平衡二叉树的删除  

与平衡二叉树的插入操作类似，以删除结点w为例来说明平衡二叉树删除操作的步骤：  

1）用二叉排序树的方法对结点w执行删除操作。2）若导致了不平衡，则从结点w开始向上回溯，找到第一个不平衡的结点 $\mathrm{_{z}}$ （即最小不平衡子树）；y为结点z的高度最高的孩子结点；x是结点y的高度最高的孩子结点。3）然后对以z为根的子树进行平衡调整，其中x、y和 $\mathrm{_{Z}}$ 可能的位置有4种情况：y是z的左孩子，x是y的左孩子（LL，右单旋转）；y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）；y是z的右孩子，x是y的右孩子（RR，左单旋转）；V是z的右孩子，x是V的左孩子（RL，先右后左双旋转）。  

这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以z为根的子树进行平衡调整；而删除操作就不一样，先对以z为根的子树进行平衡调整，若调整后子树的高度减1，则可能需要对z的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）。  

以删除图7.16（a）的结点32为例，由于32为叶结点，直接删除即可，向上回溯找到第一个不平衡结点44（即z），z的高度最高的孩子结点为78（y），y的高度最高的孩子结点为 $50\ \mathrm{\Omega}(\mathbf{x})$ ，满足RL情况，先右后左双旋转，调整后的结果如图7.16（c）所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7583531b4059bdd4839026ef84e33d80a0e80d188229f9a181a9205146f44d1b.jpg)  
图7.16平衡二叉树的删除  

# 4.平衡二叉树的查找  

命题追踪指定条件下平衡二叉树的结点数的分析（2012）  

在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，进行关键字的比较次数不超过树的深度。假设以 $n_{h}$ 表示深度为 $h$ 的平衡二叉树中含有的最少结点数。显然，有 $n_{0}\!=\!0,n_{1}\!=\!1,n_{2}\!=\!2,$ ，并且有 $n_{h}\,{=}\,n_{h-2}+n_{h-1}+1\,,$ ，如图7.17所示，依次推出 $n_{3}\,{=}\,4$  $n_{4}\,{=}\,7$  $n_{5}=12,\cdots$ 含有 $n$ 个结点的平衡二叉树的最大深度为 $O(\log_{2}\!n)$ ，因此平均查找效率为 $O(\log_{2}n)$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05527187cb555c4a8c169a1c9bb747cea9d526708b08d8e44da08c7188104059.jpg)  
图7.17结点个数  $n$  最少的平衡二叉树  

> attention:  

该结论可用于求解给定结点数的平衡二叉树的查找所需的最多比较次数（或树的最大高度）。如在含有12个结点的平衡二叉树中查找某个结点的最多比较次数？  

深度为 $h$ 的平衡二叉树中含有的最多结点数显然是满二叉树的情况。  

# 7.3.3 红黑树  

1.红黑树的定义  

为了保持AVL树的平衡性，在插入和删除操作后，会非常频繁地调整全树整体拓扑结构代价较大。为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构。  

一棵红黑树是满足如下红黑性质的二叉排序树： $\textcircled{\scriptsize{1}}$ 每个结点或是红色，或是黑色的。  

$\textcircled{2}$ 根结点是黑色的。  

$\textcircled{3}$ 叶结点（虚构的外部结点、NULL结点）都是黑色的。  

$\circledast$ 不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。  

$\circledast$ 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。与折半查找树和B树类似，为了便于对红黑树的实现和理解，引入了 $n+1$ 个外部叶结点，  
以保证红黑树中每个结点（内部结点）的左、右孩子均非空。图7.18所示是一棵红黑树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6302ead6b67560702595dc181ea237d148fcc79e5f41102d878fe7c0d83723be.jpg)  
图7.18一棵红黑树  

从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh），黑高的概念是由性质 $\circledast$ 确定的。根结点的黑高称为红黑树的黑高。  

结论1：从根到叶结点的最长路径不大于最短路径的2倍。  

由性质 $\circledast$ ，当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。由性质 $\textcircled{4}$ ，当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时红结点和黑结点的数量相同。图7.18中的 $_{6-2}$ 和 $6\!-\!15\!-\!18\!-\!20$ 就是这样的两条路径。  

# 结论2：有 $n$ 个内部结点的红黑树的高度 $h{\leqslant}2{\log_{2}(n+1)}$  

证明：由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为 $h/2$ ，于是有 $n{\geqslant}2^{h/2}{-}1$ ，即可求得结论。  

可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任意一个结点左右子树的高度，相差不超过2倍”，也降低了动态操作时调整的频率。对于一棵动态查找树，若插入和删除操作比较少，查找操作比较多，则采用AVL树比较合适，否则采用红黑树更合适。但由于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛， $\mathrm{C++}$ 中的map和set（Java Tree Map Tree Set）就是用红黑树实现的。  

# 2.红黑树的插入  

红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新结点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。  

# 结论3：新插入红黑树中的结点初始着为红色。  

假设新插人的结点初始看为黑色，则这个结点所在的路径比其他路径多出一个黑结点（几乎每次插人都破坏性质 $\circledast$ ），调整起来也比较麻烦。若插人的结点是红色的，则此时所有路径上的黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。  

设结点z为新插入的结点。插入过程描述如下：  

1）用二叉查找树插入法插入，并将结点z着为红色。若结点z的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树。2）若结点z是根结点，则将 $\mathrm{_{z}}$ 着为黑色（树的黑高增1)，结束。3）若结点z不是根结点，且z的父结点z.p是红色的，则分为下面三种情况，区别在于z的叔结点y的颜色不同，因z.p是红色的，插入前的树是合法的，根据性质 $\mathcal{Q}$ 和 $\textcircled{4})$ ，爷结点Z.P.P必然存在且为黑色。性质 $\textcircled{4}$ 只在 $\mathrm{_{Z}}$ 和z.p之间被破坏了。  
情况1：z的叔结点y是黑色的，且z是一个右孩子。情况2：z的叔结点y是黑色的，且z是一个左孩子。每棵子树 $T_{\parallel}$ 、 $T_{2}$ 、 $T_{3}$ 和 $T_{4}$ 都有一个黑色根结点，且具有相同的黑高。  

情况1（LR，先左旋，再右旋），即z是其爷结点的左孩子的右孩子。先做一次左旋将此情形转变为情况2（变为情况2后再做一次右旋），左旋后z和父结点z.p交换位置。因为z和z.p都是红色的，所以左旋操作对结点的黑高和性质 $\circledast$ 都无影响。  

情况2（LL，右单旋），即 $\mathrm{_{z}}$ 是其爷结点的左孩子的左孩子。做一次右旋，并交换z的原父结点和原爷结点的颜色，就可以保持性质 $\circledast$ ，也不会改变树的黑高。这样，红黑树中也不再有连续两个红结点，结束。情况1和情况2的调整方式如图7.19所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6141fe894e84b2ccf481ee1228f8dde35deaefe9f7c1b34e6857aad4fded5586.jpg)  
图7.19情况1和情况2的调整方式  

若父结点z.p是爷结点z.p.p的右孩子，则还有两种对称的情况：RL（先右旋，再左旋）和RR（左单旋），这里不再赘述。红黑树的调整方法和AVL树的调整方法有异曲同工之妙。  

情况3：z的叔结点y是红色的。  

情况3 $\mathrm{_{Z}}$ 是左孩子或右孩子无影响）， $_\mathrm{z}$ 的父结点z.p和叔结点y都是红色的，因为爷结点Z.p.p是黑色的，将z.p和y都着为黑色，将z.p.p着为红色，以在局部保持性质 $\textcircled{4}$ 和 $\circledast$ 。然后，把z.p.p作为新结点z来重复循环，指针z在树中上移两层。调整方式如图7.20所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f5ccc56ed08320a072e5b4dc2d9a90053800244c9efa93005dfc054cd43073d8.jpg)  
图7.20情况3的调整方式  

若父结点z.p是爷结点z.p.p的右孩子，也还有两种对称的情况，不再赘述。  

只要满足情况3的条件，就会不断循环，每次循环指针z都会上移两层，直到满足2）（表示z上移到根结点）或情况1或情况2的条件。效  

可能的疑问：虽然插入的初始位置一定是红黑树的某个叶结点，但因为在情况3中，结点z存在不断上升的可能，所以对于三种情况，结点z都有存在子树的可能。  
以图7.21（a）中的红黑树为例（虚线表示插入后的状态），先后插入5、4和12的过程如图7.21所示。插入5，为情况3，将5的父结点3和叔结点10着为黑色，将5的爷结点变为红色，此时因为7已是根，所以又重新着为黑色，树的黑高加1，结束。插入4，为情况1的对称情况（RL），此时特别注意虚构黑色空结点的存在，先对5做右旋：转变为情况2的对称情况（RR），交换3和4的颜色，再对3做左旋，结束。插入12，父结点是黑色的，无须任何调整，结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/866a8fdbeb20f4f9f1017d2842fcadd4a0308566f5ba94047bdd131149297787.jpg)  
图7.21红黑树的插入过程  

# \*3.红黑树的删除  

红黑树的插入操作容易导致连续的两个红结点，破坏性质 $\textcircled{4}$ 。而册除操作容易造成子树黑高的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质 $\circledast$  

删除过程也是先执行二叉查找树的册除方法。若待删结点有两个孩子，不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后继结点至多只有一个孩子，这样就转换为待删结点是终端结点或仅有一个孩子的情况。  

最终，删除一个结点有以下两种情况：  

待删结点只有右子树或左子树。待删结点没有孩子。1）若待删结点只有右子树或左子树，则只有两种情况，如图7.22所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cab26f5079edd0a6447893d1eae634ce7de3b9df2de6eabbb5a6359254c2e364.jpg)  
图7.22只有右子树或左子树的删除情况  

只有这两种情况存在。子树只有一个结点，且必然是红色，否则会破坏性质 $\circledast$ 2）待删结点无孩子，且该结点是红色的，这时可直接删除，而不需要做任何调整。3）待删结点无孩子，且该结点是黑色的，这时设待删结点为y，x是用来替换y的结点（注  
意，当y是终端结点时，x是黑色的NULL结点）。删除y后将导致先前包含y的任何路径上的黑结点数量减1，因此y的任何祖先都不再满足性质 $\circledast$ ，简单的修正办法就是将替换y的结点x视为还有额外一重黑色，定义为双黑结点。也就是说，若将任何包含结点x的路径上的黑结点数量加1，则在此假设下，性质 $\circledast$ 得到满足，但破坏了性质 $\circledcirc$ 。于是，删除操作的任务就转化为将双黑结点恢复为普通结点。  

分为以下四种情况，区别在于x的兄弟结点w及w的孩子结点的颜色不同。  

情况1：X的兄弟结点W是红色的。  

情况1，w必须有黑色左右孩子和父结点。交换w和父结点x.p的颜色，然后对x.p做一次左旋，而不会破坏红黑树的任何规则。现在，x的新兄弟结点是旋转之前w的某个孩子结点，其颜色为黑色，这样，就将情况1转换为情况2、3或4处理。调整方式如图7.23所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60760335c4d8bc8941e363634d6e9120ff151d6b6f52818aa54fe7a239bac7ed.jpg)  
图7.23情况1的调整方式  

情况2：x的兄弟结点W是黑色的，且w的右孩子是红色的。情况3：x的兄弟结点W是黑色的，W的左孩子是红色的，W的右孩子是黑色的。  

情况2（RR，左单旋），即这个红结点是其爷结点的右孩子的右孩子。交换w和父结点x.P的颜色，把w的右孩子着为黑色，并对x的父结点x.p做一次左旋，将x变为单重黑色，此时不再破坏红黑树的任何性质，结束。调整方式如图7.24所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0acf8e79a22ee8cdebb7c67323a375bbd51c9a6a9a72ff5305d1ec8bf75d6c37.jpg)  
图7.24情况2的调整方式  

情况3（RL，先右旋，再左旋），即这个红结点是其爷结点的右孩子的左孩子。交换W和其左孩子的颜色，然后对w做一次右旋，而不破坏红黑树的任何性质。现在， $_\mathrm{x}$ 的新兄弟结点W的右孩子是红色的，这样就将情况3转换为了情况2。调整方式如图7.25所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21ad3f76de9b3e1effcce1f8a03e3fcbb06283ab2c8c5ded905ca2ecfa56abc7.jpg)  
图7.25情况3的调整方式  
情况4：x的兄弟结点W是黑色的，且w的两个孩子结点都是黑色的。  

在情况4中，因为w也是黑色的，所以可从 $_\mathrm{x}$ 和w上去掉一重黑色，使得 $_\mathrm{x}$ 只有一重黑色而w变为红色。为了补偿从x和w中去掉的一重黑色，把 $\mathbf{X}$ 的父结点xp额外着一层黑色，以保持局部的黑高不变。通过将x.p作为新结点 $_\mathrm{x}$ 来循环，×上升一层。若是通过情况1进入情况4的，因为原来的x.p是红色的，将新结点 $_\textrm{x}$ 变为黑色，终止循环，结束。调整方式如图7.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f77f4733c0cffc561dc2e545e593ce2eb429d88b4703d725d26d24d9778e963.jpg)  
图7.26情况4的调整方式  

若×是父结点x.p的右孩子，则还有四种对称的情况，处理方式类似，不再赘述。  

归纳总结：在情况4中，因x的兄弟结点w及左右孩子都是黑色，可以从 $_\mathrm{x}$ 和w中各提取一重黑色（以让×变为普通黑结点），不会破坏性质 $\textcircled{4}$ ，并把调整任务向上“推”给它们的父结点xp。在情况1、2和3中，因为x的兄弟结点w或w左右孩子中有红结点，所以只能在x.p子树内用调整和重新着色的方式，且不能改变 $_\mathrm{x}$ 原根结点的颜色（否则向上可能破坏性质 $^{(4)}$ ）。情况1虽然可能会转换为情况4，但因为新 $\mathbf{X}$ 的父结点 $\mathrm{x.p}$ 是红色的，所以执行一次情况4就会结束。情况1、2和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯一情况，每执行一次指针x上升一层，至多 $O(\log_{2}n)$ 次。  

以图7.27a)中的红黑树为例（虚线表示删除前的状态），依次删除5和15的过程如图7.27所示。删除5，用虚构的黑色NULL结点替换，视为双黑NULL结点，为情况1，交换兄弟结点12和父结点8的颜色，对8做一次左旋；转变为情况4，从双黑NULL结点和10中各提取一重黑色（提取后，双黑NULL结点变为普通NULL结点，图中省略，10变为红色），因原父结点8是红色，所以将8变为黑色，结束。删除15，为情况3的对称情况（LR），交换8和10的颜色，对8做左旋；转变为情况2的对称情况（LL），交换10和12的颜色（两者颜色一样，无变化），将10的左孩子8着为黑色，对12做右旋，结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16b040213c28dc879ebf6aede317568cd287ae396fdf09e05e9949dcf6c67b0e.jpg)  
图7.27红黑树的删除过程  
# 7.3.4 本节试题精选  

# 一、单项选择题  

01.对于二叉排序树，下面的说法中，（）是正确的。  

A.二叉排序树是动态树表，查找失败时插入新结点，会引起树的重新分裂和组合 B.对二叉排序树进行层序遍历可得到有序序列C.用逐点插入法构造二叉排序树，若先后插入的关键字有序，二叉排序树的深度最大D.在二叉排序树中进行查找，关键字的比较次数不超过结点数的1/2  

02.按（）遍历二叉排序树得到的序列是一个有序序列。  

A.先序B.中序C.后序D.层次  

03.在二叉排序树中进行查找的效率与（）有关。  

A.二叉排序树的深度B.二叉排序树的结点的个数C.被查找结点的度D.二叉排序树的存储结构  

04.在常用的描述二叉排序树的存储结构中，关键字值最大的结点（）。  

A.左指针一定为空B.右指针一定为空C.左右指针均为空D.左右指针均不为空  

05.设二叉排序树中关键字由1到1000的整数构成，现要查找关键字为363的结点，下述关键字序列中，不可能是在二叉排序树上查找的序列是（）  

A.2,252,401,398,330,344,397,363 B.924,220,911,244,898,258,362,363 C.925,202,911,240,912,245,363 D.2,399,387,219,266,382,381,278,363  

06.分别以下列序列构造二叉排序树，与用其他3个序列所构造的结果不同的是（）。  

A.（100,80,90,60,120,110,130)B.（100,120,110,130,80,60,90）C.（100,60,80,90,120,110130) D.(100,80,60,90,120,130,110)  

07.从空树开始，依次插入元素52，26，14，32，71，60，93，58，24和41后构成了一棵二叉排序树。在该树查找60要进行比较的次数为（）  

A.3 B.4 C.5 D.6  

08.在含有n个结点的二叉排序树中查找某个关键字的结点时，最多进行（）次比较  

A.n/2 B.log2n C.  $\log_{2}\!n+1$  D.n  

09.五个不同结点构造的二叉查找树的形态共有（）种。  

A.20 B.30 C.32 D.42  

10.构造一棵具有 $n$ 个结点的二叉排序树时，最理想情况下的深度为（）  

A.n/2 B.n C.  $\lfloor\log_{2}(n+1)\rfloor$  D.  $\lceil\log_{2}(n+1)\rceil$  

11.含有20个结点的平衡二叉树的最大深度为（）  

A.4 B.5 C.6 D.7  

12.具有5层结点的平衡二叉树至少有（）个结点。  

A.10 B.12 C.15 D.17  

13.高度为3的平衡二叉排序树的形态共有（）种。  

A.13 B.14 C.16 D.15  

14.在平衡二叉树的基本操作中，可能发生两次旋转的操作是（）  

A.添加、删除结点B.仅删除结点C.仅添加结点D.都不会  

15.将关键字 $1,2,3,\cdots$ ，1024依次插入到初始为空的平衡二叉树中，假设只有一个根结点的二叉树的高度为0，则插入结束后的平衡二叉树的高度是（）A.8 B.9 C.10 D.11  
16.下列关于红黑树和AVL树的说法中，不正确的是（）  

I.一棵含有 $n$ 个结点的红黑树的高度至多为 $2\log_{2}(n+1)$ I1.若一个结点是红色的，则它的父结点和孩子结点都是黑色的III.红黑树的查询效率一般要优于含有相同结点数的AVL树IV.若AVL树的某结点的左右孩子的平衡因子都是零，则该结点的平衡因子也是零  

A.I、IIIB.IⅢIC.II、IVD.III、IV

17.下列关于红黑树和AVL树的描述中，不正确的是（）  

A.两者都属于自平衡的二叉树 B.两者查找、插入、删除的时间复杂度都相同0.红黑树插入和删除过程至多有2次旋转操作D.红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过2  

18.下列关于红黑树的说法中，正确的是（）  

A.红黑树的红结点的数目最多和黑结点的数目相同 B.若红黑树的所有结点都是黑色的，则它一定是一棵满二叉树C.红黑树的任何一个分支结点都有两个非空孩子结点D.红黑树的子树也一定是红黑树  

19.下列四个选项中，满足红黑树定义的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/163d2c1c24d51082b4e3d8856b95339ee3e673164beafa2f96cf980e9aa814c0.jpg)  

20.将关键字 $1,2,3,4,5,6,7$ 依次插入初始为空的红黑树 $T_{c}$ 则 $T$ 中红结点的个数是（）A.1 B.2 C.3 D.4

 21.将关键字5，4，3，2，1依次插入初始为空的红黑树 $T_{\ast}$ 则 $T$ 的最终形态是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fb9f751a239f192d32a03a91f5c9a80712aaa3db250d7f8231832c8ea5fea238.jpg)  

22.在下图所示的红黑树中插入结点2且染成红色后，则下一步应进行的操作是（）。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/24e0d835ffb74dd4617321a3dec991e5e8ed0ed460d51cb11ed2e5d5521edbb4.jpg)  

A.左旋 B.右旋 C.变色 D.无须调整

 23.【2009统考真题】下列二叉排序树中，满足平衡二叉树定义的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d15c90af1a8f5f933149a2fc29f5af4b11488c2c321ddc1eb431e88c285c94a.jpg)  

24.【2010统考真题】在下图所示的平衡二叉树中插入关键字48后得到一棵新平衡二叉树 在新平衡二叉树中，关键字37所在结点的左、右子结点中保存的关键字分别是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/88fd92cebf308f9fe22fc16b0a18416cde8f242c7f0cf2aacba9b840039cfb6c.jpg)  

A.13,48 B.24,48 C.24,53 D.24,90

 25.【2011统考真题】对下列关键字序列，不可能构成某二叉排序树中一条查找路径的是（）。  

A.95,22,91,24,94,71 B.92,20,91,34,88,35 C.21,89,77,29,36,38 D.12,25,71,68,33,34  

26.【2012统考真题】若平衡二叉树的高度为6，且所有非叶结点的平衡因子均为1，则该平衡二叉树的结点总数为（）。  

A.12 B.20 C.32 D.33  

27.【2013统考真题】在任意一棵非空二叉排序树 $T_{\parallel}$ 中，删除某结点v之后形成二叉排序树 $T_{2}$ ，再将 $\nu$ 插入 $T_{2}$ 形成二叉排序树 $T_{3}$ 。下列关于 $T_{1}$ 与 $T_{3}$ 的叙述中，正确的是（）。  

I.若 $\nu$ 是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 不同II.若v是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  相同 I1.若v不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 不同IV.若 $v$ 不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 相同  

A.仅I、IⅢIB.仅I、IVC.仅II、IIID.仅II、IV  

28.【2013统考真题】若将关键字1，2，3，4，5，6，7依次插入初始为空的平衡二叉树  $T_{e}$  则  $T$  中平衡因子为0的分支结点的个数是（）。  

A.0 B.1 C.2 D.3  

29.【2015统考真题】现有一棵无重复关键字的平衡二叉树（AVL），对其进行中序遍历可得到一个降序序列。下列关于该平衡二叉树的叙述中，正确的是（）  

A.根结点的度一定为2B.树中最小元素一定是叶结点C.最后插入的元素一定是叶结点D.树中最大元素一定是无左子树  
30.【2018统考真题】已知二叉排序树如下图所示，元素之间应满足的大小关系是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c0339e3f9f5a37b8f71445dcb279a11b83cedd1bd8134be673fb284ac424743.jpg)  

A.  $x_{1}\!<\!x_{2}\!<\!x_{5}$  B.  $x_{1}\!<\!x_{4}\!<\!x_{5}$  C.  $x_{3}\!<\!x_{5}\!<\!x_{4}$  D.  $x_{4}\!<\!x_{3}\!<\!x_{5}$  

31.【2019统考真题】在任意一棵非空平衡二叉树（AVL树） $T_{\parallel}$ 中，删除某结点 $v$ 之后形成平衡二叉树 $T_{2}$ ，再将 $v$ 插入 $T_{2}$ 形成平衡二叉树 $T_{3\circ}$ 下列关于 $T_{1}$ 与 $T_{3}$ 的叙述中，正确的是（）。  

I.若 $v$ 是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 可能不相同II.若 $v$ 不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 一定不相同IⅢ.若 $v$ 不是 $T_{1}$ 的叶结点，则 $T_{1}$ 与 $T_{3}$ 一定相同  

A.仅IB.仅ⅡIC.仅I、IID.仅I、II

32.【2020统考真题】下列给定的关键字输入序列中，不能生成右边二叉排序树的是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/969432b052ae7342c68faa602d2c92cee50cf468340b5f5468af6b0b4f401857.jpg)  

A.4,5,2,1,3 B.4,5,1,2,3 C.4,2,5,3,1 D.4,2,1,3,5

 33.【2021统考真题】给定平衡二叉树如下图所示，插入关键字23后，根中的关键字是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/703412ed88fe1e8b11c35bac1174ef38dd3cb015652a29dedb3f08a32bfe7703.jpg)  

A.16 B.20 C.23 D.25  

# 二、综合应用题  

01.一棵二叉排序树按先序遍历得到的序列为（50,38，30,45，40,48，70,60，75，80），试画出该二叉排序树，并求出等概率下查找成功和查找失败的平均查找长度。

02.按照序列（40，72，38，35，67，51，90，8,55，21）建立一棵二叉排序树，画出该树，并求出在等概率的情况下，查找成功的平均查找长度。

03.依次把结点（34，23，15，98，115，28，107）插入初始状态为空的平衡二叉排序树，使得在每次插入后保持该树仍然是平衡二叉树。请依次画出每次插 $\leftthreetimes$ 后所形成的平衡二叉排序树。

04.给定一个关键字集合25，18，34，9，14，27，42，51，38}，假定查找各关键字的概率相同，请画出其最佳二叉排序树。

05.试编写一个算法，判断给定的二叉树是否是二叉排序树。

06.设计一个算法，求出指定结点在给定二叉排序树中的层次。

07.利用二叉树遍历的思想编写一个判断二叉树是否是平衡二叉树的算法。08.设计一个算法，求出给定二叉排序树中最小和最大的关键字。  
09.设计一个算法，从大到小输出二叉排序树中所有值不小于 $k$ 的关键字。  

10.编写一个递归算法，在一棵有 $n$ 个结点的、随机建立起来的二叉排序树上查找第 $k$  $1\!\leqslant\!k\!\leqslant\!n$ ）小的元素，并返回指向该结点的指针。要求算法的平均时间复杂度为 $O(\log_{2}n)$ 。二叉排序树的每个结点中除data、1child、rchild等数据成员外，增加一个count成员，保存以该结点为根的子树上的结点个数。  

# 7.3.5 答案与解析  

# 一、单项选择题  

01.C  

二叉排序树插入新结点时不会引起树的分裂组合。对二义排序树进行中序遍历可得到有序序列。当插入的关键字有序时，二叉排序树会形成一个长链，此时深度最大。在此种情况下进行查找，有可能需要比较每个结点的关键字，超过总结点数的1/2。  

02.B  

由二叉排序树的定义不难得出中序遍历二叉树得到的序列是一个有序序列。  

03.A 二叉排序树的查找路径是自顶向下的，其平均查找长度主要取决于树的高度。  

04.B  

在二叉排序树的存储结构中，每个结点由三部分构成，其中左（或右）指针指向比该结点的关键字值小（或大）的结点。关键字值最大的结点位于二义排序树的最右位置，因此它的右指针一定为空（有可能不是叶结点）。还可用反证法，若右指针不为空，则右指针上的关键字肯定比原关键字大，所以原关键字结点一定不是值最大的，与条件矛盾，所以右指针一定为空。  

05.C  

在二叉排序树上查找时，先与根结点值进行比较，若相同，则查找结束，否则根据比较结果，沿看左子树或石子树向下继续查找。根据二义排序树的定义，有左子树结点值 $\leqslant$ 根结点值≤石子树结点值。C序列中，比较911关键字后，应转向其左子树比较240，左子树中不应出现比911更大的数值，但240竟有一个右孩子结点值为912，所以不可能是正确的序列。  

06.C  

按照二叉排序树的构造方法，不难得到A，B，D序列的构造结果相同。  

07.A  

以第一个元素为根结点，依次将元素插入树，生成的二叉排序树如下图所示。进行查找时，先与根结点比较，然后根据比较结果，继续在左子树或右子树上进行查找。比较的结点依次为5271,60。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cbf41c7577b0831c9694e0c6c9bc117557c0447488336244f4c33e1a37935b8.jpg)  

08.D  

当输入序列是一个有序序列时，构造的二叉排序树是一个单支树，当查找一个不存在的关键字值或最后一个结点的关键字值时，需要 $n$ 次比较。  
09.D  

五个不同结点构造的二叉查找树，中序序列是确定的。先序序列的个数为 $n=5$ 的卡特兰数，加上中序序列和先序序列能唯一确定一棵二叉树，因此二叉排序树的形态共有Catalan（5） $=42$ 种。  

10.D  

当二叉排序树的叶结点全部都在相邻的两层内时，深度最小。理想情况是从第一层到倒数第二层为满二叉树。类比完全二叉树，可得深度为 $\lceil\log_{2}(n+1)\rceil_{\circ}$  

11.C  

平衡二叉树结点数的递推公式为 $n_{0}=0\,,\,\,\,n_{1}=1\,,\,\,\,n_{2}=2\,,\,\,\,n_{h}=1+n_{h-1}+n_{h-2}$  $h$ 为平衡二叉树高度， $n_{h}$ 为构造此高度的平衡二叉树所需的最少结点数）。通过递推公式可得，构造5层平衡二叉树至少需12个结点，构造6层至少需要20个结点。  

12.B  

设 $n_{h}$ 表示高度为 $h$ 的平衡二叉树中含有的最少结点数，则有 $n_{1}\!=\!1,n_{2}\!=\!2,n_{h}\!=\!n_{h\!-\!1}+n_{h\!-\!2}+1$ ，由此求出 $n_{5}\!=\!12$ ，对应的AVL如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/757001b26f14b87e57a0a567962e98dcdb3faf19b2a4437b34b3496e2840997d.jpg)  

13.D  

高度为3的平衡二叉树的左右子树的高度共有三种情况： $\textcircled{\scriptsize{1}}$ 左右子树都是高度为2的平衡二叉树： $\circledcirc$ 左子树是高度为1的平衡二叉树，右子树是高度为2的平衡二叉树： $\textcircled{3}$ 左子树是高度为2的平衡二叉树，右子树是高度为1的平衡二叉树。高度为1的平衡二叉树只有1种形态，即单个结点，如图1所示；高度为2的平衡二叉树有3种形态，如图2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4fc3ce99f5862697a27c711091a41697b49da44fec0085171c1a1d8409225a9d.jpg)  
图1  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c0d86e39e94af8af3761adaa7c6e466b34128d1c70d0d1e5bdb10540c6feedc.jpg)  
图2  

因此，对于情况 $\textcircled{\scriptsize{1}}$ ，共有 $3{\times}3=9$ 种树形态：对于情况 $\circledcirc$ ，共有 $1\!\times\!3=3$ 种树形态；情况 $\circledast$ 和情况②类似，也有3种树形态，所以共有 $9+3+3=15$ 种树形态。  

14.A  

插入和删除结点都有可能引起LR平衡旋转或者RL平衡旋转，发生两次旋转操作。  

15.C  

当按关键字有序的顺序插入初始为空的平衡二叉树时，若关键字个数 $n=2^{k}-1$ 时，则该平衡二叉树一定是一棵满二叉树（可以用 $1{\sim}3\times1{\sim}7$ 手工验证）。当插入关键字1023时，平衡二叉树正好是一棵满二义树，高度是9。因此，插入关键字1024后，平衡二叉树的高度是10。  

16.D  

I和IⅡI都是红黑树的性质。AVL是高度平衡的二叉查找树，红黑树是适度平衡的二叉查找树，从这一点也可以看出AVL的查询效率往往更优，III错误。AVL的某结点的左右孩子的平衡因子都是零，并不能说明左右子树的高度相等，因此该结点的平衡因子不一定为零，IV错误。  

17.C  
自平衡的二叉排序树是指在插入和册除时能自动调整以保持其所定义的平衡性，两者都属于自平衡二叉树，A正确。两者的查找、插入、删除操作的时间复杂度都为 $O(\log_{2}n)$ ，B正确。在红黑树中删除结点时，情况1可能变为情况2、3或4，情况2会变为情况3，可能会出现旋转次数超过2次的情况，C错误。从任一结点到每个叶结点的所有路径都包含相同数目的黑结点，没有两个连续的红结点，且叶结点是红色的，这意味看在任一结点到其左石子树中最远和最近的时结点之间，红结点的数目小于或等于黑结点的数目，路径长度之比不超过2，D正确。  

# 18.B  

红黑树的红结点数目最大可以是黑结点数目的2倍（如一棵有3个结点的红黑树，第1层为黑色，第2层为红色），A错误。从根结点出发到所有叶结点的黑结点数是相同的，若所有结点都是黑色，则一定是满二叉树，B正确。考虑某个黑结点，它可以有一个空叶结点孩子和一个非空红结点孩子，C错误。红黑树中可能存在红结点，根结点为红色的子树不是红黑树，D错误。  

# 19.A  

红黑树是一种特殊的二叉排序树，B项不满足二叉排序树的性质。C项中，结点2的左右黑结点数不同。D项中，结点3的左右黑结点数不同。只有A项满足红黑树的定义。  

20.C  

关键字 $1,2,3,4,5,6,7$ 依次插入红黑树后的形态变化如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c27a51c5772a51bcde439143b9c61d568b118a23dad1a6807fd9d25b0457f9da.jpg)  

# 21.D  

关键字 $5,4,3,2,1$ 依次插入红黑树后的形态变化如下：  

# 22.B  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9289eb1ec4af4861df533975c421bce082e01497e341be62ddbc12eec3f167.jpg)  

插入结点2且将其染成红色后违反不红红原则，并且叔结点是黑色，应进行LL旋转，将结点3右旋旋转到结点5的位置，结点2和结点5分别成为结点3的左、右孩子，然后将结点3染成黑色，结点2和结点5染成红色。因此，下一步应进行右旋操作。  
23.B  

根据平衡二叉树的定义，任意结点的左、右子树高度差的绝对值不超过1。而其余3个答案均可以找到不满足条件的结点。答题时可以把每个非叶结点的平衡因子都写出来。  

24.C  

插入48以后，该二叉树根结点的平衡因子由-1变为-2，在最小不平衡子树根结点的右子树（R）的左子树（L）中插入新结点引起的不平衡属于RL型平衡旋转（先右旋后左旋）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e81662b64bcb48da34de429ff499625461f0aa969233b426ca6107eccc92514.jpg)  
调整后，关键字37所在结点的左、右子结点中保存的关键字分别是24、53。  

25.A  

在二叉排序树中，左子树结点值小于根结点，右子树结点值大于根结点。在选项A中，当查找到91后再向24查找，说明这一条路径（左子树）之后查找的数都要比91小，而后面却查找 到了94（解题过程中，建议配合画图），因此错误。  

画图法：各选项对应的查找过如下图，选项B、C、D对应的查找树都是二叉排序树，选项A对应的查找树不是二叉排序树，因为在91为根的左子树中出现了比91大点的结点94。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e22f0ee6e7d5424ac3de4239981d63f25c35cb583db1ec9a129e4dc4ffb49de.jpg)  
（a）选项A的查找过程（b）选项B的查找过程（c）选项C的查找过程（d）选项D的查找过程  

26.B  

所有非叶结点的平衡因子均为1，即平衡二叉树满足平衡的最少结点情况，如下图所示。对于高度为 $n_{\checkmark}$ 左右子树的高度分别为 $n-1$ 和 $n\!-\!2\cdot$ 所有非叶结点的平衡因子均为1的平衡二叉树，计算总结点数的公式为 $C_{n}=C_{n-1}+C_{n-2}+1,\,C_{1}=1,\,C_{2}=2,\,C_{3}=2+1+1=4$ 可推出 $C_{6}\!=\!20$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6275c40fc894320237a3f623a550474064c28f50c6e018df50beb44373431f21.jpg)  

画图法：先画出 $T_{1}$ 和 $T_{2}$ ：然后新建一个根结点，连接 $T_{2}$ 、 $T_{1}$ 构成 $T_{3}$ ：新建一个根结点，连接 $T_{3}$ 、 $T_{2}$ 构成 $T_{4}$ 直到画出 $T_{6}$ ，可知 $T_{6}$ 的结点数为20。  
排除法：对于A，高度为6、结点数为12的树怎么也无法达到平衡。对于C，结点较多时，考虑较极端的情形，即第6层只有最左叶子的完全二叉树刚好有32个结点，虽然满足平衡的条件，但显然再删去部分结点依然不影响平衡，不是最少结点的情况。同理D错误。  

27.C  

由于在二义排序树中插入结点的位置是一个新的叶结点，若删除的是叶结点，则重新插入后得到的二叉排序树与原来的二叉排序树相同。若删除的是非叶结点，在删除过程中会找其他结点填补，重新插入后变成叶结点，则得到的二叉排序树与原来的二叉排序树不同。  

28.D  

利用7个关键字构建平衡二叉树T，平衡因子为0的分支结点个数为3，构建的平衡二叉树及构造与调整过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1f35f2259f4716c9e2ffea999ad8aab2c71a3318e2c97905e13236b5579256b.jpg)  

29.D  

大多数教材将平衡二叉树定义为一种高度平衡的二叉排序树，二叉排序树的中序序列是一个升序序列，而题意正好相反。由此可知，命题老师认为平衡二叉树仅为一棵满足高度平衡的二叉 树，不一定是二叉排序树。只有两个结点的平衡二义树的根结点的度为1，A错误。中序遍历后得到一个降序序列（与二叉排序树正好相反），树中最大元素一定无左子树（可能有右子树），这与二叉排序树也正好相反，也因此不一定是叶结点，B错误，D正确。最后插入的结点可能会导致平衡调整，而不一定是叶结点，C错误。  

30.C  

根据二叉排序树的特性：中序遍历（LNR）得到的是一个递增序列。图中二叉排序树的中序遍历序列为 $x_{1},x_{3},x_{5},x_{4},x_{2}$ ，可知 $x_{3}\!<\!x_{5}\!<\!x_{4}$  

31.A  

在非空平衡二叉树中插入结点，在失去平衡调整前，一定插入在叶结点的位置。  

若删除的是 $T_{1}$ 的叶结点，则删除后平衡二叉树可能不会失去平衡，即不会发生调整，再插入此结点得到的二叉平衡树 $T_{1}$ 与 $T_{3}$ 相同：若删除后平衡二叉树失去平衡而发生调整，再插入结点得到的二叉平衡树 $T_{3}$ 与 $T_{1}$ 可能不同。说法I正确。例如，如下图所示，删除结点0，平衡二叉树失衡调整，再插入结点0后，平衡二义树和以前不同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8bee9e20b5f41eb72f9be27f992fccadae215df16b6446ea9167c732e1855826.jpg)  
对于比较绝对的说法ⅡI和Ⅲ1，通常只需举出反例即可。  

若删除的是 $T_{\downarrow}$ 的非叶结点，且删除和插入操作均没有导致平衡二叉树的调整（这时可以首先想到删除的结点只有一个孩子的情况），则该结点从非叶结点变成了叶结点， $T_{1}$ 与 $T_{3}$ 显然不同。例如，如下图所示，删除结点2，用右孩子结点3填补，再插入结点2，平衡二叉树和以前不同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/04a663aef7a3b681eb2339aa426e9f5e1daa776dbbe7661ea3ff1f14664ae0ba.jpg)  

若删除的是 $T_{\parallel}$ 的非叶结点，且删除和插入操作后导致了平衡二叉树的调整，则该结点有可能通过旋转后继续变成非叶结点， $T_{1}$ 与 $T_{3}$ 相同。例如，如下图所示，删除结点2，用右孩子结点3填补，再插入结点2，平衡二叉树失衡调整，调整后的平衡二叉树和以前相同。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aaa01fa6cb5ec56375e69a522c869a72b953704fd0cf11b32fc43437d142956.jpg)  

32.B  

每个选项都逐一验证，选项B生成二叉排序树的过程如下图所示，显然错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/200820177957ee15e4eb3c9f6e86744c0dd2db0c2478eee8fc74fd1849303370.jpg)  

33.D  

关键字23的插入位置为25的左孩子，此时破坏了平衡的性质，需要对平衡二叉树进行调整。最小不平衡子树就是该树本身，插入位置在根结点的右子树的左子树上，因此需要进行RL旋转，RL旋转过程如下图所示，旋转完成后根结点的关键字为25，所以选D。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/964e6d538821f6beab710647587b6bd65b259e660d25419acb9a05269a421223.jpg)  

# 二、综合应用题  

01.【解答】  

先序序列为（50，38，30，45，40，48，70，60，75，80），二叉树的中序序列是一个有序序列，所以为（30,38，40，45，48，50，60，70，75，80），由先序序列和中序序列可以构造出对应的二叉树，如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e8352c6cc4340d5e771f7d9b0d954db2926162c7b9ecf27cafd20a6fb034d9e.jpg)  

查找成功的平均查找长度为  

$$
\mathrm{ASL}=(1\!\times\!1+2\!\times\!2+3\!\times\!4+4\!\times\!3)/10=2.9
$$  

图中的方块结点为虚构的查找失败结点，其查找路径为从根结点到其父结点（圆形结点）的结点序列，所以对应的查找失败平均长度为  

$$
\mathrm{ASL}=(3{\times}5+4{\times}6)/11=39/11
$$  

# 02.【解答】  

根据二叉排序树的定义，该序列所对应的二叉排序树如下图所示  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/98bb969effa80a78785a477d91aafc868a54ef5ca349485e71b06be2ff5dd08f.jpg)  

平均查找长度为 $\mathrm{ASL}=(1+2{\times}2+3{\times}3+4{\times}2+5{\times}2)/10=3.2$  

03.【解答】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/87e92e1261fb3e42755f1304eab95e621f370a86ba53f454d2123b41c55af0a0.jpg)  

第一步：插入结点34，23.15后，需要根结点34的子树做LL调整。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/147225c38e376997c8ee95b5b6237c773fed8ffde4d21a2cfd36e2f4dc993868.jpg)  

第二步：插入结点98.115后，需要根结点34的子树做RR调整。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4002ba341039ae309747a895cc3e4aee686217a98abd61089d381df4192dfdd9.jpg)  
第三步：插入结点28后，需要根结点23的子树做RL调整。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05536c6e8542eb0430d79c91ae1171417af3378dd638113342a5b9a5fd761913.jpg)  

第四步：插入结点107后，需要根结点98的子树做RL调整。  

04.【解答】  

当各关键字的查找概率相等时，最佳二叉排序树应是高度最小的二叉排序树。构造过程分两步走：首先对各关键字按值从小到大排序，然后仿照折半查找的判定树的构造方法构造二叉排序 树。这样得到的就是最佳二义排序树，结果如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c00a0b7152ef11d3113a91edbc8987195d90fa33fe1f1979b0d14a781472574d.jpg)  

05.【解答】  

对二义排序树来说，其中序遍历序列为一个递增有序序列。因此，对给定的二义树进行中序遍历，若始终能保持前一个值比后一个值小，则说明该二叉树是一棵二叉排序树。算法实现如下：  

KeyType predt  $=$  -32767;  

int JudgeBST（BiTree bt) int bl,b2; if(bt  $==$  NULL) returnl;  

l/predt为全局变量，的值，初值为-  

/空树  

b1  $=$  JudgeBsT(bt->lchild); //判断左子树是否是二叉排序树 if $\tt^{b1}\!\!=\!\!=\!\!0$ lpredt>=bt->data）//若左子树返回值为0或前驱大于或等于当前结点return0;//则不是二叉排序树predt=bt->data;//保存当前结点的关键字 ${\tt b}2{\tt=}$  JudgeBsT(bt->rchild); //判断右子树 return b2;//返回右子树的结果  

06.【解答】  

算法思想：设二叉树采用二叉链表存储结构。在二叉排序树中，查找一次就下降一层。因此，查找该结点所用的次数就是该结点在二义排序树中的层次。采用二义排序树非递归查找算法，用 $n$ 保存查找层次，每查找一次， $n$ 就加1，直到找到相应的结点。算法如下：  

int level（BiTree bt,BSTNode  ${\star_{\mathsf{P}}}$  int $\scriptstyle{\mathrm{~n}=0}$ 川统计查找次数BiTreet=bt; if(bt）  $!=$  NULL){  $\mathrm{n++}$  
while(t->data!=p->data){ if(p->data<t->data) /在左子树中查找 t=t->lchild; else //在右子树中查找 t=t->rchild;  $\mathrm{n++}$  /层次加1 return n;  

07.【解答】  

设置二叉树的平衡标记balance，以标记返回二叉树bt是否为平衡二叉树，若为平衡二叉树，则返回1，否则返回0：h为二义树bt的高度。采用后序遍历的递归算法：  

1）若bt为空，则高度为0，balance  $^{=1}$  

2）若bt仅有根结点，则高度为1，balance  $^{=1}$  

3）否则，对bt的左、右子树执行递归运算，返回左、右子树的高度和平衡标记，bt的高度为最高子树的高度加1。若左、右子树的高度差大于1，则balance $\scriptstyle{i=0}$ ；若左、右子树的高度差小于或等于1，且左、右子树都平衡时，balance $^{=1}$ ，否则balance $_{:=0}$ 算法如下：  

void Judge AVL（BiTree bt,int &balance，int &h）{ int $_{b1=0}$ ,br $\scriptstyle{:=0}$  $_{\mathrm{h1}=0}$  $\scriptstyle\mathtt{h r}=0$ /左、右子树的平衡标记和高度if(bt  $==$  NULL){ /空树，高度为0  $\scriptstyle{\mathrm{h}}=0$  balance  $^{=1}$  } elseif（bt->lchild  $==$  NULL&&bt->rchild=  $=$  NULL）（//仅有根结点，则高度为1  $\mathtt{h}\!=\!\mathtt{1}$  balance  $^{=1}$  elsef JudgeAVL(bt->lchild,bl,hl); //递归判断左子树 Judge AvL(bt->rchild,br,hr); /递归判断右子树  $\mathrm{h}{=}$  (hl>hr?hl:hr)  $^{+1}$  if(abs(hl-hr) $^{<2}$ /若子树高度差的绝对值<2，则看左、右子树是否都平衡balance=bl&&br；//&&为逻辑与，即左、右子树都平衡时，二叉树平衡else balance  $=\!0$  

08.【解答】  

在一棵二叉排序树中，最左下结点即为关键字最小的结点，最右下结点即为关键字最大的结点，本算法只要找出这两个结点即可，而不需要比较关键字。算法如下：  

KeyType MinKey(BSTNode\*bt) while(bt->lchild!  $=$  NULL) bt=bt->lchild; return bt->data;  

KeyType MaxKey（BSTNode\*bt) 求出二叉排序树中最大关键字结点  
while(bt->rchild!  $=$  NULL) bt  $=$  bt->rchild; return bt->data;  

09.【解答】  

由二义排序树的性质可知，右子树中所有的结点值均大于根结点值，左子树中所有的结点值均小于根结点值。为了从大到小输出，先遍历右子树，再访问根结点，后遍历左子树。算法如下：  

{//本算法从大到小输出二叉排序树中所有值不小于 $\kappa$ 的关键字  

if(bt  $==$  NULL) return; if(bt->rchild！  $=$  NULL) OutPut（bt->rchild,k);/递归输出右子树结点if(bt->data>  $\mathbf{\Psi}^{=}\mathbf{k}$  printf("&d",bt->data); //只输出大于或等于  $\kappa$  的结点值 if(bt->lchild  $!=$  NULL) OutPut（bt->lchild,k);/递归输出左子树的结点  

本题也可采用中序遍历加辅助栈的方法实现。  

10.【解答】  

设二叉排序树的根结点为\*t，根据结点存储的信息，有以下几种情况：  

当t->lchild为空时，情况如下：  

1）若t->rchild非空且 $\kappa{=}{1}$ ，则 $\star_{\mathsf{C}}$ 即为第 $\kappa$ 小的元素，查找成功。2）若t->rchild非空且 $\mathtt{k H}\!=\!\mathtt{1}$ ，则第 $\kappa$ 小的元素必在\*t的右子树。  

当t->lchild非空时，情况如下：  

1)t->lchild->count  $==\!\!1\!\!-\!1$  ，  $\star_{\mathsf{C}}$  即为第  $\mathtt{k}$  小的元素，查找成功 2)t->lchild->count>k-1，第 $\boldsymbol{\mathrm{k}}$ 小的元素必在 $\star_{\mathsf{C}}$ 的左子树，继续到 $\star_{\mathsf{C}}$ 的左子树中查找。3)t->lchild->count<k-1，第 $\boldsymbol{\mathrm{k}}$ 小的元素必在右子树，继续搜索右子树，寻找第k-（t->lchild->count $^{+1}$ ）小的元素。  

对左右子树的搜索采用相同的规则，递归实现的算法描述如下：  

BSTNode\*Search Small BST Node\*t,intk){ //在以t为根的子树上寻找第 $\kappa$ 小的元素，返回其所在结点的指针。 $\kappa$ 从11开始计算/在树结点中增加一个count数据成员，存储以该结点为根的子树的结点个数if(k<lllk>t->count)return NuLL; if(t->lchild=  $=$  NULL){ if(  $\kappa{=}{1}$  ）return t; else return Search Small(t->rchild,k-l); elset if(t->lchild->count  $==\!\!1\!\!-\!1$  )return t; if(t->lchild->count>k-1) return Search Small(t->lchild,k); if(t->lchild->count<k-1) return Search Small(t->rchild,k-(t->lchild->count+1));  

最大查找长度取决于树的高度。由于二叉排序树是随机生成的，其高度应是 $O(\log_{2}\!n)$ ，算法的时间复杂度为 $O(\log_{2}n)$  
# B树和  $\mathbf{B}+$  树  

考研大纲对B树和 $^{\mathrm{B+}}$ 树的要求各不相同，重点在于考查B树，不仅要求理解B树的基本特点，还要求掌握B树的建立、插入和删除操作，而对 $^{\mathrm{B+}}$ 树则只考查基本概念。  

# 7.4.1B树及其基本操作  

所谓 $m$ 阶B树是所有结点的平衡因子均等于0的 $m$ 路平衡查找树。  

# 命题追踪B树的定义和特点（2009）  

一棵 $m$ 阶B树或为空树，或为满足如下特性的 $m$ 叉树：  

1）树中每个结点至多有 $m$ 棵子树，即至多有 $m-1$ 个关键字。2）若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字。3）除根结点外的所有非叶结点至少有 $\lceil m/2\rceil$ 棵子树，即至少有 $\lceil m/2\rceil_{-1}$ 个关键字。  

4）所有非叶结点的结构如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/641123898fc54d168c81307aaa0f46a0aeb4dc3c39dc6bc0add67a795683e706.jpg)  

其中， $K_{i}$  $(i=1,2,\cdots,n)$ 为结点的关键字，且满足 $K_{1}<K_{2}<\cdots<K_{n};\,\,\,P_{i}\,\,(i=0,\,1,\cdots,n)$ 为指向子树根结点的指针，且指针 $P_{i+1}$ 所指子树中所有结点的关键字均小于 $K_{i}$ ， $P_{i}$ 所指子树中所有结点的关键字均大于 $K_{i}$ ； $n~(\lceil m/2\rceil\!-\!1\!\leqslant\!n\!\leqslant\!m-1)$ 为结点中关键字的个数。  

5）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的失败结点，实际上这些结点并不存在，指向这些结点的指针为空）。  

# 命题追踪B树中关键字数和结点数的分析（2013、2014、2018、2021）  

图7.28所示为一棵5阶B树，可以借助该实例来分析上述性质：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3296559c5d2d7110e03f8b45bfcbf4ee8b8931f234697bbe0eba579683969db7.jpg)  
图7.28一棵5阶B树的实例  

1）结点的孩子个数等于该结点中关键字个数加1。  

2）若根结点没有关键字就没有子树，则此时B树为空；若根结点有关键字，则其子树个数必然大于或等于2，因为子树个数等于关键字个数加1。  

3）除根结点外的所有非叶结点至少有 $\scriptstyle{m/2}\,=\,\left\lceil5/2\right\rceil=3$ 棵子树（即至少有 $\lceil m/2\rceil\!-1\!=\!\lceil5/2\rceil\!-1=$  
2个关键字）；至多有5棵子树（即至多有4个关键字）。  

4）结点中的关键字从左到右递增有序，关键字两侧均有指向子树的指针，左侧指针所指子树的所有关键字均小于该关键字，右侧指针所指子树的所有关键字均大于该关键字。或者看成下层结点的关键字总是落在由上层结点的关键字所划分的区间内，如第二层最左结点的关键字划分成了3个区间： $(-\infty,5),(5,11),(11,+\infty)$ ，该结点中的3个指针所指子树的关键字均分别落在这3个区间内。  

5）所有叶结点均在第4层，代表查我失败的位置。  

# 1.B树的查找  

在B树上进行查找与二叉排序树很相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。  

B树的查找包含两个基本操作： $\textcircled{\scriptsize{1}}$ 在B树中找结点； $\textcircled{2}$ 在结点内找关键字。由于B树常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查我操作是在内存中进行的，即在磁盘上找到目标结点后，先将结点信息读入内存，然后再采用顺序查找法或折半查找法。因此，在磁盘上进行查找的次数即目标结点在B树上的层次数，决定了B树的查找效率。  

在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找（例如，在图7.28中查找关键字42，首先从根结点开始，根结点只有一个关键字，且 $42>22$ ，若存在，必在关键字22的右边子树上，右孩子结点有两个关键字，而 $36<42<45$ ，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查我成功)。查找到叶结点时（对应指针为空），则说明树中没有对应的关键字，查找失败。  

# 2.B树的高度（磁盘存取次数）  

由上一节得知，B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。  

下面来分析B树在不同情况下的高度。当然，首先应该明确B树的高度不包括最后的不带任何信息的叶结点所处的那一层（有些书对B树的高度的定义中，包含最后的那一层）。  

若 $n\!\geqslant\!1$ ，则对任意一棵包含 $n$ 个关键字、高度为 $h$ 、阶数为 $m$ 的B树：1）若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小。  

因为B树中每个结点最多有 $m$ 棵子树， $m-1$ 个关键字，所以在一棵高度为 $h$ 的 $m$ 阶B树中关键字的个数应满足 $n\!\leqslant\!(m-1)(1+m+m^{2}+\cdots+m^{h-1})=m^{h}-1$ ，因此有  

$h\geqslant\log_{m}\left(n+1\right)$  

2）若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大。  

第一层至少有1个结点；第二层至少有2个结点：除根结点外的每个非叶结点至少有 $\lceil m/2\rceil$ 棵子树，则第三层至少有 $2\left\lceil m/2\right\rceil$ 个结点第 $h+1$ 层至少有 $2(\lceil m/2\rceil)^{h-1}$ 个结点，注意到第 $h+1$ 层是不包含任何信息的叶结点。对于关键字个数为 $n$ 的B树，叶结点即查找不成功的结点为 $n+1$ ，由此有 $n+1\!\geqslant\!2(\lceil m/2\rceil)^{h-1}$ ，即 $h{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1.$  

例如，假设一棵3阶B树共有8个关键字，则其高度范围为 $2\!\leqslant\!h\!\leqslant\!3.17$ ，取整数。  

# 3.B树的插入  

# 命题追踪通过插入操作构造一棵初始为空的B树（2020）  

与二叉排序树的插入操作相比，B树的插入操作要复杂得多。在B树中查找到插入的位置后，并不能简单地将其添加到终端结点（最底层的非叶结点）中，因为此时可能会导致整棵树不再满足B树定义中的要求。将关键字key插入B树的过程如下：  
1）定位。利用前述的B树查找算法，我出插入该关键字的终端结点（在B树中查找key时，会找到表示查找失败的叶结点，因此插入位置一定是最底层的非叶结点）。  

2）插入。每个非根结点的关键字个数都在  $[\lceil m/2\rceil\!-\!1,\,m\!-\!1]$  。若结点插入后的关键字个数小 于 $m$ ，可以直接插入；若结点插入后的关键字个数大于 $m-1$ ，必须对结点进行分裂。  

分裂的方法是：取一个新结点，在插入key后的原结点，从中间位置 $(\lceil m/2\rceil)$ 将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置 $(\lceil m/2\rceil)$ 的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。  

对于 $m=3$ 的B树，所有结点中最多有 $m-1=2$ 个关键字，若某结点中已有两个关键字，则结点已满，如图7.29(a)所示。插入一个关键字60后,结点内的关键字个数超过了 $m-1$ ,如图7.29(b)所示，此时必须进行结点分裂，分裂的结果如图7.29（c)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80d65ed644ea63d8e94f85979f930603e6eb9b46bb9c910cd6cf03ad6c8bf748.jpg)  
图7.29结点的“分裂”示意  

# 4.B树的删除  

B树的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数≥m/21-1，因此将涉及结点的“合并”问题。  

# 命题追踪B树的删除操作的实例（2012、2022）  

当被删关键字 $k$ 不在终端结点中时，可以用 $k$ 的前驱（或后继） $k^{\prime}$ ，即 $k$ 的左侧子树中“最右下”的元素（或右侧子树中“最左下”的元素），来替代 $k$ ，然后在相应的结点中删除 $k^{\prime}$ ，关键字 $k^{\prime}$ 必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在图7.30的4阶B树中，删除关键字80，用其前驱78替代，然后在终端结点中删除78。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7238b2b80bcf193f427d7371143169091e88dc7e89de6a71f0c30816046d808c.jpg)  
图7.30B树中删除非终端结点关键字的取代  

因此只需讨论被删关键字在终端结点中的情形，有下列三种情况：  

1）直接删除关键字。若被删关键字所在结点删除前的关键字个数 $\geqslant\!\lceil m/2\rceil$ ，表明删除该关键字后仍满足B树的定义，则直接删去该关键字。  

2）兄弟够借。若被删关键字所在结点删除前的关键字个数 $\scriptstyle[=\lceil m/2\rceil-1$ ，且与该结点相邻的右（或左）兄弟结点的关键字个数 $\geqslant\!\left\lceil m/2\right\rceil$ ，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡。在图7.31(a)中删除4阶B树的关键字65，右兄弟关键字个数 $\geqslant\!\left\lceil m/2\right\rceil\!=2$ ，将71取代原65的位置，将74调整到71的位置。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/215b6baf0ac411ac31105377425b16f9f12f9828b89f9a64b2c180cfee010990.jpg)  
图7.314阶B树中删除终端结点关键字的示意图  

3）兄弟不够借。若被删关键字所在结点删除前的关键字个数 $\scriptstyle\cdot=\left\lceil m/2\right\rceil-1$ ，且此时与该结点相邻的左、右兄弟结点的关键字个数都 $\scriptstyle\left\langle=\left\lceil m/2\right\rceil-1$ ，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。在图7.31（b）中删除4阶B树的关键字5，它及其右兄弟结点的关键字个数 $\it{\Delta}=\left\lceil m/2\right\rceil-1=1$ ，所以在5删除后将60合并到65结点中。  

# 命题追踪非空B树的查找、插入、删除操作的特点（2023）  

在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根：若双亲结点不是根结点，且关键字个数减少到 $\lceil m/2\rceil_{-2}$ ，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。  

# 7.4.2 $\mathbf{B}+$ 树的基本概念  

# 命题追踪 $^{\mathsf{B}+}$ 树的应用场合（2017）  

$^{\mathrm{B+}}$ 树是应数据库所需而出现的一种B树的变形树。一棵 $m$ 阶 $^{\mathrm{B+}}$ 树应满足下列条件  

1）每个分支结点最多有 $m$ 棵子树（孩子结点）。2）非叶根结点至少有两棵子树，其他每个分支结点至少有 $\lceil m/2\rceil$ 棵子树3）结点的子树个数与关键字个数相等。4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）。5）所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。  

# 命题追踪B树和 $^{\mathsf{B}+}$ 树的差异的分析（2016）  

$m$ 阶 $^{\mathrm{B+}}$ 树与 $m$ 阶B树的主要差异如下  

1）在 $^{\mathrm{B+}}$ 树中，具有 $n$ 个关键字的结点只含有 $n$ 棵子树，即每个关键字对应一棵子树：而在 $n+1$  

B树中，具有 $n$ 个关键字的结点含有棵子树。2）在 $\mathbf{B}+$ 树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\lceil m/2\rceil{\leqslant}n{\leqslant}m$ （非叶根结点： $2\!\leqslant\!n\!\leqslant\!m)$ ：而在B树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\lceil m/2\rceil_{-1}$  ${\leqslant}n{\leqslant}m-1$ （根结点： $1\!\leqslant\!n\!\leqslant\!m\!-\!1!$ 。  
3）在 $^{\mathrm{B+}}$ 树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。  

4）在 $^{\mathrm{B+}}$ 树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快。  

5）在 $^{\mathrm{B+}}$ 树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表。  

图7.32所示为一棵4阶B+树。可以看出，分支结点的关键字是其子树中最大关键字的副本。通常在 $^{\mathrm{B+}}$ 树中有两个头指针：一个指尚根结点，另一个指向关键字最小的叶结点。因此，可以对 $^{\mathrm{B+}}$ 树进行两种查找运算：一种是从最小关键学开始的顺序查找，另一种是从根结点开始的多路查找  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db9dc115f173d19c088aab329b4f42f2125e735f6d5222eacbec4640c3e2ffab.jpg)  
图7.32B+树结构示意图  

$^{\mathrm{B+}}$ 树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。所以，在 $^{\mathrm{B+}}$ 树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。  

# 7.4.3 本节试题精选  

# 一、单项选择题  

01.下图所示是一棵（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1ac19a6ecb5d0be8b5a3089fba49718c702d91b1d8fb04ba5e110211820e4c7a.jpg)  

A.4阶B树B.3阶B树C.4阶 $^{\mathrm{B+}}$ 树D.无法确定02.下列关于 $m$ 阶B树的说法中，错误的是（）。  

A.根结点至多有  $m$  棵子树 B.所有叶结点都在同一层次上C.非叶结点至少有  $m/2$  (  $m$  为偶数）或  $(m+1)/2$  (  $m$  为奇数）棵子树 D.根结点中的数据是有序的  

03.以下关于 $m$ 阶B树的说法中，正确的是（）。  

1.每个结点至少有两棵非空子树 11.树中每个结点至多有 $m\!-\!1$ 个关键字I1I所有叶结点在同一层IV.插入一个元素引起B树结点分裂后，树长高一层  
A.I、IIB.II、IIC.III、IVD.I、II、IV  

04.在一棵 $m$ 阶B树中做插入操作前，若一个结点中的关键字个数等于（），则插入操作后必须分裂成两个结点；在一棵 $m$ 阶B树中做删除操作前，若一个结点中的关键字个数等于（），则删除操作后可能需要同它的左兄弟或右兄弟结点合并成一个结点。  

A.  $m$   $\lceil m/2\rceil_{-2}$  B.m-1，[m/2]-1 C.  $m+1$   $\lceil m/2\rceil$  D.m/2,  $\lceil m/2\rceil+1$  

05.具有 $n$ 个关键字的 $m$ 阶B树，应有（）个叶结点。A.  $n+1$  B.  $n-1$  C.mn D.nm/2

 06.高度为5的3阶B树至少有（）个结点，至多有（）个结点。A.32 B.31 C.120 D.121

 07.含有 $n$ 个非叶结点的 $m$ 阶B树中至少包含（）个关键字。A.  $n(m+1)$  B.  $n$  C.  $n(\lceil m/2\rceil_{-1})$  D.  $(n-1)(\lceil m/2\rceil\!-\!1)+1$  08.已知一棵5阶B树中共有53个关键字，则树的最大高度为（），最小高度为（）。A.2B.3C.4D.5

09.已知一棵3阶B树中有2047个关键字，则此B树的最大高度为（），最小高度为（）。A.11 B.10 C.8 D.7

 10.下列关于B树和 $\mathbf{B}+$ 树的叙述中，不正确的是（）。  

A.B树和 $^{\mathrm{B+}}$ 树都能有效地支持顺序查找B.B树和 $\mathbf{B}+$ 树都能有效地支持随机查找C.B树和  $\mathbf{B}+$  树都是平衡的多叉树 D.B树和 $^{\mathrm{B+}}$ 树都可以用于文件索引结构  

11.在7阶B树中搜索第2016个关键字，若根结点已读入内存，则最多需启动（）次1/OA.4 B.5 C.6 D.7  

12.【2009统考真题】下列叙述中，不符合 $m$ 阶B树定义要求的是（）。  

A.根结点至多有 $m$ 棵子树B.所有叶结点都在同一层上C.各结点内关键字均升序或降序排列 D.叶结点之间通过指针链接  

13.【2012统考真题】已知一棵3阶B树，如下图所示。删除关键字78得到一棵新B树，其最右叶结点中的关键字是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a786127a16bf8bcbf4297060523f4f656161e7ac19fd06e281a471ae5b332eda.jpg)  

A.60 B.60,62 C.62,65 D.65

 14.【2013统考真题】在一棵高度为2的5阶B树中，所含关键字的个数至少是（）A.5 B.7 C.8 D.14

 15.【2014统考真题】在一棵有15个关键字的4阶B树中，含关键字的结点个数最多是（）。A.5 B.6 0 C.10 D.15

 16.【2016统考真题】 $^{\mathrm{B+}}$ 树不同于B树的特点之一是（）  

A.能支持顺序查找B.结点中含有关键字C.根结点至少有两个分支D.所有叶结点都在同一层上  
17.【2017统考真题】下列应用中，适合使用 $^{\mathrm{B+}}$ 树的是（）  

A.编译器中的词法分析B.关系数据库系统中的索引C.网络中的路由表快速查找D.操作系统的磁盘空闲块管理  

18.【2018统考真题】高度为5的3阶B树含有的关键字个数至少是（）A.15 B.31 C.62 D.242  

19.【2020统考真题】依次将关键字5，6，9，13，8，2，12，15插入初始为空的4阶B树后，根结点中包含的关键字是（）。  

A.8 B.6,9 C.8,13 D.9,12  

20.【2021统考真题】在一棵高度为3的3阶B树中，根为第1层，若第2层中有4个关键字，则该树的结点数最多是（）。  

A.11K B.10 C.9 D.8  

21.【2022统考真题】在下图所示的5阶B树 $T$ 中，删除关键字260之后需要进行必要的调整，得到新的B树 $T_{1\circ}$ 下列选项中，不可能是 $T_{1}$ 根结点中关键字序列的是（）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f3a2b9d42d3ee340695a6f6dbb54a8d6f9eec22569ffef599a94af089d854a8d.jpg)  

A.60,90,280 B.60,90,350 C.60,85,110,350 D.60,90,110,350  

22.【2023统考真题】下列关于非空B树的叙述中，正确的是（）。  

I.插入操作可能增加树的高度11.删除操作一定会导致叶结点的变化III.查找某关键字总是要查找到叶结点IV.插入的新关键字最终位于叶结点中  

A.仅IB.仅I、ⅡIC.仅IⅢI、IVD.仅I、Ⅱ、IV  

# 二、综合应用题  

01.给定一组关键字20，30.50，52.60，68.70，给出创建一棵3阶B树的过程。  

02.对如下图所示的3阶B树，依次执行下列操作，画出各步操作的结果。1）插入90 2）插入25 3）插入45 4）删除60 5）删除80  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a49427774f9917d43cdfcc10a2f671cb4d94c024b87f657aae9324cb2bb34312.jpg)  

03.利用B树做文件索引时，若假设磁盘页块的大小是4000B（实际应是2的次幂，此处是为了计算方便），指示磁盘地址的指针需要5B。现有20000000个记录构成的文件，每个记录为200B，其中包括关键字5B。  

试问在这个采用B树作索引的文件中，B树的阶数应为多少？假定文件数据部分未按关键字有序排列，则索引部分需要占用多少磁盘页块？  

# 7.4.4 答案与解析  

# 一、单项选择题  

01.D  

关键字数目比子树数目少1，首先可排除 $^{\mathrm{B+}}$ 树。对于4阶B树，根结点至少有2棵子树（关键字数至少为1)，其他非叶结点至少有 $\overset{\cdot}{n}/2\,\overset{\cdot}{\left}\,=2\right$ 棵子树（关键字数至少为1）、至多有4棵子树（关键字数至多为3）。5阶B树和6阶B树的分析也类似。题目所示的B树，同时满足4阶B树、5阶B树和6阶B树的要求，因此不能确定是哪种类型的B树。  
02.C  

除根结点外的所有非叶结点至少有 $\dot{}_{m/2}$ 棵子树。对于根结点，最多有 $m$ 棵子树，若其不是叶结点，则至少有2棵子树。  

03.B  

每个非根的内部结点必须至少有 $\lceil m/2\rceil$ 棵子树，而根结点至少要有两棵子树，所以选项I不正确。选项ⅡI、ⅢI显然正确。对于IV，插入一个元素引起B树结点分裂后，只要从根结点到该元素插入位置的路径上至少有一个结点未满，B树就不会长高，如图1所示；只有当结点的分裂传到根结点，并使根结点也分裂时，才会导致树高增1，如图2所示，因此选项IV错误。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6b70ea789351b9436e9ce2a3bf9da40873cc2757acd01ee0f1573c4de34bd70f.jpg)  
图1结点分裂不导致树高增1（3阶B树）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ec8ae0dd430f2a129d4c07e31e6fb710c86e06f5d28ce3d315106a797815c733.jpg)  
图2结点分裂导致树高增1（3阶B树）  

04.B  

由于B树每个结点内的关键字个数最多为 $m-1$ ，所以当关键字个数大于 $m-1$ 时，则应该分裂。每个结点内的关键字个数至少为 $\bar{m}/2^{\top}\!\!-1$ 个，所以当关键字个数少于 $\lceil m/2\rceil_{-1}$ 时，则可能与其他结点合并（除非只有根结点）。若将本题题干改为 $^{\mathrm{B+}}$ 树，请读者思考上述问题的解答。  

05. A  

B树的叶结点对应查找失败的情况，对有 $n$ 个关键字的查找集合进行查找，失败可能性有 $^{n+}$ 1种。  

06.B、D  

由 $m$ 阶B树的性质可知，根结点至少有2棵子树；根结点外的所有非终端结点至少有 $\left\lceil m/2\right\rceil$ 棵子树，结点数最少时，3阶B树形状至少类似于一棵满二叉树，即高度为5的B树至少有 $2^{5}\!-\!1\!=$ 31个结点。由于每个结点最多有 $m$ 棵子树，所以当结点数最多时，3阶B树形状类似于满三叉树，结点数为 $(3^{5}-1)/2=121$ （注意，这里求的是结点数而非关键字数，若求的是关键字数，则还应把每个结点中关键字数的上下界确定出来）。  

# 07.D  

除根结点外， $m$ 阶B 树中的每个非叶结点至少有 $\lceil m/2\rceil_{-1}$ 个关键字，根结点至少有一个关键字，所以总共包含的关键字最少个数 $=(n-1)(\lceil m/2\rceil_{-}1)+1$  

> attention:  

由以上题目可知B树和 $^{\mathrm{B+}}$ 树的定义与性质尤为重要，需要熟练掌握。  
08.C、B  

5阶B树中共有53个关键字，由最大高度公式 $H{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1$ 得最大高度 $H\leqslant$  $\log_{3}[(53+1)/2]+1=4$ ，即最大高度为4；由最小高度公式 $h{\geqslant}\log_{m}(n+1)$ 得最小高度 $h\!\gg\!\log_{5}\!54\!\approx\!2.5$ 从而最小高度为3。  

09.A、D  

利用前面的公式即最小高度 $h{\geqslant}\log_{m}(n+1)$ 和最大高度 $H{\leqslant}\log_{\lceil m/2\rceil}[(n+1)/2]+1$ ，易算出最大高度 $H{\leqslant}\log_{2}[(2047+1)/2]+1=11$ ，最小高度 $h\!\geq\!\log_{3}\!2048=6.9$ ，从而最小高度取7（注意，有些辅导书针对本题算出的高度要比这里给出的答案多1，因为它们在对B树的高度定义中，把最底层不包含任何关键字的叶结点也算进去了）。  

10.A  

B树和 $^{\mathrm{B+}}$ 树的差异主要体现在： $\textcircled{\scriptsize{1}}$ 结点关键字和子树的个数： $^{\textregistered}\mathrm{B}^{+}$ 树非叶结点仅起索引作用： $(\mathbf{\mathcal{3}})\mathbf{B}$ 树叶结点关键字和其他结点包含的关键字是不重复的： $\textcircled{4}$ B+树支持顺序查找和随机查找，而B树仅支持随机查找。由于 $^{\mathrm{B+}}$ 树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，因此可以进行顺序查找，而B树不支持顺序查找。B树和 $\mathbf{B}+$ 树都可用于文件索引结构，但 $^{\mathrm{B+}}$ 树更适合做数据库索引和文件索引，因为它的磁盘读/写代价更低。  

11.A  

根据B树树高 $h$ 的计算公式： $\log_{m}(n+1){\leqslant}h{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1$ ，计算得 $h\!=\!5$ （取整数），因为B树的根结点已读入内存，所以最多需再启动4次磁盘 $\mathrm{I}/\mathrm{O}$  

12.D  

$m$ 阶B树不要求将各叶结点之间用指针链接。选项D描述的实际上是 $^{\mathrm{B+}}$ 树。  

13.D  

对于图中所示的3阶B树，被删关键字78所在的结点在删除前的关键字个数 $=1=\!\!\lceil3/2\rceil\!\!-\!\!1$ 且其左兄弟结点的关键字个数 $=2\!\geqslant\!\!\lceil3/2\rceil$ ，属于“兄弟够借”的情况，因此要把该结点的左兄弟结点中的最大关键字上移到双亲结点中，同时把双亲结点中大于上移关键字的关键字下移到要删除关键字的结点中，这样就达到了新的平衡，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84cffa5a4e36be277510866df229dad3433a44c6c4593cd4b7a91f8f06bd4432.jpg)  

14.A  

对于5阶B树，根结点的分支数最少为2（关键字数最少为1），其他非叶结点的分支数最少为 $\left\lceil n/2\right\rceil=3$ （关键字数最少为2），因此关键字个数最少的情况如下图所示（叶结点不计入高度）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f8f59e804ac095fa4ad361b3178550c2a93112e18e01d3c4093a9e714ac51c16.jpg)  
> attention:  

一般对于某个具体的B树图形，并不能确定是几阶B树。对于本题所述的5阶B树，不要误认为：“存在至少有一个含关键字结点中的关键字达到 $4^{\circ}$ 才符合5阶B树的要求，因为5阶B树中各个结点包含的关键字个数最少为2（ $\lceil5/2\rceil_{-1}=2$ )，最多为4 ( $5\!-\!1=\!4$ )。当5阶B树中各个结点包含的关键字个数为2时，也满足5阶B树的要求。  

15.D  

关键字数量不变，要求结点数量最多，即要求每个结点中含关键字的数量最少。根据4阶B树的定义，根结点最少含1个关键字，非根结点中最少含  $\lceil4/2\rceil-1=1$  个关键字，所以每个结 点中关键字数量最少都为1个，即每个结点都有2个分支，类似于排序二叉树，而15个结点正好可以构造一个4层的4阶B树，使得终端结点全在第四层，符合B树的定义，因此选D。  

16.A  

由于 $^{\mathrm{B+}}$ 树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，因此可以进行顺序查找，而B树不支持顺序查找（只支持多路查找）。  

17. B  

$^{\mathrm{B+}}$ 树是应文件系统所需而产生的B树的变形，前者比后者更加适用于实际应用中的操作系统的文件索引和数据库索引，因为前者的磁盘读/写代价更低，查询效率更加稳定。编译器中的词法分析使用有穷自动机和语法树。网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法。系统一般使用空闲空间链表管理磁盘空闲块。  

18.B  

$m$ 阶B树的基本性质：根结点以外的非叶结点最少含有 $\lceil m/2\rceil_{-1}$ 个关键字，代入 $m=3$ 得到每个非叶结点中最少包含1个关键字，而根结点含有1个关键字，因此所有非叶结点都有两个孩子。此时其树形与  $h=5$  的满二叉树相同，可求得关键字最少为31个。  

19.B  

一个4阶B树的任意非叶结点至多含有 $m\!-\!1\!=\!3$ 个关键字，在关键字依次插入的过程中，会导致结点的不断分裂，插入过程如下图所示。得到根结点包含的关键字为6,9。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d973b047763897bf348baea36055d366507ab95fbb33e08e0c536905e65e903d.jpg)  

20. A  

在阶为3的B树中，每个结点至多含有2个关键字（至少1个），至多有3棵子树。本题规定第二层有4个关键字，欲使B树的结点数达到最多，则这4个关键字包含在3个结点中，B树树形如下图所示，其中A,B,C,，M表示关键字，最多有11个结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1876fb411dc415a97896e022a84ffdce44ee8c844cd9ba4feb4002883493f38a.jpg)  
21.D  

在5阶B树中，除根结点外的非叶结点的关键字数 $k$ 需要满足 $2\leqslant k\leqslant4$ 。当被删关键字x不在终端结点（最底层非叶结点）时，可以用x的前驱（或后继）关键字V来替代 $_\mathrm{x}$ ，然后在相应结点中删除y。情况  $\textcircled{\scriptsize{1}}$  ：删除260，将其前驱110放入260处，删除110后的结点  $<\!100\!>$  不满足 5阶B树定义，从左兄弟中借85，将85放入根中，将根中的90移入结点 $<\!100\!>$ 变为 $\mathord{\lvert<\!90}$  $100{>}$ 情况 $\circledcirc$ ：删除260，将其后继280放入260处，结点 $<\!300\!>$ 不满足5阶B树定义且左右兄弟都不够借，结点 $<\!300\!>$ 可以和左兄弟 $\mathord{<}100$  $110\substack{>}$ 以及关键字280合并成一个新的结点 ${<}100$ 110,280, $300{>}$ 。情况 $\textcircled{3}$ ：在情况 $\circledcirc$ 中，结点 $<\!300\!>$ 也可以和右兄弟 ${\tt<}400$ .500>以及关键字350合并成一个新的结点 $<\!300.$ ,350, 400, $500\substack{>}$ 。综上， $T_{1}$ 根结点中的关键字序列可能是 ${<\!60}$ 85,110,350>或 ${\mathord{<}}60,$ 90, $350{>}$ 或 ${\tt<}60$ 90, $280{>}$ ，仅D不可能。  

快速解法：假如选项D的60,90,110,350作为根结点，则在90和110之间只有100这一个数据，显然不符合5阶B树的定义，因此D项不可能。  

22.B  

B树的插入操作可能导致叶结点分裂，而叶结点分裂可能导致父结点分裂，若这个分裂过程传导到根结点，则会导致B树高度增1，I正确。若被删结点是叶结点，则显然会导致叶结点变 化；若被删结点不是叶结点，则要先将被删结点和它的前驱或后继交换，最终转换为删除叶结点，还是导致叶结点变化，Ⅱ正确。若在非叶结点中查找到了给定的关键字，则不用向下继续查找， ⅢI错误。插入关键字的初始位置是最底层叶结点，但可能因结点分裂而被转移到父结点中，IV错误。  

# 二、综合应用题  

# 01.【解答】  

$m=3$ ，因此除根结点外，非叶结点关键字个数为 $_{1\sim2}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8250b9758269a977f34e3cef30fdda41fdef47e0b546280a99d3e28470950f2.jpg)  

如上图所示，首先插入20，30，结点内关键字个数不超过 $m-1=2$ ，不会引起分裂；插入50，插入20,30所在的结点，引起分裂，结点内第 $\lceil m/2\rceil$ 个关键字30上升为父结点。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1babae086f1fd49f6dc59ecc541439f4f994923be9710fd264a4ce098a39a207.jpg)  

如上图所示，插入52，插入50所在的结点，不会引起分裂；继续插入60，插入50.52所在的结点，引起分裂，52上升到父结点中，不会引起父结点的分裂。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5cca2de7289e0f067eb089a65d7e23d55a4199971a31bb96620b3482cc1c3585.jpg)  

如上图所示，插入68，插入60所在的结点，不会引起分裂；继续插入70，插入60,68所在的结点，引起分裂，68上升为新的父结点，68上升到30.52所在的结点后，会继续引起该结点的分裂，所以52上升为新的根结点。最后得到的B树如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5063156976442bac31f278c2809bfc32599ef28647f038954981baefcccc6620.jpg)  

# 02.【解答】  

1）插入90：将90插入100所在的结点，插入90后该结点中的元素个数不超过 $\left\lceil3/2\right\rceil=2$ 不会引起结点的分裂，插入后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92ea03be230fd165f2eccc0a312692706a04fee071d58beaf48797db372afd18.jpg)  

2）插入25：将25插入8，20所在的结点，插入后结点内的元素个数为3，引起分裂。所以将结点内的中间元素20上升到父结点中，此时父结点中的元素个数为2（元素20和30）不会引起继续分裂，插入25后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1953444666fce4e5c614460b7334ef98bf1c8bc6aba164f11c5e74923f7ad73.jpg)  

3）插入45：将45插入35，40所在的结点，引起分裂，中间元素40上升到父结点（20，30所在的结点）中，引起父结点分裂，中间元素30上升到父结点（50所在的结点）中，两次分裂后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e33900611d2dd51774b8b72702b89f90933940171e0e6d3103ef1ffe77da326.jpg)  

4）删除60：删除60后，其所在的结点元素为空，从而导致借用右兄弟结点的元素，调整后的B树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7ea07cf34b158b258e09049544dd929fbac26b467f0056fcdb6617f41723c202.jpg)  

5）删除80：删除80后，导致80所在结点的父结点与其右兄弟结点合并，这时父结点元素个数为0，再次对父结点进行调整。将50与40合并成一个新结点，则90.100所在结点为这个结点的子结点。从而构造的B树如下图所示。注意，这次调整的过程实际上包含多次调整过程，希望读者对照考点讲解中的删除过程仔细思考。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d40411ff0fb9b2ee27179dc17e36e4b5e15242536957796ca4fce04a5553f149.jpg)  

> attention:  

B树中结点的插入、删除操作（特别是插入、删除后的结点分裂与合并）是本节的重点，也是难点，请读者务必熟练掌握。  

03.【解答】  

根据B树的概念，一个索引结点应适应操作系统一次读/写的物理记录大小，其大小应取不超过但最接近一个磁盘页块的大小。假设B树为 $m$ 阶，一个B树结点最多存放 $m-1$ 个关键字（5B）和对应的记录地址（5B）、 $m$ 个子树指针（5B）和1个指示结点中的实际关键字个数的整数（2B），则有  

$$
(2{\times}(m-1)+m){\times}5+2{\leqslant}4000
$$  

计算结果为 $m{\leqslant}267$  

一个索引结点最多可以存放 $m\!-\!1=\!266$ 个索引项，最少可以存放 $\lceil m/2\rceil\!-\!1=133$ 个索引项。全部有 $n\,{=}\,20000000$ 个记录，每个记录占用空间200B，每个页块可以存放 $4000/200=20\$ 个记录，则全部记录分布在 $2000000/20=1000000$ 个页块中，最多需要占用 $1000000/133=7519$ 个磁盘页块作为B树索引，最少需要占用 $1000000/266=3760$ 个磁盘页块作为B树索引（注意B树与 $^{\mathrm{B+}}$ 树的不同，B树所有对数据记录的索引项分布在各个层次的结点中， $^{\mathrm{B+}}$ 树所有对数据记录的索引项都在叶结点中）。  

# 7.5散列（Hash）表  

# 7.5.1散列表的基本概念  

在前面介绍的线性表和树表的查找中，查找记录需进行一系列的关键字比较，记录在表中的位置与记录的关键字之间不存在映射关系，因此在这些表中的查找效率取决于比较的次数。  

散列函数（也称哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 $\operatorname{Hash}(\ker)=$ Addr（这里的地址可以是数组下标、索引或内存地址等）。  

散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生冲突的不同关键字称为同义词。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。  

散列表（也称哈希表）：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。  

理想情况下，对散列表进行查找的时间复杂度为 $O(1)$ ，即与表中元素的个数无关。下面分别介绍常用的散列函数和处理冲突的方法。  

# 7.5.2散列函数的构造方法  

在构造散列函数时，必须注意以下几点：  

1）散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小  
2）散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。  

3）散列函数应尽量简单，能在较短的时间内计算出任意一个关键字对应的散列地址。  

下面介绍常用的散列函数。  

# 1.直接定址法  

直接取关键字的某个线性函数值为散列地址，散列函数为  

式中， $a$ 和 $b$ 是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。  

# 2.除留余数法  

这是一种最简单、最常用的方法，假定散列表表长为 $m$ ，取一个不大于 $m$ 但最接近或等于 $m$ 的质数 $p$ ，利用以下公式把关键字转换成散列地址。散列函数为  

$$
H(\mathrm{kcy})=\mathrm{kcy}\,\%\,p
$$  

除留余数法的关键是选好 $p$ ，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。  

# 3.数字分析法  

设关键字是 $r$ 进制数（如十进制数），而 $r$ 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。  

# 4.平方取中法  

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。  

在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况。  

# 7.5.3处理冲突的方法  

应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。用 $H_{i}$ 表示处理冲突中第 $i$ 次探测得到的散列地址，假设得到的另一个散列地址 $H_{1}$ 仍然发生冲突，只得继续求下一个地址 $H_{2}$ ，以此类推，直到 $H_{k}$ 不发生冲突为止，则 $H_{k}$ 为关键字在表中的地址。  

# 1.开放定址法  

所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为  

$$
H_{i}\,{=}\,(H(\mathrm{kcy})+d_{i})\,\%\,m
$$  

式中，H(key)为散列函数； $i=1,2,\cdots,k$  $.k{\leqslant}m-1)$ ； $m$ 表示散列表表长； $d_{i}$ 为增量序列。取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：  

# 命题追踪堆积现象导致的结果（2014）  

1）线性探测法，又称线性探测再散列法。 $d_{i}=1,2,\cdots,m-1$ 。它的特点是：冲突发生时，顺  
序查看表中下一个单元（探测到表尾地址 $m\!-\!1$ 时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。  

线性探测法可能使第 $i$ 个散列地址的同义词存入第 $i+1$ 个散列地址，这样本应存入第 $i+$ 1个散列地址的元素就争夺第 $i+2$ 个散列地址的元素的地址从而造成大量元素在相邻的散列地址上聚集（或堆积）起来，大大降低了查找效率。  

2）平方探测法，又称二次探测法。 $d_{i}=1^{2},-1^{2},2^{2},-2^{2},\cdots,k^{2},-k^{2}$ ，其中 $k{\leqslant}m/2$ ，散列表长度 $m$ 必须是一个可以表示成 $4k+3$ 的素数。平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。  

3）双散列法。 $d_{i}=i{\times}\mathrm{Hash}_{2}(\mathrm{ker})$ 。需要使用两个散列函数，当通过第一个散列函数H(key）得到的地址发生冲突时，则利用第二个散列函数Hashz（key)计算该关键字的地址增量。它的具体散列函数形式如下：  

$$
H_{i}\,{=}\,(H(\mathrm{kcy})+i{\times}\mathrm{Hash}_{2}(\mathrm{kcy}))\:\%\:m
$$  

初始探测位置 $H_{0}\,{=}\,H(\mathrm{kcy})\;\%\,m$ 。 $i$ 是冲突的次数，初始为0。  

4）伪随机序列法。 $d_{i}\!=$ 伪随机数序列。  

# 命题追踪散列表中删除部分元素后的查找效率分析（2023）  

> attention:  

采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径。因此，要删除一个元素时，可以做一个删除标记，进行逻辑删除。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。  

# 2.拉链法（链接法，chaining）  

显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表的第 $i$ 个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。  

例如，关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，散列函数 $H(\mathrm{kcy})=\mathrm{kcy}\%13$ 用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可以尝试计算本例的平均查找长度ASL)。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1940764bbe5838b67ac8609d78335783a585aa5c7fc0cb6560c6e81692cd7da.jpg)  
图7.33拉链法处理冲突的散列表  
# 7.5.4散列查找及性能分析  

# 命题追踪散列表的构造及查找效率的分析（2010、2018、2019）  

散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：  

初始化：Addr $\smile$ Hash (key) ;  

$\textcircled{\scriptsize{1}}$ 检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，  

比较它与key的值，若相等，则返回查找成功标志，否则执行步骤 $\mathcal{Q}$  

$\circledcirc$ 用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤 $^\mathrm{(Q)}$  

例如，关键字序列{19,14,23,01,68,20,84,27,55,11,10,79}按散列函数H(key) $=$ key%13和线性探测处理冲突构造所得的散列表 $\mathbb{L}$ 如图7.34所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/37af350f00080c15707906e376408f9d353587a88dd2c9322a9a8e4bad9e594b.jpg)  

给定值84的查找过程为：首先求得散列地址1 $\nexists\left(\,8\,4\,\right)=\,6$ ，因L[6]不空且 $\mathtt{L}\left[\,6\,\right]\neq8\,4$ ，则我第一次冲突处理后的地址 $\mathrm{{H_{1}}\mathrm{{=}}\left(\mathrm{{6}\mathrm{{+}1}\right)\mathrm{{\circ}1\mathrm{{6}\mathrm{{=}7}}}}}$ ，而L[7]不空且 $\mathtt{L}\left[\,7\,\right]\neq\!8\,4$ ，则找第二次冲突处理后的地址 $\mathrm{H}_{2}{=}\left(6{+}2\right)\circ16{=}8$ ，L[8]不空且 $\mathtt{L}\left[\,8\,\right]\mathtt{=}8\,4$ ，查找成功，返回记录在表中的序号8。  

给定值38的查找过程为：先求散列地址H $(38){=}12$ ，L[12]不空且 $\mathtt{L}\,[\,12\,]\,\neq\,38$ ，则找下一地址 $\mathrm{H}_{1}{=}\,(12{+}1)\,\%16{=}13$ ，由于L[13]是空记录，所以表中不存在关键字为38的记录。  

查找各关键字的比较次数如图7.35所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/becdbede030512e5e2ac3b81b756cc81d076a78bca8c20dbff207903db34e92a.jpg)  

平均查找长度ASL为  

$$
\operatorname{ESL}\!\!=(1\!\times\!\!6+2+3\!\times\!3+4+9)/12=2.5
$$  

对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同，本例与上节采用拉链法的平均查找长度不同。  

从散列表的查找过程可见：  

1）虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，  

使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍然需要以平均查找长度作为衡量散列表的查找效率的度量。  

命题追踪影响散列表查找效率的因素（2011、2022）2）散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。装填因子。散列表的装填因子一般记为 $\alpha$ ，定义为一个表的装满程度，即  

$$
\alpha\!=~\frac{\ddagger\!\mp\!\mathrm{i}\vec{\mathrm{x}}\!\stackrel{\sharp}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!n}{\ddagger\!\!/\!\!\chi\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!\stackrel{\sharp\!\!/}{\mathcal{K}}\!m}
$$  

散列表的平均查找长度依赖于散列表的装填因子 $\alpha$ ，而不直接依赖于 $n$ 或 $m$ 。直观地看， $\alpha$ 越大，表示装填的记录越“满”，发生冲突的可能性越大；反之发生冲突的可能性越小。  
读者应能在给出散列表的长度、元素个数及散列函数和解决冲突的方法后，在求出散列表的基础上计算出查找成功时的平均查找长度和查找不成功的平均查找长度。  

# 7.5.5 本节试题精选  

# 一、单项选择题  

01.只能在顺序存储结构上进行的查找方法是（）A.顺序查找法B.折半查找法C.树形查找法D.散列查找法02.散列查找一般适用于（）的情况下的查找。  

A.查找表为链表B.查找表为有序表C.关键字集合比地址集合大得多D.关键字集合与地址集合之间存在对应关系  

03.下列关于散列表的说法中，正确的是（）  

I.若散列表的填装因子 $\alpha\!<\!1$ ，则可避免碰撞的产生I1.散列查找中不需要任何关键字的比较I1I.散列表在查找成功时平均查找长度仅与表长有关IV.若在散列表中删除一个元素，不能简单地将该元素删除  

A.I和IV B.II和III C. 1 Y D.IV 04.在开放定址法中散列到同一个地址而引起的“堆积”问题是由于（）引起的  

A.同义词之间发生冲突B.非同义词之间发生冲突C.同义词之间或非同义词之间发生冲突D.散列表“溢出”  

05.下列关于散列冲突处理方法的说法中，正确的有（）。  

I.采用平方探测法处理冲突时不易产生聚集II.采用线性探测法处理冲突时，所有同义词在散列表中一定相邻III.采用链地址法处理冲突时，若限定在链首插入，则插入任意一个元素的时间相同IV.采用链地址法处理冲突易引起聚集现象  

A.I和IIIB.I、Ⅱ和IⅢIC.II和IVD.I和IV  

06.设有一个含有200个表项的散列表，用线性探测法解决冲突，按关键字查询时找到一个表项的平均探测次数不超过1.5，则散列表项应能够容纳（）个表项（设查找成功的平均查找长度为 $\mathrm{ASL}=[1+1/(1-\alpha)]/2$ ，其中α为装填因子）。  

A.400 B.526 C.624 D.676  

07.假定有 $K$ 个关键字互为同义词，若用线性探测法把这 $K$ 个关键字填入散列表，至少要进行（）次探测。  

A.  $K-1$  B.  $K$  C.  $K+1$  D.  $K(K+1)/2$  08.对包含 $n$ 个元素的散列表进行查找，平均查找长度（）A.为 $O(\log_{2}n)$ B.为 $O(1)$ C.不直接依赖于 $n$ D.直接依赖于表长 $m$ 09.采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（）。  

A.数据元素过多B.负载因子过大C.散列函数选择不当D.解决冲突的方法选择不当  
10.当用线性探测再散列法解决冲突时，计算出的一系列“下一个空位”的要求是（）。  

A.必须大于或等于原散列地址 B.必须小于或等于原散列地址 C.可以大于或小于但不等于原散列地址D.对地址在何处没有限制  

11.一组记录的关键字为19，14,23，1,68,20，84，27,55，11,10,79}，用链地址法构造散列表，散列函数为 $\mathtt{H}\left(\mathtt{k e y}\right)\mathtt{=}\mathtt{k}$ eymod13，散列地址为1的链中有（）个记录。  

A.1 B.2 C.3 D.4  

12.在采用链地址法处理冲突所构成的散列表上查找某一关键字，则在查找成功的情况下，所探测的这些位置上的关键字值（）；若采用线性探测法，则（）。  

A.一定都是同义词B.不一定都是同义词C.都相同D.一定都不是同义词  

13.若采用链地址法构造散列表，散列函数为 $\mathtt{H}\,(\,\mathtt{k e y})=\mathtt{k e y}$ mod17，则需（ $\textcircled{\scriptsize{1}}$ ）个链表。这些链的链首指针构成一个指针数组，数组的下标范围为（ $\circledcirc$ )。  

$\textcircled{\scriptsize{1}}$  A.17 B.13 C.16 D.任意  $\circledcirc$  A.0\~17 B.1\~17 C.0\~16 D.1\~16  

14.设散列表长 $m\,=\,14$ ，散列函数为 $\mathrm{H\,(\,k e y)=k e y\,\%\,1\,1}$ ，表中仅有4个结点 $\mathrm{~H~}(15)\!=\!4$ ， $\mathrm{H}\left(38\right){=}5$ ， $\mathrm{H}\left(61\right)=6$ ， $\mathrm{~H~}(\,8\,4\,)=7$ ，若采用线性探测法处理冲突，则关键字为49的结点地址是（）。  

A.8 B.3 C.5 D.9  

15.现有长度为17、初始为空的散列表HT，散列函数H $(\mathtt{k e y})\!=\!\mathtt{k e y}\!\circ\!17$ ，用线性探查法解决冲突。将关键字序列26,25，72，38，8，18,59依次插入HT后，则查找59需探查（）次。  

A.2B.3C.4D.5  

16.现有长度为17、初始为空的散列表HT，散列函数H（key） $=\ \ker\gamma\sqrt[\circ]{17}$ ，用平方探测法解决冲突： $\mathtt{H}_{i}\,(\,\mathtt{k e y})=(\mathtt{H}\,(\,\mathtt{k e y})\pm i^{2})\mathbb{s}\,\mathtt{l}\,\mathtt{7}$ 。将关键字序列6,22，7，26，9，23依次插入HT后，则关键字23存放在散列表中的位置是（）。  

A.0 B.2 C.6 D.15  

17.将10个元素散列到100000个单元的散列表中，则（）产生冲突。  

A.一定会B.一定不会C.仍可能会D.不确定  

18.【2011统考真题】为提高散列表的查找效率，可以采取的正确措施是（）。I.增大装填（载）因子II1设计冲突（碰撞）少的散列函数IⅢI.处理冲突（碰撞）时避免产生聚集（堆积）现象  

A.仅IB.仅ⅡIC.仅I、ⅡID.仅Ⅱ、III  

19.【2014统考真题】用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象，下列选项中，会受堆积现象直接影响的是（）。  

A.存储效率B.散列函数C.装填（装载）因子D.平均查找长度  

20.【2018统考真题】现有长度为7、初始为空的散列表HT，散列函数 $\mathrm{H\left(k\right)=k\leqslant7}$ ，用线性探测再散列法解决冲突。将关键字22，43，15依次插入HT后，查找成功的平均查找长度是（）。  

A.1.5 B.1.6 C.2 D.3  
21.【2019统考真题】现有长度为11且初始为空的散列表HT，散列函数是F $\mathrm{i}\,(\,\mathrm{keV})\,{=}\,\mathrm{keV}\,^{\circ}\,7$ 采用线性探查（线性探测再散列）法解决冲突。将关键字序列87，40,30，6,11，22，98,20依次插入HT后，HT查找失败的平均查找长度是（）。  

A.4 B.5.25 C.6 D.6.29

 22.【2022统考真题】下列因素中，影响散列（哈希）方法平均查找长度的是（））  

I.装填因子II.散列函数III.冲突解决策略A.仅I、ⅡIB.仅I、IIIC.仅II、IIID.I、II、IⅢI  

23.【2023统考真题】现有长度为5、初始为空的散列表HT，散列函数 $\mathrm{H}\left(\mathsf{k}\right)=\left(\mathsf{k}\!+\!4\right)$ %5，用线性探查再散列法解决冲突。若将关键字序列2022，12，25依次插入HT，然后删除关键字25，则HT中查找失败的平均查找长度为（）。  

A.1 B.1.6 C.1.8 D.2.2  

# 二、综合应用题  

01.若要在散列表中删除一个记录，应如何操作？为什么？按照处理冲突的方法为开放地址法和拉链法分别说明。  

02.假定把关键字keY散列到有 $n$ 个表项（从0到 $n\!-\!1$ 编址）的散列表中。对于下面的每个函数H（key）（key为整数），这些函数能够当作散列函数吗？若能，它是一个好的散列函数吗？说明理由。设函数random（n）返回一个0到 $n-1$ 之间的随机整数（包括0与 $n\!-\!1$ 在内）。  

1)  $\mathrm{H\left(kg\right)=}\mathrm{keV/n_{\circ}}$  2)H  $(\mathtt{k e y})\!=\!1$  3)H $(\mathsf{k e y})=(\mathsf{k e y}\!+\!1$ random（n))&n。4）H $\mathrm{i}\left(\mathrm{secy}\right){=}\mathrm{secy\,\%\,p\left(n\right)}$ ；其中p（n）是不大于 $n$ 的最大素数。  

03.使用散列函数 $\mathrm{H_{\tau}(k e y)=k e y\circ11}$ ，把一个整数值转换成散列表下标，散列表的长度为11，现在要把数据1，13，12，34，38，33，27，22依次插入散列表1）使用线性探测法来构造散列表。2）使用链地址法构造散列表。试针对这两种情况，分别确定查找成功所需的平均查找长度，及查找不成功所需的平均查找长度。  

04.已知一组关键字为26，36,41，38，44，15，68，12，6,51，25}，用链地址法解决冲突，假设装填因子 $\alpha\,{=}\,0.73$ ，散列函数的形式为 $\mathtt{H}\left(\mathtt{k e y}\right)=\mathtt{k e y}\,^{\circ}\mathtt{P}$ ，P为不大于表长的最大素数，请回答以下问题：1）构造出散列函数。2）分别计算出等概率情况下查找成功和查找失败的平均查找长度（查找失败的计算中只将与关键字的比较次数计算在内即可）。  

$m=13$  再散列函数分别为： $\mathrm{H}_{0}\left(\mathrm{ker}\right)=\mathrm{ker}{\mathfrak{S}}13$ 注：是求余数运算（ $=$ mod） $\mathrm{H}_{i}{=}\left(\mathrm{H}_{i-1}{+}\mathrm{REV}\left(\mathrm{ker}{+}1\right)\mathrm{\S}\boldsymbol{1}\boldsymbol{1}{+}1\right)\mathrm{\S}\boldsymbol{1}\boldsymbol{3};\quad i=1,2,3,\cdots,m-1$  其中，函数 $\scriptstyle{\mathrm{REV}}(x)$ 表示颠倒十进制数 $x$ 的各位，如RE $\nabla\left(37\right){=}73$ ，REV $(7){=}7$ 等。若插入的关键码序列为（2，8，31，20，19，18，53，27），请回答：1）画出插入这8个关键码后的散列表。2）计算查找成功的平均查找长度ASL，  
06.【2010统考真题】将关键字序列（7，8，30，11，18，9,14)散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组，散列函数为 $\mathtt{H}\left(\mathtt{k e y}\right)=\left(\mathtt{k e y}\times3\right)$ mod7，处理冲突采用线性探测再散列法，要求装填（载）因子为0.7。  

1）请画出所构造的散列表2）分别计算等概率情况下，查找成功和查找不成功的平均查找长度。  

# 7.5.6 答案与解析  

# 一、单项选择题  

01.B  

顺序查找可以是顺序存储或链式存储：折半查找只能是顺序存储且要求关键字有序：树形查我法要求采用树的存储结构，既可以采用顺序存储也可以采用链式存储：散列查找中的链地址法解决冲突时，采用的是顺序存储与链式存储相结合的方式。  

02. D  

关键字集合与地址集合之间存在对应关系时，通过散列函数表示这种关系。这样，查找以计算散列函数而非比较的方式进行查找。  

03.D  

冲突（碰撞）是不可避免的，与装填因子无关，因此需要设计处理冲突的方法，1错误。散列查找的思想是计算出散列地址来进行查找，然后比较关键字以确定是否查找成功，ⅡI错误。散列查找成功的平均查找长度与装填因子有关，与表长无直接关系，ⅢI错误。在开放定址的情形下，不能随便删除散列表中的某个元素，否则可能会导致搜索路径被中断（因此通常的做法是在要册除的地方做删除标记，而不是直接删除），IV正确。  

04.C  

在开放定址法中散列到同一个地址而产生的“堆积”问题，是同义词冲突的探查序列和非同义词之间不同的探查序列交织在一起，导致关键字查询需要经过较长的探测距离，降低了散列的效率。因此要选择好的处理冲突的方法来避免“堆积”。  

05.A  

平方探测法采用的增量序列是非线性的，它可以跳过一些已被占用的单元，而不是顺序地探测下一单元，这样能减小冲突的概率，1正确。散列地址 $i$ 的关键字，和为解决冲突形成的某次探测地址为 $i$ 的关键字，都争夺地址 $i,\,i+1,\cdots$ ，因此不一定相邻，ⅡI错误。ⅢI正确。同义词冲突不等于聚集，链地址法处理冲突时将同义词放在同一个链表中，不会引起聚集现象，IV错误。  

06. A  

若有200个表项要放入散列表，采用线性探测法解决冲突，限定查找成功的平均查找长度不 超过1.5，则  

$$
\mathsf{A S L}_{n\!g\!;\!m}=\frac{1}{2}\bigg(1\!+\!\frac{1}{1\!-\!\alpha}\bigg)\!\leqslant\!1.5\Rightarrow\alpha\!=\!\frac{200}{m}\!\leqslant\!\frac{1}{2}\!\Rightarrow m\!\geqslant\!400
$$  

07.D  

$K$ 个关键字在依次填入的过程中，只有第一个不会发生冲突，所以探测次数为 $1+2+3+\cdots+K=$  $K(K+1)/2$  

08.C  

散列表的平均查找长度与装填因子 $\alpha$ 直接相关，表的查找效率不直接依赖于表中已有表项个数  $n$  或表长  $m$  。若表中存放的记录全是某个地址的同义词，则平均查找长度为  $O(n)$  而非  $O(1)$  
09.D  

聚集是因选取不当的处理冲突的方法，而导致不同关键字的元素对同一散列地址进行争夺的现象。用线性探查法时，容易引发聚集现象。  

10.C “下一个空位”可以大于或小于但不等于原散列地址，等于原散列地址是没有意义的。  

11.D 由散列函数计算可知，14，1，27，79散列后的地址都是1，所以有4个记录。  

12.A,B  

因为在链地址法中，映射到同一地址的关键字都会链到与此地址相对应的链表上，所以探测过程一定是在此链表上进行的，从而这些位置上的关键字均为同义词：但在线性探测法中出现两个同义关键字时，会把该关键字对应地址的下一个地址也占用掉，两个地址分别记为Addr、Addr $^{\cdot+1}$ 查找一个满足 $\mathtt{H}\left(\mathtt{k e y}\right)\mathtt{=}\mathtt{A d d r+1}$ 的关键字key时，显然首次探测到的不是key的同义词。  

13. A, C  

H 的取值有17种可能，对应到不同的链表中，所以链表的个数应为17。由于H(key)的取值范围是 $0{\sim}16$ ，所以数组下标为 $0{\sim}16$  

14.A  

线性探测法的公式为 $\mathrm{H}_{i}{=}\left(\mathrm{H}\left(\mathrm{kep}\right){+}\mathrm{d}_{i}\right)\,\%\mathrm{m}$ ，其中 $d_{i}=1$ 2,.., $m-1$ 。 $\mathrm{~H~}(\,49\,)\!=\!49\,\%\,11\!=\!5$ ，有冲突； $\mathrm{H}_{1}{=}\left(\mathrm{H}\left(49\right){+}\mathbb{1}\right)\circ\mathbb{1}{4}{=}6$ ，有冲突； $\mathrm{H}_{2}{=}\left(\mathrm{H}\left(49\right){+}2\right)\circ14{=}7$ ，有冲突； $\mathrm{H}_{3}\mathrm{=(H}\left(49\right)+3)\stackrel{\circ}{\circ}\!14\mathrm{=}8$ ，无冲突。  

15.C  

插入过程如下： $\mathrm{H}\left(26\right){=}9$ ，不冲突；H $(25){=}8$ ，不冲突； $\mathrm{~H~}(72)\!=\!4$ ，不冲突； $\mathrm{H}\left(38\right){=}4$ ，冲突，冲突处理后的地址为5； $\mathrm{H}\left(8\right){=}8$ ，冲突，冲突处理后的地址为10； $\mathrm{H}\left(18\right){=}1$ ，不冲突； $\mathrm{H}\left(59\right){=}8$ ，冲突，冲突处理后的地址为11。因此，在表中查找59需要探查4次。  

16.B  

插入过程如下： $6\!\stackrel{\circ}{\otimes}\!17\!=\!6$ ； $22\!\leqslant\!17\!=\!5$ ； $7\,\%\,1\,7\!=\!7$ ； $26817{=}9$ ； $9\%17{=}9$ ，冲突，平方探测法探测10（无冲突）； $23\!\leqslant\!17\!=\!6$ ，冲突，平方探测法探测7（冲突），探测5（冲突），探测10（冲突)探测2（无冲突）。因此，关键字23应放在位置2。构造的散列表如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de875321c5ffb1c7d6626f77a8d8d4f773e2a3f046b3bdbf2cd7574208e6f7a5.jpg)  

17.C  

由于散列函数的选取，仍然有可能产生地址冲突，冲突不能绝对地避免。  

18.D  

散列表的查找效率取决于散列函数、处理冲突的方法和装填因子。显然，冲突的产生概率与装填因子（即表中记录数与表长之比）的大小成正比，1与题意相反。ⅡI显然正确。采用合适的冲突处理方法可避免聚集现象，也将提高查找效率，Ⅲ正确。例如，用链地址法处理冲突时不存在聚集现象，用线性探测法处理冲突时易引起聚集现象。  

19.D  

堆积现象因冲突而产生，它对存储效率、散列函数和装填因子均不会有影响，而平均查找长度会因为堆积现象而增大。散列函数是指将关键字映射到哈希地址的函数。存储效率和装填（装载）因子的定义相同，指哈希表中已存储的元素个数与哈希表长度的比值。这些因素都与堆积现象无关，而只与哈希表的结构和设计有关。  
20.C  

根据题意，得到的HT如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1f79e6cf33d4630a5bb54160b88b8adc98a306b814bcf3659065adc540026756.jpg)  

ASL  $\L_{n\&h}=(1+2+3)/3=2\,\circ$  

21.C  

采用线性探查法计算每个关键字的存放情况如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d6c5fc2bc665fb26fdb6a83cbddf241eae8a7f0593b25861a4b0dfd2852eaf1.jpg)  

由于 $\mathtt{H}\,(\,\mathtt{k e y})\!=\!\!0\!\sim\!6$ ，查找失败时可能对应的地址有7个，对于计算出地址为0的关键字key0，只有比较完 $_{0\sim8}$ 号地址后才能确定该关键字不在表中，比较次数为9；对于计算出地址为1的关键字keyl，只有比较完 $\pmb{1}\!\sim\!8$ 号地址后才能确定该关键字不在表中，比较次数为8；以此类推。需要特别注意的是，散列函数不可能计算出地址7，因此有  

$$
\ast\kappa=(9+8+7+6+5+4+3)/7=6
$$  

22.D  

原题再现。填装因子越大，说明哈希表中存储的元素越满，发生冲突的可能性就越高，导致平均查找长度越大。散列函数、冲突解决策略也会影响发生冲突的可能性。I、ⅡI、Ⅲ都正确。  

23.C  

当采用开放定法时，不能随便物理删除表中的已有元素，因为若删除元素，则可能截断其他具有相同散列地址的元素的查找地址。因此，当要删除一个元素时，可给它做一个删除标记。依次将2022，12，25插入散列表，然后删除25，得到的散列表如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0dca011576076efde8af6d061e4c266422582a12cfa1bd5e5ba10ae8394db2c.jpg)  

当查找位置是删除标记时，应继续往后查找。查找失败的平均查找长度为 $(1+3+2+1+2)/5=1.8$  

# 二、综合应用题  

01.【解答】  

在散列表中删除一个记录，在拉链法情况下可以物理地删除。但在开放定址法情况下，不能物理地删除，只能做删除标记。该地址可能是该记录的同义词查找路径上的地址，物理地删除就中断了查找路径，因为查找时碰到空地址就认为是查找失败。  

02.【解答】  

1）不能作为散列函数，因为key/n可能大于 $n$ ，这样就无法找到适合的位置2）能够作为散列函数，但不是一个好的散列函数，因为所有关键字都映射到同一位置，造成大量的冲突机会。3）不能当作散列函数，因为该函数的返回值不确定，这样无法进行正常的查找。  
4）能够作为散列函数，是一个好的散列函数  

# 03.【解答】  

由散列函数可知散列地址的范围为 $0{\sim}10$  

采用线性探测法构造散列表时，首先应计算出关键字对应的散列地址，然后检查散列表中对应的地址是否已经有元素。若没有元素，则直接将该关键字放入散列表对应的地址中：若有元素则采用线性探测的方法查找下一个地址，从而决定该关键字的存放位置。  

采用链地址法构造散列表时，在直接计算出关键字对应的散列地址后，将关键字结点插入此散列地址所在的链表。  

具体解答如下。  

1）线性探测法。  

H  $(\mathbb{1})=\mathbb{1}$  ，无冲突，地址1存放关键字  $1\!\circ\!\mathrm{H}\left(13\right)\!=\!2$  ，无冲突，地址2存放关键字13。H  $(\mathbb{1}2)=\mathbb{1}$  发生冲突，根据线性探测法： $\mathtt{H}_{1}{=}2$ ，发生冲突，继续探测 $\mathtt{H}_{2}{=}3$ ，无冲突，于是12存放在地址为3的表项中。H $(34){=}1$ ，发生冲突，根据线性探测法： $_\mathrm{H_{l}}{=}2$ ，发生冲突， $\mathtt{H}_{2}{=}3$ ，发生冲突， $\mathtt{H}_{3}{=}4$ ，没有冲突，于是34存放在地址为4的表项中。  

同理，可以计算其他的数据存放情况，最后结果如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7345b2f08c4b4921f6bcfe02930d17754488ea02f7d9aefc759d2138744943f9.jpg)  

下面计算平均查找长度：  

查找成功时，显然查找每个元素的概率都是1/8。对于33，由于冲突次数为0，所以仅需1次比较便可查找成功；对于22，由于计算出的地址为0，但需要8次比较才能查找成功，所以22的查找长度为8：其他元素的分析类似。因此有  

$$
_{w h}=(1+1+1+3+4+1+2+8)/8=21/8
$$  

查找失败时，由于 $\mathrm{H\(kg)}\!=\!0\!\sim\!10$ ，因此对每个位置查找的概率都是1/11，对于计算出的地址为0的关键字key0，只有探测完 $_{0\sim8}$ 号地址后才能确定该元素不在表中，比较次数为9；对于计算出的地址为1的关键字key1，只有探测完 $\pm\!\sim\!8$ 号地址后，才能确定该元素不在表中，比较次数为8，以此类推。而对于计算出的地址为8，9，10的关键字，这些单元中没有存放元素，所以只需比较1次便可确定查找失败，因此有  

$$
\mathrm{ASL}_{\mathrm{\scriptsize~\#~}}=(9+8+7+6+5+4+3+2+1+1+1)/11=47/11
$$  

2）链地址法构造的表如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dad8bd3bf4db7a9e81b9a1fd719441116853a9562ac4487e6126b5fa030915ae.jpg)  

在链地址表中查找成功时，查找关键字为33的记录需进行1次比较，查找关键字为22的记录需进行2次比较，以此类推。因此有  
$$
\mathrm{ASL}_{\mathbb{R}^{n h}}=(1\!\times\!4+2\!\times\!3+3)/8=13/8
$$  

查找失败时，对于地址0，比较3次后确定元素不在表中（空指针算1次），所以其查找长度为3：对于地址1，其查找长度为4：对于地址2，查找长度为2；以此类推。因此有  

$$
\mathrm{ASL}_{\mathrm{\scriptsize~\#~}}=(3+4+2+1+1+3+1+1+1+1+1)/11=19/11
$$  

注意，求查找失败的平均查找长度时有两种观点：其一，认为比较到空结点才算失败，所以比较次数等于冲突次数加1；其二，认为只有与关键字的比较才算比较次数。  

# 04.【解答】  

由装填因子的计算公式 $\scriptstyle\alpha\,=\,n/N$  $n$ 为关键字个数， $N$ 为表长），不难得出表长，而根据散列函数的选择要求， $P$ 应该取不大于表长的最大素数，从而可以确定 $P$ 的大小，也就构造出了散列函数。这里采用链地址法解决冲突，两种情况下的平均查找长度的计算过程与上一题完全相似。  

具体解答如下。  

1）由 $\alpha\!=\!n/N$ 得 $N\!=\!n/\alpha$ 由于 $N$ 为整数，所以应该向上取整，即 $N\!=\!\!\lceil n/\alpha\rceil\!=\!15$ ，从而 $P=13$ 6因此散列函数为 $\mathtt{H}\,(\,\mathtt{k e y})\!=\!\mathtt{k e y}\!\circ\!13$ 6  

2）由1）求出的散列函数，计算各关键字对应的散列地址如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28a3192a05cddf0924e0e302178484f784cec7e6ebab5acc08ab3cc0ba284477.jpg)  

由此构造的链地址法处理冲突的散列表为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/49d70cef373cdb1c5c2147ba92f934d33ca15bb6ee57a133157851d01087c260.jpg)  

由上图不难计算出  

$\mathrm{ASL}_{\mathbb{R}^{3\mathbb{h}}}=(1\!\times\!7+2\!\times\!2+3\!\times\!1+4\!\times\!1)/11=18/11$   $\begin{array}{r}{\mathsf{A S L}_{\mathcal{H}}=(1+0+2+1+0+1+1+0+0+0+1+0+4)/13=11/13}\end{array}$  

05.【解答】  

1) $\mathtt{H}_{0}\left(2\right)=2$ ， $\mathrm{H}_{0}\left(8\right){=}8$ ， $\mathrm{H}_{0}\left(31\right){=}5$ ， $\mathrm{H}_{0}\left(20\right){=}7$ ， $\mathrm{H}_{0}\left(19\right){=}6$ ，没有冲突。 $\mathrm{H}_{0}\left(18\right){=}5$ ，发生冲突， $\mathtt{H}_{1}\left(\mathtt{1}\,\mathtt{8}\right)=\left(\mathtt{H}_{0}\left(\mathtt{1}\,\mathtt{8}\right)\,+\mathtt{R E V}\left(\mathtt{1}\,\mathtt{8}\,\mathtt{+}\,\mathtt{1}\right)\,\mathtt{S l1}\,\mathtt{+}\,\mathtt{1}\right)\,\mathtt{S l3}=\left(\mathtt{5}\,\mathtt{+}\,\mathtt{3}\,\mathtt{+}\,\mathtt{1}\right)\,\mathtt{S l3}=9\,\mathtt{s i d}\,\mathtt{s p a}\,\mathtt{F},$ ，没有冲突。 $\mathrm{H}_{0}\left(53\right)\mathrm{=}1$ ，没有冲突。 $\mathrm{H}_{0}\left(27\right){=}1$ ，发生冲突， $\mathtt{H}_{1}\left({27}\right){=}\left(\mathtt{H}_{0}\left({27}\right){+}\mathtt{R E V}\left({27{+}1}\right)\mathbb{S}\mathtt{11}{+}\mathtt{1}\right)\mathbb{S}\mathtt{13}{=}$  $(1\!+\!5\!+\!1)\,\circ\,13\!=\!7$ ，发生冲突，H2（27）=（H（27）+REV（27+1） $^{\circ}^{\perp\perp+1}$  $\stackrel{\circ}{\circ}\!\bot\!3\!=\!0$ ，没有冲突。构造的散列表如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/625fd0636210f4574d07a4898e4082050a4123637d9a782448b943f98a41c5a5.jpg)  
2）由1）中散列表的构造过程，各个关键字查找成功的比较次数如上表所示，所以有  

$$
,\,_{i i v h}=(3+1+1+1+1+1+1+2)/8=11/8
$$  

06.【解答】  

1）由装填因子0.7和数据总数7，得一维数组大小为 $7/0.7=10\$ ，数组下标为 $_{0\sim9}$ 。所构造的散列函数值如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/358953af5aeabecde87bbb12614a23cf1a01ba593d2cd6553420b155c1c0c8e6.jpg)  

采用线性探测再散列法处理冲突，所构造的散列表为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/07cb86b65e45ffcd55fe2ab43973be64df37775eb62e8cb65d75c0b7a42ac71d.jpg)  

2）查找成功时，在等概率情况下，查找每个表中元素的概率是相等的。因此，根据表中元素的个数来计算平均查找长度，各关键字的比较次数如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9e4ac265f11d106ab91877b12711e02dd03ba83e2164a55346b9307ebcfa2871.jpg)  

所以ASL $\psi(x)=$ 查找次数/元素个数 $=(1+2+1+1+1+3+3)/7=12/7.$  

在计算查找失败时的平均查找长度时，要特别注意防止思维定式，在查找失败的情况下既不是根据表中的元素个数，也不是根据表长来计算平均查找长度的。  

查找失败时，在等概率情况下，经过散列函数计算后只可能映射到表中的 $0{\sim}6$ 位置，且映射到 $0{\sim}6$ 中任意一个位置的概率是相等的。因此，是根据散列函数（mod后面的数字）来计算平均查找长度的。在等概率情况下，查找失败的比较次数如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d5915433b5a31ba16d6e994357731f4aef9885391a2bf681d0e7d72e08e914d4.jpg)  

所以ASL $_{\mp i k x y}=$ 查找次数/散列后的地址个数 $=(3+2+1+2+1+5+4)/7=18/7\,\circ$  

# 归纳总结  

本章的核心考查点是求平均查找长度（ASL），以度量各种查找算法的性能。查找算法本身依托于查找结构，查找结构又是由相同数据类型的记录或结点构成的，所以最终落脚于数据结构类型的区别。不管是何种查找算法，其平均查找长度的计算公式都是一样的。  

查找成功的平均查找长度AS $\mathrm{~L~}_{n\in i}=\sum_{i=1}^{n}p_{i}c_{i}$ 查找失败的平均查找长度A $\backslash\mathrm{SL}_{\mathbb{F}^{n\mathbb{W}}}=\sum_{j=0}^{n}q_{j}c_{j}$  

设一个查找集合中已有 $n$ 个数据元素，每个元素的查找概率为 $p_{i}$ ，查找成功的数据比较次数为 $c_{i}\ (i=1,2,\cdots,n)$ ：不在此集合中的数据元素分布在由这 $n$ 个元素的间隔构成的 $n+1$ 个子集合内，每个子集合元素的查找概率为 $q_{j}$ ，查找不成功的数据比较次数为 $c_{j}\ (j=0,\,1,\cdots,\,n)$ 。因此，对某一特定查找算法的查找成功的ASL成动和查找失败的ASL $\exp[-]$ ，是综合考虑还是分开考虑呢？  
若综合考虑，即 $\sum_{i=1}^{n}p_{i}+\sum_{j=0}^{n}q_{j}=1$ ，若所有元素查找概率相等，则有 $p_{i}=q_{j}=\frac{1}{2n+1}$ 若分开考虑，即 $\sum_{i=1}^{n}p_{i}=1\;,\;\;\sum_{j=0}^{n}q_{j}=1$ ，若所有元素查找概率相等，则有 $p_{i}={\frac{1}{n}}\,,\;\;q_{j}={\frac{1}{n+1}}\,.$  

虽然综合考虑更为理想，但在实际应用中多数是分开考虑的，因为对于查找不成功的情况，很多场合下没有明确给出，往往会被忽略掉。不过读者仍要注意的是，这两种考虑的计算结果是不同的，考试中一定要仔细阅读题目的要求，以免失误。  

# 思维拓展  

本章介绍了几种基本的查找算法，在实际中又会碰到怎样的查找问题呢？  

题目：数组中有一个数字出现的次数超过了数组长度的一半，请找出这个数字。读者也许会想到先进行排序，位于位置 $(n+1)/2$ 的数即为要找的数，这样最小时间复杂度就为 $O(n\mathrm{log}_{2}n)$ ；若进行散列查找，数字的范围又未知，则应如何将时间复杂度控制在 $O(n)$ 内呢？  

提示：出现的次数超过数组长度的一半，表明这个数字出现的次数比其他数字出现的次数的总和还多。所以我们可以考虑每次删除两个不同的数，则在剩下的数中，待查找数字出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除其他的数字，最终剩下的都为同一个数字，即为要找的数字。  
# 第8章排序  

# 【考纲内容】  

（一）排序的基本概念  

（二）插入排序直接插入排序：折半插入排序：希尔排序（shellsort）（三）交换排序冒泡排序（bubblesort）：快速排序（四）选择排序简单选择排序：堆排序 （五）二路归并排序（mergesort）（六）基数排序（七）外部排序（八）排序算法的分析和应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/08a16d8a8b640262f36d9686866d92f5ba9d690ee8e2b9b03a94808ae99e6d5b.jpg)  

# 【复习提示】  

堆排序、快速排序和归并排序是本章的重难点。读者应深入掌握各种排序算法的思想、排序过程（能动手模拟）和特征（初态的影响、复杂度、稳定性、适用性等），通常以选择题的形式考查不同算法之间的对比。此外，对于一些常用排序算法的关键代码，要达到熟练编写的程度：看到某特定序列，读者应具有选择最优排序算法（根据排序算法特征）的能力。  
# 8.1排序的基本概念  

# 8.1.1排序的定义  

排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下：  

输入： $n$ 个记录 $R_{1},R_{2},\cdots,R_{n}$ ，对应的关键字为 $k_{1},k_{2},\cdots,k_{n}$  

输出：输入序列的一个重排 $R_{1}^{\prime},R_{2}^{\prime},\cdots,R_{n}^{\prime}$ ，使得 $k_{1}^{\prime}\leqslant k_{2}^{\prime}\leqslant\cdots\leqslant k_{n}^{\prime}$ （其中“≤”可以换成其他的比较大小的符号)。  

算法的稳定性。若待排序表中有两个元素 $R_{i}$ 和 $R_{j}$ ，其对应的关键字相同，即 ${\bf k e y}_{i}={\bf k e y}_{j}$ ，且在排序前 $R_{i}$ 在 $R_{j}$ 的前面，若使用某一排序算法排序后， $R_{i}$ 仍然在 $R_{j}$ 的前面，则称这个排序算法是稳定的，否则称这个排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。若待排序表中的关键字不充许重复，排序结果是唯一的，则对于排序算法的选择，稳定与否无关紧要。  

> attention:  

对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。  

在排序过程中，根据数据元素是否完全存放在内存中，可将排序算法分为两类： $\textcircled{\scriptsize{1}}$ 内部排序，是指在排序期间元素全部存放在内存中的排序： $\circledcirc$ 外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中粮据要求不断地在内、外存之间移动的排序。  

一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，基数排序就不基于比较操作。  

每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。  

> attention:  

大多数的内部排序算法都更适用于顺序存储的线性表。  

# 8.1.2 本节试题精选  

# 一、单项选择题  

01.下述排序算法中，不属于内部排序算法的是（）。  

A.插入排序 B.选择排序 C.拓扑排序 D.冒泡排序  

02.排序算法的稳定性是指（）  

A.经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变B.经过排序后，能使关键字相同的元素保持原顺序中的绝对位置不变C.排序算法的性能与被排序元素个数关系不大  
D.排序算法的性能与被排序元素的个数关系密切 03.下列关于排序的叙述中，正确的是（）。  

A.稳定的排序算法优于不稳定的排序算法B.对同一线性表使用不同的排序算法进行排序，得到的排序结果可能不同C.排序算法都是在顺序表上实现的，在链表上无法实现排序算法D.在顺序表上实现的排序算法在链表上也可以实现  

04.对任意7个关键字进行基于比较的排序，至少要进行（）次关键字之间的两两比较。  

A.13 B.14 C.15 D.6  

# 8.1.3 答案与解析  

# 一、单项选择题  

01.C  

拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于我们这里所提到的内部排序范畴，也不满足前面排序的定义。  

02.A  

注意，这里的绝对位置是指若在排序前元素 $R$ 在位置，则绝对位置就是i，即排序后 $R$ 的位置不发生变化，显然B是不对的。C、D与题自要求无关。  

03.B  

算法的稳定性与算法优劣无关，A排除。使用链表也可以进行排序，只是有些排序算法不再适用，因为这时定位元素只能顺序逐链查找，如折半插入排序。  

04.A  

对于任意序列进行基于比较的排序，求至少的比较次数应考虑最坏情况。对任意 $n$ 个关键字排序的比较次数至少为 $\lceil\log_{2}(n!)\rceil$ .将 $n=7$ 代入公式，答案为13。  

上述公式的证明：在基于比较的排序算法中，每次比较两个关键字后，仅出现两种可能的转移。假设整个排序过程至少要做 $t$ 次比较，显然会有 $2^{t}$ 种情况。由于 $n$ 个记录共有 $_{n}$ 种不同的排列，因此有 $n!$ 种不同的比较路径，于是有 $2^{t}{\geqslant}n!$ ，即 $\scriptstyle t\geq\log_{2}(n!)$ 。考虑到 $t$ 为整数，所以比较次数为 $\lceil\log_{2}(n!)\rceil.$  

# 8.2 插入排序  

插入排序是一种简单直观的排序算法，其基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。  

# 8.2.1直接插入排序  

根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表L[1..n]在某次排序过程中的某一时刻状态如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d25ff3c4c8f034d8e69956e4e46fa3d66458180385b7fec90ac66beacd5b43c8.jpg)  
要将元素L（i）插入已有序的子序列L[1i-1]，需要执行以下操作（为避免混淆，下面用L[表示一个表，而用L（）表示一个元素）：  

1）查找出L（i）在L[1.i-1]中的插入位置k。  

2）将L[k...i-1]中的所有元素依次后移一个位置。  

3）将L（i）复制到L（k）。  

为了实现对L[1.n]的排序，可以将 $\mathtt{L}\left(2\right)\sim\mathtt{L}\left(\mathtt{n}\right)$ 依次插入前面已排好序的子序列，初始工[1]可以视为一个已排好序的子序列。上述操作执行 $n-1$ 次就能得到一个有序的表。插入排序在实现上通常采用原地排序（空间复杂度为 $O(1)$ ），因而在从后往前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。  

下面是直接插入排序的代码，其中再次用到了前面提到的“哨兵”（作用相同）  

void InsertSort（ElemType A[],int n){ inti,j; for( $_{\pm=2}$  $\scriptstyle{\dot{\mathbf{\rho}}}_{\mathrm{E}}<={\mathbf{\rho}}_{\mathrm{E}}$  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ //依次将 $\mathtt{A}\left[2\right]\sim\mathtt{A}\left[\mathfrak{n}\right]$ 插入前面已排序序列if(A[i] $<\mathtt{A}$ [i-1]){/若A[i]关键码小于其前驱，将A[i]插入有序表 $\mathbb{A}\left[\,0\,\right]=\mathbb{A}\left[\,{\mathrm{i}}\,\right]$ //复制为哨兵，A[0]不存放元素for（j=i-1；A[0]<A[j]；--j）/从后往前查找待插入位置A[ $_{1+1]=\mathbb{A}}$ [j];/向后挪位 $\mathbb{A}\left[\,\mathfrak{j}+1\,\right]=\mathbb{A}\left[\,\mathfrak{O}\right.$ /复制到插入位置  

假定初始序列为49，38，65，97，76，13，27，49，初始时49可以视为一个已排好序的子序列，按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f692fcf6091936b992c48b73392b1b8b99439fcc63adb80f34bf4a92dc3a7bc.jpg)  
图8.1直接插入排序示例  

直接插入排序算法的性能分析如下：  

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了 $n\!-\!1$ 趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。  

在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 $O(n)$  

在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大，总的时间复杂度为 $O(n^{2})$  

平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为  
平均情况下的时间复杂度，总的比较次数与总的移动次数均约为 $n^{2}/4$ 因此，直接插入排序算法的时间复杂度为 $O(n^{2})$  

稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序算法。  

适用性：直接插入排序适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。  

# 8.2.2 折半插入排序  

从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作： $\textcircled{\scriptsize{1}}$ 从前面的有序子表中查找出待插入元素应该被插入的位置： $\circledcirc$ 给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下：  

void InsertSort（ElemType A[l,int n){ int i,j,low,high,mid; for(  $_{\dot{\mathbf{1}}=2}$   $\scriptstyle{\dot{\mathbf{1}}}<={\boldsymbol{\mathrm{n}}}$   $\ \ \mathrm{i++}$  //依次将A[2]\~A[n]插入前面的已排序序列  $\mathtt{A}\left[\,0\,\right]\mathrm{=A}$  [i]; //将A[i]暂存到A[0] low  $^{=1}$  ;high  $\scriptstyle{\cfrac{\sinh(i-1)}{\sinh(i-1)}}$  //设置折半查找的范围 while(low< $\mathbf{\beta}=$ high){//折半查找（默认递增有序）mid=（low+high)/2;//取中间点if（A[mid]>A[0]）high=mid-1；//查找左半子表elselow=mid+l;//查找右半子表for( $\scriptstyle{\mathrm{j}}={\mathrm{i}}-1$ ;j>=high+1;--j)A[j $+1]=\mathtt{A}$ [j];//统一后移元素，空出插入位置A[high+1] $\mathtt{\ =}\mathtt{A}$ [0];/插入操作  

# 命题追踪直接插入排序和折半插入排序的比较（2012）  

从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，时间复杂度约为 $O(n\mathrm{log}_{2}n)$ 该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数 $n$ ：而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为 $O(n^{2})$ ，但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序算法。  

折半插入排序仅适用于顺序存储的线性表。  

# 8.2.3 希尔排序  

从前面的分析可知，直接插入排序算法的时间复杂度为 $O(n^{2})$ ，但若待排序列为“正序”时，其时间效率可提高至 $O(n)$ ，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。  

# 命题追踪希尔排序中各子序列采用的排序算法（2015）  

希尔排序的基本思想是：先将待排序表分割成若干形如 $\operatorname{L}[i,i+d,i+2d,\cdots,i+k d]|$ 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。  
# 命题追踪根据希尔排序的中间过程判断所采用的增量（2014、2018）  

希尔排序的过程如下：先取一个小于 $n$ 的增量 $d_{1}$ ，把表中的全部记录分成 $d_{1}$ 组，所有距离为 $d_{1}$ 的倍数的记录放在同一组，在各组内进行直接插入排序；然后取第二个增量 $d_{2}\!<\!d_{1}$ ，重复上述过程直到所取到的 $d_{t}=1$ ，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，因此可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以8.2.1节的关键字为例，假定第一趟取增量 $d_{1}=5$ ，将该序列分成5个子序列，即图中第2行至第6行，分别对各子序列进行直接插入排序，结果如第7行所示：假定第二趟取增量 $d_{2}\!=\!3$ ，分别对三个子序列进行直接插入排序，结果如第11行所示：最后对整个序列进行一趟直接插入排序，整个排序过程如图8.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fed15f10d006d56734ed7a4ea13576087c06e17f9b076afa8e5ea4725e0fb071.jpg)  
图8.2希尔排序示例  

希尔排序算法的代码如下：  

void ShellSort（ElemType A[],int n)( I/A[0】只是暂存单元，不是哨兵，当 $\scriptstyle{\frac{1}{3}}<=0$ 时，插入位置已到int dk,i，j; for( ${\mathsf{d k}}{=}{\mathsf{n}}/2$ ;dk ${>}{=}1$ ;dk=dk/2)/增量变化（无统一规定）for(  $\scriptstyle{\dot{1}}=\mathrm{d}k+1$   $\scriptstyle{\mathrm{i}}<={\mathrm{n}}$   ${++}\,{\mathrm{i}}$  if(A[i]<A[i-dk]){ //需将A[i]插入有序增量子表  $\mathbb{A}\left[0\right]{=}\mathbb{A}\left[\mathrm{i}\right]$ //暂存在A[0]for(  $\scriptstyle{\dot{\mathbf{j}}}={\dot{\mathbf{i}}}\cdot$  -dk;j>0&&A[0]<A[j];j-=dk) A[j+dk] $\mathtt{\ =A}$ [j];//记录后移，查找插入的位置A[j+dk] $\mathbf{\equiv}\mathtt{A}\left[0\right]$ //插入  

希尔排序算法的性能分析如下：  

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间效率：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 $n$ 在某个特定范围时，希尔排序的时间复杂度约为 $O(n^{1.3})$ 在最坏情况下希尔排序的时间复杂度为 $O(n^{2})$  
稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序算法。例如，图8.2中49与49的相对次序已发生了变化。适用性：希尔排序仅适用于顺序存储的线性表。  

# 8.2.4 本节试题精选  

# 一、单项选择题  

01.对5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（）A.8 B.10 C.15 D.25 02.在待排序的元素序列基本有序的前提下，效率最高的排序算法是（）。A.直接插入排序B.简单选择排序C.快速排序D.归并排序  

03.在图书馆中，计算机类书籍区共有12列书架，书架上的书都是按照编号排列好的，其中有些书被读者放错了地方，但通常不超过一个书架。未来将这些书重新放回正确的位置，应该采用何种排序算法？（）。  

A.堆排序B.直接插入排序C.归并排序D.简单选择排序  

04.对有 $n$ 个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是（），在最好情况下所需的比较次数是（）。  

A.n-1 B.  $n+1$  C.n/2 D.  $n(n-1)/2$  05.数据序列 $\{8,10,13,4,6,7,22,2,3\}$ 只能是（）两趟排序后的结果。A.简单选择排序B.冒泡排序 C.直接插入排序 D.堆排序 06.用直接插入排序算法对下列4个表进行（从小到大）排序，比较次数最少的是（）。  

A.94,32,40,90,80,46,21,69 B.21,32,46,40,80,69,90,94 C.32,40,21,46,69,94,90,80 D.90,69,80,46,21,32,94,40  

07.在下列算法中，（）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上。  

A.堆排序B.冒泡排序C.直接插入排序D.快速排序  

08.希尔排序属于（）  

A.插入排序 B.交换排序 C.选择排序 D.归并排序  

09.对序列15，9，7，8，20，-1，41采用希尔排序，经一趟后序列变为 $\{15,-1,4,8,20,9,7\}$ ，则该次采用的增量是（）。  

A.1T B.4 C.3 D.2  

10.若序列15，9,7,8,20，-1,41经一趟排序后变成{9，15，7,8,20，-1,4}，则采用的是（）方法。  

A.选择排序B.快速排序C.直接插入排序D.冒泡排序  

11.对序列98，36，-9,0,47,23，1，8,10,71采用希尔排序，下列序列（）是增量为4的一趟排序结果。  

A.{10,7,-9,0,47,23,1,8,98,36 B.{-9,0,36,98,1,8,23,47,7,10} C.{36,98,-9,0,23,47,1,8,7,10}D.以上都不对  

12.对序列E，A,S，Y，Q，U，E，S,T,I,O,N按照字典顺序排序，采用增量  $d\!=\!6,3,1$  的希尔排 序算法。则前两趟排序后，关键字的总比较次数为（）。  

A.15 B.17 C.16 D.18 13.已知输入序列13,24，7,1,8,9,11,56,34,51,2,77,5}，增量序列  $d\!=\!5,3,1$  ，采用希尔排  
序算法进行排序，则两趟排序后的结果为（）。  

A.17,8,9,13,24,11,34,51,2,5,56,77 B.17,5,2,8,9,24,11,34,51,13,77,56 C.2,11,5,1,8,9,24,7,34,51,13,77,56 D.2,5,11,1,8,9,7,24,34,13,51,77,56  

14.折半插入排序算法的时间复杂度为（）  

A. O(n) B.O(nlog2n) C. 0(n) D. 0(n)  

15.有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，（）算法不会出现此种情况。  

A.希尔排序 B.堆排序 C.冒泡排序 D.快速排序  

16.以下排序算法中，不稳定的是（）  

A.冒泡排序B.直接插入排序C.希尔排序D.归并排序  

17.以下排序算法中，稳定的是（）  

A.快速排序B.堆排序C.直接插入排序D.简单选择排序  

18.【2012统考真题】对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是（）。  

A.排序的总趟数B.元素的移动次数C.使用辅助空间的数量D.元素之间的比较次数  

19.【2014统考真题】用希尔排序算法对一个数据序列进行排序时，若第一趟排序结果为9，1]4，13，7，8，20，23，15，则该趟排序采用的增量（间隔）可能是（）。  

A.2B.3C.D.520.【2015统考真题】希尔排序的组内排序采用的是（）A.直接插入排序B.折半插入排序C.快速排序D.归并排序  

21.【2018统考真题】对初始数据序列（8.3，9,11，2,1，4，7,5，10,6）进行希尔排序。若第一趟排序结果为 $1,3,7,5,2,6,4,9,11,10,8)$ ，第二趟排序结果为 $(1,2,6,4,3,7,5,8,11,10,9)$ ，则两趟排序采用的增量（间隔）依次是（）。  

A.3,1 B.3,2 C.5,2 D.5,3  

# 二、综合应用题  

01.给出关键字序列4，5，1，2，6,31的直接插入排序过程。  

02.给出关键字序列50，26,38,80,70,90,8,30,40,20}的希尔排序过程（取增量序列为 $d\!=$ {5，3，1，排序结果为从小到大排列）。  

# 8.2.5 答案与解析  

# 一、单项选择题  

01.B  

直接插入排序在最坏的情况下要做 $n(n-1)/2$ 次关键字的比较，当 $n=5$ 时，关键字的比较次数为10。注意不考虑与哨兵的比较。  

02.A  

由于序列初始基本有序，因此使用直接插入排序算法的时间复杂度接近 $O(n)$ ，而使用其他算法的时间复杂度均大于 $O(n)$  

03.B  
由于大部分图书都是有序的，因此采用直接插入排序比较合适。  

04.D、A  

待排序表为反序时，直接插入排序需要进行 $n(n-1)/2$ 次比较（从前往后依次需要比较 $1,2,\cdots$  $n\!-\!1$ 次)；待排序表为正序时，只需进行 $n\!-\!1$ 次比较。注意本题不考虑与哨兵的比较。  

05.C  

冒泡排序和选择排序经过两趟排序后，应该有两个最大（或最小）元素放在其最终位置；插入排序经过两趟排序后，前三个元素应该是局部有序的。只可能是插入排序。  

> attention:  

在排序过程中，每趟都能确定一个元素在其最终位置的有冒泡排序、简单选择排序、堆排序、快速排序，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。  

06.B  

越接近正序的序列，直接插入排序的比较次数就越少。B和C是比较接近正序的，然后分别判断两个序列的比较次数，以B为例：第一趟，插入32，比较1次；第二趟，插入46，比较1次；第三趟，插入40，因为40比46小但比32大，所以比较2次；第四趟，插入80，比较1次；第五趟，插入69，比较2次；以此类推，共比较9次。同理求出C的比较次数为11次。所以选B项。  

07. C  

在直接插入排序中，若待排序列中的最后一个元素应插入表中的第一个位置，则前面的有序子序列中的所有元素都不在最终位置上。  

08.A 希尔排序是对直接插入排序算法改进后提出来的，本质上仍属于插入排序的范畴。  

09.B 希尔排序将序列分成若干组，记录只在组内进行交换。由观察可知，经过一趟后9和-1交换，7和4交换，可知增量为4。  

10.C 前两个元素已经局部有序，很明显一趟直接插入排序算法有效。再排除其他算法即可。  

11.A  

增量为4意味着所有相距为4的记录构成一组，然后在组内进行直接插入排序，经观察，只有A项满足要求。  

12.B  

第一趟：EE为一组，比较；AS为一组，比较；ST为一组，比较；YI为一组，比较后交换；QO为一组，比较后交换；UN为一组，比较后交换，结果为EASIONESTYQU。第二趟：EIEY为一组，用直接插入排序需要依次比较I和E、E和I、E和E、Y和I；AOSQ为一组，依次比较O和A、S和O、Q和S、Q和O；SNTU为一组，依次比较N和S、T和S、U和T。第一趟比较次数为6，第二趟比较次数为11，总比较次数为17。  

13.B  

第一趟增量 $d\!=\!5$ ，第一趟排序后，结果为2，11,5，1,8,9,24,7,34,51,13,77,56。第二趟增量 $d\!=\!3$ ，第二趟排序后，结果为1,7,5,2,8,9,24,11,34,51,13,77,56。  

14.C 虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数未发生变化，时间复杂度仍为 $O(n^{2})$  
15.A  

因为希尔排序是基于插入排序算法提出的，所以它不一定在每趟排序过程后将某一元素放置到最终位置上。  

16.C  

希尔排序是一种复杂的插入排序算法，它是一种不稳定的排序算法。  

17.C  

基于插入、交换、选择的三类排序算法中，通常简单方法是稳定的（直接插入、折半插入、冒泡），但有一个例外就是简单选择，复杂方法都是不稳定的（希尔排序、快速排序、堆排序）。  

18.D  

折半插入排序与直接插入排序都将待插入元素插入前面的有序子表，区别是：确定当前记录在前面有序子表中的位置时，直接插入排序采用顺序查找法，而折半插入排序采用折半查找法。排序的总趟数取决于元素个数  $n$  ，两者都是  $n\!-\!1$  趟。元素的移动次数都取决于初始序列，两者相 同。使用辅助空间的数量也都是 $O(1)$ 。折半插入排序的比较次数与序列初态无关，时间复杂度为为 $O(n\log_{2}n)$ ：而直接插入排序的比较次数与序列初态有关，时间复杂度为 $O(n){\sim}O(n^{2})$  

19.B  

首先，第二个元素为1，是整个序列中的最小元素，可知该希尔排序为从小到大排序。然后考虑增量问题，若增量为2，则第1+2个元素4明显比第1个元素9要小，排除A。若增量为3，则第 $i,$  $i+3,i+6\;\;(i=1,2,3\,)$ 个元素都为有序序列，符合希尔排序的特点。若增量为4，则第1个元素9比第 $1+4$ 个元素7要大，排除C。若增量为5，则第1个元素9比第1+5个元素8要大，排除D。  

20.A  

希尔排序的思想是：先将待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。  

21.D  

如下图所示。初始序列：8,3,9,11,2.1,4,7,5,10,6第一趟：1,3,7,5.2,6,4,9,11,10,8第二趟：1,2,6.4.3,7,5,8,11,10, 第一趟分组：8.1.6；3.4：9.7：11.5：2.10：间隔为5，排序后组内递增第二趟分组：1，5，4.10：3.2.9.8；7.6,11：间隔为3，排序后组内递增。因此，选择选项D。  

二、综合应用题  

01.【解答】  

直接插入排序过程如下。  

初始序列： $\begin{array}{l}{4,5,1,2,6,3}\\ {4,5,1,2,6,3}\\ {1,4,5,2,6,3}\\ {1,2,4,5,6,3}\\ {1,2,4,5,6,3}\\ {1,2,3,4,5,6}\end{array}$ 第一趟：（将5插入{4}）第二趟：（将1插入{4.5}）第三趟：（将2插入{1,4,5}）第四趟：（将6插入{1,2,4,5}）第五趟：（将3插入 $\{1,2,4,5,6\}$  
# 02.【解答】  

原始序列： $\begin{array}{c}{50,26,38,80,70,90,8,30,40,20}\\ {50,8,30,40,20,90,26,38,80,70}\\ {26,8,30,40,20,80,50,38,90,70}\\ {8,20,26,30,38,40,50,70,80,90}\end{array}$ 第一趟（增量5）：第二趟（增量3）：第三趟（增量1）：  

# 8.3 交换排序  

所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，一般很少直接考查，通常会重点考查快速排序算法的相关内容。  

# 8.3.1 冒泡排序  

冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般遂渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置·这样最多做 $n-1$ 趟冒泡就能把所有元素排好序。  

图8.3所示为冒泡排序的过程，第一趟冒泡时： $27<\overline{{49}}$ ，不交换； $13<27$ ，不交换； $76>13$ 交换； $97>13$ ，交换； $65>13$ ，交换； $38>13$ ，交换； $49>13$ ，交换。通过第一趟冒泡后，最小元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排序，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ed7cdadbc990048828d90cd70389495b74cc134c304ca5434cc034bef5c682a7.jpg)  
图8.3冒泡排序示例  

冒泡排序算法的代码如下：  

void BubbleSort（ElemType A[],int for(int  $\scriptstyle{\dot{\boldsymbol{\perp}}}=0$  ;i<n-1;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  boolflag  $=$  false; for(int  $\scriptstyle{\mathfrak{j}}=\mathbf{n}-1$  ;j>i;j--) if(A[j-1]>A[j]){  

//表示本趟冒泡是否发生交换的标志

/一趟冒泡过程

//若为逆序  
swap（A[j-1]，A[j]）；//使用封装的swap函数交换flag  $=$  true; if(flag  $==$  false) return;川本趟遍历后没有发生交换，说明表已经有序  

冒泡排序的性能分析如下：  

空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换），从而直接跳出循环，比较次数为 $n\!-\!1$ ，移动次数为0，从而最好情况下的时间复杂度为 $O(n)$ ：当初始序列为逆序时，需要进行 $n-1$ 趟排序，第 $i$ 趟排序要进行 $_{n-i}$ 次关键字的比较，而且每次比较后都必须移动元素3次来交换元素位置。这种情况下，  

$=\sum_{i=1}^{n-1}3(n-i)={\frac{3n(n-1)}{2}}$  

从而，最坏情况下的时间复杂度为 $O(n^{2})$ ，平均时间复杂度为 $O(n^{2})$ 稳定性：由于 $i\!>\!j$ 且 $\mathbb{A}\left[\dot{\mathtt{\lambda}}\right]{=}\mathbb{A}$ [j]时，不会发生交换，因此冒泡排序是一种稳定的排序算法。适用性：冒泡排序适用于顺序存储和链式存储的线性表。  

> attention:  

冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于（或大于）无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。  

# 8.3.2 快速排序  

快速排序（以下有时简称快排）的基本思想是基于分治法的：在待排序表L[1..n]中任取一个元素pivot作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1.k-1]和 $\operatorname{L}\left[\mathsf{k}\!+\!1...\mathsf{n}\right]$ ，使得L[1.k-1]中的所有元素小于pivot， $\mathrm{L}\,[\,\mathsf{k}\!+\!1...\mathsf{n}\,]$ 中的所有元素大于或等于pivot，则pivot放在了其最终位置L（k）上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。Y  

一趟快速排序的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针和j，初值分别为low和high，取第一个元素49为枢轴赋值到变量pivot。  

指针j从high往前搜索找到第一个小于枢轴的元素27，将27交换到i所指位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/526c93eb7112f29a9e13e9ad683c9d3dc855c77dc463ca2b2d7e5ec96387ca9d.jpg)  

指针i从1ow往后搜索找到第一个大于枢轴的元素65，将65交换到j所指位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/567c047e31d6ce1a994c684a4dfb4b2d64c9ba4e4c04b1136c9c4c4e3317aa7d.jpg)  
指针继续往前搜索找到小于枢轴的元素13，将13交换到1所指位置。  

27 38 97 76 13 65 49  

指针i继续往后搜索找到大于枢轴的元素97，将97交换到j所指位置。  

27 38 13 97 76 65 4S  

指针j继续往前搜索小于枢轴的元素，直至 $\scriptstyle{\dot{\Sigma}}=={\dot{\bar{\jmath}}}$  

27 38 13 76 97 65 49  

命题追踪快速排序的中间过程的分析（2014、2019、2023）  

此时，指针i（ $==$ ）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放在 $i$ 所指位置即其最终位置，经过第一趟排序后，将原序列分割成了前后两个子序列。  

第一趟后：{273813}4976976549}按照同样的方法对各子序列进行快速排序，若待排序列中只有一个元素，显然已有序。  

第二趟后：{13}27{38}49{4965}76{97}第三趟后：1327384949{65)76{97}第四趟后：13273849496576(97}  

用二叉树的形式描述这个举例的递归调用过程，如图8.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2bdd6336cf0831776e3ad890454e55448ca6aee0524d2ccb668cfe812107e532.jpg)  
图8.4快速排序的递归执行过程  

假设划分算法已知，记为Partition（），返回的是上述的 $\boldsymbol{\kappa}$ ，则L（k）已放在其最终位置。因此可以先对表进行划分，然后对两个子表递归地调用快速排序算法进行排序。代码如下：  
//Partition（）就是划分操作，将表A[low"high]划分为满足上述条件的两个子表 in t pivot pos $=$ Partition（A,low，high）;//划分QuickSort（A，low，pivotpos-l）；//QuickSort(A,pivotpos  $^{+1}$  ,high);  

# 命题追踪  

（算法题）快速排序中划分操作的应用（2016）  

快速排序算法的性能主要取决于划分操作的好坏。考研所考查的快速排序的划分操作通常总以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，使得一趟Partition（)操作后，表中的元素被枢轴一分为二。代码如下：  

in t Partition（ElemTypeA[]，intlow，inthigh）{//一趟划分 ElemType pivot $\mathtt{=}\mathtt{A}$ [1ow］；//将当前表中第一个元素设为枢轴，对表进行划分while（low<high){//循环跳出条件while（low<high&&A[high]>=pivot)--high; A[low]  $\mathtt{\ =}\mathtt{A}$  [high]；//将比枢轴小的元素移动到左端 while(low<high&&A[low]  $<=$  pivot)  $++\bot{\mathrm{or}}w$  A[high] $\mathtt{\ =}\mathtt{A}$ [low]；/将比枢轴大的元素移动到右端A[low] $=$ pivot;//枢轴元素存放到最终位置returnlow;/返回存放枢轴的最终位置  

快速排序算法的性能分析如下：  

# 命题追踪快速排序中递归次数的影响因素分析（2010）  

空间效率：由于快速排序是递归的，因此需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大层数一致。最好情况下为 $O(\log_{2}\!n)$ ；最坏情况下，要进行 $n-1$ 次递归调用，因此栈的深度为 $O(n)$ ；平均情况下，栈的深度为 $O(\log_{2}n)$  

时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含 $n\!-\!1$ 个元素和0个元素时，这种最大限度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为 $O(n^{2})$  

有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。  

在最理想的状态下，即Partition（)能做到最平衡的划分，得到的两个子问题的大小都不可能大于 $n/2$ ，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为 $O(n\mathrm{log}_{2}n)$ 好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。  

稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序算法。例如，表 $L=$ 3，2，2}，经过一趟排序后 $L=\{2,2,3\}$ ，最终排序序列也是 $L=\{2,2,3\}$ ，显然，2与2的相对次序已发生了变化。  

# 命题追踪快速排序适合采用的存储方式（2011）  

适用性：快速排序仅适用于顺序存储的线性表。  
> attention:  

在快速排序算法中，并不产生有序子序列，但每一趟排序后会将上一趟划分的各个无序子表的枢轴（基准）元素放到其最终的位置上。  

# 8.3.3 本节试题精选  

# 一、单项选择题  

01.对 $n$ 个不同的元素利用冒泡法从小到大排序，在（）情况下元素交换的次数最多。  

A.从大到小排列好的B.从小到大排列好的C.元素无序D.元素基本有序  

02.若用冒泡排序算法对序列10，14，26，29，41，52}从大到小排序，则需进行（）次比较。A.3 B.10 C.15 D.25  

03.用某种排序算法对线性表25，84，21，47，15，27，68，35，20进行排序时，元素序列的变化情况如下：  

1)25,84,21,47,15,27,68,35,20 2）20,15,21,25,47,27,68,35,84 3）15,20,21,25,35,27,47,68,84 4）15.20.21,25,27,35,47,68,84 则所采用的排序算法是（）  

A.选择排序 B.插入排序 C.二路归并排序 D.快速排序  

04.一组记录的关键码为（46，79，56，38，40，84），则利用快速排序算法，以第一个记录为基准，从小到大得到的一次划分结果为（）  

A.（38,40,46,56,79,84)B.（40,38,46,79,56,84）C.（40,38,46,56,79,84)D.（40,38,46,84,56,79）  

05.快速排序算法在（）情况下最不利于发挥其长处。  

A.要排序的数据量太大B.要排序的数据中含有多个相同值C.要排序的数据个数为奇数D.要排序的数据已基本有序  

06.就平均性能而言，目前最好的内部排序算法是（！）A.冒泡排序B.直接插入排序C.希尔排序D.快速排序  

$F\!=\{2,1,4,9,8,10,6,20\}$ 只能是下列排序算法中的（）两趟排序后的结果。A.快速排序 B.冒泡排序 C.选择排序 D.插入排序  

08.对数据序列 $\{8,9,10,4,5,6,20,1,2\}$ 采用冒泡排序（从后往前次序进行，要求升序），需要进行的趟数至少是（）。  

A.3 B.4 C.5 D.8  

09.双向冒泡排序是指对一个序列在正反两个方向交替进行扫描，第一趟把最大值放在序列的最右端，第二趟把最小值放在序列的最左端，之后在缩小的范围内进行同样的扫描，放在次右端、次左端，直至序列有序。对数组4，7，8，3，5，6，10，9，1，21进行双向冒泡排序，则排序趟数是（）。（第一趟从左往右开始，从左往右或从右往左都称为一趟。）  

A.7 B.6 C.8 D.9  

10.对下列关键字序列用快速排序进行排序时，每次选取的基准元素都为待处理序列的第一个元素，速度最快的情形是（），速度最慢的情形是（）。  
A.{21,25,5,17,9,23,30} B.{25,23,30,17,21,5,9} C.{21,9,17,30,25,23,5} D.{5,9,17,21,23,25,30}  

11.对下列4个序列，以第一个关键字为基准用快速排序算法进行排序，在第一趟过程中移动记录次数最多的是（）。  

A.92,96,88,42,30,35,110,100 B.92,96,100,110,42,35,30,88 C.100,96,92,35,30,110,88,42 D.42,30,35,92,100,96,88,110  

12.下列序列中，（）可能是执行第一趟快速排序后所得到的序列（按从大到小排序和从小到大排序来分别讨论）。  

1.{68,11,18,69,23,93,73} II.{68,11,69,23,18,93,73} IⅢI.{93,73,68,11,69,23,18} IV.{68,11,69,23,18,73,93} A.I、IVB.II、IⅢIC.IⅢI、IVD.只有IV  

13.对 $n$ 个关键字进行快速排序，最大递归深度为（），最小递归深度为（）A. 1 B.n C. log2n D. nlog2n

 14.对8个元素的序列进行快速排序，在最好情况下的关键字比较次数是（）。A. 7 B.8 C. 12 D.13  

15.【2010统考真题】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是（）。  

A.递归次数与初始数据的排列次序无关B.每次划分后，先处理较长的分区可以减少递归次数C.每次划分后，先处理较短的分区可以减少递归次数D.递归次数与每次划分后得到的分区的处理顺序无关  

16.【2011统考真题】为实现快速排序算法，待排序序列宜采用的存储方式是（）。A.顺序存储 B．散列存储 C.链式存储 D.索引存储

 17.【2014统考真题】下列选项中，不可能是快速排序第二趟排序结果的是（）  

A.2,3,5,4,6,7,9 B.2,7,5,6,4,3,9 C.3,2,5,4,7,6,9 D.4,2,3,5,7,6,9  

18.【2019统考真题】排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列序列中，不可能是快速排序第二趟结果的是（）。  

A.5,2,16,12,28,60,32,72 B.2,16,5,28,12,60,32,72 C.2,12,16,5,28,32,72,60 D.5,2,12,28,16,32,72,60  

19.【2023统考真题】使用快速排序算法对数据进行升序排序，若经过一次划分后得到的数据序列是68,11,70,23,80,77,48,81,93,88，则该次划分的枢轴是（）。  

A. 11 B.70 C. 80 D. 81  

# 二、综合应用题  

01.已知线性表按顺序存储，且每个元素都是不相同的整数型元素，设计把所有奇数移动到所有偶数前边的算法（要求时间最短，辅助空间最小）。  

02.试编写一个算法，使之能够在数组L[l..n]中找出第 $k$ 小的元素（即从小到大排序后处于第 $k$ 个位置的元素）  

03.荷兰国旗问题：设有一个仅由红、白、蓝三种颜色的条块组成的条块序列，存储在一个顺序表中，请编写一个时间复杂度为 $O(n)$ 的算法，使得这些条块按红、白、蓝的顺序排好，即排成荷兰国旗图案。请完成算法实现：typedef enum(RED,WHITE,BLUE} color; /设置枚举数组 void Flag Arrange（color a[],int n) $\{\mathrm{~\,~\,~}\}$  
04.【2016统考真题】已知由  $n$  C  $n\!\geqslant\!2$  ）个正整数构成的集合  $A\!=\!\{a_{k}|0\!\leqslant\!k<\!n\}$  ，将其划分为 两个不相交的子集 $A_{1}$ 和 $A_{2}$ ，元素个数分别是 $n_{1}$ 和 $n_{2}$ ， $A_{1}$ 和 $A_{2}$ 中的元素之和分别为 $S_{1}$ 和 $S_{2}.$ ，设计一个尽可能高效的划分算法，满足 $|n_{1}\!-\!n_{2}|$ 最小且 $|S_{1}\!-\!S_{2}|$ 最大。要求：  

1）给出算法的基本设计思想。2）根据设计思想，采用C或 $\mathrm{C++}$ 语言描述算法，关键之处给出注释。3）说明所设计算法的平均时间复杂度和空间复杂度。  

# 8.3.4 答案与解析  

# 一、单项选择题  

01.A  

冒泡排序最少进行1趟冒泡，最多进行 $n\!-\!1$ 趟冒泡。初始序列为逆序时，需进行 $n\!-\!1$ 趟冒孢，并且元素交换的次数最多。初始序列为止序时，进行1趟冒泡（无交换）就可结束算法。  

02.C  

冒泡排序始终在调整“逆序”，因此交换次数为排列中逆序的个数。对逆序序列进行冒泡排序，每个元素向后调整时都需要进行比较，因此共需要比较 $5+4+3+2+1=15$ 次。  

03.D  

选择排序在每趟结束后可以确定一个元素的最终位置，不对。插入排序，第 $i$ 趟后前 $i+1$ 个元素应该是有序的，不对。第二趟{20,15}和{21，25}是反序的，因此不是归并排序。快速排序每趟都将基准元素放在其最终位置，然后以它为基准将序列划分为两个子序列。观察题中的排序过程，可知是快速排序。  

04.C  

以46为基准元素，首先从后往前扫描比46小的元素，并与之进行交换，而后从前往后扫描比46大的元素并将46与该元素交换，得到(40,46,56,38，79,84)。此后，继续重复从后往前扫描与从前往后扫描的操作，直到46处于最终位置。  

05.D  

当待排序数据为基本有序时，每次选取第 $n$ 个元素为基准，会导致划分区间分配不均匀，不利于发挥快速排序算法的优势。相反，当待排序数据分布较为随机时，基准元素能将序列划分为两个长度大致相等的序列，这时才能发择快速排序的优势。  

06.D  

这里问的是平均性能，选项A、B的平均性能都会达到 $O(n^{2})$ ，而希尔排序虽然大大降低了直接插入排序的时间复杂度，但其平均性能不如快速排序。另外，虽然众多排序算法的平均时间复杂度也是 $O(n\log_{2}n)$ ，但快速排序算法的常数因子是最小的。  

07. A  

若为插入排序，则前三个元素应该是有序的，显然不对。而冒泡排序和选择排序经过两趟排序后应该有两个元素处于最终位置（最左/右端），无论是按从小到大还是从大到小排序，数据序列中都没有两个满足这样的条件的元素，因此只可能选A项。  

【另解】先写出排好序的序列，并和题中的序列做对比。题中序列：2149810620已排好序序列：1246891020  
在已排好序的序列中，与题中序列相同的元素有4、8和20，最左和最右两个元素与题中的序列不同，所以不可能是冒泡排序、选择排序或插入排序。  

08.C  

从后往前冒泡的过程为，第一趟{1,8,9,10,4,5,6,20,2}，第二趟/1,2,8,9,10,4,5，6,20}，第三趟 $\{1,2,4,8,9,10,5,6,20\},$ 第四趟1,2,4,5,8,9,10,6,20}，第五趟{1,2,4,5,6,8,9,10,20}，经过第五趟冒泡后，序列已经全局有序，所以选择选项C。实际每趟冒泡发生交换后可以判断是否会产生新的逆序对，若不会产生，则本趟冒泡之后序列全局有序，所以最少5趟即可。  

# 09.B  

第一趟从左往右的排序结果为 $4,7,3,5,6,8,9,1,2,10;$ ：第二趟从右往左的排序结果为1，4,7，3,5，6,8,9,2,10；第三趟从左往右的排序结果为1,4,3，5，6,7,8,2，9,10；第四趟从右往左的排序结果为1,2,4，3,5，6，7,8,9,10；第五趟从左往右的排序结果为 $1,2,3,4,5,6,7,8,9,10$ ，此时序列已有序，但仍需进行一趟无交换的排序才能确定序列已有序，因此共需6趟排序。  

10.A、D  

当每趟的枢轴值都把表等分为长度相近的两个子表时，速度是最快的；当表本身已经有序或逆序时，速度最慢。选项D中的序列已按关键字排好序，因此它是最慢的，而选项A中第一趟枢轴值21将表划分为两个子表{9，17，5}和{25，23，30}，而后对两个子表划分时，枢轴值再次将它们等分，所以该序列是快速排序最优的情况，速度最快。针对其他选项，可以进行类似的分析。  

11.B  

对各序列分别执行一趟快速排序，可做如下分析（以选项A为例）：由于枢轴值为92，因此35移动到第一个位置，96移动到第六个位置，30移动到第二个位置，再将枢轴值移动到30所在的单元，即第五个位置，所以A项中序列移动的次数为4。同样，可以分析出B项中序列的移动次数为8，C项中序列的移动次数为4，D项中序列的移动次数为2。  

12.C  

显然，若按从小到大排序，则最终有序的序列是{11,18,23,68,69,73,93}；若按从大到小排 序，则最终有序的序列是93，73.69.68.23.18.11。对比可知选项1、ⅡI中没有处于最终位置的元素，所以I、Ⅱ项都不可能。Ⅲ项中73和93处于从大到小排序后的最终位置，而且73将序列分割成大于73和小于73的两部分，所以IⅢI项是有可能的。IV项中73和93处于从小到大排列后的最终位置，73也将序列分割成大于73和小于73的两部分。  

13.B、C  

快速排序过程构成一个递归树，递归深度即递归树的高度。枢轴值每次都将子表等分时，递归树的高为 $\log_{2}\!n$ ；枢轴值每次都是子表的最大值或最小值时，递归树退化为单链表，树高为 $n$  

14. D  

快速排序的最好情况是每次划分将待排序列划分为等长的两部分。因此，第一趟将第1个元素与后面的7个元素进行比较，将原序列划分为长度为3和4的两个子表，比较7次：第二趟对两个子表进行划分，将长度为3的子表划分为长度为1的两个子表（不用继续划分），比较2次，将长度为4的子表划分为长度为1和2的两个子表，比较3次；第三趟将长度为2的子表划分为长度为1的子表，比较1次。至此，排序结束，共进行的比较次数是 $7+2+3+1=13$  

15.D  

快速排序的递归次数与元素的初始排列有关。若每次划分后分区比较平衡，则递归次数少：若划分后分区不平衡，则递归次数多。递归次数与分区处理顺序无关。  

16.A  
对于绝大部分内部排序而言，只适用于顺序存储结构。快速排序在排序的过程中，既要从后往前查找，也要从前往后查找，因此宜采用顺序存储。  

17. C  

对 $n$ 个元素进行第一趟快速排序后，会确定一个基准元素，根据这个基准元素在数组中的位置，有两种情况： $\textcircled{\scriptsize{1}}$ 基准元素在数组的首端或尾端，接下来对剩下的 $n^{-1}$ 个元素构成的子序列进行第二趟快速排序，再确定一个基准元素。这样，在两趟排序后就至少能确定两个元素的最终位置，其中至少有一个元素是在数组的首端或尾端。 $\circledcirc$ 基准元素不在数组的首端或尾端，第二趟快快速排序对基准元素划分开的两个子序列分别进行一次划分，两个子序列各确定一个基准元素。这样，两趟排序后就至少能确定三个元素的最终位置。基于上述结论，观察题中的四个选项，A项的2,3，6,7，9符合第一种或第二种情况；B项中2，9符合第一种情况；D项中5，9符合第一种情况；最后看C项，只有9处于最终位置，因此不可能是快速排序第二趟的结果。  

18.D  

基于上题中分析得出的结论，观察题中的四个选项，A项的28，72符合第一种情况；B项的2，72符合第一种情况；C项的2，28，32符合第一种或第二种情况：最后看D项，只有12和32处于最终位置，既不符合第一种情况，又不符合第二种情况。  

19.D  

第一趟划分后得到的序列中只有一个枢轴，因此可将当前序列和最终排好序的序列进行比较，如下表所示。枢轴会出现在两个序列的相同位置，可以看出枢轴只可能是77、81，选项只有81。在当前序列中，77左边有比它大的元素80，因此77不是枢轴；而81左边都是比它小的元素，右边都是比它大的元素，因此81是枢轴。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/14ea3a3aee3d03b516d8d5f1e07e7e546d7165bc0b12e5b009d41cbf65597c2a.jpg)  

# 二、综合应用题  

01.【解答】  

本题可采用基于快速排序的划分思想来设计算法，只需遍历一次即可，其时间复杂度为 $O(n)$ 空间复杂度为 $O(1)$ 。假设表为L[l.n]，基本思想是：先从前往后找到一个偶数元素L（i），再从后往前找到一个奇数元素L(j)，将二者交换；重复上述过程直到i大于j。  

算法的实现如下：  

void move(ElemType A[l,intlen){ //对表A按奇偶进行一趟划分int  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\dot{\mathbf{\rho}}}=\mathbf{L}\mathbf{e n}-1$  //i表示左端偶数元素的下标；j表示右端奇数元素的下标 while(i<j){ while（i<j&&A[i]2！=0) $\ \ \mathrm{i}_{++}$ ；//从前往后找到一个偶数元素while（i<j&&A[j]2！=1）j--；//从后往前找到一个奇数元素if (i<j){ Swap(A[i],A[j]);//交换这两个元素 $\ \ \mathrm{i++}$ ;j--;  

02.【解答】  

显然，本题最直接的做法是用排序算法对数组先进行从小到大的排序，然后直接提取L(k)便得到了第 $k$ 小的元素，但其平均时间复杂度将达到 $O(n\mathrm{log}_{2}n)$ 以上。此外，还可采用小顶堆的方法，每次堆顶元素都是最小值元素，时间复杂度为 $O(n+k\log_{2}n)$ 。下面介绍一个更精彩的算法，它基于快速排序的划分操作。  
这个算法的主要思想如下：从数组L[1..n]中选择枢轴pivot（随机或直接取第一个）进行和快速排序一样的划分操作后，表L[1.n]被划分为L[1..m-1]和 $\mathbb{L}\left[\mathbb{m}\!+\!\mathbb{1}\mathrm{...n}\right]$ ，其中L $\mathrm{(m)=}$ pivot。  

讨论 $m$ 与 $k$ 的大小关系：  

1）当 $m\!=\!k$ 时，显然pivot就是所要寻找的元素，直接返回pivot即可。2）当 $m<k$ 时，所要寻找的元素一定落在 $\mathbb{L}\left[\mathbb{m}\!+\!1...\mathbb{n}\right]$ 中，因此可对 $\mathbb{L}\left[\mathbb{m}\!+\!1...\mathbb{n}\right]$ 递归地查找第 $k\!-\!m$ 小的元素。3）当 $m>k$ 时，所要寻找的元素一定落在L[1.m-1]中，因此可对 $\mathbb{L}\left[1...\mathbb{m}^{-1}\right]$ 递归地查找第 $k$ 小的元素。  

该算法的时间复杂度在平均情况下可以达到 $O(n)$ ，而所占空间的复杂度则取决于划分的方法。算法的实现如下：  

int kth elem（int a[],int low,int high,int k)( int pivot=a[low]; int low temp $=$ low;//由于下面会修改1ow与high，在递归时又要用到它们int high temp  $\scriptstyle\varepsilon=$  high; while（low<high){ while（low<high&&a[high]  $>=$  pivot) --high; a[low]  $=\mathtt{a}$  [high]; while（low<high&&a[low]  $<=$  pivot)  $++1o w$  a[high]  $=\mathtt{a}$  [low]; a[low]=pivot; //上面为快速排序中的划分算法//以下是本算法思想中所述的内容if（low $\scriptstyle{\left(==k\right.}$ /由于与 $\kappa$ 相同，直接返回pivot元素returna[low]; else if(low>k)在前一部分表中递归寻找return kth_elem(a,low_temp,low-1,k); else/在后一部分表中递归寻找returnkth elem（a,low+1,high temp,k）;  

03.【解答】  

算法思想：顺序扫描线性表，将红色条块交换到线性表的最前面，蓝色条块交换到线性表的最后面。为此，设立三个指针，其中， $j$ 为工作指针，表示当前扫描的元素，i以前的元素全部为红色， $k$ 以后的元素全部为蓝色。根据 $j$ 所指示元素的颜色，决定将其交换到序列的前部或尾部。初始时 $i=0$ ， $k\!=\!n-1$ ，算法的实现如下：  

type de fe num{RED，WHITE，BLUE}color；//设置枚举数组void Flag Arrange（colora[],int n）int  $\scriptstyle{\dot{\mathtt{i}}}=0\,,\;{\dot{\mathtt{j}}}=0\,,\;{\dot{\mathtt{k}}}={\mathtt{n}}-1$  while  $|j<=k$  switch（a[jl）（//判断条块的颜色caseRED:Swap（a[i],a[j]);  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  ;j++;break; 川红色，则和i交换CaseWHITE:  $\,\mathsf{j}^{++}$  ;break;  
case BLUE:Swap（a[j],a[k]);k--;//蓝色，则和  $\kappa$  交换 /这里没有 $\j++$ 语句，以防止交换后a[j]仍为蓝色  

例如，将元素值正数、负数和零排序为前面都是负数，接着是0，最后是正数，也用同样的方法。思考：为什么caseRED语句不用考虑交换后a[j]仍为红色，而caseBLUE语句中却需要考虑交换后a[j]仍为蓝色？  

# 04.【解答】  

1）算法的基本设计思想  

由题意可知，将最小的 $_{n/2,}$ 个元素放在 $A_{1}$ 中，其余的元素放在 $A_{2}$ 中，分组结果即可满足题自要求。仿照快速排序的思想，基于枢轴将 $n$ 个整数划分为两个子集。根据划分后枢轴所处的位置i分别处理：  

$\textcircled{\scriptsize{1}}$ 若 $i\!=\!\lfloor n/2\rfloor$ ，则分组完成，算法结束。  

$\circledcirc$ 若 $i<\lfloor n/2\rfloor$ ，则枢轴及之前的所有元素均属于 $A_{1}$ ，继续对 $i$ 之后的元素进行划分。  

$\textcircled{3}$ 若 $i\!>\!\lfloor n/2\rfloor$ ，则枢轴及之后的所有元素均属于 $A_{2}$ ，继续对 $i$ 之前的元素进行划分。  

基于该设计思想实现的算法，无须对全部元素进行全排序，其平均时间复杂度是 $O(n)$ ，空间复杂度是  $O(1)$  

2）算法实现  

int set Partition（int a[],int n){ int pivotkey，low  $\scriptstyle{\prime=0}$  ,low  $){=}0$  ,high=n-1,high0=n-l,flag  $\scriptstyle{=1}$  ，  $\scriptstyle\kappa=n/2$  ,i; int  $_{s1=0}$   $_{{\tt S Z}=0}$  while（flag){ pivotkey  $\mathrm{=a}$  [low]; /选择枢轴 while（low<high)//基于枢轴对数据进行划分while（low<high&& a[high]  $>=$  pivotkey)--high; if(low!  $=$  high)a[low]  $=\mathtt{a}$  [high]; while（low<high&& a[low]  $<=$  pivotkey)++low; if(low!  $=$  high)a[high]  $=\mathrm{a}$  [low]; llend of while（low<high) a[low]  $=$  pivotkey; if(low  $\scriptstyle{\prime=k-1}$  /若枢轴是第  $\mathrm{n}/2$  小的元素，划分成功 flag  $=\!0$  elsef1/是否继续划分if（low<k-1){ lowo  $\scriptstyle\left(=++\right.$  low; high  $\scriptstyle=$  higho; elsef higho  $=$  --high; low=low0; for $|\dot{\mathbf{\nabla}}\dot{\mathbf{\mathrm{i}}}\!=\!0$ ;i<k;i++）sl+=a[i];for  $(\mathrm{i}\!=\!\!\mathrm{k}$   $\scriptstyle{\mathrm{~i~}}<{\mathrm{n}}$   $\ \ \mathrm{i}_{\leftarrow}$  ）s2+=a[i]; return s2-sl;  
3）本算法的平均时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$  

# 8.4 选择排序  

选择排序的基本思想是：每一趟（如第 $i$ 趟）在后面 $n-i+1\ (i=1,2,\cdots,n-1)$ 个待排序元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到第 $n\!-\!1$ 趟做完，待排序元素只剩下1个，就不用再选。选择排序中的堆排序是历年统考考查的重点。  

# 8.4.1 简单选择排序  

根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为L[1.n]，第 $i$ 趟排序即从L[i.n]中选择关键字最小的元素与L（i）交换，每一趟排序可以确定一个元素的最终位置，这样经过 $n\!-\!1$ 趟排序就可使得整个排序表有序。  

简单选择排序算法的代码如下：  

void SelectSort（ElemType A[l,int n){ for(int  $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$   $\scriptstyle{\mathrm{i}}<{\mathrm{n}}-1$   $\ \ \mathrm{i}_{\mathrm{^{++}}}$  //一共进行n-1趟 int min $\mathbf{\tau}=\dot{\mathbf{\tau}}\mathbf{\Gamma}$ //记录最小元素位置for（int $\scriptstyle{\mathrm{j}}={\mathrm{i}}+1$ ;j<n; $\j++$ //在A[in-1]中选择最小的元素if(A[j] $\tt<\tt A$ [min]） min=j;/更新最小元素位置if(min ${\mathfrak{z}}={\mathfrak{z}}$ ）swap（A[i]，A[min]）；//封装的swap（）函数共移动元素3次  

简单选择排序算法的性能分析如下：  

空间效率：仅使用常数个辅助单元，所以空间效率为 $O(1)$  

时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过 $3(n-1)$ 次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是 $n(n-1)/2$ 次，因此时间复杂度始终是 $O(n^{2})$  

稳定性：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与含有相同关键字的元素的相对位置发生改变。例如，表 $L=\{2,2,1\}$ ，经过一趟排序后 $L=\{1,2,2\}$ ，最终排序序列也是 $L=\{1,2,2\}$ ，显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳定的排序算法。女  

适用性：简单选择排序适用于顺序存储和链式存储的线性表，以及关键字较少的情况。  

# 8.4.2 堆排序  

堆的定义如下， $n$ 个关键字序列L[1..n]称为堆，当且仅当该序列满足：  

$\textcircled{1}\,\texttt{L}(\dot{\texttt{i}})>=\texttt{L}$ （2i）且 $\tt L\left(\mathrm{i}\right)\mathrm{>=}\tt L$ （2i+1）或 $\circledcirc\mathrm{~\bf~L~}(\dot{\mathrm{~\bf~i~}})<=\tt{L}$ （2i）且 $\mathrm{~\tt~L~}(\mathrm{i})<=\tt L\;(2\,\mathrm{i}+1)$ （1≤i≤Ln/2]）  

命题追踪堆的性质与特点（2020）  

可以将堆视为一颗完全二叉树，满足条件 $\circledcirc$ 的堆称为大根堆（大顶堆），大根堆的最大元素存放在根结点，且其任意一个非根结点的值小于或等于其双亲结点值。满足条件 $\mathcal{Q}$ 的堆称为小根堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2247078dce401249cf3e73341e50d39d624875f9123a83d24eb59f6fed868004.jpg)  
图8.5一个大根堆示意图  

堆排序的思路很简单：首先将存放在L[1.n]中的 $n$ 个元素建成初始堆，因为堆本身的特点（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再 输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见，堆排序需要解决两个问题： $\textcircled{\scriptsize{1}}$ 如可将无序序列构造成初始堆？ $\circledcirc$ 输出堆顶元素后，如何将剩余元素调整成新的堆？  

# 命题追踪初始建堆的操作（2018、2021）  

堆排序的关键是构造初始堆。 $n$ 个结点的完全二叉树，最后一个结点是第 $\lfloor n/2\rfloor$ 个结点的孩子。对以第 $\lfloor n/2\rfloor$ 个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点 $(\lfloor n/2\rfloor-1{\sim}1)$ 为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。  

如图8.6所示，初始时调整  $L(4)$  子树，  $09<32$  ，交换，交换后满足堆的定义；向前继续调整 L(3）子树， $78<$ 左右孩子的较大者87，交换，交换后满足堆的定义；向前调整 $L(2)$ 子树， $17<$ 左右孩子的较大者45，交换后满足堆的定义：向前调整至根结点 $L(1)$ ， $53<$ 左右孩子的较大者87，交换，交换后破坏了 $L(3)$ 子树的堆，采用上述方法对 $L(3)$ 进行调整， $53<$ 左右孩子的较大者78，交换，至此该完全二叉树满足堆的定义。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a02575fe03c9077c1e1b12da0a42128eed1a6389ff67ccc69548cc3ecd8c9411.jpg)  
图8.6自下往上逐步调整为大根堆  
# 命题追踪输出堆顶元素后调整堆的比较次数的分析（2015）  

输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。将09和左右孩子的较大者78交换，交换后破坏了 $L(3)$ 子树的堆，继续对 $L(3)$ 子树向下筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.7所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/705800718fde337b1004d353eb67a4467c05345b00380d86c440143a0192d934.jpg)  
图8.7输出堆顶元素后再将剩余元素调整成新堆  

下面是建立大根堆的算法：  

void Build Max Heap（ElemType A[],intlen) for（inti=len/2;i>0;i--) 川/从  $\mathrm{i}\!=\![\mathrm{n}/2]\!\sim\!1$  ，反复调整堆 HeadAdjust（A,i,len);  

void HeadAdjust（ElemType A[],int k,int len）(//Head Adjust  $\kappa$  为根的子树进行调整  

$\mathtt{A}\left[\,0\,\right]\mathtt{=A}\left[\,k\,\right]$  I/A[0】暂存子树的根结点 for（int $\scriptstyle{\dot{1}}=Z^{\star}k$  $\scriptstyle{\mathrm{i}}<={\mathrm{1em}}$  $\scriptstyle{\mathrm{~i~}}\star=2$ ）/沿key较大的子结点向下筛选if（i<len&&A[i]<A[i+l])  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ //取key较大的子结点的下标if  $\scriptstyle(\mathtt{A}\,[\,0\,]\,>=\mathtt{A}\,[\,\mathtt{i}\,]$  )break; 筛选结束 elsel A[k]  $\mathtt{\ =A}$  [i]; //将A[i]调整到双亲结点上  $\kappa{=}1$ //修改 $\kappa$ 值，以便继续向下筛选A[k]=A[0];//被筛选结点的值放入最终位置  

调整的时间与树高有关，为 $O(h)$ 。在建含 $n$ 个元素的堆时，关键字的比较总次数不超过 $4n$ 时间复杂度为 $O(n)$ ，这说明可以在线性时间内将一个无序数组建成一个堆。  

下面是堆排序算法：  

void HeapSort（ElemType A[],int len){ Build Max Heap(A,len); /初始建堆 for（int i=len; $^{\mathrm{i}>1}$ ;i--）{ ${\mathrm{{//n-1}}}$ 趟的交换和建堆过程Swap(A[i],A[1]);//输出堆顶元素（和堆底元素交换）HeadAdjust（A,l,i-1); /调整，把剩余的i-1个元素整理成堆  

# 命题追踪堆的插入操作及比较次数的分析（2009、2011）  

同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。大根堆的插入操作示例如图8.8所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/98ce82e66a4eab0bac8b05ca1e714ecc3d9283c4602d47d25fd506bba0c39752.jpg)  
图8.8大根堆的插入操作示例  

# 命题追踪堆在海量数据中选出最小 $\pmb{k}$ 个数的应用及效率分析（2022）  

堆排序适合关键字较多的情况。例如，在1亿个数中选出前100个最大值。首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。  

堆排序算法的性能分析如下：  

空间效率：仅使用了常数个辅助单元，所以空间复杂度为 $O(1)$  

时间效率：建堆时间为 $O(n)$ ，之后有 $n\!-\!1$ 次向下调整操作，每次调整的时间复杂度为 $O(h)$ 所以在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n\log_{2}n)$  

稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序算法。例如，表 $L=\{1,2,2\}$ ，构造初始堆时可能将2交换到堆顶，此时 $L=\{2,1,2\}$ 最终排序序列为 $L=\{1,2,2\}$ ，显然，2与2的相对次序已发生变化。  

适用性：堆排序仅适用于顺序存储的线性表。  

# 8.4.3 本节试题精选  

# 一、单项选择题  

01.在以下排序算法中，每次从未排序的记录中选取最小关键字的记录，加入已排序记录的末尾，该排序算法是（）。  

A.简单选择排序B.冒泡排序 C.堆排序 D.直接插入排序  

02.简单选择排序算法的比较次数和移动次数分别为（）  

A. O(n),  $O(\log_{2}n)$  B.  $O(\log_{2}\!n)$   $O(n^{2})$  C. $O(n^{2})$ ，0(n)D. $O(n\mathrm{log}_{2}n)$ ， $O(n)$  

03.若只想得到100000个元素组成的序列中第10个最小元素之前的部分排序的序列，用（）方法最快。  

A.冒泡排序 B.快速排序 C.归并排序 D.堆排序  

04.下列（）是一个堆。  

A.19,75,34,26,97,56 B.97,26,34,75,19,56 C.19,56,26,97,34,75 D.19,34,26,97,56,75  

05.在含有 $n$ 个关键字的小根堆中，关键字最大的记录有可能存储在（）位置。A.n/2 B.  $n/2+2$  XC.1 D.n/2-1 06.向具有 $n$ 个结点的堆中插入一个新元素的时间复杂度为（），删除一个元素的时间复杂  
度为（）。  

A.0(1) B.O(n) C.  $O(\log_{2}\!n)$  D.O(nlog2n)  

07.构建 $n$ 个记录的初始堆，其时间复杂度为（）；对 $n$ 个记录进行堆排序，最坏情况下其时间复杂度为（）。  

A.O(n) B.O(n²) C.  $O(\log_{2}\!n)$  D.O(nlog2n)  

08.下列4种排序算法中，排序过程中的比较次数与序列初始状态无关的是（）  

A.简单选择排序B.直接插入排序C.快速排序D.冒泡排序  

09.对由相同的 $n$ 个整数构成的二叉排序树和小根堆，下列说法中不正确的是（）。  

A.二叉排序树的高度大于或等于小根堆的高度B.对二叉排序树进行中序遍历可以得到从小到大的序列C.从小根堆的根结点到任意叶结点的路径构成从小到大的序列D.对小根堆进行层序遍历可以得到从小到大的序列  

10.有一组数据（15，9,7，8,20，-1，7，4），用堆排序的筛选方法建立的初始小根堆为（））  

A.-1,4,8,9,20,7,15,7 B.-1,7,15,7,4,8,20,9 C.-1,4,7,8,20,15,7,9 D.A、B、C均不对  

11.对关键字序列{23，17,72，60,25，8,68,71,52}进行堆排序，输出两个最小关键字后的剩余堆是（）)。  

A.{23,72,60,25,68,71,52} B.{23,25,52,60,71,72,68} C.{71,25,23,52,60,72,68} D.{23,25,68,52,60,72,71}  

12.堆排序分为两个阶段：第一阶段将给定的序列构造成一个初始堆，第二阶段逐次输出堆顶元素，并调整使其保持堆的性质。设有给定序列48，62，35，77，55，14，35，98，若在堆排序的第一阶段将该序列构造成一个大根堆，则交换元素的次数为（）。  

A.5 B.6 C.7 D.8  

13.已知大根堆62，34，53，12，8，46，22}，删除堆顶元素后需要重新调整堆，则在此过程中关键字的比较次数为（）  

A.2B.3C.4D.5

14.哪种数据结构从根结点到任意叶结点的路径都是有序的（）A.红黑树 B.二叉查找树 C.哈夫曼树 D.堆  

15.【2009统考真题】已知关键字序列15，8,12,19,28，20，15，221是小根堆，插入关键字3，调整好后得到的小根堆是（）  

A.3,5,12,8,28,20,15,22,19 B.3,5,12,19,20,15,22,8,28 C.3,8,12,5,20,15,22,28,19 D.3,12,5,8,28,20,15,22,19  

16.【2011统考真题】已知序列{25，13，10，12，9是大根堆，在序列尾部插入新元素18，再将其调整为大根堆，调整过程中元素之间进行的比较次数是（）。  

A. 1 B.2 C.4 D.5  

17.【2015统考真题】已知小根堆为8，15，10,21，34，16，12，删除关键字8之后需重建堆，在此过程中，关键字之间的比较次数是（）  

A.1 B.2 WTC.3 D.4  

18.【2018统考真题】在将序列 $(6,1,5,9,8,4,7)$ 建成大根堆时，正确的序列变化过程是（）。A.  $6,1,7,9,8,4,5\to6,9,7,1,8,4,5\to9,6,7,1,8,4,5\to9,8,7,1,6,4,5$  B.  $6,9,5,1,8,4,7\rightarrow6,9,7,1,8,4,5\rightarrow9,6,7,1,8,4,5\rightarrow9,8,7,1,6,4,5$  C.  $6,9,5,1,8,4,7\rightarrow9,6,5,1,8,4,7\rightarrow9,6,7,1,8,4,5\rightarrow9,8,7,1,6,4,5$  
D.  $6,1,7,9,8,4,5\to7,1,6,9,8,4,5\to7,9,6,1,8,4,5\to9,7,6,1,8,4,5\to9,8,6,1,7,4,5$  

19.【2020统考真题】下列关于大根堆（至少含2个元素）的叙述中，正确的是（）  

1.可以将堆视为一棵完全二叉树11.可以采用顺序存储方式保存堆III.可以将堆视为一棵二叉排序树IV.堆中的次大值一定在根的下一层  

A.仅I、ⅡIB.仅II、IIIC.仅I、ⅡI和IVD.I、IⅢI和IV

20.【2021统考真题】将关键字6,9,1,5，8,4，7依次插入初始为空的大根堆H，得到的H是（）A.9,8,7,6,5,4,1 B.9,8,7,5,6,1,4 C.9,8,7,5,6,4,1 D.9,6,7,5,8,4,1  

# 二、综合应用题  

01.指出堆和二叉排序树的区别？  

02.画出一棵二叉树，使得它既满足大根堆的要求又满足二叉排序树的要求。  

03.若只想得到一个序列中第k（ $k{\geqslant}5$ ）个最小元素之前的部分的排序序列，则最好采用什么排序算法？  

04.通常使用的堆又称二叉堆，因为它是用完全二叉树来实现的，树中结点最多只有两个孩子。同理可以有 $m$ 叉堆，即用完全 $m$ 叉树来实现的堆。1）下图是一个 $m$ 叉小根堆，问 $m$ 值是多少？向这个堆插入一个元素65后，堆中的元素如何变化？再删除堆顶元素呢？请画出变化后的树形。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/feb1f44db8a85d6f4578848663fb91e1e680ba5b352d71751b25f36677bc9f98.jpg)  

2）从0开始对完全4叉树中的结点从左到右、从上到下进行编号。若给定一个结点 $k$ 其父结点的编号是多少？（若存在），其第i（ $(i\!=\!1,2,3,4$ ）个孩子的编号是多少？3）在 $m$ 叉堆中进行插入和删除操作的时间复杂度是多少？  

05.编写一个算法，在基于单链表表示的待排序关键字序列上进行简单选择排序。  

06.试设计一个算法，判断一个数据序列是否构成一个小根堆。  

07.【2022统考真题】现有 $n$ ( $n>100000$ ）个数保存在一维数组M中，需要查找M中最小的10个数。请回答下列问题。  

1）设计一个完成上述查找任务的算法，要求平均情况下的比较次数尽可能少，简述其算法思想（不需要编程实现）。2）说明你所设计的算法平均情况下的时间复杂度和空间复杂度。  

# 8.4.4 答案与解析  

# 一、单项选择题  

01.A 02.C  
注意，读者应熟练掌握各种排序算法的思想、过程和特点。  

03.D  

采用堆排序时，读入前10个元素，建立含10个元素的大根堆，而后依次扫描剩余元素，若大于堆顶，则舍弃，否则用该元素取代堆顶并重新调整堆，当元素全部扫描完毕，堆中保存的即是最小的10个元素。冒泡排序需要从后往前执行10趟冒泡才能得到10个最小的元素。两者的时间复杂度都和数据规模 $n$ 线性相关，但显然堆排序的常系数更小。而快速排序、归并排序的每一趟都不能保证得到当前序列的最小值，也无法达到线性时间复杂度。  

04.D  

可将每个选项中的序列表示成完全二叉树，再看父结点与子结点的关系是否全部满足堆的定义。例如，项A中序列对应的完全二义树如下图所示。显然，最小元素19在根结点，因此可能是小根堆，但75与26的关系却不满足小根堆的定义，所以项A中的序列不是一个堆。其他选项采用类似的过程分析。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9ab8e0f9cdbe44b2f873611d240a932e4089ac3d5650c75adea56060a9e7698.jpg)  

05.B  

这是小根堆，关键字最大的记录一定存储在这个堆所对应的完全二叉树的叶结点中：又因为二叉树中的最后一个非叶结点存储在 $_{n/2}$ 中，所以关键字最大记录的存储范围为n/2+ $1\!\sim\!n$  

06.C、C  

在向有 $n$ 个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等于树的高度减1，因为树的高度为 $\lfloor\log_{2}\!n\rfloor+1$ ，所以堆的向上调整算法的比较次数最多等于 $\lfloor\log_{2}\!n\rfloor_{\circ}$ 此处需要注意，调整堆和建初始堆的时间复杂度是不一样的，读者可以仔细分析两个算法的具体执行过程。  

07.A、D  

建堆过程中，向下调整的时间与树高 $h$ 有关，为 $O(h)$ 。每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为 $n$ 的序列上建堆，其时间复杂度为 $O(n)$ 。无论是在最好情况下还是在最坏情况下，堆排序的时间复杂度均为 $O(n\mathrm{log}_{2}n)$  

08.A  

简单选择排序的比较次数始终为 $n(n-1)/2$ ，与序列状态无关。  

09.D  

堆是顺序存储的完全二叉树，因此其高度小于或等于结点数相同的二叉排序树，A正确。B显然正确。根据小根堆的定义，其根结点到任意叶结点的路径构成从小到大的序列，C正确。堆的各层结点之间没有大小要求，因此层序遍历不能保证得到有序序列，D错误。  

10.C  

从 $\lfloor n/2\rfloor\!\sim\!1$ 依次筛选堆的过程如下图所示，显然选C项。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c1e9addeca78e042908b93b3601b16e5fb2407c67be9afd0bc616dde71c7033d.jpg)  

11.D  

筛选法初始建堆为{8,17,23,52,25,72,68,71,60}，输出8后重建的堆为{17,25,23,52,60,72，68,71}，输出17后重建的堆为{23,25,68,52,60.72,71}。  

12.B  

初始序列是一棵顺序存储的完全二叉树，然后根据大根堆的要求，按照从下到上、从右到左的顺序进行调整。98和77比较，98和77交换（交换1次）：14和35比较，35和35比较，不交换：98和55比较，98和62比较，98和62交换（交换1次）；62和77比较，77和62交换（交换1次）：98和35比较，98和48比较，98和48交换（交换1次）：77和55比较，77和48比较，77和48交换（交换1次）；48和62比较，62和48交换（交换1次），一共交换6 次。  

13.B  

删除堆顶62后，将堆尾22放入堆顶，然后自上而下调整。首先34与53比较（第一次比较），较大者53与根22比较（第二次比较），53被换至堆顶：22只有一个孩子，直接与其左孩子46比较（第3次比较），22与46交换，至此大根堆调整结束，具体过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba69cc31bfb95c944e8f4daaea81f4735512a8fef5c8bf3c776921efe99ca5aa.jpg)  

14.D  

红黑树和二叉查找树的中序序列是有序序列，从根结点到任意叶结点的路径不能保证是有序的。哈夫曼树是根据权值按一定规则构造的树，和关键字次序无关。若是小根堆，则从根结点到任意叶结点的路径是升序序列：若是大根堆，则从根结点到叶结点的路径是降序序列。  

15.A  

插入关键字3后，堆的变化过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aab4d7b8744ed7ff4aff7922991879f0ed31d57dbca9e7a05f8af20ad0e802d.jpg)  

16.B  

首先18与10比较，交换；18与25比较，不交换。共比较2次，调整过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d2994bb10da15e0a39af61ecf17f161f834550dc2f78acc7206ab1da944f48d1.jpg)  

17.C  

删除8后，将12移动到堆顶，第一次是15和10比较，第二次是10和12比较并交换，第三次还需比较12和16，所以比较次数为3。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8cc075f07a664909645f82aebb0d5286d84fdb8ac9d37c86bbb8aa3aed6ab63f.jpg)  

18.A  

要熟练掌握建堆和调整堆的方法，从序列末尾开始向前遍历，变换过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4f456f2485b9a3f8d8e9e2465b318bf14df528d977d88ecbd7c7f943a5880725.jpg)  

19.C  

简单概念题。堆是一棵完全树，采用一维数组存储，I正确，IⅡI正确。大根堆只要求根结点值大于左右孩子值，并不要求左右孩子值有序，IⅢ错误。堆的定义是递归的，所以其左右子树也是大根堆，所以堆的次大值一定是其左孩子或右孩子，IV正确。  

20.B  

要熟练掌握调整堆的方法，建堆的过程如下图所示，所以答案选择选项B。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d30fdad61c740e7b029d170ee5baa1d17ca5e297cfe31f053c0808b91328c16b.jpg)  

注意，给定序列依次插入空堆的结果与给定序列直接调整成堆的结果是不同的，最终得到的堆的形式也不同。若对序列6,9，1,5,8，4,7直接调整成堆，则会误选C项。  

# 二、综合应用题  

01.【解答】  

以小根堆为例，堆的特点是双亲结点的关键字必然小于或等于该孩子结点的关键字，而两个孩子结点的关键字没有次序规定。在二叉排序树中，每个双亲结点的关键字均大于左子树结点的关键字，均小于右子树结点的关键字，也就是说，每个双亲结点的左、右孩子的关键字有次序关系。这样，当对两种树执行中序遍历后，二叉排序树会得到一个有序的序列，而堆则不一定能得到一个有序的序列。  

02.【解答】  

大根堆要求根结点的关键字值既大于或等于左子女的关键字值，又大于或等于右子女的关键字值。二义排序树要求根结点的关键字值大于左子女的关键字值，同时小于石子女的关键字值。两者的交集是：根结点的关键字值大于左子女的关键字值。这意味着它是一棵左斜单支树，但大根堆要求是完全二叉树，因此最后得到的只能是如下图所示的两个结点的二叉树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/57a37593ae1db77ae3725de3e991c6748d5fe0b23ced68bf572f47cb03024344.jpg)  

读者也可能会注意到，当只有一个结点时，显然是满足题意的，但我们不举一个结点的例子是为了体现出排序树与大根堆的区别。  

03.【解答】  

在基于比较的排序算法中，插入排序、快速排序和归并排序只有在将元素全部排完序后，才能得到前 $k$ 个最小的元素序列，算法的效率不高。  

冒泡排序、堆排序和简单选择排序可以，因为它们在每一趟中都可以确定一个最小的元素。采用堆排序最合适，对于 $n$ 个元素的序列，建立初始堆的时间不超过 $4n$ ，取得第 $k$ 个最小元素之前的排序序列所花的时间为 $k{\mathrm{log}}_{2}n$ ，总时间为 $4n+k{\log_{2}}n$ ；冒泡和简单选择排序完成此功能所花的时间为km，当 $k{\geqslant}5$ 时，通过比较可以得出堆排序最优。  

> attention:  

求前 $k$ 个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序，  

04.【解析】  

1）除最后一个分支结点外，其余每个分支结点都有4个孩子，所以该树是完全4叉树。插入元素65后，再删除堆顶元素的树形分别如下图1和图2所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/585fc9ae0f04fc7396f5cda5301e8799dab4fb5907b8f483238fb81e070f0070.jpg)  

2）父结点的编号为 $k/4$ ，第 $i$ 个孩子的编号为 $4{\times}k+i,\,\,\,i=1,\,2,\,3,\,4$  

3）与二叉堆类似，插入和删除操作都有向上、向下调整的过程，操作时间都与树的高度有 关。因此，插入和删除操作的时间复杂度都为 $O(\log_{m}\!n)$ ，其中 $n$ 为元素个数。  

# 05.【解答】  

算法的思想是：每趟在原始链表中摘下关键字最大的结点，把它插入结果链表的最前端。由于在原始链表中摘下的关键字越来越小，在结果链表前端插入的关键字也越来越小，因此最后形成的结果链表中的结点将按关键字非递减的顺序有序链接。  

单链表的定义如第2章所述，假设它不带表头结点。  

void selectSort(LinkedList& L)( //对不带表头结点的单链表L执行简单选择排序 LinkNode  $^{\star}\mathrm{h}{=}\mathbb{L}$   $\star_{\mathsf{P}}$  ,\*q，\*r，\*s;  $\scriptstyle{\mathrm{L}}=$  NULL; while(h! $=$ NULL)I//持续扫描原链表 $\scriptstyle{\mathtt{p}}={\mathtt{S}}={\mathtt{h}}$   $\scriptstyle{\mathfrak{q}}={\mathfrak{r}}=$  NULL; /指针s和 $\boldsymbol{\tau}$ 记忆最大结点和其前驱：p为工作指针，g为其前驱while(p!=NULL){ //扫描原链表寻找最大结点s if(p->data>s->data)( $\scriptstyle{\mathtt{S}}={\mathtt{P}}$  $\scriptstyle\mathtt{r}=\mathtt{q}_{i}$ ）//找到更大的，记忆它和它的前驱q=p;p-p->link; //继续寻找 if(  $\scriptstyle{\mathrm{s}}=={\mathrm{h}}$  1  $\mathtt{h}{=}\mathtt{h}$ ->link;/最大结点在原链表前端else r->link $\scriptstyle=$ s->link;最大结点在原链表表内s->link  $\mathbf{\mu=}\mathbb{L}$   $\scriptstyle{\mathbb{L}}={\mathbb{S}}$  结点s插入结果链前端  

# 06.【解答】  

将顺序表L[1..n]视为一个完全二叉树，扫描所有分支结点，遇到孩子结点的关键字小于根结点的关键字时返回false，扫描完后返回true。算法的实现如下：  

bool IsMinHeap(ElemType A[],int len)（if（ $\scriptstyle1\in\mathbb{S}^{2}=0.$ l/len为偶数，有一个单分支结点if(A[len/2]>A[len])/判断单分支结点  
return false; for( $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}={\boldsymbol{\mathbf{I}}}$ en/2-1; $\scriptstyle{\mathrm{~i~}}>=1$ ；i--）//判断所有双分支结点if(A[i]>A[2\*i]llA[i]>A  $[2^{\star}\,\mathtt{i}\,\mathtt{+}\,\mathtt{1}\,]$  return false; elsef//len为奇数时，没有单分支结点for( $\scriptstyle{\dot{\mathbf{1}}}\,=$ len/2; $_\mathrm{i}\!>=\!1$ 八 $\mathrm{i--}$ //判断所有双分支结点if(A[i]>A[2\*i]l|A[i]>A[2\*i+1]) return false; return true;  

07.【解答】  

1）算法思想。  

【方法1】定义含10个元素的数组A，初始时元素值均为该数组类型能表示的最大数MAX。forM中的每个元素s  

if（ $\mathsf{S<A}\left[\mathsf{9}\right]$ 一丢弃A[9]并将s按升序插入A；当数据全部扫描完毕，数组 $\mathtt{A}\left[\,0\,\right]\sim_{\mathtt{A}}[\,9\,]$ 保存的就是最小的10个数。  

【方法2】定义含10个元素的大根堆H，元素值均为该堆元素类型能表示的最大数MAX。  

forM中的每个元素sif（ $\tt s\!<\!H$ 的堆顶元素）删除堆顶元素并将s插入H；当数据全部扫描完毕，堆日中保存的就是最小的10个数。  

2）算法平均情况下的时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$  

# 8.5 归并排序、基数排序和计数排序  

# 8.5.1 归并排序  

命题追踪二路归并操作的功能（2022）  

归并排序与上述基于交换、选择等排序的思想不一样，归并的含义是将两个或两个以上的有序表合并成一个新的有序表。假定待排序表含有  $n$  个记录，则可将其视为  $n$  个有序的子表，每个 子表的长度为1，然后两两归并，得到 $\lceil n/2\rceil$ 个长度为2或1的有序表；继续两两归并如此重复，直到合并成一个长度为 $n$ 的有序表为止，这种排序算法称为二路归并排序。  

图8.9所示为二路归并排序的一个例子，经过三趟归并后合并成了有序序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/365d58fda45f0a53c2d1bd276f956db5d5d2faf07813666f234e33ea5ffff7d7.jpg)  
图8.9二路归并排序示例  
# 命题追踪（算法题）归并排序思想的应用（2011）  

Merge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[low..mid]、A[mid+1..high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从B的两段中取出一个记录进行关键字的比较，将较小者放入A中，当B中有一段的下标超出其对应的表长（即该段的所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A中。算法如下：  

ElemType ${}^{\star}\mathtt{B}=$ （ElemType \*)malloc（ $(\mathtt{n}\!+\!1)$ \*sizeof（ElemType））；//辅助数组Bvoid Merge（ElemType A[],int low,int mid,int high)(表A的两段A[low..mid]和A[mid+1..high]各自有序，将它们合并成一个有序表int i,j，k; for(  $\kappa=$  low;  $\kappa\!<=$  high;  $\kappa++$  B[k]  $\mathtt{\ =}\mathtt{A}$  [k]; /将A中所有元素复制到B中 for(  $\dot{x}=$  low,j=mid+1,  $\kappa{=}1$   $\mathrm{i}<=$  mid&&j  $<=$  high;  $\kappa++$  if（B[i] $<=\mathtt{B}$ [j])/比较B的两个段中的元素A[k] $\mathbf{\tau}=\mathbf{F}$ 3 $\mathtt{i}_{\mathcal{+++}}$ //将较小值复制到A中else A[k]=B[j++]; while $\scriptstyle{\dot{\mathbf{z}}}<={\mathfrak{m}}$ id) $\mathbb{A}\left[\mathbb{k}^{++}\right]\!=\!\mathbb{B}\left[\mathbb{i}^{++}\right]$ ：//若第一个表未检测完，复制while( $\scriptstyle{\mathrm{~j}}<=$ high) $\mathbb{A}\left[\mathbb{k}{+}{+}\right]{=}\mathbb{B}\left[\mathbb{j}{+}{+}\right]$ ：//若第二个表未检测完，复制  

> attention:  

在上面的代码中，最后两个while循环只有一个会执行  

一趟归并排序的操作是，调用 $\left(n/2h\right]$ 次算法merge（），将L[1..n]中前后相邻且长度为 $h$ 的有序段进行两两归并，得到前后相邻、长度为 $_{2h}$ 的有序段，整个归并排序需要进行1ogn趟。  

递归形式的二路归并排序算法是基于分治的，其过程如下。  

分解：将含有 $n$ 个元素的待排序表分成各含 $n/2$ 个元素的子表，采用二路归并排序算法对两个子表递归地进行排序。  

合并：合并两个已排序的子表得到排序结果。  

void MergeSort（ElemType A[],int low,int high）{if(low<high){ int mid $=$ (low+high)/2;从中间划分两个子序列MergeSort（A,low,mid);//对左侧子序列进行递归排序MergeSort(A,mid+l,high); /对右侧子序列进行递归排序 Merge(A,low,mid,high); /归并  

# 命题追踪 归并排序和插入排序的对比（2017）  

二路归并排序算法的性能分析如下：  

空间效率：Merge（）操作中，辅助空间刚好为 $n$ 个单元，因此算法的空间复杂度为 $O(n)$  

时间效率：每趟归并的时间复杂度为 $O(n)$ ，共需进行 $\lceil\log_{2}n\rceil$ 趟归并，因此算法的时间复杂度为 $O(n\mathrm{log}_{2}n)$  

稳定性：由于Merge（）操作不会改变相同关键字记录的相对次序，因此二路归并排序算法是一种稳定的排序算法。  
适用性：归并排序适用于顺序存储和链式存储的线性表。  

> attention:  

一般而言，对于 $N$ 个元素进行 $k$ 路归并排序时，排序的趟数 $m$ 满足 $k^{m}\!=\!N$ ，从而 $m\!=\!\log_{k}\!N$ 又考虑到 $m$ 为整数，因此 $\scriptstyle m\,=\,\lceil\log_{k}N\rceil_{\circ}$ 这和前面的二路归并排序算法是一致的。  

# 8.5.2 基数排序  

基数排序是一种很特别的排序算法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。  

假设长度为  $n$  的线性表中每个结点  $a_{j}$  的关键字由  $d$  元组  $(\,k_{j}^{d-1}\,,k_{j}^{d-2}\,,\cdots,k_{j}^{1}\,,k_{j}^{0}\,)$  ）组成，满足  $0\!\leqslant\!k_{j}^{\iota}\!\leqslant\!r\!-\!1\:\:(0\!\leqslant\!j\!<\!n,0\!\leqslant\!i\!\leqslant\!d\!-\!1)$ 。其中 $k_{j}^{d-1}$ 为最主位关键字， $k_{j}^{0}$ 为最次位关键字。  

为实现多关键字排序，通常有两种方法：第一种是最高位优先（MISD）法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列：第二种是最低位优先（LSD）法，按关键字位权重递增依次进行排序，最后形成一个有序序列。  

下面描述以 $r$ 为基数的最低位优先基数排序的过程，在排序过程中，使用 $r$ 个队列 $Q_{0},\boldsymbol{Q}_{1},\cdots$  $Q_{r-1}$ 。基数排序的过程如下：  

对 $i\!=\!0,1,\cdots,d\!-\!1$ ，依次做一次分配和收集（其实是一次稳定的排序过程）。  

$\textcircled{\scriptsize{1}}$ 分配：开始时，把 $\mathcal{Q}_{0},\mathcal{Q}_{1},\cdots,\mathcal{Q}_{r-1}$ 各个队列置成空队列，然后依次考察线性表中的每个结点 $a_{j}$  $_i\ (j\,{=}\,0,1,\cdots,n-1)$ ，若 $a_{j}$ 的关键字 $k_{j}^{i}\!=\!k_{i}$ ，就把 $a_{j}$ 放进 $Q_{k}$ 队列中。  

$\circledcirc$ 收集：把 $\mathcal{Q}_{0},\mathcal{Q}_{1},\cdots,\mathcal{Q}_{r-1}$ 各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。  

# 命题追踪基数排序的中间过程的分析（2013、2021）  

通常采用链式基数排序，假设对如下10个记录进行排序：  

$$
\twoheadrightarrow\left[278\right]\twoheadrightarrow\left[109\right]\twoheadrightarrow\left[063\right]\twoheadrightarrow\left[589\right]\twoheadrightarrow\left[184\right]\twoheadrightarrow\left[505\right]\twoheadrightarrow\left[269\right]\twoheadrightarrow\left[008\right]\twoheadrightarrow\left[083\right]
$$  

每个关键字是1000以下的正整数，基数 $r=10$ ，在排序过程中需借助10个链队列，每个关键字由3位子关键字构成一一 $\cdot\mathrm{K}^{1}\mathrm{K}^{2}\mathrm{K}^{3}$ ，分别代表百位、十位和个位，一共进行三趟“分配”和“收集”操作。第一趟分配用最低位子关键字 $\mathrm{K}^{3}$ 进行，将所有最低位子关键字（个位）相等的记录分配到同一个队列，如图8.10(a)所示，然后进行收集操作。第一趟收集后的结果如图8.10(b)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/48cc62165ce2360ed01930db009972b6262a390392448a6089225dc7f219ffea.jpg)  
图8.10第一趟链式基数排序操作  

第二趟分配用次低位子关键字 $\mathrm{K}^{2}$ 进行，将所有次低位子关键字（十位）相等的记录分配到同一个队列，如图8.11(a)所示。第二趟收集后的结果如图8.11(b)所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c6f2bf6f54e66bb9877535bef33f0c0f8826a93ead82956fa1cc97ee0d7f7ec.jpg)  
图8.11第二趟链式基数排序操作  

第三趟分配用最高位子关键字 $\mathrm{K}^{1}$ 进行，将所有最高位子关键字（百位）相等的记录分配到同一个队列，如图8.12（a）所示，第三趟收集后的结果如图8.12（b）所示，至此整个排序结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16003a2547311992cc50f4c5ee3d857229a213f2dc465318c889f2714a206b93.jpg)  
图8.12第三趟链式基数排序操作  

基数排序算法的性能分析如下。  

空间效率：一趟排序需要的辅助存储空间为 $r~(r$ 个队列： $r$ 个队头指针和 $r$ 个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为 $O(r)$  

# 命题追踪元素的移动次数与序列初态无关的排序算法（2015）  

时间效率：基数排序需要进行 $d$ 趟“分配”和”收集”操作。一趟分配需要遍历所有关键字，时间复杂度为 $O(n)$ ；一趟收集需要合并 $r$ 个队列，时间复杂度为 $O(r)$ 。因此基数排序的时间复杂度为 $O(d(n+r))$ ，它与序列的初始状态无关。  

稳定性：每一趟分配和收集都是从前往后进行的，不会交换相同关键字的相对位置，因此基数排序是一种稳定的排序算法。  

适用性：基数排序适用于顺序存储和链式存储的线性表。  

#  ${\bf\ast8.5.3}$  计数排序  

# 命题追踪（算法题）计数排序思想的应用（2013、2015、2018）  

计数排序也是一种不基于比较的排序算法。计数排序的思想是：对每个待排序元素 $x$ ，统计小于 $x$ 的元素个数，利用该信息就可确定 $x$ 的最终位置。例如，若有8个元素小于 $x$ ，则 $x$ 就排在第9号位置上。当有几个元素相同时，该排序方案还需做一定的优化。  

> attention:  

计数排序并不在统考大纲的范围内，但其排序思想在历年真题中多次涉及！  
在计数排序算法的实现中，假设输入是一个数组A[n]，序列长度为n，我们还需要两个数组：B[n]存放输出的排序序列，C[k]存储计数值。用输入数组A中的元素作为数组C的下标（索引），而该元素出现的次数存储在该元素作为下标的数组C中。算法如下：  

# 命题追踪计数排序相关的思想和代码的分析（2021）  

void CountSort（ElemType A[],ElemType B[],int n,int k){ int i,C[k]; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<k;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$   ${\textsf{C}}\left[{\dot{\Sigma}}\right]\,=\,0$ //初始化计数数组for( $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$ ;i<n; $\ \ \dot{\mathbf{i}}_{++}$ 1//遍历输入数组，统计每个元素出现的次数C[A[i] $]{++}$ //C[A[i]]保存的是等于A[i]的元素个数for(  $_\mathrm{i}\!=\!\mathtt{1}$   $\scriptstyle{\dot{\mathbf{1}}}\times\mathbf{k}$   $\dot{\mathbf{1}}++$  C[i]=C[i]+C[i-1];//C[x]保存的是小于或等于 $\mathrm{_x}$ 的元素个数for( $\scriptstyle{\dot{\mathbf{z}}}=\mathbf{n}-1$  $\scriptstyle{\dot{\mathbf{z}}}>=0$ ;i--）{1/从后往前遍历输入数组B[C[A[i]-1]]=A[i];//将元素A[i]放在输出数组B[]的正确位置上C[A[i]]  $\scriptstyle{=\mathbb{C}}$  [A[i]]-1;  

第一个for循环执行完后，数组c的值初始化为0。第二个for循环遍历输入数组A，若一个输入元素的值为 $_\mathrm{x}$ ，则将c[x]值加1，该for循环执行完后，C[x]中保存的是等于 $_\mathrm{x}$ 的元素个数。第三个for循环通过累加计算后，C[x]中保存的是小于或等于 $_\mathrm{x}$ 的元素个数。第四个for循环从后往前遍历数组A，把每个元素A[i1放入它在输出数组B的正确位置上。若数组A中不存在相同的元素，则C[A[i]]-1就是A[i]在数组B中的最终位置，这是因为共有C[A[i]]个元素小于或等于A[i]。若数组A中存在相同的元素，将每个元素A[i]放入数组B[]后，都要将C[A[i]]减1，这样，当遇到下一个等于A[i]的输入元素（若存在）时，该元素就可放在数组B中A[i]的前一个位置上。  

假设输入数组 $\mathbb{A}\left[\,\right]=\left\{\,2\,,\,4\,,\,3\,,\,0\,,\,2\,,\,3\,\right\}$ ，第二个for循环执行完后，辅助数组c的情况如图8.13（a）所示；第三个for循环执行完后，辅助数组c的情况如图8.13（b）所示。图8.13（c）至图8.13（h）分别是第四个for循环每迭代一次后，输出数组B和辅助数组c的情况。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6d44032ce8506b47ebbb00a8709f6c74ae4f9f3c10eef0ae5cff2a9686fb669.jpg)  
图8.13计数排序的过程  
由上面的过程可知，计数排序的原理是：数组的索引（下标）是递增有序的，通过将序列中的元素作为辅助数组的索引，其个数作为值放人辅助数组，遍历辅助数组来排序。  

计数排序算法的性能分析如下。  

空间效率：计数排序是一种用空间换时间的做法。输出数组的长度为 $n$ ：辅助的计数数组的长度为 $k$ ，空间复杂度为 $O(n+k)$ 。若不把输出数组视为辅助空间，则空间复杂度为 $O(k)$  

时间效率：上述代码的第1个和第3个for循环所花的时间为 $O(k)$ ，第2个和第4个for循环所花的时间为 $O(n)$ ，总时间复杂度为 $O(n+k)$ 。因此，当 $k=O(n)$ 时，计数排序的时间复杂度为 $O(n)$ ：但当 $k\!>\!O(n\!\log\!n)$ 时，其效率反而不如一些基于比较的排序（如快速排序、堆排序等）。  

稳定性：上述代码的第4个for循环从后往前遍历输入数组，相同元素在输出数组中的相对位置不会改变，因此计数排序是一种稳定的排序算法。  

适用性：计数排序更适用于顺序存储的线性表。计数排序适用于序列中的元素是整数且元素范围 $(0{\sim}\mathrm{k{-}l}$ ）不能太大，否则会造成辅助空间的浪费。  

# 8.5.4 本节试题精选  

# 一、单项选择题  

01.以下排序算法中，（）在一趟结束后不一定能选出一个元素放在其最终位置上。A.简单选择排序B.冒泡排序 C.归并排序 D.堆排序 02.以下排序算法中，（）不需要进行关键字的比较。A.快速排序 B.归并排序 C.基数排序 D.堆排序  

03.在下列排序算法中，平均情况下空间复杂度为 $O(n)$ 的是（），最坏情况下空间复杂度为O(n)的是（)。  

I.希尔排序 II.堆排序 III冒泡排序 IV.归并排序 V.快速排序 VI.基数排序 A.I、IV、VIB.ⅡI、VC.IV、VD.IV  

04.下列排序算法中，排序过程中比较次数的数量级与序列初始状态无关的是（）  

A.归并排序 B.插入排序 C.快速排序 D.冒泡排序  

05.二路归并排序中，归并趟数的数量级是（）  

A. O(n) B.  $O(\log_{2}\!n)$  C.   $O(n\mathrm{log}_{2}n)$  D. 0(n)  

06.若对27个元素只进行三趟多路归并排序，则选取的归并路数最少为（）  

A. 2  B.3 C.4 D.5  

07.将两个各有 $N$ 个元素的有序表合并成一个有序表，最少的比较次数是（），最多的比较次数是(）。  

A.  $N$  B.2N-1 C. 2N D. N-1 08.用归并排序算法对序列 $\{1,2,6,4,5,3,8,7\}$ 进行排序，共需要进行（）次比较A.12 B.13 C.14 D.15  

09.一组经过第一趟二路归并排序后的记录的关键字为{25,50,15,35,80,85,20,40,36,70}，其中包含5个长度为2的有序表，用二路归并排序算法对该序列进行第二趟归并后的结果为()。  

A.15,25,35,50,80,20,85,40,70,36 B.15,25,35,50,20,40,80,85,36,70 C.15,25,50,35,80,85,20,36,40,70 D.15,25,35,50,80,20,36,40,70,85  

10.若将中国人按照生日（不考虑年份，只考虑月、日）来排序，则使用下列排序算法时，最快的是（）。  
A.归并排序 B.希尔排序 C.快速排序 D.基数排序  

11.设线性表中每个元素有两个数据项 $k_{1}$ 和 $k_{2}$ ，现对线性表按以下规则进行排序：先看数据项 $k_{1}$ ， $k_{1}$ 值小的元素在前，大的元素在后；在 $k_{1}$ 值相同的情况下，再看 $k_{2}$ ， $k_{2}$ 值小的元素在前，大的元素在后。满足这种要求的排序算法是（）。  

A.先按 $k_{1}$ 进行直接插入排序，再按 $k_{2}$ 进行简单选择排序B.先按 $k_{2}$ 进行直接插入排序，再按 $k_{1}$ 进行简单选择排序C.先按 $k_{1}$ 进行简单选择排序，再按 $k_{2}$ 进行直接插入排序D.先按 $k_{2}$ 进行简单选择排序，再按 $k_{1}$ 进行直接插入排序  

12.对{05,46,13，55，94，17,421进行基数排序，一趟排序的结果是（）  

A.05,46,13,55,94,17,42 B.05,13,17,42,46,55,94 C.42,13,94,05,55,46,17 D.05,13,46,55,17,42,94  

13.有 $n$ 个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队列个数是（）。  

A. n B.2 C. 5 D.10

 14.下列各种排序算法中，（）需要的附加存储空间最大。A.快速排序 B.堆排序 C.归并排序 D.插入排序  

15.【2013统考真题】已知两个长度分别为 $m$ 和 $n$ 的升序链表，若将它们合并为长度为 $m+n$ 的一个降序链表，则最坏情况下的时间复杂度是（）。  

A. O(n) B.O(mn) C.   $O(\operatorname*{min}(m,n))$  D.  $O(\operatorname*{max}(m,n))$  

16.【2013统考真题】对给定的关键字序列110,119,007,911,114,120,122进行基数排序，第二趟分配、收集后得到的关键字序列是（）。  

A.007,110,119,114,911,120,122 B.007,110,119,114,911,122,120 C.007,110,911,114,119,120,122 D.110,120,911,122,114,007,119  

17.【2015统考真题】下列排序算法中，元素的移动次数与关键字的初始状态无关的是（）。A.直接插入排序B.冒泡排序C.基数排序D.快速排序  

18.【2021统考真题】设数组S[]={93，946，372，9，146，151，301，485，236，327，43，892），采用最低位优先（LSD）基数排序将S排列成升序序列。第一趟分配、收集后，元素372之前、之后紧邻的元素分别是（）。  

A.43,892 B.236,301 C.301,892 D.485,301  

19.【2022统考真题】使用二路归并排序对含 $n$ 个元素的数组M进行排序时，二路归并排序的功能是（）。  

A.将两个有序表合并为一个新的有序表B.将M划分为两部分，两部分的元素个数大致相等C.将M划分为 $n$ 个部分，每个部分中仅含有一个元素D.将M划分为两部分，一部分元素的值均小于另一部分元素的值  

# 二、综合应用题  

01.已知序列{503，87，512，61，908，170,897，275，653，462}，采用非递归的二路归并排序算法对该序列做升序排序时需要几趟排序？给出每一趟的结果。  

02.设待排序的关键字序列为{12，2，16，30，28，10，16，20,6，18}，试写出使用最低位优先（LSD）基数排序算法每趟排序后的结果，并说明做了多少次关键字比较。  

03.【2021统考真题】已知某排序算法如下：  

void cmp Count Sort（int a[],int b[],int n）{inti,j,\*count;  
count $=$ （int\*)malloc（sizeof（int） $\star_{\mathrm{n}})$ //C $^{++}$ 语言：count $=$ newint[n];for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  八  $\scriptstyle{\mathrm{~i~}}<{\mathrm{n}}$   $\ \ \mathrm{i}_{\mathrm{++}}$  1 count  $[\dot{\bf x}]\!=\!0$  for( $\scriptstyle{\dot{\mathbf{z}}}=0$ ;i<n-l;i++）for(  $\mathfrak{j}\!=\!\mathrm{i}\!+\!\mathrm{1}$  ;j<n;j++) if(a[i]<a[j]) count[j]  $^{++}$  else count[i]++; for(  $\scriptstyle{\dot{\mathbf{\tau}}}=0$  ;i<n;i++） b[count[i]]  $=$  a[i]; free（count);//C++语言：delete count；  

请回答下列问题。  

1）若有inta[] $=$ （25，-10，25，10，11，19}，b[6];，则调用cmpCountSort（a，b，6）后数组b中的内容是什么？2）若a中含有 $n$ 个元素，则算法执行过程中，元素之间的比较次数是多少？3）该算法是稳定的吗？若是，阐述理由；否则，修改为稳定排序算法。  

# 8.5.5 答案与解析  

# 一、单项选择题  

01.C  

我们知道插入排序不能保证在一趟排序结束后一定有元素放在最终位置上。事实上，归并排序也不能保证。例如，序列 $\{6,5,7,8,2,1,4,3\}$ 进行一趟二路归并排序（从小到大）后为{5，6，7，81，2，3，4，显然它们都未被放在最终位置上。  

02.C  

基数排序是基于关键字各位的大小进行排序的，而不是基于关键字的比较进行的，  

03.D、C  

归并排序在平均情况和最坏情况下的空间复杂度都是 $O(n)$ ，快速排序只在最坏情况下才是 $O(n)$ ，平均情况是 $O(\log_{2}\!n)$ 。因此，归并排序是本章所有排序算法中占用辅助空间最多的。  

04.A  

前面已讲过选择排序的比较次数与序列初始状态无关，归并排序的比较次数的数量级也与序列的初始状态无关。读者应能从算法的原理方面来考虑为什么和初始状态无关。  

05.B  

$N$ 个元素进行 $k$ 路归并排序的趟数 $m$ 满足 $k^{m}\!=\!N$ ，即 $m=\lceil\log_{k}N\rceil$ ，本题中为 $\lceil\log_{2}\!n\rceil,$  

06.B  $N$ 个元素进行 $k$ 路归并排序的趟数 $m$ 满足 $k^{m}\!=\!N$ ，这里要求的是 $k$ ，代入可得 $k\!=\!3$  

07.A、B  

注意，当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比较 $N$ 次；而当两个表中的元素依次间隔地比较时，即 $a_{1}\!<\!b_{1}\!<\!a_{2}\!<\!b_{2}\!<\!\cdots\!<\!a_{n}\!<\!b_{n}$ 时，比较的次数是最多的，为 $2N{-1}$ 次。  

建议读者对此举一反三：若将本题中的两个有序表的长度分别设为 $M$ 和 $N_{e}$ 则最多（或最少）的比较次数是多少？时间复杂度又是多少？  

08.C  

第一趟归并后{1,2}，{4,6}，{3,5}，{7,8}，共比较4次；第二趟归并后 $\{1,2,4,6\},\{3,5,7,8\}$ 共比较4次；第三趟归并后 $\{1,2,3,4,5,6,7,8\}$ ，共比较6次。三趟归并共需进行14次比较。  

09.B  
由于这里采用二路归并排序算法，而且是第二趟排序，因此每4个元素放在一起归并，可将序列划分为{25,50,15,35}，{80,85,20,40}和{36,70}，分别对它们进行排序后有{15,25,35,50}，20,40,80,85}和36,70。  

10.D  

按照所有中国人的生日排序，一方面 $N$ 是非常大的，另一方面关键字所含的排序码数为2，且一个排序码的基数为12，另一个排序码的基数为31，都是较小的常数值，因此采用基数排序可以在 $O(N)$ 内完成排序过程。  

11.D  

本题思路来自基数排序的LSD，首先应确定 $k_{1}$ 、 $k_{2}$ 的排序顺序，若先排 $k_{1}$ 再排 $k_{2}$ ，则排序结果不符合题意，排除A和C。再考虑排序的稳定性，当 $k_{2}$ 排好序后，再对 $k_{1}$ 排序，若对 $k_{1}$ 排序采用的方法是不稳定的，则对于 $k_{1}$ 相同而 $k_{2}$ 不同的元素可能会改变相对次序，从而不一定能满足题设要求。直接插入排序是稳定的，而简单选择排序是不稳定的，只能选D。  

12.C  

基数排序有MSD和LSD两种，基数排序是稳定的。对于A，不符合LSD和MSD；对于B，符合MSD，但关键字42、46的相对位置发生了变化：对于D，不符合LSD和MSD。  

13.D  

基数排序中建立的队列个数等于进制数。  

14.C  

快速排序的平均空间复杂度是 $O(\log n)$ ，归并排序的空间复杂度是 $O(n)$ ，其他都是 $O(1)$  

15.D  

考虑两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置（取较小元素，头插法）。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为 $2\mathrm{max}(m,n)\!\geqslant\!m\!+\!n$ ，所以时间复杂度为 $O(\operatorname*{max}(m,n))$ 。此外，每次比较把两个链表中的较小结点插入新链表的表头，直到一个链表为空，因为原链表是升序排列的，要求合并后为降序排列的，因此还要把另一个链表剩下的结点一一插入新链表的表头，不论是最好情况还是最坏情况，都需要遍历两个链表中的所有结点，  

16.C  

基数排序的第一趟排序是按照个位数字的大小来进行的，第二趟排序是按照十位数字的大小来进行的，排序的过程如下图所示。  
17.C  

基数排序的元素移动次数与序列初态无关，而其他三种排序算法都与序列初态有关。  

18.C  

基数排序是一种稳定的排序算法。由于采用最低位优先（LSD）的基数排序，即第一趟对个位进行分配和收集操作，因此第一趟分配和收集后的结果是151，301，372，892，93，43，485，946146，236，327，91，元素372之前、之后紧邻的元素分别是301和892。  

19.A。  

送分题。本书对归并的定义原话是“归并的含义是将两个或两个以上的有序表合并成一个新的有序表”，而二路归并是将两个有序表合并为一个新的有序表。  

# 二、综合应用题  

01.【解答】  

$n=10$ ，需要排序的趟数 $=\!\left\lceil\log_{2}\!10\right\rceil\!=\!4$ ，各趟的排序结果如下：初始序列：503,87,512,61,908,170,897,275,653,462第一趟：87,503,61,512,170,908,275,897,462,653（长度为2）第二趟：61,87,503,512,170,275,897,908,462,653（长度为4）第三趟：61,87,170,275,503,512,897,908,462,653（长度为8）第四趟：61,87,170,275,462,503,512,653，897,908（长度为10）  

# 02.【解答】  

使用链式队列的基数排序的排序过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db244ef47f0991b5f9d0832e962e39a8ba55bc7b6bbba6df51bc5d66373c7897.jpg)  

需要通过2次分配和收集完成排序。  
# 03.【解答】  

cmpCountSort算法基于计数排序的思想，对序列进行排序。cmpCountSort算法遍历数组中的元素，count数组记录比对应待排序数组元素下标大的元素个数，例如，count $[\mathbb{1}]\!=\!3$ 的意思是数组a中有三个元素比a[1]小，即a[1]是第四大元素，a[1]的正确位置应是b[3]。  

1）排序结果为 $\mathsf{b}\left[6\right]\!=\!\{\substack{-10\,,\,10\,,\,11\,,\,19\,,\,25\,,\,25\}$  

2）由代码for $\scriptstyle\left({\mathrm{i}=0};{\mathrm{i}<\mathrm{n}-1};{\mathrm{i}++}\right)$ 和for( $\scriptstyle{\dot{\boldsymbol{\mathrm{\phi}}}}={\dot{\boldsymbol{\mathrm{I}}}}+{\boldsymbol{\mathrm{I}}}$ ;j<n; $\gimel^{++}$ ）可知，在循环过程中，每个元素都与它后面的所有元素比较一次（即所有元素都两两比较一次），比较次数之和为 $(n-1)+(n-2)+\cdots+1$ ，所以总比较次数是 $n(n\!-\!1)/2$ 。  

3）不是。需要将程序中的if语句修改如下：  

if(  $\mathsf{a}\left[\dot{\mathbf{i}}\right]\mathsf{<=a}\left[\dot{\mathbf{j}}\right]$  ）count[j]  $^{++}$  else count[i]  $^{++}$  

若不加等号，两个相等的元素比较时，前面元素的count值会加1，则导致原序列中靠 前的元素在排序后的序列中处于靠后的位置。  

# 8.6各种内部排序算法的比较及应用  

# 8.6.1 内部排序算法的比较  

前面讨论的排序算法很多，对各种排序算法的比较是考研常考的内容。一般基于五个因素进行对比：时间复杂度、空间复杂度、稳定性、适用性和过程特征。  

# 命题追踪各种排序算法的特点、比较和适用场景（2017、2020、2022）  

从时间复杂度看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为 $O(n^{2})$ ，且实现过程也较为简单，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到 $O(n)$ ，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可以在线性时间内完成建堆，且在 $O(n\mathrm{log}_{2}n)$ 内完成排序过程。快速排序基于分治的思想，虽然最坏情况下的时间复杂度会达到 $O(n^{2})$ ，但快速排序的平均性能可以达到 $O(n\mathrm{log}_{2}n)$ ，在实际应用中常常优于其他排序算法。归并排序同样基于分治的思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为 $O(n\log_{2}n)$  

从空间复杂度看：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数个辅助空间。快速排序需要借助一个递归工作栈，平均大小为 $O(\log_{2}\!n)$ ，当然在最坏情况下可能会增长到 $O(n)_{\circ}$ 二路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为 $O(n)$ 虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。  

# 命题追踪排序算法的稳定性判断及改进（2021、2023）  

从稳定性看：插入排序、冒泡排序、归并排序和基数排序是稳定的排序算法，而简单选择排 序、快速排序、希尔排序和堆排序都是不稳定的排序算法。平均时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的稳定排序算法只有归并排序，对于不稳定的排序算法，只需举出一个不稳定的实例即可。对于排序算法的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。  

# 命题追踪更适合采用顺序存储的排序算法（2017）  

从适用性看：折半插入排序、希尔排序、快速排序和堆排序适用于顺序存储。直接插入排序、冒泡排序、简单选择排序、归并排序和基数排序既适用于顺序存储，又适用于链式存储。  
# 命题追踪  

# 命题追踪  

根据排序的中间过程判断所采用的排序算法（2009、2010）  

每趟排序后都至少能确定一个元素的最终位置的排序算法（2012）  

从过程特征看：采用不同的排序算法，在一趟或几趟处理后的排序结果通常是不同的，考研题中经常出现给出一个待排序的初始序列和已部分排序的序列，问其采用何种排序算法。这就要对各类排序算法的过程特征十分熟悉，如冒泡排序、简单选择排序和堆排序在每趟处理后都能产生当前的最大值或最小值，而快速排序一趟处理至少能确定一个元素的最终位置等。  

表8.1列出了各种排序算法的时空复杂度和稳定性情况，其中空间复杂度仅列举了平均情况的复杂度，因为希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。  

表8.1各种排序算法的性质
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b1409c5ee2c569d34f51b5f3a267d60625ccf83b77b7de8ecb3eb03282fc0fb.jpg)  

# 8.6.2内部排序算法的应用  

通常情况，对排序算法的比较和应用应考虑以下情况。  

# 命题追踪选取排序算法时需要考虑的因素（2019）  

# 1.选取排序算法需要考虑的因素  

1）待排序的元素个数 $n$ 2）待排序的元素的初始状态。3）关键字的结构及其分布情况。4）稳定性的要求。5）存储结构及辅助空间的大小限制等。  

# 2.排序算法小结  

1）若 $n$ 较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因此当记录本身信息量较大时，用简单选择排序较好。  

2）若 $n$ 较大，应采用时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的排序算法：快速排序、堆排序或归并排序。当待排序的关键字随机分布时，快速排序被认为是目前基于比较的内部排序算法中最好的算法。堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能的最坏情况，这两种排序都是不稳定的。若要求稳定且时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，可选用归并排序。  

3）若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。4）在基于比较的排序算法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，  
因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 $n$ 个关键字随机分布时，任何借助于“比较”的排序算法，至少需要 $O(n\mathrm{log}_{2}n)$ 的时间。  

5）若 $n$ 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。  

6）当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。  

# 8.6.3 本节试题精选  

# 一、单项选择题  

01.若要求排序是稳定的，且关键字为实数，则在下列排序算法中应选（）A.直接插入排序B.选择排序C.基数排序D.快速排序

02.以下排序算法中时间复杂度为 $O(n\mathrm{log}_{2}n)$ 且稳定的是（）A.堆排序B.快速排序C.归并排序D.直接插入排序  

03.设被排序的结点序列共有 $n$ 个结点，在该序列中的结点已十分接近有序的情况下，用直接插入排序、归并排序和快速排序对其进行排序，这些算法的时间复杂度应为（）。  

A.  $O(n),O(n),O(n)$  B. O(n), O(nlogzn), O(nlog2n) C.   $O(n),O(n\mathrm{log}_{2}n),O(n^{2})$  D.  $O(n^{2}),O(n\mathrm{log}_{2}n),O(n^{2})$  

04.下列排序算法中属于稳定排序的是（ $\textcircled{\scriptsize{1}}$ )，平均时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的是( $\circledcirc$ )，在最好的情况下，时间复杂度可以达到线性时间的有（ $\textcircled{3}$ )。（注：多选题）  

I.冒泡排序ⅡI.堆排序III.选择排序IV.直接插入排序V.希尔排序VI.归并排序 VII.快速排序  

05.就排序算法所用的辅助空间而言，堆排序、快速排序和归并排序的关系是（）。  

A.堆排序<快速排序 $<$ 归并排序B.堆排序<归并排序<快速排序C.堆排序  $>$  归并排序>快速排序 D.堆排序>快速排序  $\scriptscriptstyle\cdot>$  归并排序  

06.排序趟数与序列的原始状态无关的排序算法是（）。  

I.直接插入排序ⅡI.简单选择排序IⅢI.冒泡排序IV.基数排序A.I、ⅢIB.I、II、IVC. 1、ⅡI、IⅢID.1、IV  

07.对 $n$ 个元素进行排序，其排序趟数肯定为 $n-1$ 趟的排序算法是（）  

A.直接插入排序和快速排序B.冒泡排序和快速排序C.简单选择排序和直接插入排序D.简单选择排序和冒泡排序  

08.若序列的原始状态为 $\{1,2,3,4,5,10,6,7,8,9\}$ ，要想使得排序过程中的元素比较次数最少，则应该采用（）方法。  

A.插入排序 B.选择排序 C.希尔排序 D.冒泡排序

 09.一般情况下，以下查找效率最低的数据结构是（）。A.有序顺序表 B.二叉排序树 C.堆 D.平衡二叉树

 10.排序趟数与序列的原始状态有关的排序算法是（）排序算法。A.插入B.选择C.冒泡D.基数

11.对于同等大小的不同初始序列，总比较次数一定的是（）。  

A.折半插入排序和简单选择排序 B.基数排序和归并排序 C.冒泡排序和快速排序 D.堆排序  

12.一台计算机具有多核CPU，可以同时执行相互独立的任务。归并排序的各个归并段可以并行执行，在下列排序算法中，不可以并行执行的有（）。  

I．基数排序 II.快速排序 III.冒泡排序 IV.堆排序 A.I、ⅢIB.I、IIC.I、Ⅲ、IVD.II、IV  
13.【2009统考真题】若数据元素序列{11，12,13，7，8，9,23，4,5}是采用下列排序算法之一得到的第二趟排序后的结果，则该排序算法只能是（）。  

A.冒泡排序 B.插入排序 C.选择排序 D.二路归并排序  

14.【2010统考真题】对一组数据（2，12,16,88,5,10）进行排序，若前3趟排序结果如下：第一趟排序结果：2.12.16.5.10.88第二趟排序结果：2,12，5.10,16.88第三趟排序结果：2，5，10.12,16,88则采用的排序算法可能是（）。  

A.冒泡排序 B.希尔排序 C.归并排序 D.基数排序  

15.【2012统考真题】在内部排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序算法中，每趟排序结束都至少能够确定一个元素最终位置的方法是()。  

I.简单选择排序II.希尔排序II.快速排序 IV.堆排序 V.二路归并排序  

A.仅I、III、IVB.仅I、ⅢI、VC.仅II、II、IVD.仅IⅢI、IV、V  

16.【2017统考真题】在内部排序时，若选择了归并排序而未选择插入排序，则可能的理由是(）。  

1.归并排序的程序代码更短II.归并排序的占用空间更少IIL.归并排序的运行效率更高  

A.仅IIB.仅IⅢIC.仅I、ID.仅I、II  

17.【2017统考真题】下列排序算法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是（）。  

ⅡI.选择排序III.冒泡排序IV.希尔排序V.堆排序 A.仅I、IⅡIB.仅ⅡI、IIIC.仅IⅢI、IVD.仅IV、V  

18.【2019统考真题】选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是()。  

I.数据的规模II.数据的存储方式III.算法的稳定性IV.数据的初始状态A.仅IⅢIB.仅I、ⅡIC.仅I、III、IVD.I、II、III、IV  

19.【2020统考真题】对大部分元素已有序的数组排序时，直接插入排序比简单选择排序效率更高，其原因是（）。  

1.直接插入排序过程中元素之间的比较次数更少 I1.直接插入排序过程中所需的辅助空间更少I11.直接插入排序过程中元素的移动次数更少  

A.仅IB.仅IIIC.仅I、IID.I、ⅡI和Ⅲ  

20.【2022统考真题】对数据进行排序时，若采用直接插入排序而不采用快速排序，则可能的原因是（）  

I.大部分元素已有序II.待排序元素数量很少II.要求空间复杂度为 $O(1)$ IV.要求排序算法是稳定的A仅IIIB.仅IIIVC.仅I、IIIVD.I、IIII、IV  

21.【2023统考真题】下列排序算法中，不稳定的是（）。I.希尔排序 I1.归并排序 III.快速排序 IV.堆排序 V.基数排序 A.仅I、IⅡIB.仅II、VC.仅I、II、IVD.仅III、IV、V  
# 二、综合应用题  

01.设关键字序列为 $\{3,7,6,9,7,1,4,5,20\}$ ，对其进行排序的最小交换次数是多少？  

02.设顺序表用数组A表示，表中元素存储在数组下标 $1\sim m+n$ 的范围内，前 $m$ 个元素递增有序，后 $n$ 个元素递增有序，设计一个算法，使得整个顺序表有序。1）给出算法的基本设计思想。2）根据设计思想，采用 $\mathrm{C}/\mathrm{C++}$ 描述算法，关键之处给出注释。3）说明你所设计算法的时间复杂度与空间复杂度。  

03.设有一个数组中存放了一个无序的关键序列 $K_{1},K_{2},\cdots,K_{n}.$ 现要求将 $K_{n}$ 放在将元素排序后的正确位置上，试编写实现该功能的算法，要求比较关键字的次数不超过 $n_{\circ}$  

# 8.6.4 答案与解析  

# 一、单项选择题  

01.A  

采用排除法。由于题目要求是稳定排序，因此排除B项和D项，又由于基数排序不能对f1oat和double类型的实数进行排序，因此排除C项。  

02.C 堆排序和快速排序不是稳定排序算法，而直接插入排序算法的时间复杂度为 $O(n^{2})$  

03.C 各种排序算法的时间和空间复杂度、稳定性等见表8.1。04. $\textcircled{\scriptsize{1}}$ I、IV、VI $\textcircled{2}$ II、VI、VII $\textcircled{3}$ 1、IV读者应能从算法的原理上理解算法的稳定性情况。堆排序和归并排序在最坏情况下的时间复杂度与最好情况下的时间复杂度是同一数量级的，都是 $O(n\mathrm{log}_{2}n)$  

05.A  

由于堆排序的空间复杂度为 $O(1)$ ，因此快速排序的空间复杂度在最坏情况下为 $O(n)$ ，平均空间复杂度为  $O(\log_{2}n)$  ，归并排序的空间复杂度为  $O(n)$  

06.B  

冒泡排序的趟数为 $1\!\sim\!n-1$ ，和序列初态有关。直接插入排序每趟都插入一个元素，排序趟数固定为 $n\!-\!1$ 。简单选择排序每趟都选出一个最小（或最大）的元素，排序趟数固定为 $n-1$ 。基数排序每趟都要进行分配和收集，排序趟数固定为 $d$  

07.C  

不论序列的原始状态如何，简单选择排序和直接插入排序的趟数都是 $n\!-\!1$ 。冒泡排序的趟数为 $1\!\sim\!n-1$ ，快速排序的趟数为 $\log_{2}\!n\!\sim\!n\!-\!1$ ，具体取决于序列的原始状态（快速排序还取决于划分方法）。  

08.A  

选择排序和序列初态无关，直接排除。初始序列基本有序时，插入排序比较次数较少。本题中，插入排序仅需比较 $n-1+4$ 次，而希尔排序和冒泡排序的比较次数均远大于此。  

09.C 堆是用于排序的，在查找时它是无序的，所以效率没有其他查找结构的高。  
10.C  

插入排序和选择排序的趟数始终为  $n\!-\!1$  ，与序列的原始状态无关。对于冒泡排序，某趟比较 后没有发生元素交换，则说明已排好序。基数排序的趟数由元素的位数决定，与原始状态无关。  

11.A  

简单选择排序的总比较次数显然是确定的。折半插入排序每趟的比较次数都为 $O(\log_{2}m)$ (m为当前已排好序的子序列的长度），因此总比较次数也是确定的。基数排序不是基于比较的排序算法。其他几种排序算法的比较次数显然和序列的初始状态有关。  

12.A  

基数排序每趟需要利用前一趟已排好的序列，无法并行执行。快速排序每趟划分的子序列互不影响，可以并行执行。冒泡排序每趟对未排序的所有元素进行一趟处理，无法并行执行。堆排序可以并行执行，因为根结点的左右子树构成的子堆在执行过程中是互不影响的。  

13.B  

每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里{11，12}和{4,5}所处的位置并不是最终位置，因此不可能是冒泡和选择排序。二路归并算法经过第二趟后应该是每4个元素有序的，但{11，12，13，7并非有序，因此也不可能是二路归并排序。  

14.A  

题中给出的排序过程，每一趟都是从前往后依次比较使最大值沉底，符合冒泡排序的特点。分别用其他3种排序算法尝试，归并排序第一趟后的结果为(2，12，16,88，5，10)，基数排序第一趟后的结果为(10,2，12，5，16,88)，希尔排序显然不符合。  

15.A  

对于1，简单选择排序每次选择未排序序列中的最小元素放入其最终位置。对于ⅡI，希尔排序每次对划分的子表进行排序，得到局部有序的结果，所以不能保证每趟结束都能确定一个元素的最终位置。对于Ⅲ，快速排序每趟结束后都将枢轴元素放到最终位置。对于IV，堆排序属于选择排序，每次都将大根堆的根结点与表尾结点交换，确定其最终位置。对于V，二路归并排序每趟对子表进行两两归并，从而得到若干局部有序的结果，但无法确定最终位置。  

16.B  

归并排序的代码比插入排序的代码更为复杂，前者的空间复杂度是 $O(n)$ ，后者是 $O(1)$ 。但是前者的时间复杂度是 $O(n\mathrm{log}n)$ ，后者是 $O(n^{2})$  

17.D  

在顺序存储的条件下，插入排序、选择排序、冒泡排序的时间复杂度都是 $O(n^{2})$ ，更换为链式存储后的时间复杂度还是 $O(n^{2})$ 。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加。  

18.D  

当数据规模较小时可选择复杂度为 $O(n^{2})$ 的简单排序算法，当数据规模较大时应选择复杂度为 $O(n\log_{2}n)$ 的排序算法，当数据规模大到内存无法放下时需选择外部排序算法，I正确。数据的存储方式主要分为顺序存储和链式存储，有些排序算法（如堆排序）只能用于顺序存储方式，Ⅱ正确。若对数据稳定性有要求，则不能选择不稳定的排序算法，ⅢI显然正确。当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是 $O(n)$ ，而归并排序的时间复杂度依旧是 $O(n\log_{2}n)$ ，IV正确。  

19.A  

考虑比较极端的情况，对于有序数组，直接插入排序的比较次数为 $_{n-1}$ ，简单选择排序的比较次数始终为 $1+2+\cdots+n-1=n(n-1)\,/\,2$ ，I正确。两种排序算法的辅助空间都是 $O(1)$ ，无差别，Ⅱ错误。初始有序时，移动次数均为0：对于通常情况，直接插入排序每趟插入都需要依次向后挪位，而简单选择排序只需与找到的最小元素交换位置，后者的移动次数少很多，1ⅢI错误。  
20.D  

直接插入排序和快速排序的特点如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/030693ca731850651b62ecd565fba55cab84dcd086c7fa264dc7742c6cc873a4.jpg)  

可见，选项I、II、IⅢI、IV都是采用直接插入排序而不采用快速排序的可能原因。  

21.C  

稳定的内部排序算法：插入排序、冒泡排序、归并排序和基数排序。不稳定的内部排序算法：简单选择排序、快速排序、希尔排序和堆排序。  

# 二、综合应用题  

01.【解答】  

由于直接插入排序的交换次数更多，因此应当采用简单选择排序。  

初始序列： $3,7,6,9,7,1,4,5,20$ 第一次：1,7,6,9,7,3,4,5,20交换1,3第二次： $1,3,6,9,7,7,4,5,20$ 交换3.7第三次： $1,3,4,9,7,7,6,5,20$ 交换4.6第四次： $1,3,4,5,7,7,6,9,20$ 交换5.9第五次： $1,3,4,5,6,7,7,9,20$ 交换67所以最小交换次数为5（注意这里求的是交换次数，而不是移动次数或比较次数）  

# 02.【解答】  

1）算法的基本设计思想如下：将数组 $\mathbb{A}\left[1...\mathbb{m}\mathbf{+}\mathbf{n}\right]$ 视为一个已经过 $m$ 趟插入排序的表，则从 $m+1$ 趟开始，将后 $n$ 个元素依次插入前面的有序表中。  

2）算法的实现如下：  

void Insert Sort（ElemType A[l,int m,int n){ int i,j; for( $\scriptstyle{\dot{\mathbf{1}}}={\mathfrak{m}}+1$  $\scriptstyle{\dot{\mathbf{1}}}<={\mathfrak{m}}+\mathbf{n}$  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ /依次将 $\mathbb{A}\left[\mathfrak{m}\!+\!1...\mathfrak{m}\!+\!\mathfrak{n}\right]$ 插入有序表 $\mathtt{A}\left[\,0\,\right]\mathrm{=A}$ [i];/复制为哨兵for( $\scriptstyle{\dot{\boldsymbol{\mathrm{\omega}}}}={\dot{\boldsymbol{\mathrm{\omega}}}}-1$ ;A[j]>A[0];j--)//从后往前插入A[  $_{\bar{1}+1\bar{1}=\bar{A}}$  [j]; //元素后移  $\mathbb{A}\left[\,\mathbb{j}\!+\!\mathbb{1}\,\right]\!=\!\mathbb{A}\left[\,0\,\right]$ //插入  

3）时间复杂度由 $m$ 和 $n$ 共同决定，从上面的算法不难看出，在最坏情况下元素的比较次数为 $O(m n)$ ，而元素移动的次数为 $O(m n)$ ，所以时间复杂度为 $O(m n)$ 6因为算法只用到了常数个辅助空间，所以空间复杂度为 $O(1)$ 此外，本题也可采用归并排序，将A[1..m]和A $\mathbf{\lambda},[\mathfrak{m}+1...\mathfrak{m}+\mathfrak{n}]$ 视为两个待归并的有序子序列，算法的时间复杂度为 $O(m+n)$ ，空间复杂度为 $O(m+n)$  

03.【解答】  

基本思想：以 $K_{n}$ 为枢轴进行一趟快速排序。将快速排序算法改为以最后一个元素为枢轴  
先从前往后，再从后往前。算法的代码如下：  

in t Partition（ElemType K[],intn)( /交换序列k[1..n]中的记录，使枢轴到位，并返回其所在位置int $_\pm=1$  $\scriptstyle{\dot{\mathbf{j}}}={\boldsymbol{\mathbf{n}}}$ //设置两个交替变量初值分别为1和 $\mathtt{n}$ ElemType pivot  $\mathbf{\mu=}\mathbb{K}$  [j]; /枢轴 while(i<j)(/循环跳出条件while（i<j&&K[i] $<=$ pivot) $\ \ \mathrm{i++}$ //从前往后找比枢轴大的元素if（i<j) K[j]  $\mathbf{\mu=}\mathbb{K}$  [i]; //移动到右端 while（i<j&&K[j] $>=$ pivot)j--;川/从后往前找比枢轴小的元素if（i<j) K[i]  $\mathbf{\mu=}\mathbb{K}$  []; /移动到左端 }l/while K[i]=pivot;/枢轴存放在最终位置returni;/返回存放枢轴的位置  

# 8.7 外部排序  

外部排序可能会考查相关概念、方法和排序过程，外部排序的算法比较复杂，不会在算法设计上进行考查。本节的主要内容有：  

$\textcircled{\scriptsize{1}}$ 外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的自的。 $\circledcirc$ 为减少平衡归并中外存读/写次数所采取的方法：增大归并路数和减少归并段个数。  

$\textcircled{3}$ 利用败者树增大归并路数。  

$\textcircled{4}$ 利用置换-选择排序增大归并段长度来减少归并段个数。 $\circledast$ 由长度不等的归并段进行多路平衡归并，需要构造最佳归并树。  

# 8.7.1外部排序的基本概念  

前面介绍过的排序算法都是在内存中进行的（称为内部排序）。而在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序算法就称为外部排序。  

# 8.7.2外部排序的方法  

文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读/写的。因为磁盘读/写的机械动作所需的时间远远超过在内存中进行运算的时间（相比而言可以忽略不计），因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即1/O次数。  

# 命题追踪对大文件排序时使用的排序算法（2016）  

外部排序通常采用归并排序算法。它包括两个阶段： $\textcircled{\scriptsize{1}}$ 根据内存缓冲区大小，将外存上的文件分成若干长度为 $\ell$ 的子文件，依次读入内存并利用内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串； $\circledcirc$ 对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。  
例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部排序得到8个初始归并段 $\mathrm{R1\!\sim\!R8}$ ，每段都含250条记录。然后对该文件做如图8.15所示的两两归并，直至得到一个有序文件。可以把内存工作区等分为三个缓冲区，如图8.14所示，其中的两个为输入缓冲区，一个为输出缓冲区。首先，从两个输入归并段R1和R2中分别读入一个块，放在输入缓冲区1和输入缓冲区2中。然后，在内存中进行二路归并，归并后的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段（R1）中，再清空输出缓冲区，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上趟的结果R1'和R2、R3'和R4'两两归并，这又是一趟归并。最后把R1"和R2"两个归并段归并，得到最终的有序文件，一共进行了3趟归并。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9dfc2273b2657ab8f22bac4053500f6f3c968af70843c709cd6de6d27e0e7f8.jpg)  
图8.14二路归并  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/594c62b9eed6c74fbcd2ef228dc89133d1f7dacc1faac7b8cf3699861e02d96b.jpg)  
图8.15二路平衡归并的排序过程  

在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果段同时存放在内存中，因此需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：  

外部排序的总时间 $=$ 内部排序的时间 $^+$ 外存信息读/写的时间 $^+$ 内部归并的时间  

显然，外存信息读/写的时间远大于内部排序和内部归并的时间，因此应着力减少1/0次数。由于外存信息的读/写是以“磁盘块”为单位的，因此可知每趟归并需进行16次读和16次写，3趟归并加上内部排序时所需进行的读/写，使得总共需进行 $32\!\times\!3+32=128$ 次读/写。  

若改用4路归并排序，则只需2趟归并，外部排序时的总读/写次数便减至 $32\!\times\!2+32=96.$ 因此，增大归并路数，可减少归并趟数，进而减少总的磁盘1/0次数，如图8.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/29ffd4a87f89e3a71844bdb43087db397877ef3872bcda905c7c5cc68854e819.jpg)  
图8.164路平衡归并的排序过程  

一般地，对 $r$ 个初始归并段，做 $k$ 路平衡归并（即每趟将 $k$ 个或 $k$ 个以下的有序子文件归并成一个有序子文件）。第一趟可将 $r$ 个初始归并段归并为 $\bar{_{r/k}}$ 个归并段，以后每趟归并将 $m$ 个归并段归并成 $\dot{}_{m/k}$ 个归并段，直至最后形成一个大的归并段为止。树的高度 $-1=\lceil\log_{k}r\rceil=$ 归并趟数S。可见，只要增大归并路数  $k$  ，或减少初始归并段个数  $r$  ，都能减少归并趟数  $S$  ，进而减少读/写 磁盘的次数，达到提高外部排序速度的目的。  

# 8.7.3 多路平衡归并与败者树  

增加归并路数 $k$ 能减少归并趟数S，进而减少1/O次数。然而，增加归并路数 $k$ 时，内部归并的时间将增加。做内部归并时，在 $k$ 个元素中选择关键字最小的元素需要 $k\!-\!1$ 次比较。  
每趟归并 $n$ 个元素需要做 $(n-1)(k-1)$ 次比较， $S$ 趟归并总共需要的比较次数为  

$$
S(n-1)(k-1)=\lceil\log_{k}r\rceil(n-1)(k-1)=\lceil\log_{2}r\rceil(n-1)(k-1)/\lceil\log_{2}k\rceil
$$  

式中， $(\,k-1\,)/\left\lceil\log_{2}\!k\right\rceil$ 随 $k$ 增长而增长，因此内部归并时间亦随 $k$ 的增长而增长。这将抵消因增大 $k$ 而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。  

为了使内部归并不受 $k$ 的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。 $k$ 个叶结点分别存放 $k$ 个归并段在归并过程中当前参加比较的元素，内部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。  

如图8.17(a)所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，b2 是败者,将段号2写入 ls[3]。b3与b4 的胜者b3与b0 比较,b0是败者,将段号0写入 Is[2]。最后两个胜者 b3与b1 比较,b1是败者，将段号1写入Is[1]。而将胜者b3 的段号 3写入 ls[0]。此时，根结点ls[0]所指的段的关键字最小。对于 $k$ 路归并，初始构造败者树需要 $k-1$ 次比较。b3中的6输出后，将下一关键字填入b3，继续比较。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e2a0f7cbaa050a4bfea0e9a28cf40956989e3d9e2e56ab38136f036fb8d98f85.jpg)  
图8.17实现5路归并的败者树  

因为 $k$ 路归并的败者树深度为 $\lceil\log_{2}\!k\rceil\!+\!1$ ，所以从 $k$ 个记录中选择最小关键字，仅需进行[logzk]次比较。因此总的比较次数约为  

$$
S(n-1)\,{\widetilde{\Gamma\log_{2}\!k}}\,{=}\,{\widetilde{\Gamma\log_{k}\!r}}\,(n-1)\,{\widetilde{\Gamma\log_{2}\!k}}\,{=}\,(n-1)\,{\widetilde{\Gamma\log_{2}\!r}}\,{\widetilde{\Gamma\log_{2}\!r}}\,{\widetilde{\Gamma\log_{2}\!r}}\,
$$  

可见，使用败者树后，内部归并的比较次数与 $k$ 无关了。因此，只要内存空间允许，增大归并路数 $k$ 将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。  

值得说明的是，归并路数 $k$ 并不是越大越好。归并路数 $k$ 增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当 $k$ 值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。  

# 8.7.4置换-选择排序（生成初始归并段）  

从8.7.2节的讨论可知，减少初始归并段个数 $r$ 也可以减少归并趟数 $S_{\circ}$ 若总的记录个数为 $n$ 每个归并段的长度为，则归并段的个数 $\scriptstyle{r=\left\lceil n/\ell\right\rceil}$ 1。采用内部排序算法得到的各个初始归并段长度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的方法，用来产生更长的初始归并段，这就是本节要介绍的置换-选择算法。  
# 命题追踪置换-选择排序生成初始归并段的实例（2023）  

设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳 $w$ 个记录。置换-选择算法的步骤如下：  

1）从FI输入 $w$ 个记录到工作区WA。  

2）从WA中选出其中关键字取最小值的记录，记为MINIIMAX记录。  

3）将MINIMAX记录输出到FO中去。  

4）若FI不空，则从FI输入下一个记录到WA中。  

5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为MINI MAX。  

6）重复 $3)\sim\!51$ ），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。  

7）重复 $2)\sim\!6)$ ，直至WA为空。由此得到全部初始归并段。设待排文件 $\mathrm{FI}=\{17,21$ ，05,44,10,12,56,32,29}，WA容量为3，排序过程如表8.2所示。  

表8.2置换-选择排序过程示例
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/06a91576d394233195d293599a1105b769edc8b13f4d56330f10343b1c301dd4.jpg)  

上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。  

# 8.7.5最佳归并树  

文件经过置换-选择排序后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等的初始归并段的归并顺序，使得1/0次数最少。假设由置换-选择排序得到9个初始归并段，其长度（记录数）依次为 $9,30,12,18,3,17,2,6,24$ 。现做3路平衡归并，其归并树如图8.18所示。  

在图8.18中，各叶结点表示一个初始归并段，上面的权值表示该归并段的长度，叶结点到根的路径长度表示其参加归并的趟数，各非叶结点代表归并成的新归并段，根结点表示最终生成的归并段。树的带权路径长度WPL为归并过程中的总读记录数，所以I/O次数 $\stackrel{\cdot}{=}2\times\mathrm{WPL}=484$  
# 命题追踪构造三叉哈夫曼树及相关的分析和计算（2013）  

显然，归并方案不同，所得归并树不同，树的带权路径长度（I/O次数）亦不同。为了优化归并树的WPL，可以将哈夫曼树的思想推广到 $m$ 叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的1/0次数最少的最佳归并树。上述9个初始归并段可构造成一棵如图8.19所示的归并树，按此树进行归并，仅需对外存进行446次读/写，这棵归并树便称为最佳归并树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/750b4b70d0ce28d6e100a1915c1ed3b27078c90f2f1ab7eb391e62ad4abbcbd8.jpg)  
图8.183路平衡归并的归并树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c05244e5d184f1800bafd18f0e9500aee22c219443d98eaf2a153b89b8ca4f3.jpg)  
图8.193路平衡归并的最佳归并树  

图8.19中的哈夫曼树是一棵严格3叉树，即树中只有度为3或0的结点。若只有8个初始归并段，如上例中少了一个长度为30的归并段。若在设计归并方案时，缺额的归并段留在最后，即除最后一次做二路归并外，其他各次归并仍是3路归并，此归并方案的1/0次数为386。显然，这不是最佳方案。正确的做法是：若初始归并段不足以构成一棵严格 $k$ 叉树（也称正则 $k$ 叉树）时，需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。因此，最佳归并树应如图8.20所示，此时的1/0次数仅为326。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/400c7ffb6e3e01b16694a55f891313b9094c8e8fae3723f8318229f52ec41d71.jpg)  
图8.208个归并段的最佳归并树  

如何判定添加虚段的数目？  

设度为0的结点有  $n_{0}$  个，度为  $k$  的结点有  $n_{k}$  个，归并树的结点总数为  $n$  ，则有：  

$n\,{=}\,n_{k}+n_{0}$ （总结点数 $=$ 度为 $k$ 的结点数 $^+$ 度为0的结点数） $n=k n_{k}+1$ （总结点数 $=$ 所有结点的度数之和+1)因此，对严格 $k$ 叉树有 $n_{0}\!=\!(k\!-\!1)n_{k}\!+1$ ，由此可得 $n_{k}\!=\!(n_{0}\!-\!1)/(k\!-\!1)\,\circ$ 若 $(n_{\scriptscriptstyle0}-1)\%(k-1)=0$ ( $\%$ 为取余运算)，则说明这 $n_{0}$ 个叶结点（初始归并段）正好可以构造  $k$  叉归并树。此时，内结点有  $n_{k}$  个。 若 $(n_{\scriptscriptstyle0}-1)\%(k-1)=u\neq0$ ，则说明对于这 $n_{0}$ 个叶结点，其中有 $u$ 个多余，不能包含在 $k$ 叉归并树中。为构造包含所有 $n_{0}$ 个初始归并段的 $k$ 叉归并树，应在原有 $n_{k}$ 个内结点的基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被代替的叶结点加上刚才多出的 $u$ 个叶结点，即再加上 $k\!-\!u\!-\!1$ 个空归并段，就可以建立归并树。  

# 命题追踪实现最佳归并时需补充的虚段数量的分析（2019）  

以图8.19为例，用8个归并段构成3叉树， $(n_{\scriptscriptstyle0}-1)\%(k-1)=(8-1)\%(3-1)=1$ ，说明7个归并段刚好可以构成一棵严格3叉树（假设把以5为根的树视为一个叶子)。为此，将叶子5变成一个内结点，再添加 $3\!-\!1\!-\!1\!=\!1$ 个空归并段，就可以构成一棵严格3叉树。  
# 8.7.6 本节试题精选  

# 一、单项选择题  

01.外部排序和内部排序的主要区别是（）  

A.内部排序的数据量小，而外部排序的数据量大B.内部排序不涉及内、外存数据交换，而外部排序涉及内、外存数据交换C.内部排序的速度快，而外部排序的速度慢D.内部排序所需的内存小，而外部排序所需的内存大  

02.下列关于外部排序的说法中，正确的是（）  

A.置换选择排序得到的初始归并段的长度一定相等B.内外存交换数据的时间只占总排序时间的一小部分C.败者树是一棵完全二叉树D.外部排序不涉及对文件的读/写操作  

03.多路平衡归并的作用是（）  

A.减少归并趟数B.减少初始归并段的个数C.便于实现败者树D.以上都对  

04.设在磁盘上存放有375000个记录，做5路平衡归并排序，内存工作区能容纳600个记录，为把所有记录排好序，需要做（）趟归并排序。  

A.3 B.4 C.5 D.6 05.在下列关于外部排序过程输入/输出缓冲区作用的叙述中，不正确的是（）  

A.暂存输入/输出记录B.内部归并的工作区C.产生初始归并段的工作区D.传送用户界面的消息  

06.在做 $m$ 路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置（ $\textcircled{\scriptsize{1}}$ 个输入缓冲区和（ $\circledcirc$ ）个输出缓冲区。  

$\textcircled{\scriptsize{1}}$ A.2B.mC.2m-1D.2m $\circledcirc$ A.2B.mC.2m-1D.2m  

07.若只需3趟排序就可完成64个元素的多路归并排序，则选取的归并路数最少是（）  

A.2K B.3 C.4 D.5  

08.置换-选择排序的作用是（）  

A.用于生成外部排序的初始归并段B.完成将一个磁盘文件排序成有序文件的有效的外部排序算法C.生成的初始归并段的长度是内存工作区的2倍D.对外部排序中输入/归并/输出的并行处理  

09.一个无序文件的 $n$ 个记录采用置换选择排序产生 $m$ 个有序段，则 $m$ 和 $n$ 的关系是（）A. $m$ 与 $n$ 成正比B. $m=\log_{2}\!n$ C. $m$ 与 $n$ 成反比D.以上都不对10.在由 $k$ 路归并构建的败者树中选取一个关键字最小的记录，则所需时间为（）A. $O(1)$ B.O(k)uC. $O({\log}k)$ D.以上都不对11.下列关于小顶堆和败者树的说法中，正确的是（）  

1.败者树从下往上维护，每上一层，只需和失败结点比较1次II.败者树的每次维护，必定要从叶结点一直走到根结点，不可能从中间停止  
IⅢI.堆从上往下维护，每下一层，若其左右孩子均不为空，则需比较2次IV.堆的每次维护，必定要从根结点一直走到叶结点，不可能从中间停止  

A.I、IⅢIB.IⅡI、IⅢIC.I、II、ⅢID.I、II、IV  

12.最佳归并树在外部排序中的作用是（）  

A.完成 $m$ 路归并排序B.设计 $m$ 路归并排序的优化方案C.产生初始归并段 D.与锦标赛树的作用类似  

13.在由 $m$ 个初始归并段构建的 $k$ 阶最佳归并树中，度为 $k$ 的结点个数是（）A. $(m-1)/k$ B.m/kC. $(m\!-\!1)/(k\!-\!1)$ D.无法确定  

14.【2013统考真题】已知三叉树  $T$  中6个叶结点的权分别是2，3，4,5，6,7，T的带权（外 部）路径长度最小是（）。  

A.27 B.46 C.54 D.56

 15.【2016统考真题】对10TB的数据文件进行排序，应使用的方法是（）。A.希尔排序 B.堆排序 C.快速排序 D.归并排序  

16.【2019统考真题】设外存上有120个初始归并段，进行12路归并时，为实现最佳归并，需要补充的虚段个数是（）。  

A.1 B.2 C.3 D.4  

# 二、综合应用题  

01.若某个文件经内部排序得到80个初始归并段，试问：  

1）若使用多路平衡归并执行3趟完成排序，则应取得的归并路数至少应为多少？2）若操作系统要求一个程序同时可用的输 $\mathrm{\sim}$ 输出文件的总数不超过15个，则按多路归并至少需要几趟可以完成排序？若限定这个趟数，可取的最低路数是多少？  

02.假设文件有4500个记录，在磁盘上每个块可放75个记录。计算机中用于排序的内存区可容纳450个记录。试问：1）可以建立多少个初始归并段？每个初始归并段有多少记录？存放于多少个块中？2）应采用几路归并？请写出归并过程及每趟需要读/写磁盘的块数。  

03.设初始归并段为(10,15,31),(9,20),(22,34,37),(6,15,42),(12,37),(84,95)。试利用败者树进行 $m$ 路归并，手工执行选择最小的5个关键字的过程。  

04.给出12个初始归并段，其长度分别为 $30,44,8,6,3,20,60,18,9,62,68,85.$ 现要做4路外归并排序，试画出表示归并过程的最佳归并树，并计算该归并树的带权路径长度WPL。  

05.【2023统考真题】对含有 $n$  $n>0$ ）个记录的文件进行外部排序，采用置换-选择排序生成初始归并段时需要使用一个工作区，工作区中能保存 $m$ 个记录。请回答：  

1)若文件中含有19个记录，其关键字依次是51,94,37,92,14,63,15,99,48,56,23,60,31，17,43.8.90.166,100，则当 $m=4$ 时，可生成几个初始归并段？各是什么？  

2）对任意的 $m$  $n\!\gg\!m>0$ )，生成的第一个初始归并段的长度最大值和最小值分别是多少?  

# 8.7.7 答案与解析  

# 一、单项选择题  

01.B 外部排序和内部排序最主要的区别是是否涉及内存、外存的数据交换。  

02.C  
置换选择排序得到的是长度不一定相等的归并段，A错误。外部排序的主要时间消耗在内外存之间的数据交换上，B错误。败者树是一棵完全二叉树，C正确。外部排序包括两个阶段：生成初始归并段和对初始归并段进行归并，这两个阶段都涉及对文件的读/写操作，D错误。  

03.A  

多路平衡归并的目的是减少归并趟数，因为当 $m$ 个初始归并段采用 $k$ 路平衡归并时，所需趟数  $s=\lceil\log_{k}m\rceil$  ，若不采用多路平衡归并，则其归并趟数大于  $s$  

04.B  

初始归并段的个数 $r=375000/600=625$ ，因此，归并趟数 $S=\!\lceil\log_{m}\!r\rceil\!=\!\lceil\log_{5}\!625\rceil\!=4$ 。第一趟把625个归并段归并成 $625/5=125$ 个；第二趟把125个归并段归并成 $125/5=25\$ 个；第三趟把25个归并段归并成  $25/5=5$  个；第四趟把5个归并段归并成  $5/5=1$  个。  

05.D  

在外部排序过程中输入/输出缓冲区就是排序的内存工作区，例如做 $m$ 路平衡归并需要 $m$ 个输入缓冲区和1个输出缓冲区，用以存放参加归并的和归并完成的记录。在产生初始归并段时也可用作内部排序的工作区。它没有传送用户界面的消息的任务。  

06.D、A  

相比普通的 $m$ 路归并：需增加一个输出缓冲区，当一个输出缓冲区满时，输出一个缓冲区的同时归并程序可向另一个输出缓冲区填充数据，这就实现了内部归并和输出的并行。需增加 $m$ 个输入缓冲区，当 $m$ 个输入缓冲区正在运行时，外部可向新增的 $m$ 个缓冲区写入数据，这就实现了输入和内部归并的并行。综上，需设置2个输出缓冲区， $2m$ 个输入缓冲区。  

07.C  

归并趟数 $\scriptstyle\stackrel{\cdot}{=}$  $\mathbf{\mu}=\left\lceil\log_{k}n\right\rceil$ ，其中 $k$ 表示归并的路数， $n$ 表示元素个数，当 $k=4$ 、 $n=64$ 时，归并趟数恰好等于3，因此选取的归并路数至少是4。  

08.A  

置换-选择排序是外部排序中生成初始归并段的方法，用此方法得到的初始归并段的长度是不等长的，其长度平均是传统等长初始归并段的2倍，从而使得初始归并段数减少到原来的近二分之一。但是，置换-选择排序不是一种完整的生成有序文件的外部排序算法。  

09.D  

设内存工作区 $w=1$ ，则文件{1,2,3,4,5}产生1个有序段，而文件{5,4,3,2,1}产生5个有序段，因此 $m$ 与待排文件、内存工作区大小 $w$ 和 $n$ 都有关，但不是A、B、C项描述的直接关系。  

10.D  

在败者树中选取最小关键字的时间复杂度取决于败者树的高度，所需时间为 $O(\log k)$  

11.D  

I正确，是败者树的性质。在败者树的维护过程中，会让胜利者一直调整到根结点，I1正确。以小根堆为例，每次调整时，先比较下一层的两个元素（1次），找出较小值，然后比较当前元素和下一层的较小元素（1次），以决定是否向下交换位置，ⅡI1正确。堆在维护时，可能会在中间某层停止（若此处无须调整），而不一定要走到叶结点，IV错误。  

12.B  

最佳归并树在外部排序中的作用是设计 $m$ 路归并排序的优化方案，仿照构造哈夫曼树的方法，以初始归并段的长度为权值，构造具有最小带权路径长度的 $m$ 叉哈夫曼树，可以有效地减少归并过程中的读/写记录数，加快外部排序的速度。  

13.C  

$k$ 阶最佳归并树中只有度为0和 $k$ 的结点。设结点总数为 $n$ ，度为0的结点数为 $n_{0}$ ，度为 $k$ 的结点数为 $n_{k},$ 则 $n_{0}\!=\!m$  $n\!-\!1\!=\!k\!\times\!n_{k}$  $n\!=\!n_{0}\!+n_{k}$ ，因此 $\scriptstyle{k\times n_{k}=m+n_{k}-1}$ ，求得 $n_{k}\!=(m-1)/(k\!-\!1),$  
14.B  

题中的三叉树为使WPL最小，必须构造三叉哈夫曼树，应满足 $(n_{0}\!-\!1)\%(3-1)\!=\!0$ 的条件，因此需添加1个权值为0的虚叶结点，说明7个叶结点刚好可构成一棵严格的三叉树。按照哈夫曼树的原则，权为0的叶结点应离树根最远，构造三叉哈夫曼树的过程如下：  

$\textcircled{\scriptsize{1}}$ 合并权值最小的三个结点0,2,3，得到新结点的权值 $=5$ ，剩下5,4.5.6,7。 $\circledcirc$ 合并权值最小的三个结点4，5，5，得到新结点的权值 $=14$ ，剩下14，6,7。 $\textcircled{3}$ 合并权值最小的三个结点6，7，14，得到新结点的权值 $=27$ ，仅有27，建树完成。  

${\mathrm{WPL=}}\sum_{1}^{n}$ 权值 $W_{n+i;i,j,i}\times$ 深度 $\begin{array}{r}{!D_{n+s+k i j}=(2+3){\times}3+(4+5){\times}2+(6+7){\times}1=46}\end{array}$  

或  

$$
\begin{array}{r}{\mathrm{WPL}\!=\!\sum_{i}^{m}\!\!\!\!\slash\!\!\!\mathbb{X}\!\left\{\!\!\mathbb{H}W_{\!\hat{\gamma}\!+\!\hat{\chi}\!\left\{\!\mathbb{H}W_{i\!j}\!+\!\hat{\chi}\!+\!\hat{\kappa}\!\right\}\!\!\right\}\!\!=\!27+14+5=46}\end{array}
$$  

每个分支结点的权值都累加了其下面所有分支结点的权值，因此采用第二种方法更方便。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/761fec12638927f96a7953aca068bb2474057195863cc8533c11f12119ec300e.jpg)  

15.D  

外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的目的。外部排序通常采用归并排序算法。A、B、C项都是内部排序的方法。  

16.B  

在12路归并树中只存在度为0和度为12的结点，设度为0的结点数、度为12的结点数和要补充的结点数分别为 $n_{0}$  $n_{12}$ 和 $n_{\psi}$ ，则有 $n_{\scriptscriptstyle0}=120\,+\,n_{\scriptscriptstyle\ddag|}$ ， $n_{\scriptscriptstyle0}=(12\!-\!1)n_{\scriptscriptstyle12}+\!1$ ，可得 $n_{12}=(120\,{-}1\,{+}\,n_{\psi})/(12\,{-}1)$ 因为结点数 $n_{12}$ 为整数，所以 $n_{\mp}$ 是使上式整除的最小整数，求得 $n_{\#}=2$ 。  

此外，题中为实现最佳归并，应满足12叉哈夫曼树， $n=120$  $m\!=\!12$ ，不满足 $(n-1)\%(m-1)\!=\!0$ 的条件，因此需要添加两个权值为0的叶结点，使得 $n=121$ ，才能满足条件。  

# 二、综合应用题  

01.【解答】  

1）设归并路数为 $m$ ，初始归并段个数 $r=80$ ，根据归并趟数计算公式 $S\!=\!\lceil\log_{m}\!r\rceil\!=\!\lceil\log_{m}\!80\rceil\!=$ 3，得 $\log_{m}\!80\!\leqslant\!3$ ， $m^{3}\!\geqslant\!80$ 。由此解得 $m{\gtrsim}5$ ，即应取的归并路数至少为5。  

2）设多路归并的归并路数为 $m$ ，需要 $m$ 个输入缓冲区和1个输出缓冲区。一个缓冲区对应一个文件，有 $m+1=15$ ，因此 $m=14$ ，可做14路归并。由 $S\!=\!\lceil\log_{m}\!r\rceil\!=\!\lceil\log_{14}\!80\rceil\!=\!2$ 即至少需要2趟归并可完成排序。若限定趟数为2，由 $S=\lceil\log_{m}\!80\rceil=2$ ，有 $80\!\leqslant\!m^{2}$ ，可取的最低路数为9。即要在2趟内完成排序，进行9路归并排序即可。  

02.【解答】  

1）文件有4500个记录，用于排序的内存区可容纳450个记录，可建立的初始归并段有 $4500/450=10$  个。每个初始归并段中有450个记录，存于  $450/75=6$  个块中。  

2）内存区可容纳6个块，可建立6个缓冲区，其中5个缓冲区用于输入，1个缓冲区用于输出，因此可采用5路归并，归并过程如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ea0271abdff5d80c703229c32e11a07fbd61b3f1692b4b5daf3ee4cb0748da5.jpg)  

共做了2趟归并，每趟需要读60块、写60块。  

03.【解答】  

做6路归并排序，选择最小的5个关键字的败者树如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/70cf272dc093f3cdbd0fbe2f862cf089af6f92b42e39d25ae1acc8420688e1be.jpg)  

04.【解答】  

设初始归并段个数 $n=12$ ，外归并路数 $k\!=\!4$ ，计算 $(n-1)\%(k-1)=11\%3=2\neq0$ ，说明不能做完全的4路归并，因为多出了两个初始归并段，必须添加 $k\!-\!2-\!1=1$ 个长度为0的空归并段，才能构成严格的4路归并树，即每次归并都有 $k$ 个归并段参加归并。  

此时，归并树的内结点应有 $(n-1+1)/(k-1)=12/3=4$ 个，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4ad5518f64fb36d9ebbd5e3f05f8de61e8848933add9bbd3138da133fa311627.jpg)  

$\mathrm{WPL}=(3+6+8)\times3+(9+18+20+30+44+60+62)\times2+(68+85)\times1=51+486+153=6$  590  

05.【解答】  

1）当文件中的 $n$ 个记录升序排列时，只生成一个归并段，长度达到最大，为 $n$ 。若初始工作区内的 $m$ 个元素都大于输入文件中剩下的所有记录，则第一个归并段的长度就为 $m$ ，此时为第一个归并段长度最小的情况。排序过程如下表所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f0ab4e2407d1c4dcd015077c8ec0ce880d41962100a754c5b17f10d7a0cbb996.jpg)  
生成三个初始归并段，分别是37,51,63,92,94,99；14,15,23,31,48,56,60,90,166；8,17,43,100。2）最大值为 $n$ ，最小值为 $m$  

# 归纳总结  

下面对本章所介绍的排序算法进行一次系统的比较和复习。  

1．直接插入排序、冒泡排序和简单选择排序是基本的排序算法，它们主要用于元素个数 $n$ 不是很大 ( $n<10000$ ）的情形。  

它们的平均时间复杂度均为 $O(n^{2})$ ，实现也都非常简单。直接插入排序对于规模很小的元素序列（ $_{,n\leqslant25}$ ）非常有效。它的时间复杂度与待排序元素序列的初始排列有关。在最好情况下，直接插入排序只需要 $n-1$ 次比较操作就可以完成，且不需要交换操作。在平均情况下和最差情况下，直接插入排序的比较和交换操作都是 $O(n^{2})$ 。冒泡排序在最好情况下只需要一趟排序过程就可以完成，此时也只需要 $n\!-\!1$ 次比较操作，不需要交换操作。简单选择排序的关键字比较次数与待排序元素序列的初始排列无关，其比较次数总是 $O(n^{2})$ ，但元素移动次数则与待排序元素序列的初始排列有关，最好情况下数据不需要移动，最坏情况下元素移动次数不超过 $3(n-1)$  

从空间复杂度来看，这三种基本的排序算法除一个辅助元素外，都不需要其他额外空间。从稳定性来看，直接插入排序和冒泡排序都是稳定的，但简单选择排序不是。  
2.对于中等规模的元素序列（ $n{\leqslant}1000$ ），希尔排序是一种很好的选择。  

在希尔排序中，开始时增量较大，分量较多，每个组内的记录数较少，因而记录的比较和移动次数较少，且移动距离较远；到后来步长越来越小（最后一步为1），分组越少，每个组内的记录数越多，但同时记录次序也越来越接近有序，因而记录的比较和移动次数也都比较少。从理论上和实验上都已证明，在希尔排序中，记录的总比较次数和总移动次数比直接插入排序时少得多，特别是当 $n$ 越大时效果越明显。而且，希尔排序代码简单，基本上不需要什么额外内存，但希尔排序是一种不稳定的排序算法。  

3.对于元素个数 $n$ 很大的情况，可以采用快速排序、堆排序、归并排序或基数排序，其中快速排序和堆排序都是不稳定的，而归并排序和基数排序是稳定的排序算法。  

快速排序是最通用的高效内部排序算法，特别是它的划分思想经常在很多算法设计题中出现。平均情况下它的时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，一般情况下所需要的额外空间也是 $O(\log_{2}n)$ 。但是快速排序在有些情况下也可能会退化（如元素序列已经有序时），时间复杂度会增加到 $O(n^{2})$ ，空间复杂度也会增加到 $O(n)$ 。但我们可以通过“三者取中”法来避免最坏情况的发生。  

堆排序也是一种高效的内部排序算法，它的时间复杂度是 $O(n\mathrm{log}_{2}n)$ ，而且没有什么最坏情况会导致堆排序的运行明显变慢，并且堆排序基本上不需要额外的空间。但堆排序不大可能提供比快速排序更好的平均性能。  

归并排序也是一个重要的高效排序算法，它的一个重要特性是性能与输入元素序列无关，时间复杂度总是 $O(n\mathrm{log}_{2}n)$ 。归并排序的主要缺点是需要 $O(n)$ 的额外存储空间。  

基数排序是一种相对特殊的排序算法，这类算法不仅是对元素序列的关键字进行比较，更重要的是它们对关键字的不同位部分进行处理和比较。虽然基数排序具有线性增长的时间复杂度，但由于在常规编程环境中，基数排序的线性时间开销实际上并不比快速排序的时间开销小很多，并且由于基数排序基于的关键字抽取算法受到操作系统和排序元素的影响，其适应性远不如普通的进行比较和交换操作的排序算法。因此，在实际工作中，常规的高效排序算法如快速排序的应用要比基数排序广泛得多。基数排序需要的额外存储空间包括和待排序元素序列规模相同的存储空间及与基数数目相等的一系列桶（一般用队列实现）。  

# 4.混合使用。  

我们可以混合使用不同的排序算法，这也是得到普遍应用的一种算法改进方法，例如，可以将直接插人排序集成到归并排序的算法中。这种混合算法能够充分发挥不同算法各自的优势，从而在整体上得到更好的性能。  

# 思维拓展  

下面是一道看起来很吓人的题目：对 $n$ 个整数进行排序，要求时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$  

提示：假设待排序整数的范围为 $0\sim65535$ ，设定一个数组intcount[65535]并初始化为0，则所需空间与  $n$  无关，为  $O(1)$  。扫描一遍待排序列x[]，count[α[i]]++，时间复杂度为  $O(n)$  再 扫描一次count[]，当count[i] ${>}0$ 时，输出count[i]个i，排序完毕所需的时间复杂度也为 $O(n)$ ；所以总的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1).$ 另外，读者可能会问假如有负整数怎么办，这种情况下可以给所有整数都加上一个偏移量，使之都变成正整数，再使用上述方法即可。  
# 参考文献  

[1]严蔚敏，吴伟民.数据结构（C语言版）[M].北京：清华大学出版社，2018.

[2]托马斯·科尔曼，查尔斯·雷瑟尔森，罗纳德·李维斯特，等.算法导论[M].北京：机械工业出版社，2013.

[3]李春葆，陈良臣，尹为民，等，数据结构教程（C++语言描述）[M].北京：清华大学出版社，2009.

[4]陈守孔，胡潇琨，李玲，算法与数据结构考研试题精析[M]：北京：机械工业出版社，2007.

[5]夏清国.数据结构考研教案[M].西安：西北工业大学出版社，2006.

[6]本书编写组.全国硕士研究生入学统一考试计算机专业基础综合考试大纲解析[M]：北京：高等教育出版社，2023.  

[7]李春葆，尹为民，陈良臣.数据结构联考辅导教程[M].北京：清华大学出版社，2010  
