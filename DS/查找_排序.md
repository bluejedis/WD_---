# 7.2.5 答案与解析  

# 一、单项选择题  

01.A
- 顺序查找特点：
  - 从表的一端开始向另一端查找
  - 不要求查找表具有随机存取特性
  - 可以是顺序存储结构或链式存储结构

02.B
- 顺序查找成功的比较次数分析：
  - 第一个元素比较次数为1
  - 第二个元素比较次数为2
  - 每个元素查找成功的比较次数只与位置有关
  - 与是否有序无关
  - 查找成功的平均时间相同

03.B
- 有序单链表顺序查找特点：
  - 查找成功的平均查找长度与无序/有序顺序表相同
  - 平均查找长度为 $(n+1)/2$

04.A
- 长度为3的顺序表查找长度计算：
  - 第一个元素查找长度为1
  - 第二个元素查找长度为2 
  - 第三个元素查找长度为3
  - $\operatorname{PSL}_{\vec{n}\times\vec{n}}{=}\frac{1}{2}{\times}1{+}\frac{1}{3}{\times}2{+}\frac{1}{6}{\times}3=\frac{5}{3}$

05.D
- 二分查找要求：
  - 采用顺序存储
  - 查找表必须有序
  - 顺序可以是从大到小或从小到大

06.C
- 折半查找与顺序查找比较：
  - 折半查找一般情况下较快
  - 特殊情况下顺序查找可能更快
  - 例如：1000个元素的有序表查找第一个元素
    - 顺序查找比较1次
    - 折半查找比较约10次

07.B
- 折半查找判定树特点：
  - 是平衡二叉树
  - 每次分割使子数组结点数差不超过1
  - 对应判定树的子树高度差不超过1

08.B
- 查找性能分析：
  - 折半查找：
    - 平均查找长度为 $O(\log_{2}n)$
    - 最大查找长度为 $O(\log_{2}n)$
  - 二叉排序树：
    - 最好情况与折半查找相同
    - 最坏情况(单支树)查找长度为 $O(n)$

09.B
- 折半查找过程分析：
  - 第一次 mid = $\lfloor(1+11)/2\rfloor = 6$
  - 第二次 mid = $\lfloor(6+1+11)/2\rfloor = 9$
  - 第三次 mid = $\lfloor(9+1+11)/2\rfloor = 10$
  - 第四次 mid = 11

10.B
- 折半查找过程：
  - 初始：low指向13，high指向134，mid指向50
  - 第一次比较：90>50，low指向62，high指向134，mid指向90
  - 第二次比较找到90

11.A
- 折半查找mid取值规则：
  - 必须统一采用向上取整或向下取整
  - A选项全部采用向下取整，符合要求
  - B、C、D选项mid取值方式不一致，不符合要求

12.A
- 判定树结点分析：
  - n个结点时，总结点数 $n=2^h-1$
  - 树高 $h=\lceil\log_2(n+1)\rceil$
  - 特殊值验证：代入n=1和n=2只有A满足

13.A、B
- 比较次数分析方法：
  - 方法一：画出判定树
    - 最小分支高度对应最少比较次数
    - 最大分支高度对应最多比较次数
  - 方法二：直接用公式
    - 最大分支高度 $H=\lceil\log_2(n+1)\rceil=5$
    - 最少比较次数为4

14.A、D
- 有序表折半查找分析：
  - 查找成功的ASL计算：
    - $(1+2×2+3×4+4×5)/12=37/12$
  - 查找失败的ASL计算：
    - $(3×3+4×10)/13$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d62638414a41c9d2f61f21d04880497f33ac6a96f5789b84f1a19767ff1dbd1.jpg)

15.D
- 折半查找特点总结：
  - 要求数据元素有序且必须顺序存储
  - 最坏情况时间性能为 $O(\log_2n)$
  - 元素查找概率不同时，平均查找长度可能大于顺序查找
16.B
- 分块查找结构特点：
  - 不要求每个索引块中的元素个数都相等

17.A
- 分块查找ASL分析：
  - 设块长为 $b$
  - 索引表包含 $n/b$ 项
  - 索引表的 $\mathrm{ASL}=(n/b+1)/2$
  - 块内的 $\mathrm{ASL}=(b+1)/2$
  - 总 $\mathrm{ASL}=(b+n/b+2)/2$
  - 最优块长分析：
    - 由均值不等式知 $b=n/b$ 时有最小值
    - 此时 $b=\sqrt{n}$
    - 最理想块长为 $\sqrt{2500}=50$

18.B
- ASL计算方法：
  - 公式法：
    - $\mathrm{ASL}=L_1+L_s=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$
    - 代入 $b=n/s,s=123/3,n=123$
  - 穷举法：
    - A块元素查找长度：$2,3,4,\cdots,42$
    - B块元素查找长度：$3,4,5,\cdots,43$
    - C块元素查找长度：$4,5,6,\cdots,44$
    - 平均查找长度为23

19.C
- 查找效率优化：
  - 最优索引块大小：$\sqrt{65025}=255$
  - 索引表项数：255
  - 采用折半查找时效率最高：$\lceil\log_2(255+1)\rceil+\lceil\log_2(255+1)\rceil=16$

20.B
- 折半查找不成功分析：
  - 最多比较次数为树高：$\lfloor\log_2n\rfloor+1$ 或 $\lceil\log_2(n+1)\rceil$
  - $n=16$ 时最多比较5次

> attention:  
折半查找判定树中的方形结点是虚构的，它不计入比较的次数。

21.A
- 查找路径分析：
  - 折半查找判定树需满足二叉排序树要求
  - A选项查找路径不满足要求

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/208fba8f531d9f042b4bb575f0d21b6def06133281f5bff8ae5b6d8e47a0c4e4.jpg)

22.B
- 跳跃式顺序查找特点：
  - 用于升序数组查找x
  - x越靠前比较次数越少

23.A
- 折半查找判定树特性：
  - 对应唯一确定的判定树
  - mid取值规则：
    - 向下取整时：
      - $2n+1$个元素：左右子树各n个
      - $2n$个元素：左子树n-1个，右子树n个
    - 向上取整时：
      - 左子树结点数等于或多于右子树一个
  - A选项符合向上取整规则

24.B
- 折半查找比较次数：
  - 最多不超过判定树高度
  - 树高 $h=\lceil\log_2(n+1)\rceil$
  - $n=600$ 时结果为10

# 二、综合应用题  

01.【解答】
- 有序顺序表与无序顺序表比较
  - 查找失败时平均查找长度不同
    - 有序表遇到大于目标值即停止
    - 无序表需查找到表尾
  - 查找成功时平均查找长度相同
    - 都是找到目标值即停止
  - 查找相同关键字时平均查找长度不同
    - 有序表可连续查找
    - 无序表需遍历全表

02.【解答】
- 判定树分析
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76e322a28944433e37007a894880a99a516312625dc2efc436b3c5c8f3b0d2f6.jpg)
- 查找次数分析
  - 查找275：比较509、154、275，共3次
  - 查找684：比较509、677、897、765，共4次
- 平均查找长度计算
  - 查找成功时
    - $\operatorname{PSL}_{n\!\!k\!\times\!\!j_{l}}=\frac{1}{14}\sum_{i=1}^{14}C_{i}=\frac{1}{14}(1+2\times2+3\times4+4\times7)=\frac{45}{14}$
  - 查找失败时
    - $\mathrm{ASL}_{\mathbb{K}^{n}\mathbb{K}^{n}}={\frac{1}{15}}\sum_{i=0}^{14}C_{i}^{\prime}={\frac{1}{15}}(3\times1+4\times14)={\frac{59}{15}}$

03.【解答】
- 查找过程分析
  - 先顺序查找后折半查找
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31eafbd9a8e3949e9c8b697dc72a887a69869cf17a7452141a76ea81a84f6ceb.jpg)
- 平均查找长度计算
  - 每个关键字查找概率为1/8n
  - 不同区间查找长度分析
    - 0~7：1次顺序+折半查找
    - 8~15：2次顺序+折半查找
    - 依此类推
  - 最终结果
    - $\operatorname{PSL}_{\scriptscriptstyle{\tilde{n}}\scriptscriptstyle{\tilde{k}};\scriptscriptstyle{\tilde{n}}}=\frac{n+1}{2}+\frac{17}{8}$

04.【解答】
- 算法基本思想
  - 根据起始和终止位置二分
  - 递归判断目标值位置
- 算法实现

typedef struct{
    ElemType *elem;
    int length;
} SSTable;

int BinSearchRec(SSTable ST, ElemType key, int low, int high) {
    if(low > high) return 0;
    mid = (low+high)/2;
    if(key > ST.elem[mid])
        BinSearchRec(ST,key,mid+1,high);
    else if(key < ST.elem[mid])
        BinSearchRec(ST,key,low,mid-1);
    else
        return mid;
}

- 复杂度分析
  - 时间复杂度：$O(\log_{2}n)$
  - 空间复杂度：$O(\log_{2}n)$

05.【解答】
- 算法基本思想
  - 从表头顺序扫描
  - 找到后与前驱交换
- 算法实现

int SeqSrch(RcdType R[], ElemType k) {
    int i = 0;
    while((R[i].key != k && i < n)) i++;
    if(i < n && i > 0) {
        temp = R[i];
        R[i] = R[i-1];
        R[i-1] = temp;
        return --i;
    }
    else return -1;
}


06.【解析】
- 算法基本思想
  - 从右上角开始比较
  - 小于目标值向下移动
  - 大于目标值向左移动
- 算法实现

bool findkey(int A[][], int n, int k) {
    int i = 0, j = n-1;
    while(i < n && j >= 0) {
        if(A[i][j] == k) return true;
        else if(A[i][j] > k) j--;
        else i++;
    }
    return false;
}

- 复杂度分析
  - 时间复杂度：$O(n)$
  - 空间复杂度：$O(1)$

07.【解答】
- 顺序查找方案
  - 按查找概率降序排列
  - 平均查找长度计算
    - $0.35\times1+0.35\times2+0.15\times3+0.15\times4=2.1$
- 二叉排序树方案
  - 构造二叉排序树存储
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/afb63decb05cee9e2bed3e965980387378416316eb46074679f198ad328a9aa8.jpg)
  - 平均查找长度计算
    - $0.15\times1+0.35\times2+0.35\times2+0.15\times3=2.0.6$



# 7.3.5 答案与解析  

# 一、单项选择题  

01.C
- 二叉排序树特性
  - 插入新结点不会引起树的分裂组合
  - 中序遍历可得到有序序列
  - 插入有序关键字时会形成长链
    - 此时深度最大
    - 查找可能需比较超过总结点数1/2的结点

02.B
- 二叉排序树性质
  - 中序遍历得到有序序列

03.A
- 二叉排序树查找特点
  - 查找路径自顶向下
  - 平均查找长度主要取决于树高

04.B
- 二叉排序树结构特征
  - 结点三部分构成
    - 左指针指向小于该结点的值
    - 右指针指向大于该结点的值
  - 最大关键字结点特点
    - 位于最右位置
    - 右指针必为空
    - 不一定是叶结点

05.C
- 二叉排序树查找过程
  - 先与根结点比较
  - 根据比较结果选择子树
  - 左子树结点值 $\leqslant$ 根结点值 $\leq$ 右子树结点值
  - C序列错误原因
    - 240的右孩子912大于根结点911

06.C
- A、B、D序列构造结果相同

07.A
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cbf41c7577b0831c9694e0c6c9bc117557c0447488336244f4c33e1a37935b8.jpg)
- 二叉排序树构造过程
  - 以第一个元素为根结点
  - 依次插入其他元素
- 查找过程
  - 先与根结点比较
  - 根据结果在子树中查找
  - 比较结点顺序：5271,60

08.D
- 有序序列构造特点
  - 形成单支树
  - 查找不存在值或最后结点时需 $n$ 次比较

09.D
- 二叉查找树构造数量
  - 中序序列确定
  - 先序序列数量为Catalan(5)=42
  - 总形态数为42种

10.D
- 最小深度条件
  - 叶结点在相邻两层
  - 理想情况：除最后一层外为满二叉树
  - 深度为 $\lceil\log_{2}(n+1)\rceil$

11.C
- 平衡二叉树结点数递推公式
  - $n_{0}=0$
  - $n_{1}=1$
  - $n_{2}=2$
  - $n_{h}=1+n_{h-1}+n_{h-2}$
- 结点数要求
  - 5层至少需12个结点
  - 6层至少需20个结点

12.B
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/757001b26f14b87e57a0a567962e98dcdb3faf19b2a4437b34b3496e2840997d.jpg)
- 平衡二叉树最少结点数
  - $n_{1}=1$
  - $n_{2}=2$
  - $n_{h}=n_{h-1}+n_{h-2}+1$
  - $n_{5}=12$

13.D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4fc3ce99f5862697a27c711091a41697b49da44fec0085171c1a1d8409225a9d.jpg)
图1
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c0d86e39e94af8af3761adaa7c6e466b34128d1c70d0d1e5bdb10540c6feedc.jpg)
图2
- 高度为3的平衡二叉树形态
  - 三种子树高度组合
    - 左右均为高度2：9种形态
    - 左高度1右高度2：3种形态
    - 左高度2右高度1：3种形态
  - 总计15种树形态

14.A
- 平衡二叉树旋转操作
  - 插入和删除可能引起LR或RL平衡旋转
  - 可能发生两次旋转

15.C
- 有序关键字插入特性
  - 当 $n=2^k-1$ 时形成满二叉树
  - 插入1023后为高度9的满二叉树
  - 插入1024后高度为10
16.D
- 红黑树与AVL树的性质比较
  - I和III都是红黑树的性质
  - AVL是高度平衡的二叉查找树
  - 红黑树是适度平衡的二叉查找树
  - AVL查询效率通常更优
  - AVL结点平衡因子特性
    - 左右孩子平衡因子为零不代表左右子树高度相等
    - 该结点平衡因子不一定为零

17.C
- 自平衡二叉排序树特性比较
  - 共同点
    - 都属于自平衡二叉树
    - 查找、插入、删除时间复杂度均为 $O(\log_{2}n)$
  - 红黑树删除特性
    - 情况1可能变为情况2、3或4
    - 情况2会变为情况3
    - 旋转次数可能超过2次
  - 红黑树路径特性
    - 所有路径黑结点数相同
    - 无连续红结点
    - 叶结点为红色
    - 最远最近路径长度比不超过2

18.B
- 红黑树结构特性
  - 红结点数目最大为黑结点2倍
  - 所有黑结点时必为满二叉树
  - 黑结点可有空叶结点和非空红结点孩子
  - 根结点为红色的子树不是红黑树

19.A
- 红黑树判定
  - 必须满足二叉排序树性质
  - 左右黑结点数必须相同
  - A项满足所有要求

20.C
- 红黑树插入过程
  - 关键字 $1,2,3,4,5,6,7$ 依次插入
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c27a51c5772a51bcde439143b9c61d568b118a23dad1a6807fd9d25b0457f9da.jpg)

21.D
- 红黑树插入过程
  - 关键字 $5,4,3,2,1$ 依次插入

22.B
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9289eb1ec4af4861df533975c421bce082e01497e341be62ddbc12eec3f167.jpg)
- 红黑树调整过程
  - 插入结点2并染红后违反不红红原则
  - 叔结点为黑色需要LL旋转
  - 结点3右旋至结点5位置
  - 结点2和5分别成为结点3左右孩子
  - 结点3染黑,结点2和5染红
  - 下一步进行右旋操作

23.B
- 平衡二叉树定义
  - 任意结点左右子树高度差不超过1
  - 其他选项均有不满足条件的结点
  - 可通过写出非叶结点平衡因子验证

24.C
- 平衡二叉树调整分析
  - 插入48后根结点平衡因子由-1变-2
  - RL型平衡旋转(先右旋后左旋)
  - 最小不平衡子树根结点右子树的左子树插入
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e81662b64bcb48da34de429ff499625461f0aa969233b426ca6107eccc92514.jpg)
  - 调整后37结点左右子结点值为24、53

25.A
- 二叉排序树查找路径分析
  - 左子树结点值小于根结点
  - 右子树结点值大于根结点
  - A选项查找91后向24查找矛盾
  - 后续查找到94违反二叉排序树性质
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e22f0ee6e7d5424ac3de4239981d63f25c35cb583db1ec9a129e4dc4ffb49de.jpg)

26.B
- 平衡二叉树最少结点分析
  - 非叶结点平衡因子均为1
  - 高度n时左右子树高度为n-1和n-2
  - 结点数递推公式: $C_{n}=C_{n-1}+C_{n-2}+1$
  - 初始值: $C_{1}=1,C_{2}=2,C_{3}=4$
  - 计算得: $C_{6}=20$
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6275c40fc894320237a3f623a550474064c28f50c6e018df50beb44373431f21.jpg)

27.C
- 二叉排序树删除插入特性
  - 叶结点删除重插入得到相同树
  - 非叶结点删除重插入可能得到不同树
  - 删除过程中其他结点填补位置
  - 重插入成为叶结点导致树形变化

28.D
- 平衡二叉树构建过程
  - 7个关键字构建
  - 平衡因子为0的分支结点3个
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1f35f2259f4716c9e2ffea999ad8aab2c71a3318e2c97905e13236b5579256b.jpg)

29.D
- 平衡二叉树性质分析
  - 仅要求高度平衡,不一定是二叉排序树
  - 两结点树根结点度为1
  - 中序遍历得到降序序列
  - 最大元素无左子树
  - 最后插入结点可能导致平衡调整

30.C
- 二叉排序树中序遍历特性
  - 中序遍历得到递增序列
  - 序列为 $x_{1},x_{3},x_{5},x_{4},x_{2}$
  - 可知 $x_{3}<x_{5}<x_{4}$

31.A
- 平衡二叉树删除插入分析
  - 插入必在叶结点位置
  - 叶结点删除情况
    - 不失衡则重插入得相同树
    - 失衡调整则可能得不同树
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8bee9e20b5f41eb72f9be27f992fccadae215df16b6446ea9167c732e1855826.jpg)
  - 非叶结点删除情况
    - 无调整时结点变为叶结点得不同树
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/04a663aef7a3b681eb2339aa426e9f5e1daa776dbbe7661ea3ff1f14664ae0ba.jpg)
    - 有调整时可能通过旋转保持相同
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aaa01fa6cb5ec56375e69a522c869a72b953704fd0cf11b32fc43437d142956.jpg)

32.B
- 二叉排序树生成验证
  - 选项B生成过程错误
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/200820177957ee15e4eb3c9f6e86744c0dd2db0c2478eee8fc74fd1849303370.jpg)

33.D
- 平衡二叉树调整过程
  - 23插入25左孩子位置
  - 破坏平衡需要调整
  - RL旋转(根结点右子树左子树)
  - 旋转后根结点值为25
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/964e6d538821f6beab710647587b6bd65b259e660d25419acb9a05269a421223.jpg)

# 二、综合应用题  

01.【解答】
- 二叉树序列分析
  - 先序序列：（50，38，30，45，40，48，70，60，75，80）
  - 中序序列：（30,38，40，45，48，50，60，70，75，80）
  - 构造二叉树
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e8352c6cc4340d5e771f7d9b0d954db2926162c7b9ecf27cafd20a6fb034d9e.jpg)  
- 查找分析
  - 查找成功平均长度
    - $\mathrm{ASL}=(1\times1+2\times2+3\times4+4\times3)/10=2.9$
  - 查找失败平均长度 
    - $\mathrm{ASL}=(3\times5+4\times6)/11=39/11$

02.【解答】
- 二叉排序树构造
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/98bb969effa80a78785a477d91aafc868a54ef5ca349485e71b06be2ff5dd08f.jpg)
- 平均查找长度
  - $\mathrm{ASL}=(1+2\times2+3\times3+4\times2+5\times2)/10=3.2$

03.【解答】
- 平衡二叉树调整过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/87e92e1261fb3e42755f1304eab95e621f370a86ba53f454d2123b41c55af0a0.jpg)
  - 第一步：插入34,23,15后LL调整
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/147225c38e376997c8ee95b5b6237c773fed8ffde4d21a2cfd36e2f4dc993868.jpg)
  - 第二步：插入98,115后RR调整
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4002ba341039ae309747a895cc3e4aee686217a98abd61089d381df4192dfdd9.jpg)
  - 第三步：插入28后RL调整
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05536c6e8542eb0430d79c91ae1171417af3378dd638113342a5b9a5fd761913.jpg)
  - 第四步：插入107后RL调整

04.【解答】
- 最佳二叉排序树构造
  - 关键字等概率查找
  - 构造步骤
    - 按值从小到大排序
    - 采用折半查找判定树方法
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c00a0b7152ef11d3113a91edbc8987195d90fa33fe1f1979b0d14a781472574d.jpg)

05.【解答】
- 二叉排序树判定算法
  - 中序遍历序列递增判定
  - 算法实现：

KeyType predt = -32767;
int JudgeBST(BiTree bt) {
    int b1,b2;
    if(bt == NULL) return 1;
    b1 = JudgeBsT(bt->lchild);
    if(b1 == 0 || predt >= bt->data)
        return 0;
    predt = bt->data;
    b2 = JudgeBsT(bt->rchild);
    return b2;
}


06.【解答】
- 结点层次查找算法
  - 非递归查找实现
  - 层次计数方法

int level(BiTree bt,BSTNode *p) {
    int n = 0;
    BiTree t = bt;
    if(bt != NULL) {
        n++;
        while(t->data != p->data) {
            if(p->data < t->data)
                t = t->lchild;
            else
                t = t->rchild;
            n++;
        }
    }
    return n;
}


07.【解答】
- 平衡二叉树判定算法
  - 后序遍历递归实现
  - 平衡条件判断

void JudgeAVL(BiTree bt,int &balance,int &h) {
    int bl=0,br=0,hl=0,hr=0;
    if(bt == NULL) {
        h = 0;
        balance = 1;
    }
    else if(bt->lchild == NULL && bt->rchild == NULL) {
        h = 1;
        balance = 1;
    }
    else {
        JudgeAVL(bt->lchild,bl,hl);
        JudgeAVL(bt->rchild,br,hr);
        h = (hl>hr?hl:hr) + 1;
        if(abs(hl-hr) < 2)
            balance = bl && br;
        else
            balance = 0;
    }
}


08.【解答】
- 最值查找算法
  - 最小值查找

KeyType MinKey(BSTNode *bt) {
    while(bt->lchild != NULL)
        bt = bt->lchild;
    return bt->data;
}

  - 最大值查找

KeyType MaxKey(BSTNode *bt) {
    while(bt->rchild != NULL)
        bt = bt->rchild;
    return bt->data;
}


09.【解答】
- 大于等于k的关键字输出算法
  - 递归实现

void Output(BiTree bt,int k) {
    if(bt == NULL) return;
    if(bt->rchild != NULL)
        Output(bt->rchild,k);
    if(bt->data >= k)
        printf("%d",bt->data);
    if(bt->lchild != NULL)
        Output(bt->lchild,k);
}


10.【解答】
- 第k小元素查找算法
  - 递归实现
  - 时间复杂度$O(\log_2n)$

BSTNode *SearchSmall(BSTNode *t,int k) {
    if(k<1 || k>t->count)
        return NULL;
    if(t->lchild == NULL) {
        if(k == 1)
            return t;
        else
            return SearchSmall(t->rchild,k-1);
    }
    else {
        if(t->lchild->count == k-1)
            return t;
        if(t->lchild->count > k-1)
            return SearchSmall(t->lchild,k);
        if(t->lchild->count < k-1)
            return SearchSmall(t->rchild,k-(t->lchild->count+1));
    }
}



# 7.4.4 答案与解析  

# 一、单项选择题  

01.D
- B树特性分析
  - 关键字数目比子树数目少1
  - 4阶B树要求
    - 根结点至少2棵子树(关键字数至少1)
    - 其他非叶结点至少 $\lceil n/2 \rceil = 2$ 棵子树(关键字数至少1)
    - 最多4棵子树(关键字数至多3)
  - 同时满足4、5、6阶B树要求，无法确定具体类型

02.C
- B树结点子树数量要求
  - 非根非叶结点至少有 $\lceil m/2 \rceil$ 棵子树
  - 根结点最多 $m$ 棵子树
  - 非叶根结点至少2棵子树

03.B
- B树性质分析
  - 非根内部结点必须至少 $\lceil m/2 \rceil$ 棵子树
  - 根结点至少两棵子树
  - 插入元素分裂特性
    - 路径上有未满结点不会增高
    - 仅根结点分裂才增高

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6b70ea789351b9436e9ce2a3bf9da40873cc2757acd01ee0f1573c4de34bd70f.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ec8ae0dd430f2a129d4c07e31e6fb710c86e06f5d28ce3d315106a797815c733.jpg)

04.B
- B树结点关键字数量限制
  - 最多 $m-1$ 个关键字
  - 最少 $\lceil m/2 \rceil - 1$ 个关键字
  - 超出范围需分裂或合并

05.A
- B树查找特性
  - 叶结点对应查找失败
  - $n$ 个关键字有 $n+1$ 种失败可能

06.B、D
- 3阶B树结点数分析
  - 最少结点数(类似满二叉树)
    - 高度5时至少 $2^5-1=31$ 个结点
  - 最多结点数(类似满三叉树)
    - 高度5时最多 $(3^5-1)/2=121$ 个结点

07.D
- B树最少关键字计算
  - 非根结点至少 $\lceil m/2 \rceil-1$ 个关键字
  - 根结点至少1个关键字
  - 总数 $(n-1)(\lceil m/2 \rceil-1)+1$

08.C、B
- 5阶B树高度计算
  - 最大高度 $H \leq \log_{\lceil m/2 \rceil}((n+1)/2)+1 = 4$
  - 最小高度 $h \geq \log_m(n+1) \approx 3$

09.A、D
- B树高度计算
  - 最大高度 $H \leq \log_2[(2047+1)/2]+1 = 11$
  - 最小高度 $h \geq \log_3 2048 = 7$

10.A
- B树与B+树差异
  - 结点关键字和子树个数
  - B+树非叶结点仅索引
  - B树关键字不重复
  - B+树支持顺序和随机查找
  - B+树更适合数据库和文件索引

11.A
- B树磁盘I/O分析
  - 树高计算公式 $\log_m(n+1) \leq h \leq \log_{\lceil m/2 \rceil}((n+1)/2)+1$
  - 高度 $h=5$
  - 根结点在内存，需4次磁盘I/O
12.D
- B树特性
  - m阶B树不要求叶结点间用指针链接
  - 选项D描述的是B+树特性

13.D
- 3阶B树删除操作
  - 删除78的情况分析
    - 删除前关键字个数 = $\lceil3/2\rceil-1$ 
    - 左兄弟关键字个数 $\geq \lceil3/2\rceil$
    - 属于"兄弟够借"情况
  - 处理方法
    - 左兄弟最大关键字上移到父结点
    - 父结点对应关键字下移到删除位置

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84cffa5a4e36be277510866df229dad3433a44c6c4593cd4b7a91f8f06bd4432.jpg)

14.A
- 5阶B树结点特性
  - 根结点要求
    - 分支数最少为2
    - 关键字数最少为1
  - 非叶结点要求
    - 分支数最少为 $\lceil n/2\rceil=3$
    - 关键字数最少为2

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f8f59e804ac095fa4ad361b3178550c2a93112e18e01d3c4093a9e714ac51c16.jpg)

15.D
- 4阶B树结构分析
  - 结点关键字要求
    - 根结点最少1个
    - 非根结点最少 $\lceil4/2\rceil-1=1$ 个
  - 最多结点情况
    - 每结点1个关键字
    - 形成类似二叉树结构
    - 4层树满足定义

16.A
- B+树与B树比较
  - B+树特点
    - 叶结点包含全部关键字
    - 叶结点按序链接
    - 支持顺序查找
  - B树特点
    - 仅支持多路查找

17.B
- B+树应用场景
  - 适用于文件系统和数据库索引
  - 磁盘读写代价低
  - 查询效率稳定
  - 其他系统应用说明
    - 编译器使用自动机和语法树
    - 路由表使用缓存和压缩技术
    - 磁盘管理用空闲链表

18.B
- 3阶B树最少关键字计算
  - 非叶结点要求
    - 最少 $\lceil m/2\rceil-1$ 个关键字
    - 代入m=3得到最少1个
  - 结构特点
    - 类似满二叉树
    - 高度h=5时有31个关键字

19.B
- 4阶B树插入过程
  - 结点特性
    - 最多含 $m-1=3$ 个关键字
  - 插入导致结点分裂
  - 最终根结点包含6,9

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d973b047763897bf348baea36055d366507ab95fbb33e08e0c536905e65e903d.jpg)

20.A
- 3阶B树结构分析
  - 结点限制
    - 最多2个关键字
    - 最多3棵子树
  - 第二层4个关键字分布
    - 分布在3个结点中
    - 最多11个结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1876fb411dc415a97896e022a84ffdce44ee8c844cd9ba4feb4002883493f38a.jpg)

21.D
- 5阶B树删除操作
  - 非叶结点关键字数k要求
    - $2 \leq k \leq 4$
  - 删除情况分析
    - 情况1:删260,借85
    - 情况2:删260,合并左兄弟
    - 情况3:删260,合并右兄弟
  - 根结点可能序列分析
    - $<60,85,110,350>$
    - $<60,90,350>$
    - $<60,90,280>$

22.B
- B树操作特性分析
  - 插入操作
    - 可能导致叶结点分裂
    - 分裂可能传导至根结点
  - 删除操作
    - 必定影响叶结点
    - 非叶结点删除转换为叶结点删除
  - 查找特性
    - 非叶结点找到即停止
    - 插入初始位置在叶结点
# 二、综合应用题  

01.【解答】

- B树插入操作分析
  - 初始插入20,30
    - 关键字个数不超过 $m-1=2$
    - 不会引起分裂
  - 插入50
    - 插入20,30所在结点
    - 引起分裂
    - 第 $\lceil m/2\rceil$ 个关键字30上升为父结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1babae086f1fd49f6dc59ecc541439f4f994923be9710fd264a4ce098a39a207.jpg)

- 继续插入操作
  - 插入52
    - 插入50所在结点
    - 不会引起分裂
  - 插入60
    - 插入50,52所在结点
    - 引起分裂
    - 52上升到父结点
    - 不会引起父结点分裂

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5cca2de7289e0f067eb089a65d7e23d55a4199971a31bb96620b3482cc1c3585.jpg)

- 最终插入操作
  - 插入68
    - 插入60所在结点
    - 不会引起分裂
  - 插入70
    - 插入60,68所在结点
    - 引起分裂
    - 68上升为新父结点
    - 68上升到30,52结点后继续分裂
    - 52最终上升为新根结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5063156976442bac31f278c2809bfc32599ef28647f038954981baefcccc6620.jpg)

02.【解答】

- B树操作过程
  - 插入90
    - 插入100所在结点
    - 元素个数不超过 $\lceil3/2\rceil=2$
    - 不会引起分裂

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92ea03be230fd165f2eccc0a312692706a04fee071d58beaf48797db372afd18.jpg)

  - 插入25
    - 插入8,20所在结点
    - 元素个数达到3,引起分裂
    - 中间元素20上升到父结点
    - 父结点元素个数为2,不继续分裂

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1953444666fce4e5c614460b7334ef98bf1c8bc6aba164f11c5e74923f7ad73.jpg)

  - 插入45
    - 插入35,40所在结点引起分裂
    - 中间元素40上升到父结点
    - 父结点继续分裂
    - 中间元素30上升到50所在结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e33900611d2dd51774b8b72702b89f90933940171e0e6d3103ef1ffe77da326.jpg)

  - 删除60
    - 删除后结点为空
    - 借用右兄弟结点元素调整

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7ea07cf34b158b258e09049544dd929fbac26b467f0056fcdb6617f41723c202.jpg)

  - 删除80
    - 删除后父结点与右兄弟合并
    - 父结点元素个数为0需再次调整
    - 50与40合并成新结点
    - 90,100成为新结点的子结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d40411ff0fb9b2ee27179dc17e36e4b5e15242536957796ca4fce04a5553f149.jpg)

> attention:  

B树中结点的插入、删除操作（特别是插入、删除后的结点分裂与合并）是本节的重点，也是难点，请读者务必熟练掌握。

03.【解答】

- B树结点大小分析
  - 结点组成
    - $m-1$ 个关键字(5B)
    - $m-1$ 个记录地址(5B)
    - $m$ 个子树指针(5B)
    - 1个关键字个数计数(2B)
  - 大小限制方程
    - $(2(m-1)+m)\times5+2\leq4000$
    - 计算得 $m\leq267$
  - 索引项容量
    - 最多 $m-1=266$ 个
    - 最少 $\lceil m/2\rceil-1=133$ 个
  - 存储空间分析
    - 总记录数 $n=20000000$
    - 每记录200B
    - 每页块存20条记录
    - 共需1000000个页块
    - B树索引页块数
      - 最多7519个
      - 最少3760个
# 7.5.6 答案与解析  

# 一、单项选择题  

01.B
- 查找方法与存储结构关系
  - 顺序查找：顺序存储或链式存储
  - 折半查找：仅顺序存储且关键字有序
  - 树形查找：树的存储结构(顺序或链式)
  - 散列查找：链地址法采用顺序与链式存储结合

02.D
- 散列查找特点
  - 通过散列函数建立关键字与地址的对应关系
  - 查找以计算代替比较

03.D
- 散列查找性质
  - 冲突不可避免，与装填因子无关
  - 查找需计算散列地址并比较关键字
  - 平均查找长度与装填因子相关，与表长无直接关系
  - 开放定址法不能随意删除元素

04.C
- 开放定址法中的堆积问题
  - 同义词与非同义词探查序列交织
  - 导致查询路径延长
  - 降低散列效率

05.A
- 平方探测法特点
  - 采用非线性增量序列
  - 可跳过已占用单元
  - 减小冲突概率
  - 同义词不一定相邻
  - 链地址法不会引起聚集

06.A
- 线性探测法平均查找长度计算
  - $\mathsf{ASL}_{n\!g\!;\!m}=\frac{1}{2}\bigg(1\!+\!\frac{1}{1\!-\!\alpha}\bigg)\!\leqslant\!1.5$
  - $\alpha\!=\!\frac{200}{m}\!\leqslant\!\frac{1}{2}$
  - $m\!\geqslant\!400$

07.D
- K个关键字填入过程
  - 第一个不发生冲突
  - 探测次数为$K(K+1)/2$

08.C
- 散列表查找效率分析
  - 平均查找长度与装填因子$\alpha$相关
  - 不直接依赖表项个数$n$或表长$m$
  - 同义词情况下为$O(n)$而非$O(1)$

09.D
- 聚集现象
  - 因不当处理冲突方法导致
  - 不同关键字争夺同一地址
  - 线性探查法易引发

10.C
- 下一个空位特点
  - 可大于原散列地址
  - 可小于原散列地址
  - 不等于原散列地址

11.D
- 散列地址分析
  - 14,1,27,79散列后地址均为1
  - 共4个记录

12.A,B
- 不同处理方法比较
  - 链地址法
    - 同义词在同一链表
    - 探测仅在链表内进行
  - 线性探测法
    - 同义词可能分散
    - 首次探测可能非同义词

13.A,C
- H函数特性
  - 取值范围0~16
  - 链表个数为17
  - 数组下标0~16

14.A
- 线性探测过程
  - 公式：$\mathrm{H}_{i}{=}\left(\mathrm{H}\left(\mathrm{kep}\right){+}\mathrm{d}_{i}\right)\,\%\,\mathrm{m}$
  - $\mathrm{H}(49)=49\,\%\,11=5$（冲突）
  - $\mathrm{H}_{1}=6$（冲突）
  - $\mathrm{H}_{2}=7$（冲突）
  - $\mathrm{H}_{3}=8$（无冲突）
15.C
- 插入过程分析
  - $\mathrm{H}(26)=9$ ，不冲突
  - $\mathrm{H}(25)=8$ ，不冲突
  - $\mathrm{H}(72)=4$ ，不冲突
  - $\mathrm{H}(38)=4$ ，冲突，处理后地址为5
  - $\mathrm{H}(8)=8$ ，冲突，处理后地址为10
  - $\mathrm{H}(18)=1$ ，不冲突
  - $\mathrm{H}(59)=8$ ，冲突，处理后地址为11
  - 查找59需探查4次

16.B
- 插入过程分析
  - $6 \% 17 = 6$
  - $22 \% 17 = 5$
  - $7 \% 17 = 7$
  - $26 \% 17 = 9$
  - $9 \% 17 = 9$ ，冲突，平方探测得10（无冲突）
  - $23 \% 17 = 6$ ，冲突，平方探测：7（冲突）→5（冲突）→10（冲突）→2（无冲突）
  - 关键字23放在位置2

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de875321c5ffb1c7d6626f77a8d8d4f773e2a3f046b3bdbf2cd7574208e6f7a5.jpg)

17.C
- 散列函数特性
  - 地址冲突不可完全避免

18.D
- 散列表查找效率影响因素
  - 与装填因子成正比
  - 合适的冲突处理方法可避免聚集
  - 链地址法不存在聚集现象
  - 线性探测法易引起聚集现象

19.D
- 堆积现象影响分析
  - 仅影响平均查找长度
  - 不影响存储效率
  - 不影响散列函数
  - 不影响装填因子

20.C
- HT结构分析
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1f79e6cf33d4630a5bb54160b88b8adc98a306b814bcf3659065adc540026756.jpg)
- 平均查找长度计算
  - $\mathrm{ASL}=(1+2+3)/3=2$

21.C
- 线性探查法分析
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d6c5fc2bc665fb26fdb6a83cbddf241eae8a7f0593b25861a4b0dfd2852eaf1.jpg)
- 查找失败分析
  - $\mathrm{H(key)}=0\sim6$
  - 地址0需比较9次
  - 地址1需比较8次
  - 平均比较次数：$(9+8+7+6+5+4+3)/7=6$

22.D
- 影响因素分析
  - 填装因子越大，冲突可能性越高
  - 散列函数影响冲突概率
  - 冲突解决策略影响效率

23.C
- 开放定址法删除特性
  - 不可物理删除
  - 需使用删除标记
- 实例分析
  - 依次插入2022、12、25
  - 删除25后的散列表：
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0dca011576076efde8af6d061e4c266422582a12cfa1bd5e5ba10ae8394db2c.jpg)
  - 查找失败平均长度：$(1+3+2+1+2)/5=1.8$
# 二、综合应用题  

01.【解答】
- 散列表删除记录分析
  - 拉链法
    - 可以物理删除
  - 开放定址法
    - 不能物理删除
    - 只能做删除标记
    - 原因：该地址可能是同义词查找路径上的地址
    - 物理删除会中断查找路径
    - 查找时碰到空地址认为查找失败

02.【解答】
- 散列函数分析
  - 函数1: $key/n$
    - 不能作为散列函数
    - 原因：$key/n$ 可能大于 $n$，无法找到适合位置
  - 函数2: 0
    - 能作为散列函数但不好
    - 原因：所有关键字映射到同一位置，造成大量冲突
  - 函数3: $random(n)$
    - 不能作为散列函数
    - 原因：返回值不确定，无法正常查找
  - 函数4
    - 能作为散列函数
    - 是一个好的散列函数

03.【解答】
- 散列表构造分析
  - 散列地址范围：$0{\sim}10$
  - 构造方法比较
    - 线性探测法
      - 计算散列地址
      - 检查地址是否有元素
      - 无元素直接放入
      - 有元素线性探测下一地址
    - 链地址法
      - 计算散列地址
      - 将关键字结点插入对应链表

1）线性探测法。

H $(\mathbb{1})=\mathbb{1}$，无冲突，地址1存放关键字 $1\!\circ\!\mathrm{H}\left(13\right)\!=\!2$，无冲突，地址2存放关键字13。H $(\mathbb{1}2)=\mathbb{1}$ 发生冲突，根据线性探测法：$\mathtt{H}_{1}{=}2$，发生冲突，继续探测 $\mathtt{H}_{2}{=}3$，无冲突，于是12存放在地址为3的表项中。H $(34){=}1$，发生冲突，根据线性探测法：$_\mathrm{H_{l}}{=}2$，发生冲突，$\mathtt{H}_{2}{=}3$，发生冲突，$\mathtt{H}_{3}{=}4$，没有冲突，于是34存放在地址为4的表项中。

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7345b2f08c4b4921f6bcfe02930d17754488ea02f7d9aefc759d2138744943f9.jpg)

- 平均查找长度计算
  - 查找成功
    - 每个元素查找概率：1/8
    - 计算公式：$\mathrm{ASL}_{成功}=(1+1+1+3+4+1+2+8)/8=21/8$
  - 查找失败
    - 每个位置查找概率：1/11
    - 计算公式：$\mathrm{ASL}_{失败}=(9+8+7+6+5+4+3+2+1+1+1)/11=47/11$

2）链地址法构造的表如下：

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dad8bd3bf4db7a9e81b9a1fd719441116853a9562ac4487e6126b5fa030915ae.jpg)

- 平均查找长度计算
  - 查找成功
    - 计算公式：$\mathrm{ASL}_{成功}=(1\times4+2\times3+3)/8=13/8$
  - 查找失败
    - 计算公式：$\mathrm{ASL}_{失败}=(3+4+2+1+1+3+1+1+1+1+1)/11=19/11$
    - 注意事项
      - 两种观点
        - 比较到空结点才算失败：比较次数=冲突次数+1
        - 只计算与关键字的比较次数

04.【解答】
- 解题思路
  - 由装填因子计算公式 $\alpha = n/N$ ($n$为关键字个数，$N$为表长)可得表长
  - 根据散列函数选择要求，$P$应取不大于表长的最大素数
  - 采用链地址法解决冲突

- 具体解答
  - 计算表长和散列函数
    - $N = \lceil n/\alpha \rceil = 15$
    - $P = 13$
    - 散列函数为 $H(key) = key \bmod 13$
  
  - 计算散列地址
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/28a3192a05cddf0924e0e302178484f784cec7e6ebab5acc08ab3cc0ba284477.jpg)

  - 构造链地址法散列表
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/49d70cef373cdb1c5c2147ba92f934d33ca15bb6ee57a133157851d01087c260.jpg)

  - 计算平均查找长度
    - 查找成功: $ASL_{成功} = (1 \times 7 + 2 \times 2 + 3 \times 1 + 4 \times 1)/11 = 18/11$
    - 查找失败: $ASL_{失败} = (1+0+2+1+0+1+1+0+0+0+1+0+4)/13 = 11/13$

05.【解答】
- 散列地址计算过程
  - $H_0(2)=2$, $H_0(8)=8$, $H_0(31)=5$, $H_0(20)=7$, $H_0(19)=6$ (无冲突)
  - $H_0(18)=5$ (发生冲突)
    - $H_1(18)=(H_0(18)+REV(18+1) \bmod 11+1) \bmod 13=9$ (无冲突)
  - $H_0(53)=1$ (无冲突)
  - $H_0(27)=1$ (发生冲突)
    - $H_1(27)=(1+5+1) \bmod 13=7$ (发生冲突)
    - $H_2(27)=0$ (无冲突)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/625fd0636210f4574d07a4898e4082050a4123637d9a782448b943f98a41c5a5.jpg)

- 平均查找长度计算
  - $ASL_{成功}=(3+1+1+1+1+1+1+2)/8=11/8$

06.【解答】
- 散列表构造
  - 数组大小计算: $7/0.7=10$，下标范围$0\sim9$
  - 散列函数值计算:
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/358953af5aeabecde87bbb12614a23cf1a01ba593d2cd6553420b155c1c0c8e6.jpg)
  
  - 线性探测再散列法处理冲突:
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/07cb86b65e45ffcd55fe2ab43973be64df37775eb62e8cb65d75c0b7a42ac71d.jpg)

- 平均查找长度计算
  - 查找成功情况:
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9e4ac265f11d106ab91877b12711e02dd03ba83e2164a55346b9307ebcfa2871.jpg)
    - $ASL_{成功}=12/7$

  - 查找失败情况:
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d5915433b5a31ba16d6e994357731f4aef9885391a2bf681d0e7d72e08e914d4.jpg)
    - $ASL_{失败}=18/7$

# 8.1.3 答案与解析  

# 一、单项选择题  

01.C
- 拓扑排序
  - 将有向图中所有结点排成一个线性序列
  - 虽然在内存中进行，但不属于内部排序范畴
  - 不满足前面排序的定义

02.A
- 绝对位置概念
  - 若排序前元素 $R$ 在位置 $i$，则绝对位置就是 $i$
  - 排序后 $R$ 的位置不发生变化
  - B选项错误，C、D选项与题目要求无关

03.B
- 排序算法特性
  - 算法稳定性与算法优劣无关(A选项排除)
  - 链表排序可行性
    - 可以使用链表进行排序
    - 部分算法不适用(如折半插入排序)
    - 原因：只能顺序逐链查找定位元素

04.A
- 基于比较的排序最少比较次数
  - 考虑最坏情况
  - 计算公式：$\lceil\log_{2}(n!)\rceil$
  - $n=7$ 时结果为13
- 公式证明
  - 每次比较后有两种可能转移
  - 设至少比较 $t$ 次，有 $2^t$ 种情况
  - $n$ 个记录有 $n!$ 种不同排列
  - 得到不等式 $2^t \geq n!$
  - 解得 $t \geq \log_2(n!)$
  - 考虑整数性质，最终结果为 $\lceil\log_2(n!)\rceil$
# 8.2.5 答案与解析  

# 一、单项选择题  

01.B
- 直接插入排序分析
  - 最坏情况下比较次数
    - 需要进行 $n(n-1)/2$ 次关键字比较
    - 当 $n=5$ 时，比较次数为10
    - 不考虑与哨兵的比较

02.A
- 序列初始基本有序的情况
  - 直接插入排序时间复杂度接近 $O(n)$
  - 其他算法时间复杂度均大于 $O(n)$

03.B
- 图书排序场景
  - 大部分图书有序
  - 适合采用直接插入排序

04.D、A
- 直接插入排序比较次数分析
  - 反序情况
    - 需要 $n(n-1)/2$ 次比较
    - 从前往后依次比较 $1,2,\cdots,n-1$ 次
  - 正序情况
    - 只需 $n-1$ 次比较
  - 不考虑与哨兵的比较

05.C
- 排序算法特征比较
  - 冒泡排序和选择排序
    - 两趟后有两个最大(最小)元素在最终位置
  - 插入排序
    - 两趟后前三个元素局部有序
    - 本题只可能是插入排序

> attention:  
- 每趟确定最终位置的算法
  - 冒泡排序
  - 简单选择排序
  - 堆排序
  - 快速排序
  - 前三者形成全局有序子序列
  - 快速排序确定枢轴元素最终位置

06.B
- 直接插入排序比较次数分析
  - 越接近正序比较次数越少
  - B序列分析(共9次比较)
    - 第一趟：插入32，比较1次
    - 第二趟：插入46，比较1次
    - 第三趟：插入40，比较2次
    - 第四趟：插入80，比较1次
    - 第五趟：插入69，比较2次

07.C
- 直接插入排序特性
  - 最后元素插入第一位时
  - 前面有序子序列中所有元素都不在最终位置

08.A
- 希尔排序本质
  - 是直接插入排序的改进
  - 属于插入排序范畴

09.B
- 希尔排序分组特征
  - 序列分成若干组
  - 记录只在组内交换
  - 观察可知增量为4
    - 9和-1交换
    - 7和4交换

10.C
- 排序算法判断
  - 前两个元素局部有序
  - 一趟直接插入排序有效
11.A
- 希尔排序增量分组特征
  - 增量为4时相距为4的记录构成一组
  - 组内进行直接插入排序
  - 只有A项满足要求

12.B
- 希尔排序过程分析
  - 第一趟分组比较
    - EE组、AS组、ST组、YI组(交换)、QO组(交换)、UN组(交换)
    - 结果为EASIONESTYQU
  - 第二趟分组比较
    - EIEY组：I和E、E和I、E和E、Y和I比较
    - AOSQ组：O和A、S和O、Q和S、Q和O比较
    - SNTU组：N和S、T和S、U和T比较
  - 总比较次数
    - 第一趟6次
    - 第二趟11次
    - 总计17次

13.B
- 希尔排序增量序列排序过程
  - 第一趟($d=5$)
    - 结果:2,11,5,1,8,9,24,7,34,51,13,77,56
  - 第二趟($d=3$)
    - 结果:1,7,5,2,8,9,24,11,34,51,13,77,56

14.C
- 折半插入排序特性
  - 仅改进了比较次数
  - 移动次数未变化
  - 时间复杂度仍为$O(n^2)$

15.A
- 希尔排序特点
  - 基于插入排序算法
  - 不一定每趟将元素放置到最终位置

16.C
- 希尔排序算法性质
  - 属于复杂插入排序
  - 是不稳定排序算法

17.C
- 排序算法稳定性分析
  - 简单方法通常稳定
    - 直接插入
    - 折半插入
    - 冒泡
  - 例外：简单选择不稳定
  - 复杂方法都不稳定
    - 希尔排序
    - 快速排序
    - 堆排序

18.D
- 折半插入与直接插入排序比较
  - 相同点
    - 都将元素插入前面有序子表
    - 排序趟数都是$n-1$趟
    - 移动次数取决于初始序列
    - 辅助空间都是$O(1)$
  - 不同点
    - 查找方式不同
      - 直接插入用顺序查找
      - 折半插入用折半查找
    - 时间复杂度不同
      - 折半插入为$O(n\log_2n)$
      - 直接插入为$O(n){\sim}O(n^2)$

19.B
- 希尔排序增量分析
  - 排序方向：从小到大
  - 增量分析
    - 增量2：不符合(4比9小)
    - 增量3：符合要求
    - 增量4：不符合(9比7大)
    - 增量5：不符合(9比8大)

20.A
- 希尔排序基本思想
  - 分割成若干子序列
  - 各子序列进行直接插入排序
  - 逐步缩减增量
  - 最后对全体元素直接插入排序

21.D
- 希尔排序实例分析
  - 初始序列：8,3,9,11,2,1,4,7,5,10,6
  - 第一趟(间隔5)
    - 分组：8,1,6；3,4；9,7；11,5；2,10
    - 结果：1,3,7,5,2,6,4,9,11,10,8
  - 第二趟(间隔3)
    - 分组：1,5,4,10；3,2,9,8；7,6,11
    - 结果：1,2,6,4,3,7,5,8,11,10,9
# 二、综合应用题  

01.【解答】  
- 直接插入排序过程
  - 初始序列：$\begin{array}{l}{4,5,1,2,6,3}\\ {4,5,1,2,6,3}\\ {1,4,5,2,6,3}\\ {1,2,4,5,6,3}\\ {1,2,4,5,6,3}\\ {1,2,3,4,5,6}\end{array}$
  - 排序过程
    - 第一趟：（将5插入{4}）
    - 第二趟：（将1插入{4,5}）
    - 第三趟：（将2插入{1,4,5}）
    - 第四趟：（将6插入{1,2,4,5}）
    - 第五趟：（将3插入{1,2,4,5,6}）

02.【解答】  
- 希尔排序过程
  - 原始序列：$\begin{array}{c}{50,26,38,80,70,90,8,30,40,20}\\ {50,8,30,40,20,90,26,38,80,70}\\ {26,8,30,40,20,80,50,38,90,70}\\ {8,20,26,30,38,40,50,70,80,90}\end{array}$
  - 排序步骤
    - 第一趟（增量5）
    - 第二趟（增量3）
    - 第三趟（增量1）
# 8.3.4 答案与解析  

# 一、单项选择题  

- 冒泡排序
  01.A
  - 趟数分析
    - 最少进行1趟冒泡
    - 最多进行 $n\!-\!1$ 趟冒泡
  - 初始序列分析
    - 逆序时需 $n\!-\!1$ 趟,元素交换次数最多
    - 有序时只需1趟(无交换)即可结束

  02.C
  - 冒泡排序特点
    - 始终在调整"逆序"
    - 交换次数等于逆序个数
  - 逆序序列分析
    - 每个元素向后调整需比较
    - 总比较次数: $5+4+3+2+1=15$

  03.D
  - 排序算法分析
    - 选择排序:每趟确定一个最终位置
    - 插入排序:前 $i+1$ 个元素有序
    - 归并排序:{20,15}和{21,25}反序不符合
    - 快速排序:基准元素最终位置确定

  04.C
  - 快速排序过程
    - 以46为基准
    - 先从后往前扫描交换小元素
    - 再从前往后扫描交换大元素
    - 重复直到46处于最终位置

  05.D
  - 快速排序效率分析
    - 基本有序数据:划分不均匀,效率低
    - 随机分布数据:划分均匀,效率高

  06.D
  - 平均性能比较
    - 直接插入和冒泡: $O(n^2)$
    - 希尔排序:优于直接插入
    - 快速排序:常数因子最小

  07.A
  - 排序算法判断
    - 插入排序:前三元素应有序
    - 冒泡/选择:两趟后两端元素应确定
    - 序列分析:1246891020与给定序列比较

  08.C
  - 冒泡排序过程分析
    - 第一趟:{1,8,9,10,4,5,6,20,2}
    - 第二趟:{1,2,8,9,10,4,5,6,20}
    - 第三趟:{1,2,4,8,9,10,5,6,20}
    - 第四趟:{1,2,4,5,8,9,10,6,20}
    - 第五趟:{1,2,4,5,6,8,9,10,20}

  09.B
  - 双向冒泡排序过程
    - 第一趟(左→右):4,7,3,5,6,8,9,1,2,10
    - 第二趟(右→左):1,4,7,3,5,6,8,9,2,10
    - 第三趟(左→右):1,4,3,5,6,7,8,2,9,10
    - 第四趟(右→左):1,2,4,3,5,6,7,8,9,10
    - 第五趟(左→右):1,2,3,4,5,6,7,8,9,10

  10.A、D
  - 快速排序效率分析
    - 最快情况:枢轴值均匀划分
    - 最慢情况:序列已有序或逆序
    - 序列分析
      - A序列:划分均匀,速度最快
      - D序列:已有序,速度最慢
11.B
- 快速排序移动次数分析
  - A序列(枢轴92)
    - 35移至第一位
    - 96移至第六位
    - 30移至第二位
    - 枢轴移至第五位
    - 总移动次数:4
  - B序列移动次数:8
  - C序列移动次数:4
  - D序列移动次数:2

12.C
- 排序序列分析
  - 最终有序序列
    - 从小到大:{11,18,23,68,69,73,93}
    - 从大到小:{93,73,69,68,23,18,11}
  - 选项分析
    - I、III项:无最终位置元素
    - III项:73,93位于从大到小最终位置
    - IV项:73,93位于从小到大最终位置

13.B、C
- 快速排序递归树分析
  - 等分情况
    - 递归树高度: $\log_{2}\!n$
  - 最大/最小值情况
    - 递归树退化为单链表
    - 树高度: $n$

14.D
- 最优情况下比较次数分析
  - 第一趟:7次比较
  - 第二趟:5次比较(2+3)
  - 第三趟:1次比较
  - 总比较次数:13次

15.D
- 快速排序递归次数特点
  - 与初始排列相关
  - 与分区处理顺序无关
  - 分区平衡性影响递归次数

16.A
- 存储结构选择
  - 内部排序适用顺序存储
  - 快速排序需双向查找
  - 宜采用顺序存储结构

17.C
- 两趟快速排序结果分析
  - 第一种情况
    - 基准元素在首/尾端
    - 确定两个最终位置
  - 第二种情况
    - 基准元素在中间
    - 确定三个最终位置
  - 选项分析结果:C项不符合要求

18.D
- 快速排序第二趟结果验证
  - A项:28,72符合第一种情况
  - B项:2,72符合第一种情况
  - C项:2,28,32符合两种情况
  - D项:不符合任何情况

19.D
- 枢轴元素确定分析
  - 可能枢轴:77,81
  - 77左侧有大元素80,非枢轴
  - 81左右元素分布合理,为枢轴

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/14ea3a3aee3d03b516d8d5f1e07e7e546d7165bc0b12e5b009d41cbf65597c2a.jpg)
# 二、综合应用题  

01.【解答】
- 基于快速排序的划分思想
  - 时间复杂度 $O(n)$
  - 空间复杂度 $O(1)$
  - 基本思想
    - 从前往后找偶数元素
    - 从后往前找奇数元素
    - 交换两个元素
    - 重复直到i>j


void move(ElemType A[], int len) {
    int i = 0, j = len-1;
    while(i < j) {
        while(i < j && A[i]%2 != 0) i++;
        while(i < j && A[j]%2 != 1) j--;
        if(i < j) {
            Swap(A[i], A[j]);
            i++;
            j--;
        }
    }
}


02.【解答】
- 查找第k小元素的算法
  - 基于快速排序的划分操作
  - 时间复杂度分析
    - 平均情况 $O(n)$
    - 空间复杂度取决于划分方法
  - 算法思想
    - 选择枢轴pivot进行划分
    - 比较m与k的大小关系
      - m=k: pivot为所求元素
      - m<k: 在右半部分递归查找
      - m>k: 在左半部分递归查找


int kth_elem(int a[], int low, int high, int k) {
    int pivot = a[low];
    int low_temp = low;
    int high_temp = high;
    
    while(low < high) {
        while(low < high && a[high] >= pivot) --high;
        a[low] = a[high];
        while(low < high && a[low] <= pivot) ++low;
        a[high] = a[low];
    }
    a[low] = pivot;
    
    if(low == k)
        return a[low];
    else if(low > k)
        return kth_elem(a, low_temp, low-1, k);
    else
        return kth_elem(a, low+1, high_temp, k);
}


03.【解答】
- 三色条块排序算法
  - 算法思想
    - 顺序扫描线性表
    - 红色条块移至前面
    - 蓝色条块移至后面
  - 指针设计
    - j为工作指针
    - i前为红色
    - k后为蓝色


typedef enum {RED, WHITE, BLUE} color;

void FlagArrange(color a[], int n) {
    int i = 0, j = 0, k = n-1;
    while(j <= k) {
        switch(a[j]) {
            case RED:
                Swap(a[i], a[j]);
                i++; j++;
                break;
            case WHITE:
                j++;
                break;
            case BLUE:
                Swap(a[j], a[k]);
                k--;
                break;
        }
    }
}


04.【解答】
- 数组分组算法
  - 基本设计思想
    - 最小n/2个元素放A1
    - 其余元素放A2
    - 基于枢轴划分处理
      - i = ⌊n/2⌋: 分组完成
      - i < ⌊n/2⌋: 继续划分后半部分
      - i > ⌊n/2⌋: 继续划分前半部分
  - 性能分析
    - 平均时间复杂度 $O(n)$
    - 空间复杂度 $O(1)$


int setPartition(int a[], int n) {
    int pivotkey, low = 0, low0 = 0, high = n-1, high0 = n-1;
    int flag = 1, k = n/2, i;
    int s1 = 0, s2 = 0;
    
    while(flag) {
        pivotkey = a[low];
        while(low < high) {
            while(low < high && a[high] >= pivotkey) --high;
            if(low != high) a[low] = a[high];
            while(low < high && a[low] <= pivotkey) ++low;
            if(low != high) a[high] = a[low];
        }
        a[low] = pivotkey;
        
        if(low == k-1)
            flag = 0;
        else if(low < k-1) {
            low0 = ++low;
            high = high0;
        }
        else {
            high0 = --high;
            low = low0;
        }
    }
    
    for(i = 0; i < k; i++) s1 += a[i];
    for(i = k; i < n; i++) s2 += a[i];
    return s2-s1;
}




# 8.4.4 答案与解析  

# 一、单项选择题  

- 排序算法思想与特点
  - 读者应熟练掌握各种排序算法的思想、过程和特点

01.A 02.C

03.D
- 堆排序与其他排序算法比较
  - 堆排序处理方法
    - 读入前10个元素建立大根堆
    - 扫描剩余元素
      - 大于堆顶则舍弃
      - 小于堆顶则替换并重新调整
    - 最终堆中保存最小10个元素
  - 时间复杂度分析
    - 堆排序和冒泡排序均为线性时间复杂度
    - 堆排序常系数更小
    - 快速排序和归并排序无法达到线性复杂度

04.D
- 堆的判定方法
  - 将序列表示为完全二叉树
  - 检查父子节点关系是否满足堆定义
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9ab8e0f9cdbe44b2f873611d240a932e4089ac3d5650c75adea56060a9e7698.jpg)

05.B
- 小根堆特性
  - 关键字最大记录存储在叶节点
  - 存储范围为 $n/2+1$ 到 $n$

06.C、C
- 堆插入操作分析
  - 向上调整算法
    - 比较次数最多为树高度减1
    - 树高度为 $\lfloor\log_2n\rfloor+1$
    - 最多比较次数为 $\lfloor\log_2n\rfloor$

07.A、D
- 堆操作时间复杂度
  - 建堆过程
    - 向下调整时间为 $O(h)$
    - 总时间复杂度为 $O(n)$
  - 堆排序
    - 最好最坏情况均为 $O(n\log_2n)$

08.A
- 简单选择排序特点
  - 比较次数固定为 $n(n-1)/2$
  - 与序列状态无关

09.D
- 堆的性质分析
  - 高度小于等于相同节点数的二叉排序树
  - 根到叶路径构成有序序列
  - 层序遍历不保证有序

10.C
- 堆的筛选过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c1e9addeca78e042908b93b3601b16e5fb2407c67be9afd0bc616dde71c7033d.jpg)

11.D
- 堆的建立与重建过程
  - 初始堆:{8,17,23,52,25,72,68,71,60}
  - 输出8后:{17,25,23,52,60,72,68,71}
  - 输出17后:{23,25,68,52,60,72,71}

12.B
- 大根堆调整过程
  - 从下到上、从右到左调整
  - 具体交换步骤
    - 98和77交换(1次)
    - 98和62交换(1次)
    - 77和62交换(1次)
    - 98和48交换(1次)
    - 77和48交换(1次)
    - 62和48交换(1次)
  - 总计交换6次

13.B
- 堆删除调整过程
  - 删除堆顶后将堆尾元素放入堆顶
  - 自上而下调整
    - 34与53比较(第1次)
    - 53与根22比较(第2次)
    - 22与左孩子46比较(第3次)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba69cc31bfb95c944e8f4daaea81f4735512a8fef5c8bf3c776921efe99ca5aa.jpg)

14.D
- 树结构序列特性比较
  - 红黑树和二叉查找树
    - 中序序列有序
    - 根到叶路径不保证有序
  - 哈夫曼树
    - 基于权值构造
    - 与关键字次序无关
  - 堆
    - 小根堆:根到叶路径升序
    - 大根堆:根到叶路径降序
15.A
- 堆的插入操作
  - 插入关键字3的变化过程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aab4d7b8744ed7ff4aff7922991879f0ed31d57dbca9e7a05f8af20ad0e802d.jpg)

16.B
- 堆的调整过程
  - 比较过程
    - 18与10比较并交换
    - 18与25比较不交换
  - 总计比较2次

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d2994bb10da15e0a39af61ecf17f161f834550dc2f78acc7206ab1da944f48d1.jpg)

17.C
- 堆的删除操作
  - 删除过程
    - 删除8后12移至堆顶
    - 15和10比较
    - 10和12比较并交换
    - 12和16比较
  - 总计比较3次

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8cc075f07a664909645f82aebb0d5286d84fdb8ac9d37c86bbb8aa3aed6ab63f.jpg)

18.A
- 堆的建立方法
  - 从序列末尾向前遍历
  - 调整堆的变换过程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4f456f2485b9a3f8d8e9e2465b318bf14df528d977d88ecbd7c7f943a5880725.jpg)

19.C
- 堆的性质分析
  - 正确的性质
    - 堆是完全树，可用一维数组存储
    - 堆的定义是递归的
    - 次大值在左右孩子中
  - 错误的性质
    - 左右孩子值不要求有序

20.B
- 堆的建立过程
  - 建堆方法说明
    - 直接调整和依次插入结果不同
    - 序列6,9,1,5,8,4,7的建堆过程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d30fdad61c740e7b029d170ee5baa1d17ca5e297cfe31f053c0808b91328c16b.jpg)

# 二、综合应用题  

01.【解答】
- 堆与二叉排序树的区别
  - 堆的特点
    - 双亲结点关键字小于等于孩子结点关键字
    - 孩子结点关键字无次序规定
  - 二叉排序树的特点
    - 双亲结点关键字大于左子树关键字
    - 双亲结点关键字小于右子树关键字
  - 中序遍历结果
    - 二叉排序树得到有序序列
    - 堆不一定得到有序序列

02.【解答】
- 大根堆与二叉排序树的交集分析
  - 共同要求
    - 根结点关键字大于左子女关键字
  - 限制条件
    - 大根堆要求完全二叉树
    - 最终结果为两个结点的二叉树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/57a37593ae1db77ae3725de3e991c6748d5fe0b23ced68bf572f47cb03024344.jpg)

03.【解答】
- 排序算法比较分析
  - 不适合的算法
    - 插入排序
    - 快速排序
    - 归并排序
  - 适合的算法
    - 冒泡排序
    - 堆排序
    - 简单选择排序
  - 时间复杂度分析
    - 堆排序: $4n + k\log_2n$
    - 当 $k \geq 5$ 时堆排序最优

> attention:

求前 $k$ 个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序

04.【解析】
- 完全4叉树分析
  - 树的特点
    - 除最后一个分支结点外每个分支结点有4个孩子
  - 结点编号规则
    - 父结点编号: $k/4$
    - 第 $i$ 个孩子编号: $4 \times k + i, i = 1,2,3,4$
  - 操作时间复杂度
    - 插入操作: $O(\log_m n)$
    - 删除操作: $O(\log_m n)$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/585fc9ae0f04fc7396f5cda5301e8799dab4fb5907b8f483238fb81e070f0070.jpg)

05.【解答】
- 单链表选择排序算法
  - 算法思想
    - 每趟摘取最大关键字结点
    - 插入结果链表最前端
  - 代码实现

void selectSort(LinkedList& L) {
    LinkNode *h = L, *p, *q, *r, *s;
    L = NULL;
    while(h != NULL) {
        p = s = h;
        q = r = NULL;
        while(p != NULL) {
            if(p->data > s->data) {
                s = p;
                r = q;
            }
            q = p;
            p = p->link;
        }
        if(s == h)
            h = h->link;
        else
            r->link = s->link;
        s->link = L;
        L = s;
    }
}


06.【解答】
- 判断小根堆算法
  - 实现代码

bool IsMinHeap(ElemType A[], int len) {
    if(len % 2 == 0) {
        if(A[len/2] > A[len])
            return false;
        for(int i = len/2-1; i >= 1; i--)
            if(A[i] > A[2*i] || A[i] > A[2*i+1])
                return false;
    } else {
        for(int i = len/2; i >= 1; i--)
            if(A[i] > A[2*i] || A[i] > A[2*i+1])
                return false;
    }
    return true;
}


07.【解答】
- 查找最小10个数的算法
  - 方法1: 有序数组法
    - 定义10个元素数组A，初值为MAX
    - 扫描每个元素s
    - 若 $s < A[9]$ 则插入A并保持升序
  - 方法2: 大根堆法
    - 定义10个元素大根堆H，初值为MAX
    - 扫描每个元素s
    - 若s小于堆顶则替换并调整堆
  - 性能分析
    - 时间复杂度: $O(n)$
    - 空间复杂度: $O(1)$

# 8.5.5 答案与解析  

# 一、单项选择题  

01.【解答】
- 归并排序特点
  - 一趟排序后不能保证元素在最终位置
  - 示例序列 $\{6,5,7,8,2,1,4,3\}$ 一趟二路归并后
    - 结果为 $\{5,6,7,8,1,2,3,4\}$
    - 所有元素都未在最终位置

02.【解答】
- 基数排序特点
  - 基于关键字各位大小排序
  - 不基于关键字比较

03.【解答】
- 空间复杂度分析
  - 归并排序
    - 平均和最坏情况均为 $O(n)$
  - 快速排序  
    - 最坏情况 $O(n)$
    - 平均情况 $O(\log_{2}n)$
  - 归并排序辅助空间最多

04.【解答】
- 排序算法与初始状态关系
  - 选择排序比较次数与初始状态无关
  - 归并排序比较次数与初始状态无关

05.【解答】
- k路归并排序趟数计算
  - N个元素k路归并排序趟数m满足 $k^m = N$
  - 即 $m = \lceil\log_k N\rceil$
  - 本题中为 $\lceil\log_2 n\rceil$

06.【解答】
- k路归并排序k值计算
  - N个元素k路归并趟数m满足 $k^m = N$
  - 代入得 $k = 3$

07.【解答】
- 归并排序比较次数分析
  - 最少情况
    - 一个表最小元素大于另一表最大元素
    - 仅需N次比较
  - 最多情况  
    - 两表元素交替比较
    - 需2N-1次比较
  - 扩展思考
    - M、N长度表的比较次数和时间复杂度

08.【解答】
- 归并排序过程分析
  - 第一趟
    - 结果:{1,2}，{4,6}，{3,5}，{7,8}
    - 比较4次
  - 第二趟
    - 结果:{1,2,4,6}，{3,5,7,8}
    - 比较4次
  - 第三趟
    - 结果:{1,2,3,4,5,6,7,8}
    - 比较6次
  - 总计14次比较

09.【解答】
- 二路归并第二趟排序过程
  - 每4个元素一组
  - 分组:{25,50,15,35}，{80,85,20,40}，{36,70}
  - 排序后:{15,25,35,50}，{20,40,80,85}，{36,70}

10.【解答】
- 生日排序算法选择
  - N值很大
  - 排序码数为2
    - 月份基数12
    - 日期基数31
  - 基数排序时间复杂度 $O(N)$

11.【解答】
- 多关键字排序方法选择
  - 排序顺序要求先k2后k1
  - k1排序需要稳定性
  - 直接插入排序稳定
  - 简单选择排序不稳定

12.【解答】
- 基数排序特点
  - MSD和LSD两种方式
  - 排序稳定性
  - 选项分析
    - A不符合LSD和MSD
    - B符合MSD但破坏稳定性
    - D不符合LSD和MSD

13.【解答】
- 基数排序队列数
  - 等于进制数

14.【解答】
- 排序算法空间复杂度
  - 快速排序 $O(\log n)$
  - 归并排序 $O(n)$
  - 其他 $O(1)$

15.【解答】
- 升序链表合并分析
  - 比较过程
    - 两两比较确定链接位置
    - 较小元素头插法
  - 时间复杂度
    - 最坏情况元素依次比较
    - $O(\operatorname*{max}(m,n))$
  - 合并过程
    - 较小结点插入表头
    - 剩余结点依次插入

16.【解答】
- 基数排序过程
  - 第一趟按个位排序
  - 第二趟按十位排序
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db244ef47f0991b5f9d0832e962e39a8ba55bc7b6bbba6df51bc5d66373c7897.jpg)

17.【解答】
- 排序算法与初始状态关系
  - 基数排序元素移动次数与初态无关
  - 其他三种排序与初态有关

18.【解答】
- 基数排序LSD特点
  - 稳定排序算法
  - 第一趟结果分析
    - 按个位排序
    - 372相邻元素为301和892

19.【解答】
- 归并定义
  - 两个或以上有序表合并为新有序表
  - 二路归并是两个有序表合并
# 二、综合应用题  

01.【解答】
- 归并排序过程分析
  - 序列长度 n=10
  - 排序趟数 $\lceil\log_{2}10\rceil=4$
  - 各趟结果
    - 初始序列：503,87,512,61,908,170,897,275,653,462
    - 第一趟：87,503,61,512,170,908,275,897,462,653（长度为2）
    - 第二趟：61,87,503,512,170,275,897,908,462,653（长度为4）
    - 第三趟：61,87,170,275,503,512,897,908,462,653（长度为8）
    - 第四趟：61,87,170,275,462,503,512,653,897,908（长度为10）

02.【解答】
- 基数排序过程
  - 使用链式队列实现
  - 需要2次分配和收集完成排序
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db244ef47f0991b5f9d0832e962e39a8ba55bc7b6bbba6df51bc5d66373c7897.jpg)

03.【解答】
- cmpCountSort算法分析
  - 基本原理
    - 基于计数排序思想
    - count数组记录比当前元素小的元素个数
    - 确定元素最终位置
  - 排序结果
    - b[6] = {-10,10,11,19,25,25}
  - 时间复杂度分析
    - 两重循环比较
    - 总比较次数 $n(n-1)/2$
  - 稳定性改进
    - 修改if语句条件
    - if(a[i]<=a[j]) count[j]++
    - else count[i]++
    - 保证相等元素相对位置不变

# 8.6.4 答案与解析  

# 一、单项选择题  

01.A
- 排除法分析
  - 稳定排序要求
    - 排除B项和D项
  - 基数排序限制
    - 不能对float和double类型排序
    - 排除C项

02.C
- 排序算法特点
  - 堆排序和快速排序不稳定
  - 直接插入排序时间复杂度为 $O(n^2)$

03.C
- 排序算法性质
  - 参考表8.1
  - 时间复杂度
  - 空间复杂度
  - 稳定性

04.
- 算法分析
  - $\textcircled{\scriptsize{1}}$ I、IV、VI
  - $\textcircled{2}$ II、VI、VII
  - $\textcircled{3}$ 1、IV
- 性能特点
  - 堆排序和归并排序
    - 最坏情况时间复杂度 $O(n\log_2n)$
    - 最好情况时间复杂度 $O(n\log_2n)$

05.A
- 空间复杂度比较
  - 堆排序: $O(1)$
  - 快速排序
    - 最坏情况: $O(n)$
    - 平均情况: $O(\log_2n)$
  - 归并排序: $O(n)$

06.B
- 排序趟数分析
  - 冒泡排序: $1\sim n-1$趟(与初态相关)
  - 直接插入排序: 固定$n-1$趟
  - 简单选择排序: 固定$n-1$趟
  - 基数排序: 固定$d$趟

07.C
- 排序趟数比较
  - 固定趟数算法
    - 简单选择排序: $n-1$趟
    - 直接插入排序: $n-1$趟
  - 可变趟数算法
    - 冒泡排序: $1\sim n-1$趟
    - 快速排序: $\log_2n\sim n-1$趟

08.A
- 排序效率分析
  - 选择排序与初态无关(排除)
  - 插入排序
    - 基本有序时效率高
    - 仅需比较$n-1+4$次
  - 希尔排序和冒泡排序比较次数较多

09.C
- 堆的特点
  - 用于排序
  - 查找时无序
  - 查找效率低于其他结构

10.C
- 排序趟数特点
  - 固定趟数
    - 插入排序: $n-1$趟
    - 选择排序: $n-1$趟
  - 可变趟数
    - 冒泡排序: 无交换则提前结束
  - 基数排序: 由位数决定

11.A
- 排序算法比较次数分析
  - 确定比较次数的算法
    - 简单选择排序
    - 折半插入排序: 每趟比较次数为$O(\log_{2}m)$
    - 基数排序: 不基于比较
  - 不确定比较次数的算法
    - 与序列初始状态相关

12.A
- 排序算法并行执行分析
  - 可并行执行
    - 快速排序: 子序列互不影响
    - 堆排序: 左右子树互不影响
  - 不可并行执行
    - 基数排序: 依赖前一趟结果
    - 冒泡排序: 需连续处理未排序元素

13.B
- 排序算法特征分析
  - 冒泡和选择排序: 每趟确定最终位置
  - 二路归并: 每4个元素应有序
  - 给定序列不符合上述特征

14.A
- 排序过程分析
  - 符合冒泡排序特征: 从前往后比较,最大值沉底
  - 其他算法结果不符
    - 归并排序首趟: (2,12,16,88,5,10)
    - 基数排序首趟: (10,2,12,5,16,88)
    - 希尔排序不符合特征

15.A
- 排序算法最终位置确定性分析
  - 每趟确定最终位置的算法
    - 简单选择排序: 选择最小元素
    - 快速排序: 枢轴元素位置
    - 堆排序: 根节点交换
  - 不确定最终位置的算法
    - 希尔排序: 仅局部有序
    - 二路归并: 局部有序结果

16.B
- 归并排序与插入排序比较
  - 归并排序
    - 代码复杂度高
    - 空间复杂度$O(n)$
    - 时间复杂度$O(n\log n)$
  - 插入排序
    - 代码简单
    - 空间复杂度$O(1)$
    - 时间复杂度$O(n^2)$

17.D
- 存储方式对排序算法的影响
  - 不受影响的算法
    - 插入排序: 仍为$O(n^2)$
    - 选择排序: 仍为$O(n^2)$
    - 冒泡排序: 仍为$O(n^2)$
  - 受影响的算法
    - 希尔排序: 失去随机访问特性
    - 堆排序: 失去随机访问特性

18.D
- 排序算法选择考虑因素
  - 数据规模
    - 小规模: $O(n^2)$算法
    - 大规模: $O(n\log_2n)$算法
    - 超大规模: 外部排序
  - 存储方式限制
  - 稳定性要求
  - 初始序列特征

19.A
- 直接插入排序与简单选择排序比较
  - 比较次数
    - 有序数组: 插入排序$n-1$次
    - 选择排序: 固定$n(n-1)/2$次
  - 空间复杂度: 均为$O(1)$
  - 移动次数: 选择排序较少

20.D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/030693ca731850651b62ecd565fba55cab84dcd086c7fa264dc7742c6cc873a4.jpg)

21.C
- 排序算法稳定性分类
  - 稳定算法
    - 插入排序
    - 冒泡排序
    - 归并排序
    - 基数排序
  - 不稳定算法
    - 简单选择排序
    - 快速排序
    - 希尔排序
    - 堆排序
# 二、综合应用题  

01.【解答】
- 简单选择排序分析
  - 选择原因：直接插入排序交换次数更多
  - 排序过程
    - 初始序列：$3,7,6,9,7,1,4,5,20$
    - 第一次：$1,7,6,9,7,3,4,5,20$ (交换1,3)
    - 第二次：$1,3,6,9,7,7,4,5,20$ (交换3,7)
    - 第三次：$1,3,4,9,7,7,6,5,20$ (交换4,6)
    - 第四次：$1,3,4,5,7,7,6,9,20$ (交换5,9)
    - 第五次：$1,3,4,5,6,7,7,9,20$ (交换6,7)
  - 最小交换次数：5次

02.【解答】
- 算法设计思想
  - 将数组$A[1...m+n]$视为已排序$m$趟的表
  - 从$m+1$趟开始，将后$n$个元素依次插入前面有序表

- 算法实现

void InsertSort(ElemType A[], int m, int n) {
    int i,j;
    for(i = m+1; i <= m+n; i++) {
        A[0] = A[i];  //复制为哨兵
        for(j = i-1; A[j] > A[0]; j--)
            A[j+1] = A[j];  //元素后移
        A[j+1] = A[0];  //插入
    }
}


- 复杂度分析
  - 时间复杂度：$O(mn)$
    - 最坏情况下比较次数：$O(mn)$
    - 元素移动次数：$O(mn)$
  - 空间复杂度：$O(1)$
  - 归并排序方案
    - 时间复杂度：$O(m+n)$
    - 空间复杂度：$O(m+n)$

03.【解答】
- 基本思想
  - 以$K_n$为枢轴进行快速排序
  - 改为以最后元素为枢轴
  - 先从前往后，再从后往前扫描

- 算法实现

int Partition(ElemType K[], int n) {
    int i = 1, j = n;
    ElemType pivot = K[j];
    while(i < j) {
        while(i < j && K[i] <= pivot) i++;
        if(i < j) K[j] = K[i];
        while(i < j && K[j] >= pivot) j--;
        if(i < j) K[i] = K[j];
    }
    K[i] = pivot;
    return i;
}

# 8.7.7 答案与解析  

# 一、单项选择题  

- 外部排序和内部排序的区别
  - 主要区别在于是否涉及内存、外存的数据交换
  
02.C
  - 置换选择排序特点
    - 得到的归并段长度不一定相等
  - 外部排序特点
    - 主要时间消耗在内外存数据交换
    - 包括生成初始归并段和归并两个阶段
  - 败者树性质
    - 是一棵完全二叉树

03.A
  - 多路平衡归并的目的
    - 减少归并趟数
  - 归并趟数计算
    - $m$ 个初始归并段采用 $k$ 路平衡归并时
    - 所需趟数 $s=\lceil\log_{k}m\rceil$
    - 不采用多路平衡归并则趟数大于 $s$

04.B
  - 归并趟数计算示例
    - 初始归并段数 $r=375000/600=625$
    - 归并趟数 $S=\lceil\log_{5}625\rceil=4$
    - 各趟归并过程
      - 第一趟: 625→125
      - 第二趟: 125→25 
      - 第三趟: 25→5
      - 第四趟: 5→1

05.D
  - 外部排序中缓冲区的作用
    - 作为排序的内存工作区
    - $m$ 路平衡归并需要 $m$ 个输入缓冲区和1个输出缓冲区
    - 可用作内部排序工作区
    - 不负责传送用户界面消息

06.D、A
  - 相比普通 $m$ 路归并的改进
    - 输出缓冲区
      - 增加一个输出缓冲区
      - 实现内部归并和输出并行
    - 输入缓冲区
      - 增加 $m$ 个输入缓冲区
      - 实现输入和内部归并并行
    - 总计需要
      - 2个输出缓冲区
      - $2m$ 个输入缓冲区

07.C
  - 归并趟数计算
    - $\mu=\lceil\log_{k}n\rceil$
    - $k$ 为归并路数
    - $n$ 为元素个数
    - 当 $k=4$、$n=64$ 时趟数为3
    - 最小归并路数为4

08.A
  - 置换-选择排序特点
    - 用于生成初始归并段
    - 得到不等长的初始归并段
    - 平均长度是传统方法的2倍
    - 初始归并段数减少近一半
    - 不是完整的外部排序算法

09.D
  - 有序段数量 $m$ 的影响因素
    - 与待排文件有关
    - 与内存工作区大小 $w$ 有关
    - 与元素个数 $n$ 有关
    - 不存在简单的直接关系

10.D
  - 败者树选取最小关键字
    - 时间复杂度取决于树高
    - 复杂度为 $O(\log k)$
11.D
- 败者树性质分析
  - 胜利者调整
    - 会让胜利者一直调整到根结点
  - 比较过程
    - 先比较下一层两个元素(1次)
    - 找出较小值后与当前元素比较(1次)
  - 维护特点
    - 可能在中间层停止
    - 不一定要走到叶结点

12.B
- 最佳归并树作用
  - 优化m路归并排序方案
  - 构造方法
    - 以初始归并段长度为权值
    - 构造最小带权路径长度的m叉哈夫曼树
  - 优化效果
    - 减少归并过程读/写记录数
    - 加快外部排序速度

13.C
- k阶最佳归并树性质
  - 结点度数
    - 只有度为0和k的结点
  - 结点关系
    - 结点总数为n
    - 度为0结点数为$n_0=m$
    - 度为k结点数为$n_k$
    - $n-1=k×n_k$
    - $n=n_0+n_k$
  - 计算结果
    - $n_k=(m-1)/(k-1)$

14.B
- 三叉哈夫曼树构造
  - 条件分析
    - 需满足$(n_0-1)%(3-1)=0$
    - 需添加1个权值为0的虚叶结点
  - 构造过程
    - 第一步:合并0,2,3得到5
    - 第二步:合并4,5,5得到14
    - 第三步:合并6,7,14得到27
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/761fec12638927f96a7953aca068bb2474057195863cc8533c11f12119ec300e.jpg)
  - WPL计算
    - 方法一:$WPL=(2+3)×3+(4+5)×2+(6+7)×1=46$
    - 方法二:$WPL=27+14+5=46$

15.D
- 外部排序特点
  - 适用于大文件排序
  - 记录存储在外存
  - 无法一次性装入内存
  - 需多次数据交换
  - 通常采用归并排序
  - A、B、C为内部排序方法

16.B
- 12路归并树分析
  - 结点度数特点
    - 只有度为0和12的结点
  - 参数定义
    - $n_0$为度为0结点数
    - $n_{12}$为度为12结点数
    - $n_{\psi}$为补充结点数
  - 关系式
    - $n_0=120+n_{\psi}$
    - $n_0=(12-1)n_{12}+1$
  - 计算结果
    - $n_{12}=(120-1+n_{\psi})/(12-1)$
    - $n_{\psi}=2$为使式子整除的最小整数
# 二、综合应用题  

01.【解答】
- 归并路数分析
  - 初始条件
    - 归并路数为$m$
    - 初始归并段个数$r=80$
  - 归并趟数计算
    - 根据公式$S=\lceil\log_{m}r\rceil=\lceil\log_{m}80\rceil=3$
    - 得$\log_{m}80\leqslant3$
    - $m^3\geqslant80$
    - 解得$m\gtrsim5$
  - 结论:归并路数至少为5
- 缓冲区分析
  - 条件
    - 需要$m$个输入缓冲区和1个输出缓冲区
    - $m+1=15$
  - 结论
    - $m=14$,可做14路归并
    - 趟数$S=\lceil\log_{14}80\rceil=2$
    - 2趟限制下最低路数为9

02.【解答】
- 初始归并段分析
  - 条件
    - 文件4500个记录
    - 内存可容纳450个记录
  - 计算
    - 初始归并段数:4500/450=10个
    - 每段记录数:450个
    - 每段块数:450/75=6个
- 归并过程分析
  - 缓冲区设置
    - 内存可容纳6个块
    - 5个输入缓冲区
    - 1个输出缓冲区
  - 采用5路归并
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ea0271abdff5d80c703229c32e11a07fbd61b3f1692b4b5daf3ee4cb0748da5.jpg)
  - 结果
    - 共2趟归并
    - 每趟读写60块

03.【解答】
- 6路归并排序败者树构造
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/70cf272dc093f3cdbd0fbe2f862cf089af6f92b42e39d25ae1acc8420688e1be.jpg)

04.【解答】
- 4路归并分析
  - 初始条件
    - 初始归并段数$n=12$
    - 归并路数$k=4$
  - 计算
    - $(n-1)%(k-1)=11\%3=2\neq0$
    - 需添加$k-2-1=1$个空归并段
  - 归并树构造
    - 内结点数$(n-1+1)/(k-1)=12/3=4$
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4ad5518f64fb36d9ebbd5e3f05f8de61e8848933add9bbd3138da133fa311627.jpg)
  - WPL计算
    - $\mathrm{WPL}=(3+6+8)\times3+(9+18+20+30+44+60+62)\times2+(68+85)\times1=51+486+153=690$

05.【解答】
- 归并段长度分析
  - 最大长度情况
    - 文件$n$个记录升序排列
    - 生成一个长度为$n$的归并段
  - 最小长度情况
    - 工作区$m$个元素大于剩余记录
    - 第一个归并段长度为$m$
- 排序过程示例
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f0ab4e2407d1c4cd015077c8ec0ce880d41962100a754c5b17f10d7a0cbb996.jpg)
  - 生成三个初始归并段
    - 37,51,63,92,94,99
    - 14,15,23,31,48,56,60,90,166
    - 8,17,43,100
  - 结论:最大值为$n$,最小值为$m$