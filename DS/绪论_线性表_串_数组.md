# 1.1.4 答案与解析  

# 一、单项选择题  

01.D
- 抽象数据类型(ADT)
  - 描述数据的逻辑结构和抽象运算
  - 表示方式
    - 使用三元组(数据对象,数据关系,基本操作集)
    - 构成完整的数据结构定义

02.A
- 数据结构分类
  - 非线性数据结构
    - 树
    - 图
  - 线性数据结构
    - 其他选项均属于此类

03.C
- 数据结构比较
  - 完整数据结构
    - 顺序表
    - 哈希表 
    - 单链表
    - 描述内容
      - 逻辑结构
      - 存储结构
      - 数据运算
  - 逻辑结构
    - 有序表
      - 关键字有序的线性表
      - 仅描述元素间逻辑关系
      - 支持多种存储方式
        - 链式存储
        - 顺序存储

04.A
- 数据结构要素
  - 逻辑结构特点
    - 面向实际问题
    - 采用抽象表达
    - 独立于存储结构
    - 存储方式可多选
  - 存储结构特点
    - 是逻辑结构在计算机上的映射
    - 不能独立于逻辑结构
  - 三要素缺一不可

05.C
- 数据存储要求
  - 需存储数据元素的值
  - 需存储数据元素间的关系
# 二、综合应用题  

01.【解答】  

应该注意到，数据的运算也是数据结构的一个重要方面，  

- 对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同
  - 二叉树和二叉排序树 
    1. 结构特点
    - 两者在物理结构和逻辑结构上完全相同
    - 二叉排序树直接使用二叉树的表示方式和存储结构

    2. 应用目的
    - 二叉树：主要用于表示层次关系
    - 二叉排序树：专门用于排序和查找

    3. 基本操作
    两者都支持以下基本操作:
    - 建立树结构
    - 插入新节点
    - 删除已有节点  
    - 查找特定节点

    4. 性能区别
    以查找操作为例:
    - 二叉树:需要遍历整棵树,平均时间复杂度为O(n)
    - 二叉排序树:利用节点的有序性,平均时间复杂度为O(log₂n)

02.【解答】  

- 线性表
  - 在顺序存储方式下，插入和删除元素
    - 平均要移动近一半的元素，时间复杂度为 $O(n)$ ；
  - 在链式存储方式下
    - 插入和删除的时间复杂度都是 $O(1)$  



# 1.2.4 答案与解析  

# 一、单项选择题  

01.B  

- 算法定义相关
  - 程序不一定满足有穷性(如死循环、操作系统等)
  - 算法必须有穷
  - 算法代表对问题求解步骤的描述
  - 程序是算法在计算机上的特定实现
  - 选项C只是算法的必要条件，不能成为算法的定义

02.C  

- 时间复杂度分析
  - 时间复杂度为 $O(n^2)$ 表示算法的时间复杂度 $T(n)$ 满足 $T(n) \leq cn^2$ (c为比例常数)
  - 时间复杂度 $T(n)$ 是问题规模 $n$ 的函数
  - 问题规模仍然是 $n$ 而不是 $n^2$

03.B  

- 空间复杂度说明
  - 空间复杂度为 $O(1)$ 表示执行算法所需辅助空间大小相对输入数据规模是常量
  - 不表示算法执行时不需要任何空间或辅助空间

04.D  

- 不同算法的时间复杂度分析
  - A: 最高阶是 $n\log_2n$，时间复杂度是 $O(n\log_2n)$
  - B: 最高阶是 $n^2$，时间复杂度是 $O(n^2)$
  - C: 最高阶是 $n\log_2n$，时间复杂度是 $O(n\log_2n)$
  - D: 最高阶是 $\log_2n$，时间复杂度是 $O(\log_2n)$

05.D  

- 算法分析
  - 基本运算: $i = i \times 2$
  - 执行条件: $2^t \leq n$，即 $t \leq \log_2n$
  - 时间复杂度: $T(n) = O(\log_2n)$

06.C  

- 基本运算分析
  - 基本运算为 $i++$
  - 执行次数 $t$ 满足: $t^3 \leq n$
  - 因此 $t \leq \sqrt[3]{n}$
  - 时间复杂度: $T(n) = O(\sqrt[3]{n})$

07.D  

- 冒泡排序分析
  - 最坏情况下的元素交换次数
  - 当所有相邻元素都为逆序时
  - 时间复杂度计算:
    $T(n) = \sum_{i=2}^{n-1}\sum_{j=1}^{i-1}1 = \sum_{i=2}^{n-1}(i-1) = (n-2)(n-1)/2 = O(n^2)$

08.A  

- 条件判断语句的时间复杂度
  - 取分支路径上的最大时间复杂度

09.A  

- 执行次数分析
  - m++语句的执行次数:
    $\sum_{i=1}^{n}\sum_{j=1}^{2i}1 = \sum_{i=1}^{n}2i = 2\sum_{i=1}^{n}i = n(n+1)$

10.C  

- 递归调用分析
  - 基本语句: if(==1) return 1
  - 递归次数 $t$ 满足: $2^t \leq n$，即 $t \leq \log_2n$
  - 总执行次数: $T = \log_2n \times 1$
  - 时间复杂度: $O(\log_2n)$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/aa8dedd06a9f028de2264878353fdb08edfddc818067525979b9fba87b412c3f.jpg)

11.A

- 时间复杂度分析
  - 基本运算为 $x = 2x$
  - 每执行一次，x乘以2
  - 设执行次数为t，则有 $2^{t+1} < n/2$
  - 所以 $t < \log_2(n/2)-1 = \log_2n-2$
  - 得出时间复杂度 $T(n) = O(\log_2n)$

12.B

- 递归调用分析
  - 递归调用可视为多重循环
  - 基本语句: if(n <= 1) return 1
  - 执行n次递归调用
  - 总执行次数 $T = 1 + 1 + \cdots + 1 = n$
  - 时间复杂度为 $O(n)$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3ab9ce82545c510a967e2aa7380a6cff1ac13187c9ce99d37eb227b11041d1ad.jpg)

13.C

- 多层循环分析
  - 单层循环转换
    - for(j=1; j<=n; j++) sum++
    - 执行次数为n
  - 循环变量幂次分析
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a400bc01830453167d54fa241d4b38f2db460ad45444a287364591b203b67ae3.jpg)
  - 外层循环条件 $k \leq n$
  - 循环结束时 $2^t \leq n < 2^{t+1}$，即 $t \leq \log_2n$
  - 总执行次数 $T = n(t+1) = n(\log_2n+1)$
  - 时间复杂度为 $O(n\log_2n)$

14.B

- 基本运算分析
  - 基本运算为 sum += ++i
  - 等价于 ++i; sum = sum+i
  - 执行过程分析:
    - i=1时，sum = 0+1
    - i=2时，sum = 0+1+2
    - i=3时，sum = 0+1+2+3
  - 得出 sum = (1+i)×i/2
  - 循环次数t满足 $(1+t)×t/2 < n$
  - 时间复杂度为 $O(n^{1/2})$

> attention 统考真题中常将 $\log_2$ 书写为log，此时默认底数为2。

15.B

- 循环终止条件分析
  - 第k次循环终止时 $(x+1)^2 > n$
  - x的初始值为0
  - 第k次判断时 x = k-1
  - 即 $k^2 > n$，$k > \sqrt{n}$
  - 时间复杂度为 $O(\sqrt{n})$

16.B

- 多层循环分析
  - 单层循环示例
    - for(i=0; i<=i; i++) sum++;
    - 执行次数为i
  - 循环变量幂次分析
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ee2c2b9c81f65e302f00979b05a9498bd4beda72833e193092a1a2853947da0.jpg)
  - 外层循环条件 i<n
  - 循环变量幂次t满足 $2^t < n \leq 2^{t+1}$
  - 总执行次数 $T = 1 + 2^1 + 2^2 + \dots + 2^t = 2^{t+1}-1$
  - 即 $n-1 \leq T < 2n-1$
  - 时间复杂度为 $O(n)$
# 二、综合应用题  

01.【解答】

- 时间复杂度分析
  - 第一种情况
    - 基本语句 $k = k + 10 \times i$ 执行 $n-2$ 次
    - 时间复杂度 $T(n) = O(n)$
  
  - 第二种情况
    - 设循环体执行 $t$ 次
    - 每次循环变量 $y$ 增加1
    - 最终 $t = y$
    - 满足 $t^2 \leq n$
    - 时间复杂度 $T(n) = O(\sqrt{n})$
  
  - 第三种情况
    - 内循环执行 $m$ 次
    - 外循环执行 $n$ 次 
    - 根据乘法原理总执行次数为 $m \times n$
    - 时间复杂度 $T(m,n) = O(mn)$


# 2.1.4 答案与解析  

# 单项选择题  

01.C
- 线性表的组成
  - 由具有相同数据类型的有限数据元素组成
  - 数据元素是由数据项组成的

02.B
- 线性表定义的要求
  - 相同数据类型
  - 有限序列
- 选项分析
  - 选项C：元素个数无穷个，错误
  - 选项A：集合中元素无前后驱关系，错误
  - 选项D：属于存储结构而非具体线性表，错误
  - 选项B：符合线性表定义要求

03.A
- 线性表元素的关系
  - 除最后一个元素外，每个元素只有一个后继
  - 除第一个元素外，每个元素只有一个前驱

04.A
- 线性表特殊元素的特点
  - 第一个元素：无直接前驱
  - 最后一个元素：无直接后继
  - 仅有一个元素时：既无直接前驱，又无直接后继



# 2.2.4 答案与解析  

# 一、单项选择题  

01.A
- 顺序表的优点
  - 存储密度较大，不需存放指针域
  - 选项B和C是链表的优点
  - 选项D错误，树形结构更适合链表表示

02.C
- 顺序表的特点
  - 必须连续存放相同类型元素
  - 与一维数组的区别
    - 数组元素可不连续存放
    - 数组可表示其他逻辑结构(栈、队列、树等)
  - 逻辑相邻元素物理位置也相邻

03.A
- 存取方式特点
  - 支持随机存取
  - 可根据起始地址加元素序号访问任意元素

04.C
- 随机存取特性
  - 访问第 $i$ 个元素时间为 $O(1)$
  - 访问时间与元素个数 $n$ 无关

05.B
- 存储空间影响因素
  - 表长
  - 元素类型大小
  - 结构体各字段类型(若元素为结构体)

06.D
- 快速存取相邻元素分析
  - 顺序表：$O(1)$ 时间复杂度
  - 其他选项：$O(n)$ 时间复杂度，需从头结点查找

07.A
- 顺序表操作特点
  - 支持随机存取
  - 末尾插入删除无需移动元素

08.C
- 操作时间复杂度分析
  - 末尾插入：$O(1)$
  - 删除操作：$O(n)$，需移动后续元素
  - 插入操作：$O(n)$，需移动 $n-i$ 个结点

09.C
- 操作效率比较
  - 交换操作：顺序表3次，链表需多次操作
  - 顺序访问：两者时间复杂度相同

10.C
- 删除元素移动分析
  - 需移动元素个数：$n-i$ 个
  - 涉及元素：$a_{i+1}$ 到 $a_n$

11.C
- 插入操作分析
  - 移动元素个数：$n-i+1$
  - 时间复杂度：$O(n)$

12.C
- 操作时间复杂度
  - 排序：最小 $O(n)$，通常 $O(n\log_2n)$ 或 $O(n^2)$
  - 支持随机存取

13.B
- 序号特点
  - 线性表序号从1开始
  - 第 $n+1$ 位置插入等同表尾追加

14.D
- 存储空间扩展
  - 需申请 $n+m$ 个连续空间
  - 复制原有 $n$ 个元素到新空间

15.D
- 有序表操作复杂度
  - 查找：$O(\log n)$（折半查找）
  - 插入：$O(n)$
  - 删除：$O(n)$
  - 按位置访问：$O(1)$
# 二、综合应用题  

01.【解答】
- 删除最小值元素
  - 算法思想
    - 搜索整个顺序表找最小值元素位置
    - 用最后一个元素填补空出位置
  - 代码实现

bool Del Min(SqList &L,ElemType &value) {
    if(L.length == 0) return false;
    value = L.data[0];
    int pos = 0;
    for(int i=1; i<L.length; i++) {
        if(L.data[i]<value){
            value = L.data[i];
            pos = i;
        }
    }
    L.data[pos] = L.data[L.length-1];
    L.length--;
    return true;
}


> attention 本题也可用函数返回值返回，两者的区别是：函数返回值只能返回一个值，而参数返回（引用传参）可以返回多个值。

02.【解答】
- 逆置顺序表
  - 算法思想
    - 扫描前半部分元素
    - 将L.data[i]与L.data[L.length-i-1]交换
  - 代码实现

void Reverse(SqList &L){
    ElemType temp;
    for(int i=0; i<L.length/2; i++) {
        temp = L.data[i];
        L.data[i] = L.data[L.length-i-1];
        L.data[L.length-i-1] = temp;
    }
}


03.【解答】
- 删除值为x的元素
  - 解法1
    - 用k记录不等于x的元素个数
    - 扫描时将不等于x的元素前移
  - 代码实现1

void delx1(SqList &L,ElemType x){
    int k = 0;
    for(int i=0; i<L.length; i++) {
        if(L.data[i] != x) {
            L.data[k] = L.data[i];
            k++;
        }
    }
    L.length = k;
}

  - 解法2  
    - 用k记录等于x的元素个数
    - 扫描时将不等于x的元素前移k位
  - 代码实现2

void delx2(SqList &L,ElemType x){
    int k = 0;
    int i = 0;
    while(i < L.length) {
        if(L.data[i] == x)
            k++;
        else
            L.data[i-k] = L.data[i];
        i++;
    }
    L.length = L.length-k;
}


04.【解答】
- 删除s到t之间的元素
  - 算法思想
    - 用k记录s到t之间元素个数
    - 不在区间内的元素前移k位
  - 代码实现

bool Del_s_t(SqList &L,ElemType s,ElemType t){
    int i, k=0;
    if(L.length==0 || s>=t)
        return false;
    for(i=0; i<L.length; i++) {
        if(L.data[i]>=s && L.data[i]<=t)
            k++;
        else
            L.data[i-k] = L.data[i];
    }
    L.length -= k;
    return true;
}


05.【解答】
- 删除有序表中重复元素
  - 算法思想
    - 将第一个元素视为非重复有序表
    - 依次判断后续元素是否与前面最后一个元素相同
  - 代码实现

bool Delete_Same(SeqList& L){
    if(L.length == 0) return false;
    int i, j;
    for(i=0,j=1; j<L.length; j++) {
        if(L.data[i] != L.data[j])
            L.data[++i] = L.data[j];
    }
    L.length = i+1;
    return true;
}


06.【解答】
- 合并两个有序表
  - 算法思想
    - 比较两表表头取较小者
    - 剩余部分直接加入新表
  - 代码实现

bool Merge(SeqList A,SeqList B,SeqList &C){
    if(A.length+B.length>C.maxSize)
        return false;
    int i=0, j=0, k=0;
    while(i<A.length && j<B.length) {
        if(A.data[i] <= B.data[j])
            C.data[k++] = A.data[i++];
        else
            C.data[k++] = B.data[j++];
    }
    while(i<A.length)
        C.data[k++] = A.data[i++];
    while(j<B.length)
        C.data[k++] = B.data[j++];
    C.length = k;
    return true;
}


07.【解答】
- 算法思想
  - 将数组A[m+n]中全部元素原地逆置
  - 对前n个元素和后m个元素分别使用逆置算法
  - 实现顺序表的位置互换

typedef int DataType;
void Reverse(DataType A[], int left, int right, int arraySize) {
    if(left >= right || right >= arraysize) return;
    int mid = (left+right)/2;
    for(int i=0; i <= mid-left; i++) {
        DataType temp = A[left+i];
        A[left+i] = A[right-i];
        A[right-i] = temp;
    }
}

void Exchange(DataType A[], int m, int n, int arraySize) {
    Reverse(A,0,m+n-1,arraySize);
    Reverse(A,0,n-1,arraySize);
    Reverse(A,n,m+n-1,arraysize);
}

08.【解答】
- 算法思想
  - 顺序存储的线性表递增有序
  - 可以顺序查找或折半查找
  - 要求最少时间查找，应使用折半查找法

void SearchExchangeInsert(ElemType A[], ElemType x) {
    int low=0, high=n-1, mid;
    while(low <= high) {
        mid = (low+high)/2;
        if(A[mid] == x) break;
        else if(A[mid] < x) low = mid+1;
        else high = mid-1;
    }
    if(A[mid] == x && mid != n-1) {
        ElemType t = A[mid];
        A[mid] = A[mid+1];
        A[mid+1] = t;
    }
    if(low > high) {
        for(int i=n-1; i>high; i--)
            A[i+1] = A[i];
        A[high+1] = x;
    }
}

09.【解析】
- 算法基本设计思想
  - 使用三个下标变量从小到大遍历数组
  - 当三个下标变量指向元素相等时，输出并向前推进指针
  - 否则仅移动小于最大元素的下标变量
  - 直到某个下标变量移出数组范围停止

void samekey(int A[], int B[], int C[], int n) {
    int i=0, j=0, k=0;
    while(i<n && j<n && k<n) {
        if(A[i] == B[j] && B[j] == C[k]) {
            printf("%d\n", A[i]);
            i++; j++; k++;
        } else {
            int maxNum = max(A[i], max(B[j], C[k]));
            if(A[i] < maxNum) i++;
            if(B[j] < maxNum) j++;
            if(C[k] < maxNum) k++;
        }
    }
}

10.【解答】
- 算法基本设计思想
  - 将问题视为把数组ab转换成数组ba
  - 先将a逆置得到$a^{-1}b$
  - 再将b逆置得到$a^{-1}b^{-1}$
  - 最后将整个$a^{-1}b^{-1}$逆置得到$(a^{-1}b^{-1})^{-1}=ba$

void Reverse(int R[], int from, int to) {
    int i, temp;
    for(i=0; i<(to-from+1)/2; i++) {
        temp = R[from+i];
        R[from+i] = R[to-i];
        R[to-i] = temp;
    }
}

void Converse(int R[], int n, int p) {
    Reverse(R,0,p-1);
    Reverse(R,p,n-1);
    Reverse(R,0,n-1);
}

11.【解答】
- 算法基本设计思想
  - 分别求两个升序序列A、B的中位数a和b
  - 若$a=b$，则a或b即为所求中位数
  - 若$a<b$，舍弃A中较小一半和B中较大一半
  - 若$a>b$，舍弃A中较大一半和B中较小一半
  - 重复上述过程直到两序列各只含一个元素

int MSearch(int A[], int B[], int n) {
    int s1=0, d1=n-1, m1, s2=0, d2=n-1, m2;
    while(s1!=d1 || s2!=d2) {
        m1 = (s1+d1)/2;
        m2 = (s2+d2)/2;
        if(A[m1] == B[m2]) return A[m1];
        if(A[m1] < B[m2]) {
            if((s1+d1)%2 == 0) {
                s1 = m1;
                d2 = m2;
            } else {
                s1 = m1+1;
                d2 = m2;
            }
        } else {
            if((s1+d1)%2 == 0) {
                d1 = m1;
                s2 = m2;
            } else {
                d1 = m1;
                s2 = m2+1;
            }
        }
    }
    return A[s1]<B[s2] ? A[s1] : B[s2];
}

12.【解答】
- 算法基本设计思想
  - 选取候选主元素
    - 扫描数组记录第一个整数及其出现次数
    - 遇到相同数计数加1，不同数计数减1
    - 计数为0时重新选取候选元素
  - 判断候选元素是否为主元素
    - 再次扫描统计出现次数
    - 若大于n/2则为主元素
    - 否则不存在主元素

int Majority(int A[], int n) {
    int i, c, count=1;
    c = A[0];
    for(i=1; i<n; i++) {
        if(A[i] == c)
            count++;
        else if(count > 0)
            count--;
        else {
            c = A[i];
            count = 1;
        }
    }
    if(count > 0) {
        for(i=count=0; i<n; i++)
            if(A[i] == c)
                count++;
        if(count > n/2)
            return c;
    }
    return -1;
}

13.【解答】
- 算法基本设计思想
  - 采用空间换时间策略
  - 分配标记数组B[n]记录1~n是否出现
  - 遍历A标记出现的正整数
  - 扫描B找到第一个未标记位置
  - 返回结果为未标记位置+1

int findMissMin(int A[], int n) {
    int i, *B;
    B = (int *)malloc(sizeof(int)*n);
    memset(B,0,sizeof(int)*n);
    for(i=0; i<n; i++)
        if(A[i]>0 && A[i]<=n)
            B[A[i]-1] = 1;
    for(i=0; i<n; i++)
        if(B[i] == 0)
            break;
    return i+1;
}

14.【解答】
- 分析
  - 当$a=b=c$时距离最小
  - 其他情况下关键是a和c之间的距离
  - 问题简化为固定c找合适的a使$|c-a|$最小

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d6964726b38ffa443e58331e9e888368e3ccb0103edcae2ddb0866240cdc33b.jpg)

- 算法基本设计思想
  - 使用$D_{min}$记录最小距离
  - 三个集合分别存在数组A、B、C中
  - 循环比较并更新最小距离
  - 移动最小值的下标寻找更小距离

#define INT_MAX 0x7fffffff
int abs_(int a) {
    if(a < 0) return -a;
    else return a;
}

bool xls_min(int a, int b, int c) {
    if(a < b && a < c) return true;
    return false;
}

int findMinOfTrip(int A[], int n, int B[], int m, int C[], int p) {
    int i=0, j=0, k=0, Dmin=INT_MAX, D;
    while(i<n && j<m && k<p && Dmin>0) {
        D = abs_(A[i]-B[j]) + abs_(B[j]-C[k]) + abs_(C[k]-A[i]);
        if(D < Dmin) Dmin = D;
        if(xls_min(A[i],B[j],C[k])) i++;
        else if(xls_min(B[j],C[k],A[i])) j++;
        else k++;
    }
    return Dmin;
}


# 2.3.8 答案与解析  

# 一、单项选择题  

01.B
- 存储结构比较
  - 不能简单比较优劣
  - 链式存储优点
    - 用指针表示逻辑结构更灵活
    - 插入删除效率高
  - 顺序存储特点
    - 支持随机存取和顺序存取
    - 链式结构只能顺序存取

02.B
- 存储结构选择
  - 散列存储不适合表示逻辑关系
  - 链式存储优势
    - 方便表示各种逻辑关系
    - 插入删除时间复杂度为 $O(1)$

03.A
- 链式存储特点
  - 结点间存储空间可不连续
  - 结点内存储单元必须连续

04.D
- 存储结构特性分析
  - 顺序存储适用于图和树
  - 删除表尾结点需遍历找前驱
  - 循环单链表特点
    - 最后结点指向头结点
    - 不存在空指针
  - 有序单链表查找插入位置时间复杂度为 $O(n)$
  - 队列操作效率
    - 带尾指针循环链表适合队列操作
    - 插入删除时间复杂度为 $O(1)$

05.A
- 不同操作效率比较
  - 单链表和顺序表时间复杂度均为 $O(n)$
  - 单链表无需移动元素效率更高

06.C
- 链表插入操作
  - s插入后g为前驱
  - p为后继

> attention:  

可能有读者认为选项C中的两条语句交换后才正确。实际上，因为本题插入位置的前后结点都有指针指示（这与前面介绍的插入操作是不同的），所以选项C中的语句顺序并不会造成断链。在此提醒读者在学习过程中一定要多动脑思考，而不要生搬硬套。

07.D
- 有序链表建立方法比较
  - 边建立边插入排序
    - 每次插入需遍历寻找位置
    - 时间复杂度 $O(n^2)$
  - 先排序后建立链表
    - 排序时间复杂度 $O(n\log_2n)$
    - 建表时间复杂度 $O(n)$
    - 总时间复杂度 $O(n\log_2n)$

08.C
- 链表连接操作
  - 遍历长度为 $m$ 的链表找尾结点
  - 将尾结点next指向另一链表首结点
  - 时间复杂度 $O(m)$

09.C
- 头结点设置目的
  - 统一插入删除算法
    - 无需特判第一个元素
  - 统一空表非空表处理
    - 头指针始终非空
    - 指向头结点位置固定

10.B
- 删除最后结点分析
  - 需要遍历找前驱结点
  - 时间复杂度 $O(n)$
  - 与表长相关

11.B，A
- 带头结点单链表判空条件
  - 头指针head指向头结点
  - 头结点next域指向第一个元素结点
  - head->next == NULL表示空表

- 不带头结点单链表判空条件
  - head直接指向第一个元素结点
  - head == NULL表示空表

12.D
- 线性表存储结构比较
  - 链式存储：删除 $a_{50}$ 不需移动元素
  - 顺序存储：需移动50个元素

13.B
- 头插法建立单链表特点
  - 数组后面元素插入链表最前端
  - 链表元素次序与数组相反

14.C
- 双链表优点分析
  - 可方便访问前驱和后继
  - 删除和插入数据方便

15.D
- 双链表插入操作步骤
  - p前一结点next域指向q
  - q的next域指向p
  - q的prior域指向p的前一结点
  - p的prior域指向q

16.A
- 双链表删除操作要点
  - 将p的前后两结点链接
  - 保证修改过程不断链

17.A
- 双链表指针修改顺序
  - 先执行q->next指向结点C
  - 再执行p->next和p->next->prior的修改

18.C
- 双链表插入结点修改指针域
  - 新结点前驱指向第一个结点
  - 新结点后继指向第二个结点
  - 第一个结点后继指向新结点
  - 第二个结点前驱指向新结点

19.B
- 有序单链表插入操作
  - 查找第一个大于x的结点前驱p
  - 在p之后插入结点
  - 查找时间复杂度 $O(n)$
  - 插入时间复杂度 $O(1)$
  - 总时间复杂度 $O(n)$

20.D
- 单链表与双链表比较
  - 插入删除都不需移动元素
  - 双链表修改指针操作更复杂
  - 双链表可快速访问前驱后继结点
21.C
- 带头结点循环单链表空表判断
  - 满足L->next = L
  - 头结点指针域与L值相等
  - 不存在空指针

22.D
- 循环双链表判空条件
  - 头结点prior和next域指向自身

23.A
- 链表末尾操作效率分析
  - 带头结点双循环链表寻找尾结点时间最少

24.C
- 链表操作时间复杂度分析
  - 删除尾结点需找前驱，时间复杂度O(n)
  - 删除首结点通过尾结点prior找到，时间复杂度O(n)
  - C选项四种算法时间复杂度均为O(1)

25.B
- 循环单链表合并要求
  - O(1)时间头尾相接
  - 两个指针需指向尾结点

26.A
- 循环单链表删除首元结点分析
  - 带头结点：删除时间O(1)
  - 不带头结点
    - 有表尾指针：时间O(1)
    - 只有表头指针：时间O(n)

27.D
- 循环单链表特性
  - 空表：head->next = head
  - 一个元素：head->next->next = head

28.D
- 双链表删除操作时间复杂度
  - 删除首结点：O(1)
  - 非循环双链表删除尾结点：O(n)
  - 循环双链表删除尾结点：O(1)

29.D
- 链表操作时间复杂度分析
  - 单循环链表
    - 尾部插入：O(n)
    - 删除首元素：O(n)
  - 双链表
    - 一种操作O(n)
    - 另一种操作O(1)
  - 有尾指针时均为O(1)

30.B
- 静态链表特点
  - 预先分配连续空间
  - 插入删除不需移动元素

31.B
- 静态链表性质
  - 存储空间顺序分配
  - 元素存储非顺序
  - 查找需按链依次进行
  - 插入删除不需移动元素
  - 存储空间一次性申请
  - 可能造成空间浪费

32.D
- 链表操作正确性分析
  - A错误：p前驱结点后继指向自身
  - B、C错误：p后继结点前驱指向自身
  - D正确

33.D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b55a688d62e061aac2783fc9eb75defada7af6550a63e9c7b42b9d53b37c3156.jpg)
- 单链表结构分析
  - a指向f：1014H
  - e指向b：1004H
  - f指向e：1010H

34.D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40ecdba2635a5405a27a716a55ab619dbad757661cefd9ea9abd3703ec340d62.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb89761bdf04ec2379266087a002c11425642f0f57076c13332cc656353865a7.jpg)
- 循环单链表删除首元素步骤
  - 临时指针q指向待删结点
  - 断开链接：h->next = q->next
  - 特殊情况处理：
    - 只有一个元素时
    - 删除后尾指针指向头结点

35.C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16abd2a2bd12a95c373225b152f3441b03f18d02706ed28c57dc271185f3bdb2.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e0e53bff60da6a9d34e202f5bf9321d9e9f0a18db590b023d5ecaeaa3d68a085.jpg)
- 链表插入操作分析
  - A错误：s->next->prev = p
  - B错误：p->next->prev = s
  - D错误：两句代码均错
  - C正确：满足插入要求
# 二、综合应用题  

01.【解答】

- 解法1：删除值为x的结点
  - 算法思路
    - 用p从头至尾扫描单链表
    - pre指向 $p$ 结点的前驱
    - 若p所指结点值为x则删除
    - 否则pre、p指针同步后移
  - 代码实现

void Del_X1(Linklist &L, ElemType x) {
    LNode *p = L->next, *pre = L, *q;
    while(p != NULL) {
        if(p->data == x) {
            q = p;
            p = p->next;
            pre->next = p;
            free(q);
        } else {
            pre = p;
            p = p->next;
        }
    }
}

  - 算法特点
    - 可用于删除满足任意条件的结点
    - 只需修改if条件即可

- 解法2：尾插法建立新链表
  - 算法思路
    - p指针扫描L的所有结点
    - 值不为x时链接到L之后
    - 值为x时释放结点
  - 代码实现

void Del_X2(Linklist &L, ElemType x) {
    LNode *p = L->next, *r = L, *q;
    while(p != NULL) {
        if(p->data != x) {
            r->next = p;
            r = p;
            p = p->next;
        } else {
            q = p;
            p = p->next;
            free(q);
        }
    }
    r->next = NULL;
}

  - 算法复杂度
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(1)$

02.【解答】

- 删除最小值结点算法
  - 算法思路
    - p从头至尾扫描单链表
    - pre指向p结点前驱
    - minp保存最小值结点指针
    - minpre指向minp结点前驱
    - 扫描比较更新最小值位置
    - 最后删除最小值结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/426fab6a29a1b98105d6229a52dc7ba3019b0fcf791fcd5eed97bd777d64f2d1.jpg)

  - 代码实现

LinkList Delete_Min(LinkList &L) {
    LNode *pre = L, *p = pre->next;
    LNode *minpre = pre, *minp = p;
    while(p != NULL) {
        if(p->data < minp->data) {
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
    return L;
}

  - 算法复杂度
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(1)$

03.【解答】

- 解法1：头插法逆置
  - 算法思路
    - 摘下头结点
    - 从第一结点开始依次插入头结点后

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8fb1d58c340cdc0b3385e86efb2b4444a351c4d8c9e303ee38554c09e7558076.jpg)

  - 代码实现

LinkList Reverse_1(LinkList L) {
    LNode *p, *r;
    p = L->next;
    L->next = NULL;
    while(p != NULL) {
        r = p->next;
        p->next = L->next;
        L->next = p;
        p = r;
    }
    return L;
}


- 解法2：就地逆置
  - 算法思路
    - pre、p、r指向三个相邻结点
    - 调整指针指向原前驱结点
    - 注意首尾结点特殊处理

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75abfb30b62d57bed70f7dbf7e20b96aaffc9536f0d9a70a136fadb4a7e9bf36.jpg)

  - 代码实现

LinkList Reverse_2(LinkList L) {
    LNode *pre, *p = L->next, *r = p->next;
    p->next = NULL;
    while(r != NULL) {
        pre = p;
        p = r;
        r = r->next;
        p->next = pre;
    }
    L->next = p;
    return L;
}

  - 算法复杂度
    - 时间复杂度：$O(n)$
    - 空间复杂度：$O(1)$

04.【解答】

- 区间删除算法
  - 算法思路
    - 逐个检查结点
    - 删除区间内的结点
  - 代码实现

void Range_Delete(LinkList &L, int min, int max) {
    LNode *pr = L, *p = L->link;
    while(p != NULL) {
        if(p->data > min && p->data < max) {
            pr->link = p->link;
            free(p);
            p = pr->link;
        } else {
            pr = p;
            p = p->link;
        }
    }
}


05.【解答】

- 查找公共结点算法
  - 问题分析
    - 公共结点后所有结点重合
    - 呈Y型而非X型结构
  - 算法思路
    - 分别遍历得到长度
    - 计算长度差k
    - 长链表先走k步
    - 同步遍历找公共结点
  - 算法复杂度
    - 蛮力法：$O(len1 \times len2)$
    - 优化后：$O(len1 + len2)$
06.【解答】

- 算法思想
  - 循环遍历链表C
  - 采用尾插法将奇数号结点插入表A，保持原顺序
  - 采用头插法将偶数号结点插入表B，顺序相反

- 代码实现
LinkList DisCreat 2(LinkList &A){ 
    LinkList $B$ = (LinkList）malloc（sizeof（LNode））;
    B->next = NULL;
    LNode $\star p = A$ ->next, $\star q$;
    LNode $\star ra = A$;
    while（p!=NULL){
        ra->next=p; 
        ra=p;
        p=p->next;
        if（p!=NULL）{
            q=p->next;
            p->next = B->next;
            B->next=p;
            p=q;
        }
    }
    ra->next = NULL;
    return B;

- 注意事项
  - 头插法插入后需保存后继结点防止断链

07.【解答】

- 算法思想
  - 扫描有序递增单链表
  - 比较相邻结点值域
  - 相等则删除后者
  - 不等则移向下一结点

- 代码实现
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0058d92a881f85ba1e46fec044cd9bb432b880617610e3b87d17f8b78b320301.jpg)

- 复杂度分析
  - 时间复杂度：$O(n)$
  - 空间复杂度：$O(1)$

- 替代方案
  - 可采用尾插法
  - 从第一结点开始比较
  - 不等则插入
  - 相等则删除当前结点

08.【解答】

- 算法思想
  - 比较A、B两表元素
  - 值小的指针后移
  - 值相等时创建新结点
  - 使用尾插法插入新链表

- 代码实现
void Get Common（LinkList A,LinkList B）{
    LNode $\star p = A$ ->next, $\star q = B$ ->next, $\star r$, $\star s$;
    LinkList C = （LinkList）malloc（sizeof（LNode））;
    r = C;
    while(p!=NULL&&q!=NULL){
        if(p->data<q->data)
            p=p->next;
        else if(p->data>q->data)
            q=q->next;
        else{
            s = (LNode*)malloc(sizeof(LNode));
            s->data=p->data;
            r->next=s;
            r=s;
            p=p->next;
            q=q->next;
        }
    }
    r->next=NULL;

09.【解答】

- 算法思想
  - 采用归并思想
  - 设置工作指针pa和pb
  - 同时出现的元素保留一个
  - 其他结点全部释放

- 代码实现
Link List Union（LinkList &la,LinkList &lb){
    LNode *pa = la->next;
    LNode *pb = lb->next;
    LNode *u, $\star pc = la$;
    while(pa&&pb){
        if(pa->data == pb->data){
            pc->next=pa;
            pc=pa;
            pa=pa->next;
            u=pb;
            pb=pb->next;
            free(u);
        }
        else if(pa->data<pb->data){
            u=pa;
            pa=pa->next;
            free(u);
        }
        else{
            u=pb;
            pb=pb->next;
            free(u);
        }
    }
    while(pa){
        u=pa;
        pa=pa->next;
        free(u);
    }
    while(pb){
        u=pb;
        pb=pb->next;
        free(u);
    }
    pc->next=NULL;
    free(lb);
    return la;

- 复杂度分析
  - 时间复杂度：$O(len1+len2)$
  - 空间复杂度：$O(1)$

10.【解答】

- 算法思想
  - 从两链表第一个结点开始
  - 数据相等则后移指针
  - 不等则A链表从后继开始
  - B链表从第一个结点开始
  - 记录A链表每次开始结点

- 代码实现
int Pattern（LinkList A,LinkList B）{
    LNode $\star p = A$;
    LNode *pre = p;
    LNode $\star q = B$;
    while(p&&q){
        if(p->data == q->data){
            p=p->next;
            q=q->next;
        }
        else{
            pre=pre->next;
            p=pre;
            q=B;
        }
    }
    if(q==NULL)
        return 1;
    else
        return 0;

> attention:  
该题其实是字符串模式匹配的链式表示形式，读者应该结合字符串模式匹配的内容重新考虑能否优化该算法。

11.【解答】

- 算法思想
  - 让p从左向右扫描，q从右向左扫描
  - 直到它们指向同一结点($\scriptstyle{\cdot{\bf p}=={\bf q}}$，当循环双链表中结点个数为奇数时)
  - 或相邻(p->next $\mathbf{\lambda}^{=}\mathbf{q}$ 或q->prior $\scriptstyle{\varphi}={\mathtt{p}}$，当循环双链表中结点个数为偶数时)
  - 若它们所指结点值相同，则继续进行
  - 若比较全部相等，则返回1，否则返回0

- 代码实现
int Symmetry(DLinkList L) {
    DNode *p = L->next, *q = L->prior;
    while(p!=q && q->next!=p) {
        if(p->data == q->data) {
            p=p->next; 
            q=q->prior;
        }
        else
            return 0;
    }
    return 1;
}

> attention:  
while循环第二个判断条件易误写成 $\mathtt{p}^{->}$ next $!\!=\!\!\mathrm{q}$，分析这样会产生什么问题。

12.【解答】

- 算法思想
  - 先找到两个链表的尾指针
  - 将第一个链表的尾指针与第二个链表的头结点链接
  - 再使之成为循环的

- 代码实现
LinkList Link(LinkList &h1, LinkList &h2) {
    LNode *p, *q;
    p = h1;
    while(p->next != h1)
        p = p->next;
    q = h2;
    while(q->next != h2)
        q = q->next;
    p->next = h2;
    q->next = h1;
    return h1;
}

13.【解答】

- 算法思想
  - 在双向链表中查找数据值为x的结点
  - 将结点从链表上摘下
  - 顺着结点的前驱链查找插入位置
    - 频度递减
    - 排在同频度的第一个
    - 向前找到第一个比它的频度大的结点
  - 插入到该位置

- 代码实现
DLinkList Locate(DLinkList &L, ElemType x) {
    DNode *p = L->next, *q;
    while(p && p->data != x)
        p = p->next;
    if(!p) 
        exit(0);
    else {
        p->freq++;
        if(p->pre == L || p->pre->freq > p->freq)
            return p;
        if(p->next)
            p->next->pre = p->pre;
        p->pre->next = p->next;
        q = p->pre;
        while(q != L && q->freq <= p->freq)
            q = q->pre;
        p->next = q->next;
        if(q->next)
            q->next->pre = p;
        p->pre = q;
        q->next = p;
        return p;
    }
}

14.【解答】

- 算法思想
  - 遍历链表计算表长n并找到尾结点
  - 将尾结点与首结点相连成循环单链表
  - 找到新链表的尾结点(原链表第n-k个结点)
  - L指向新链表尾结点的下一个结点
  - 断开环得到新链表

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

- 代码实现
LNode* Converse(LNode *L, int k) {
    int n = 1;
    LNode *p = L;
    while(p->next != NULL) {
        p = p->next;
        n++;
    }
    p->next = L;
    for(int i = 1; i <= n-k; i++)
        p = p->next;
    L = p->next;
    p->next = NULL;
    return L;
}

15.【解答】

- 算法思想
  - 设置快慢两指针fast和slow指向链表头
  - slow每次走一步(slow = slow->next)
  - fast每次走两步(fast = fast->next->next)
  - fast先进入环，slow后进入环
  - 两指针在环上相遇判断是否有环

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bdb7d910bfd7dd0ebfecea3a879b39d0c6e32a2b269503dc941ce0503a88e98d.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d933b428b27dfd211713bf5b90ce363d4b59da08263ebc6724f6c84467006dc3.jpg)

- 数学推导
  - ${\sf2}\left({\sf a}\!+\!{\sf x}\right){\sf=}{\sf a}\!+\!{\sf n}^{\star}{\sf x}\!+\!{\sf x}$
  - $\mathsf{a}\!=\!\mathsf{n}\,\mathsf{r}-\mathsf{x}$
  - 从头结点到环入口点距离等于n倍环长减去环入口点到相遇点距离

- 代码实现
LNode* Find_Loop_Start(LNode *head) {
    LNode *fast = head, *slow = head;
    while(fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast)
            break;
    }
    if(fast == NULL || fast->next == NULL)
        return NULL;
    LNode *p1 = head, *p2 = slow;
    while(p1 != p2) {
        p1 = p1->next;
        p2 = p2->next;
    }
    return p1;
}

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

16.【解答】

- 算法思想
  - 设置快慢指针fast和slow
  - slow指向第一个结点，fast指向第二个结点
  - slow每次走一步，fast每次走两步
  - fast到表尾时slow指向中间点
  - 将后半部分逆置
  - 两指针分别指向前后半部分首结点
  - 遍历计算结点元素和并维护最大值

- 代码实现
int PairSum(LinkList L) {
    LNode *fast = L->next, *slow = L;
    while(fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }
    LNode *newHead = NULL, *p = slow->next, *tmp;
    while(p != NULL) {
        tmp = p->next;
        p->next = newHead;
        newHead = p;
        p = tmp;
    }
    int mx = 0;
    p = L;
    LNode *q = newHead;
    while(p != NULL) {
        if((p->data + q->data) > mx)
            mx = p->data + q->data;
        p = p->next;
        q = q->next;
    }
    return mx;
}

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
17.【解答】
- 算法的基本设计思想
  - 问题关键：设计高效算法，通过链表一次遍历找到倒数第k个结点
  - 设计思路：
    - 定义指针p和q初始指向第一个结点
    - p指针先移动k个结点
    - q指针开始与p同步移动
    - p到最后时q指向倒数第k个结点

- 算法详细实现步骤
  - $\textcircled{\scriptsize{1}}$ count $_{:=0}$ ，p和q指向链表表头结点的下一个结点
  - $\circledast$ 若p为空，转 $\circledast$
  - $\textcircled{3}$ 若count等于 $\boldsymbol{\mathrm{k}}$ ，则q指向下一个结点；否则，count $=$ count $^{+1}$
  - $\textcircled{4}$ p指向下一个结点，转 $\mathcal{Q}$
  - $\circledast$ 若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0
  - $^\mathrm{\textregistered}$ 算法结束

- 算法实现代码

typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *link;
} LNode, *LinkList;

int Search_k(LinkList list, int k) {
    LNode *p = list->link, *q = list->link;
    int count = 0;
    while(p != NULL) {
        if(count < k)
            count++;
        else 
            q = q->link;
        p = p->link;
    }
    if(count < k)
        return 0;
    else {
        printf("%d", q->data);
        return 1;
    }
}


- 评分说明
  - 一遍扫描得到正确结果：15分
  - 两遍或多遍扫描得到正确结果：最高10分
  - 递归算法得到正确结果：最高10分
  - 使用大小与k有关的辅助数组：最高10分

18.【解答】
- 问题分析
  - 两个链表长度不同时无法同时到达尾结点
  - 假设长度差为k，先在长链表遍历k个结点
  - 之后同步遍历可保证同时到达公共结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/36d0acc99387087b02e725404b7d4955b6d7521febf196003c5d29f58896cb90.jpg)

- 算法基本设计思想
  - $\textcircled{\scriptsize{1}}$ 求出str1和str2的长度m和n
  - $\circledcirc$ 以表尾对齐：
    - 若 $m \geq n$，p先走m-n+1个结点
    - 若 $m < n$，q先走n-m+1个结点
  - $\textcircled{3}$ p和q同步移动直到指向同一结点

- 算法实现代码

typedef struct Node {
    char data;
    struct Node *next;
} SNode;

int listlen(SNode *head) {
    int len = 0;
    while(head->next != NULL) {
        len++;
        head = head->next;
    }
    return len;
}

SNode* find_list(SNode *str1, SNode *str2) {
    int m, n;
    SNode *p, *q;
    m = listlen(str1);
    n = listlen(str2);
    
    for(p = str1; m > n; m--)
        p = p->next;
    for(q = str2; m < n; n--)
        q = q->next;
        
    while(p->next != NULL && p->next != q->next) {
        p = p->next;
        q = q->next;
    }
    return p->next;
}


- 时间复杂度：$O(\mathrm{len1} + \mathrm{len2})$ 或 $O(\max(\mathrm{len1}, \mathrm{len2}))$

19.【解答】
- 算法基本设计思想
  - 用空间换时间，使用辅助数组记录出现的数值
  - 数组大小为n+1，初值为0
  - 扫描链表检查q[|data|]：
    - 为0则保留并置1
    - 非0则删除结点

- 数据类型定义

typedef struct node {
    int data;
    struct node *link;
} NODE;
typedef NODE *PNODE;


- 算法实现代码

void func(PNODE h, int n) {
    PNODE p = h, r;
    int *q, m;
    q = (int *)malloc(sizeof(int)*(n+1));
    for(int i = 0; i < n+1; i++)
        *(q+i) = 0;
    
    while(p->link != NULL) {
        m = p->link->data > 0 ? p->link->data : -p->link->data;
        if(*(q+m) == 0) {
            *(q+m) = 1;
            p = p->link;
        } else {
            r = p->link;
            p->link = r->link;
            free(r);
        }
    }
    free(q);
}


- 时间复杂度：$O(m)$，空间复杂度：$O(n)$

20.【解答】
- 算法基本设计思想
  - 观察规律：$L'$ 由L交替取首尾元素组成
  - 步骤：
    - 找到中间结点
    - 后半段原地逆置
    - 依次取前后两段结点重排

- 算法实现代码

void change_list(NODE *h) {
    NODE *p, *q, *r, *s;
    p = q = h;
    
    while(q->next != NULL) {
        p = p->next;
        q = q->next;
        if(q->next != NULL)
            q = q->next;
    }
    
    q = p->next;
    p->next = NULL;
    
    while(q != NULL) {
        r = q->next;
        q->next = p->next;
        p->next = q;
        q = r;
    }
    
    s = h->next;
    q = p->next;
    p->next = NULL;
    
    while(q != NULL) {
        r = q->next;
        q->next = s->next;
        s->next = q;
        s = q->next;
        q = r;
    }
}


- 时间复杂度分析
  - 找中间结点：$O(n)$
  - 逆置：$O(n)$
  - 合并链表：$O(n)$
  - 总时间复杂度：$O(n)$


# 3.1.5 答案与解析  

# 一、单项选择题  

- 栈和队列的基本概念
  01.B
  - 栈和队列的逻辑结构相同，都属于线性结构，只是对数据的运算不同

  02.C
  - 栈是线性表，可分为顺序栈和链栈
  - 栈和队列都是限制存取点的线性结构

  03.B
  - 基本操作是最核心、最基本的运算
  - 删除栈底元素不属于栈的基本运算，可通过基本运算实现

- 顺序栈的实现
  04.C
  - 数组下标范围为 $0 \sim n-1$
  - 初始top为1，第一个元素入栈后top为0
  - 栈向高地址方向增长，入栈时先top+1再存入元素

  05.B
  - 数组下标范围为 $1 \sim n$
  - 初始top为1，指向栈顶元素的下一个元素
  - 栈向高地址方向增长，入栈时先存入元素再top+1

  06.A
  - 数组下标范围为 $1 \sim n$
  - 初始top为 $n+1$，指向栈顶元素
  - 栈向低地址方向增长，入栈时先top-1再存入元素

  07.A
  - 每个元素需要1个存储单元
  - 入栈top+1，出栈top-1
  - top值变化:1001H→1002H→1001H→1002H→1001H→1002H→1001H→1002H

  08.A
  - 顺序栈用数组存储，大小固定
  - 链栈优势在于可动态分配存储空间

- 链表结构
  09.C
  - 双向循环链表:表头/尾指针都可方便找到表头结点
  - 单循环链表:尾指针可方便找表头，头指针找尾需遍历
  - 插入删除后找尾结点时间复杂度为 $O(n)$

- 链栈操作
  10.C
  - 不带头结点的链栈进栈:首部插入结点x
  - x->next = top，top指向x

  11.D
  - 栈顶指针指向栈顶元素

  12.A
  - 前3句执行后:栈内为a,b(b为栈顶)
  - 第4句:b出栈，x=b
  - 最后一句:读取栈顶元素a，x=a

- 栈的应用
  13.B
  - n个不同元素进栈，出栈序列个数:
  $\frac{1}{n+1}C_{2n}^{n}=\frac{1}{n+1}\frac{(2n)!}{n! \times n!}=\frac{6 \times 5 \times 4}{4 \times 3 \times 2 \times 1}=5$

  14.D
  - c最先出栈时，栈内必为a和b
  - a先进栈必晚出栈
  - 先进栈晚出栈的元素按逆序出栈

  15.A
  - 出栈序列为cd时的操作序列:
    - a进栈→b进栈→c进栈→c出栈→d进栈→d出栈→b出栈→a出栈
  - 唯一可能序列为cdba

  16.D
  - A,B,C出栈序列分别为1243,3241,1324
  - 1234得到1342的进出栈序列:
    1进→1出→2进→3进→3出→4进→4出→2出

  17.D
  - 第n个元素第一个出栈
  - 前n-1个元素按序入栈
  - 输出序列为输入序列的逆序

  18.D
  - 第i个元素第一个出栈
  - i之前元素可依次排在i后出栈
  - 剩余元素可进栈并排在i之前元素出栈
  - 第j个出栈元素不确定

  19.C
  - A可能顺序:a入→a出→b入→b出→c入→c出→d入→d出
  - B可能顺序:a入→b入→c入→c出→b出→d入→d出→a出
  - D可能顺序:a入→a出→b入→c入→c出→b出→d入→d出
  - C无对应序列

【另解】若出栈序列的第一个元素为 $d$ ，则出栈序列只能是dcba。该思想通常也适用于出栈序列的局部分析：如12345入栈，问出栈序列34152是否正确？如何分析？若第一个出栈元素是3，则此时12必停留在栈中，它们出栈的相对顺序只能是21，所以34152错误。  

20. C
- 入栈序列分析
  - 由于 $P_3 = 1$，$P_1,P_2,P_3$ 连续入栈后，第一个出栈元素是 $P_3$
  - $P_1,P_2$ 已按序进栈，$P_2$ 必定在 $P_1$ 之前出栈
  - 第二个出栈元素是2，而此时 $P_1$ 不是栈顶元素，因此 $P_1$ 不可能是2

21. A
- $P_1$ 取值可能性分析
  - 情况1：$P_1=1$
    - $P_1$ 进栈后立即出栈
    - $P_2=2$，进栈后立即出栈
    - $P_3=3$，进栈后立即出栈
  - 情况2：$P_1=2$
    - $P_2=1$
    - $P_1,P_2$ 依次进栈后全部出栈
    - $P_3=3$，进栈后立即出栈
  - 结论：$P_1$ 既可能是1，又可能是2

22. C
- 入栈出栈序列分析
  - A序列可能：1入→1出→2入→2出→3入→3出→4入→4出
  - B序列可能：1入→2入→3入→3出→2出→4入→4出→1出
  - D序列可能：1入→1出→2入→3入→3出→2出→4入→4出
  - C序列不可能：
    - 4在栈中时，前面元素(1,2,3)都已入过栈
    - 若4第二个出栈，栈中剩余两个有序元素
    - 可能组合为(1,2)(1,3)(2,3)均不满足条件

23. C
- 标识符组合分析
  - 合法组合：n1_、n_1、_1n
  - 操作序列：
    - n1_：n进出→1进出→_进出
    - n_1：n进出→1进→_进出→1出
    - _1n：n进→1进→_进出→1出→n出
  - _n1不可能出现

24. B
- 共享栈特点
  - 上溢：存储器满还往里写
  - 下溢：存储器空还往外读
  - 共享栈优点：
    - 解决上溢问题
    - 节省存储空间
    - 一个栈可使用另一个栈空闲空间

25. A
- 共享栈实现
  - 详见考点精析部分
  - 思考：top1=0，top2=n-1时栈满条件

26. C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/35ffdfafa42c62ee1e16c8b3b0996e73456b35e4a5e684971cc464ac9d7b353b.jpg)
- 栈操作分析
  - 栈内最大深度为3
  - 栈S容量至少为3
  - 出入栈次序详见表格

27. D
- 出入栈序列分析
  - A序列：a进→b进→c进→d进→d出→c出→e进→e出→b出→f进→f出→a出
  - B序列：a进→b进→c进→c出→b出→d进→d出→a出→e进→e出→f进→f出
  - C序列：a进→b进→b出→c进→c出→a出→d进→e进→e出→f进→f出→d出
  - D序列不符合要求：连续3次退栈操作

28. B
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c2253c260f2e0f7135a64146ae00064f87c4da832ac52d12ec6e8a1b1eeb82a.jpg)
- d首出栈后可能操作
  - e进出：decba
  - c出→e进出：dceba
  - cb出→e进出：dcbea
  - cba出→e进出：dcbae

29. C
- $P_3$ 取值分析
  - 3之后的数都可取
  - $P_1=1$时，$P_3$可取2
  - $P_1=2$时，$P_3$可取1
  - $P_3$可取除3外所有数，共n-1个

30. D
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a24554276770537a27b7d0060d2e31cdbf6fd3201a21910e3e6471df3d8ae76b.jpg)
- 出栈序列为b,c,e

31. D
- 入栈出栈序列关系
  - 可通过模拟判断序列合法性
  - 立即出栈：in序列=out序列
  - 全部入栈后出栈：in序列与out序列互为倒序

# 二、综合应用题  

01.【解答】

- CD出栈后状态分析
  - 三种可能操作：
    - E进栈后出栈：CDEBA
    - B出栈，E进栈后出栈：CDBEA  
    - B出栈，A出栈，E进栈后出栈：CDBAE
  - 最终得到三种序列：CDEBA、CDBEA、CDBAE

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ccd4891f31b158fdad1290f9d184806b217185ca59cf2f16deb3c9d5016a2f96.jpg)

02.【解答】

- 出栈序列分析
  - 可得到序列BCAED
    - 操作序列：A进→B进→B出→C进→C出→A出→D进→E进→E出→D出
  - 不能得到序列DBACE
    - 原因：D开头要求ABC先入栈，C在栈顶，BA不可能早于C出栈

03.【解答】

- 合法性判断
  - A、D合法
  - B、C不合法
    - B错误：连续出栈2次
    - C错误：入栈出栈次数不一致
  - 判断原则
    - 过程中入栈次数≥出栈次数
    - 结束时栈为空

- 算法实现
  - 基本思想
    - 扫描序列检查条件
    - 出栈次数不超过入栈次数
    - 最终入栈出栈次数相等

bool Judge(char A[ ]）( 
    int $\scriptstyle{\dot{\mathbf{z}}}=0$ int $\scriptstyle{\dot{\boldsymbol{\mathrm{\omega}}}}={\boldsymbol{\mathrm{k}}}=0$ 
    while（A[i]!='\0'）{
        switch(A[i]){ 
            case'I': $\gimel^{++}$ ;break;
            case'o': $\kappa++$ 
                if（k>j）{
                    printf（"序列非法\n"）;
                    exit（0）;
                }
        }
        $\mathrm{i++}$
    }
    if（j $!\!=\!\!\kappa!,$ printf（"序列非法\n"）; 
    return false; 
    else{ 
        printf（"序列合法\n"）;
        return true;
    }
}

04.【解答】

- 中心对称判断算法
  - 基本思想
    - 前半部分入栈
    - 后半部分逐一比较
    - 栈空则对称
  - 实现细节
    - 奇数长度跳过中心节点
    - 不等时立即退出

int dc（LinkList L,int n）{
    int i; 
    chars[n/2];
    LNode $\star_{\mathsf{P}}\!\!=\!\!\mathtt{L}->$ next;
    for( $\scriptstyle{\dot{\mathbf{z}}}=0$ ;i<n/2; $\dot{\mathbf{i}}^{++}$ ){
        s[i] $\tt=p$ ->data;
        p=p->next;
    }
    i--;
    if $\mathfrak{n}\mathfrak{s}\mathfrak{2}\mathrm{==}\mathtt{1}$ 
        $\tt p\mathrm{=}\tt p$ ->next;
    while(p!$=$ NULL&&S[i]$\scriptstyle==_{\mathtt{P}}$ ->data){
        $\mathrm{i--}$
        $\scriptstyle{\mathtt{p}}={\mathtt{p}}$ ->next;
    }
    if（$\scriptstyle{\dot{\mathbf{i}}}\;==-1$ )
        return 1;
    else 
        return 0;
}

05.【解答】

- 共享栈实现
  - 基本结构
    - 两端为栈底
    - S1栈顶指针初始-1
    - S2栈顶指针初始maxsize
  - 栈操作特点
    - S1常规操作
    - S2反向操作
    - 栈满条件：指针相邻

#define maxsize 100
#define elemtpint 
typedef struct{ 
    elemtp stack[maxsize];
    int top[2];
}stk;
stk S;

- 入栈操作实现
int push（int i,elemtp x）{
    if（i<0li>1){
        printf（"栈号输入不对"）；
        exit(0);
    }
    if(s.top[1]-s.top[0] $==1$ ){
        printf（"栈已满\n"）；
        return 0;
    }
    switch（i）{
        case 0:
            s.stack[$++s$.top[0]]=x;
            return 1；
            break;
        case1:
            s.stack[--s.top[1]]$\!=\!\mathrm{x}$;
            return 1:
    }
}

- 出栈操作实现
if（i<01li>1){
    printf（"栈号输入错误\n"）;
    exit（0);
}
switch(i){
    case0:
        if(s.top[0] $==-1$ ){
            printf（"栈空\n"）;
            return -1;
        }
        else 
            return s.stack[s.top[o]--];
        break;
    case 1:
        if(s.top[1] $==$ maxsize){
            printf（"栈空\n"）；
            return -1;
        }
        else 
            return s.stack[s.top$[1]++]$;
        break;
}

# 3.2.6 答案与解析  

# 一、单项选择题  

01.D
- 栈和队列的区别
  - 都是线性结构
  - 都可采用顺序存储或链式存储
  - 本质区别在于限定表中插入和删除操作位置的不同

02.B
- 队列"先进先出"特性
  - 先进队列的元素先出队列
  - 后进队列的元素后出队列
  - 进队列对应插入操作
  - 出队列对应删除操作
  - I和IV正确

03.D
- 删除队头元素即出队是队列的基本操作之一

04.B

05.D
- 循环队列操作
  - 数组下标范围 $0 \sim n$，容量为 $n+1$
  - 入队操作为 $\text{rear} \leftarrow (\text{rear}+1) \bmod (n+1)$

06.C
- 队列长度计算
  - 公式：$(\text{rear}-\text{front}+\text{maxsize}) \bmod \text{maxsize} = (21-16) \bmod 21 = 16$

> attention:  
数组A[n]的下标范围为 $0 \sim n-1$。若写成A[0..n]，则说明下标范围为 $0 \sim n$

07.B
- 循环队列指针操作
  - 删除元素：$\text{front} = (\text{front}+1) \bmod 6$
  - 插入元素：$\text{rear} = (\text{rear}+1) \bmod 6$
  - 操作后：$\text{front}=0$，$\text{rear}=3$

08.D
- 队列一个元素时的指针状态
  - front指向该元素前一位置
  - rear指向该元素
  - 队空时队首指针等于队尾指针

09.C
- 队空队满判断
  - 采用牺牲一个存储单元的方法
  - 队满标志：队列头指针在队尾指针的下一位置

10.A
- 队空队满判断条件
  - 队满：$(\text{rear}+1) \bmod (n+1) = \text{front}$
  - 队空：$\text{front} = \text{rear}$

11.D
- 链式队列特点
  - 长度受内存空间限制
  - 进队出队时间为 $O(1)$
  - 可顺序访问
  - 不能直接计算元素个数

12.B
- 链队实现选择
  - 需双端操作
  - 首尾指针结构最适合
  - 便于首结点删除和尾结点插入

13.A
- 非循环双链表队列操作
  - 入队需修改队尾结点指针域
  - 查找队尾结点时间为 $O(n)$

14.A
- 链头作为队头便于出队操作

15.D
- 链式队列删除操作
  - 通常仅需修改头指针
  - 仅一个元素时需同时修改尾指针
  - 删除后队空时：$\text{rear} = \text{front}$
16.D
- 链式队列插入操作
  - 结点 $x$ 插入链表尾部
  - rear指向结点 $x$
  - 队尾 $x\text{->next}$ 必须置空

17.A
- 循环单链表进队分析
  - 队尾在链表表头
  - 只设头指针无头结点和尾指针
  - 寻找表尾结点时间复杂度 $O(n)$
  - 进队时间复杂度 $O(n)$

18.B
- 队列序列模拟分析
  - $Q_1$ 和 $Q_2$ 两个队列
  - 5最先出队情况
    - $1,2,3,4$ 入队 $Q_1$
    - 5入队 $Q_2$
    - 得到序列5,1,2,3,4

19.C
- 双端队列序列分析
  - 右端输入受限情况
    - 左入得4,3,2,1
    - 左右交替出得4,1,3,2
  - 右端输出受限情况
    - 左右交替入得4,2,1,3

20.C
- 输出受限双端队列分析
  - 元素进队顺序限制
  - $a,b$ 必须相邻
  - 选项C中 $a,b$ 不相邻不合题意

21.B
- 循环队列指针分析
  - 首元素存储在A[0]
  - front和rear初值为0
  - 入队执行 $(\text{rear}+1)\bmod n$
  - front保持为0不变

> attention:  
$\textcircled{\scriptsize{1}}$ 循环队列是指顺序存储的队列，而不是指逻辑上的循环，如循环单链表表示的队列不能称为循环队列。 $\textcircled{2}$ front和rear的初值并不是固定的。  

22.A
- 队列指针状态分析
  - end1指向队头元素
  - end2指向队尾后一位置
  - 队空条件：$\text{end1}=\text{end2}$
  - 队满条件：$\text{end1}=(\text{end2}+1)\bmod M$

23.C
- 操作序列分析
  - 输出3要求1,2先入栈
  - 2必须比1先出栈
  - 无法得到要求的1,2输出顺序

24.D
- 双端队列入队限制
  - 左端允许入队出队
  - 右端只允许入队
  - 序列验证分析
    - A：右入1,2，左入3,4,5
    - B：右入1,2，左入3，右入4，左入5
    - C：左入1,2，右入3，左入4，右入5
    - D：无法验证

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/787d203e22b7fec4520a4cca00193f260c6a167c436c780f9efc73cfd1809866.jpg)
二、综合应用题  

01.【解答】
- 循环队列类型结构设计
  - 增设tag整型变量
    - 进队置tag为1
    - 出队置tag为0
  - 初始状态
    - tag = 0
    - front = rear = 0
  - 队列4要素
    - 队空条件：Q.front == Q.rear && Q.tag == 0
    - 队满条件：Q.front == Q.rear && Q.tag == 1
    - 进队操作：Q.data[Q.rear] = x; Q.rear = (Q.rear + 1) % MaxSize; Q.tag = 1
    - 出队操作：x = Q.data[Q.front]; Q.front = (Q.front + 1) % MaxSize; Q.tag = 0
  - 入队算法实现
    int EnQueuel(SqQueue &Q,ElemType x){
      if(Q.front == Q.rear && Q.tag == 1) return 0;
      Q.data[Q.rear] = x;
      Q.rear = (Q.rear + 1) % MaxSize;
      Q.tag = 1;
      return 1;
    }
  - 出队算法实现
    int DeQueuel(SqQueue &Q,ElemType &x){
      if(Q.front == Q.rear && Q.tag == 0) return 0;
      x = Q.data[Q.front];
      Q.front = (Q.front + 1) % MaxSize;
      Q.tag = 0;
      return 1;
    }

02.【解答】
- 队列元素逆置算法
  - 基本思路
    - 队列元素无法直接逆置
    - 利用栈实现元素逆序
  - 算法实现步骤
    - 队列元素依次出队入栈
    - 栈中元素依次出栈入队
  - 代码实现
    void Inverser(Stack &S,Queue &Q){
      while(!QueueEmpty(Q)){
        x = DeQueue(Q);
        Push(S,x);
      }
      while(!StackEmpty(S)){
        Pop(S,x);
        EnQueue(Q,x);
      }
    }

03.【解答】
- 用两个栈模拟队列
  - 基本原理
    - S1用于入队操作
    - S2用于出队操作
  - 关键操作规则
    - S2为空时将S1元素全部转移到S2
    - S1满时需确保S2为空
  - 算法实现
    - 入队算法
      int EnQueue(Stack &S1,Stack &S2,ElemType e){
        if(!StackOverflow(S1)) {
          Push(S1,e);
          return 1;
        }
        if(StackOverflow(S1) && !StackEmpty(S2)) {
          printf("队列满");
          return 0;
        }
        if(StackOverflow(S1) && StackEmpty(S2)) {
          while(!StackEmpty(S1)) {
            Pop(S1,x);
            Push(S2,x);
          }
          Push(S1,e);
          return 1;
        }
      }
    - 出队算法
      void DeQueue(Stack &S1,Stack &S2,ElemType &x) {
        if(!StackEmpty(S2)) {
          Pop(S2,x);
        }
        else if(StackEmpty(S1)) {
          printf("队列为空");
        }
        else {
          while(!StackEmpty(S1)) {
            Pop(S1,x);
            Push(S2,x);
          }
          Pop(S2,x);
        }
      }
    - 判空算法
      int QueueEmpty(Stack S1,Stack S2) {
        if(StackEmpty(S1) && StackEmpty(S2)) return 1;
        else return 0;
      }

04.【解答】
- 循环链式队列设计
  - 存储结构选择
    - 采用链式存储
    - 设计为首尾相接的循环单链表
  - 指针设置
    - 队头指针front
    - 队尾指针rear
  - 状态判断
    - 队空条件：front == rear
    - 队满条件：front == rear->next

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/380c264a1128fdb1df6ed7dfb1ef3d1684cd6e6ab71433fa1d3a19bf35a7a8c7.jpg)

- 队列操作状态
  - 插入第一个元素后状态

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ebe831b2e73eb16d67dd91c3dbb644c74e082a79f54dc9de8725737ab0d7f2b2.jpg)

- 基本操作过程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7a08ad28343bc900eb3c7413b361bbc507540302fc355d120f096827603aceb.jpg)

# 3.3.7 答案与解析  

# 一、单项选择题  

01.D
- 缓冲区实现
  - 使用队列实现
  - A、B、C都是典型应用

02.B
- 后缀表达式转换
  - 基本原理
    - 计算符号位于两个操作数后面
    - 按计算优先级进行变换
  - 转换方法
    - 将直接操作数用括号括起
    - 将操作符提到括号后
    - 去掉括号
    - 例如: $\left(\mathfrak{O}\left(\mathfrak{O}^{\mathfrak{a}^{\star}}\left(\mathfrak{O}^{\mathfrak{b}+\mathfrak{c}}\right)\ \right)-\mathfrak{d}\right)$ 转换为 abc+*d-
  - 补充说明
    - 学完第5章后可用二叉树
    - 通过后序遍历求得后缀表达式

03.D
- 算法应用比较
  - FIFO页面替换算法使用队列
  - 其他算法使用栈

04.B
- 栈的应用分析
  - 运算过程
    - A入栈,B入栈,计算R1
    - C入栈,计算R2
    - D入栈,计算R3
    - 最大栈深为2
  - 技巧说明
    - 根据算符优先级统计
    - 计算未参与运算的运算符个数
    - 以选项C为例分析运算符栈变化

05.B
- 递归计算过程
  - 递归模型组成
    - 递归出口
    - 递归体
  - 计算过程
    - f$(0)=2$
    - f$(1)=1*f(0)=2$
    - $\textsf{f}(\textsf{f}(1))=6$

06.C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/748a9385d350d2b15e01cd71af324a050e09a739feb1950922e64d938adba8c6.jpg)
- 递归调用分析
  - 根据递归调用树
  - F()函数调用9次

07.C
- 递归执行顺序
  - 内层参数计算
    - func(5) = func(3) + func(1) = 4
    - 共执行3次func函数
  - 外层函数执行
    - func(func(5)) = func(4) = func(2) + func(0) = 4
    - 第4个执行的是func(4)

08.B
- 递归算法特点
  - 存在重复计算
  - 效率较低

09.C
- 函数调用机制
  - 系统构造活动记录
    - 包含参数表
    - 包含返回地址
  - 压栈过程
    - 活动记录入栈
    - 局部变量入栈

10.B
- 算法实现特点
  - 涉及第5章和第6章内容
  - 图的广度优先搜索类似树的层序遍历
  - 都需要队列辅助实现
11.A
- 栈与递归的关系
  - 栈可模拟递归过程消除递归
  - 单向递归和尾递归可用迭代方式消除
  - 栈用于处理函数/过程调用
  - 栈只允许在栈顶操作，队列允许两端操作

12.B
- 缓冲区特性
  - 数据提取需保持原顺序
  - 具有先进先出特性

13.A
- 中缀转后缀表达式规则
  - 操作数处理
    - 扫描到操作数直接输出
  - 操作符处理规则
    - 遇到"("直接入栈
    - 遇到")"弹出栈顶运算符直到"("并删除"("
    - 当前运算符优先级高于栈顶或遇到"("时直接入栈
    - 当前运算符优先级低于等于栈顶时依次弹出直到遇到高优先级或"("

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/78d512e78db05c1a412424d4c4cc766b5e1e1194fb52e210182b3de3f31dd898.jpg)

14.B
- 中缀表达式转换过程
  - 表达式: $a/b+(c*d-e*f)/g$
  - 扫描到f时栈中元素为+(-*

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e075fb533b14cf49d93eac009ae1901b31b1e028be2a6e81c37f79b6306778e.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/38d9c0ad26a5ef626d629d8777642f355830d0424202669aaea4c5abc6992a02.jpg)

15.A
- 递归调用栈分析
  - 系统栈信息保存顺序
    - 栈底到栈顶: main(), S(1), S(0)
  - 注意事项
    - 系统为每层递归开辟工作栈
    - 存储返回点、局部变量、传入实参

16.C
- 队列入队出队分析
  - 入队顺序: $8,4,2,5,3,9,1,6,7$
  - 出队顺序: $1\sim9$
  - 队列使用规则
    - 后入队元素必须大于前面元素
    - 需确保使用最少队列数
  - 最优解需要4个队列

17.C
- 命题分析
  - 命题I反例
    - 斐波那契数列迭代实现只需一个循环
  - 命题III反例
    - 不同入栈出栈操作可产生不同序列
  - 命题IV
    - 栈只允许一端操作
  - 命题II正确

18.B
- 栈操作过程分析
  - 第一次调用
    - S1弹出2和3
    - S2弹出+
    - 计算3+2=5
    - 5压入S1
  - 第二次调用
    - S1弹出5和8
    - S2弹出-
    - 计算8-5=3
    - 3压入S1
  - 第三次调用
    - S1弹出3和5
    - S2弹出*
    - 计算5*3=15
    - 15压入S1
# 二、综合应用题  

01.【解答】

- 括号匹配算法思想
  - 栈的典型应用
  - 基本思路
    - 扫描每个字符
    - 遇左括号(花、中、圆)进栈
    - 遇右括号检查栈顶是否匹配
      - 匹配则退栈
      - 不匹配则配对错误
    - 最后栈非空则错误

- 代码实现

bool BracketsCheck(char *str) {
    InitStack(S);  // 初始化栈
    int i = 0;
    while(str[i] != '\0') {
        switch(str[i]) {
            // 左括号入栈
            case '(': Push(S, '('); break;
            case '[': Push(S, '['); break; 
            case '{': Push(S, '{'); break;
            // 右括号检测栈顶
            case ')': 
                Pop(S, e);
                if(e != '(') return false;
                break;
            case ']':
                Pop(S, e);
                if(e != '[') return false;
                break;
            case '}':
                Pop(S, e);
                if(e != '{') return false;
                break;
            default: break;
        }
        i++;
    }
    
    if(!IsEmpty(S)) {
        printf("括号不匹配\n");
        return false;
    } else {
        printf("括号匹配\n");
        return true;
    }
}

# 3.4.6 答案与解析  

# 一、单项选择题  

01.D
- 特殊矩阵压缩存储
  - 含有很多相同元素或零元素
  - 可采用压缩存储节省空间

02.C
- 三角矩阵存储
  - 只需存储上三角或下三角部分(含对角线)
  - 元素个数为 $n+(n-1)+\cdots+1=n(n+1)/2$

03.A
- 矩阵存储细节
  - 注意事项
    - 矩阵最小下标为0
    - 数组下标从0开始
    - 矩阵按行优先存储
  - 解题技巧
    - 特殊值代入法求解
    - "平移"搬动思想
    - 结合草图理解
    - 注意起始下标

04.D
- 二维数组地址计算
  - 按行优先顺序公式
    - $\mathrm{LOC}(i,j)=\mathrm{LOC}(0,0)+(\,i\times m+j)\times L$
    - $\mathrm{LOC}(0,\,0)=\mathrm{SA}$ (数组首地址)
    - $L=3$ (元素长度)
    - $m=9-0\,+\,1=10$ (数组列数)
  - 计算结果
    - $\mathrm{LOC}(8,5)=\mathrm{SA}+(8{\times}10+5){\times}3=\mathrm{SA}+255$

05.A
- 二维数组推理
  - 已知条件
    - 按行优先存储
    - A[3][3]地址为446
    - A[3][1]地址为444
    - A[1][1]地址为420
  - 推理过程
    - A[1][1]和A[3][1]相差2行
    - 矩阵列数为12
    - A[5][5]地址计算: $446+24+2=472$

06.B
- 三对角矩阵压缩存储
  - 压缩规则
    - A[1..n][1..n]压缩至B[1...3n-2]
    - $a_{i,j}$ 与 $b_{k}$ 对应关系: $k\!=\!2i+j\!-2$
  - A[66][65]在数组B中位置计算
    - $k=2{\times}66+65-2=195$

07.C
- 按列优先存储计算
  - 元素 $a_{i j}$ 前面有
    - $j-1$ 列
    - $1+2+3+\cdots+j-1=j(j-1)/2$ 个元素
  - 位置计算
    - 第 $j$ 列上第 $i$ 个元素
    - 数组B下标从1开始
    - $k\!=\!j(j\!-\!1)/2+i$

08.B
- 列优先存储详细计算
  - 元素 $a_{i,j}$ 之前有
    - $j-1$ 列
    - $(j-1)(2n-j+2)/2$ 个元素
  - 位置确定
    - 第j列上第 $i-j+1$ 个元素
    - 数组B下标从1开始
    - $k\!=\!(j\!-\!1)(2n\!-\!j+2)/2+i\!-\!j\!+1$

09.B
- 稀疏矩阵存储特点
  - 采用三元组压缩存储
  - 存储内容
    - 矩阵元素的行列下标
    - 相应的值
  - 局限性
    - 不能快速定位矩阵元素
    - 失去随机存取特性

10.D
- 三对角矩阵特征
  - 非零元分布
    - 第1行和最后1行有2个非零元
    - 其余各行有3个非零元
  - 稀疏矩阵特点
    - 非零元个数较少
11.B
- 三对角矩阵压缩存储
  - 存储方式
    - 3条对角线上元素按行优先存放在一维数组B中
    - $a_{1,1}$ 存放于B[0]

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fa3ea5f7260fe17e292865159b0d1cf5053f88bb67bd6ff07d67a0253a39a290.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4a30b3705b2457b9d0660a6c5cea4144340219f749e3e8965305d2cd9bc62523.jpg)  

  - 元素位置计算
    - 公式法: $k = 2i + j - 3$ 
    - 观察法
      - 第一行有2个元素
      - 中间28行每行3个元素
      - $m_{30,30}$ 前有一个元素 $m_{30,29}$
      - 计算: $2 + 28 \times 3 + 2 - 1 = 87$

> attention:  
- 下标起始问题
  - 矩阵可能从 $a_{0,0}$ 或 $a_{1,1}$ 开始
  - 数组可能从B[0]或B[1]开始
  - 需要适时调整计算方法

12.A
- 稀疏矩阵存储结构比较
  - 三元组表
    - 存储行、列、值三种信息
    - 主要用于稀疏矩阵
  - 十字链表
    - 结合行列单链表存储
  - 邻接矩阵
    - 空间复杂度 $O(n^2)$
    - 不适合稀疏矩阵
  - 二叉链表
    - 又名左孩子右兄弟表示法
    - 用于表示树或森林

13.A
- 数组下标计算
  - C语言数组N下标从0开始
  - $m_{1,1}$ 对应 $n_0$
  - 各行元素数: 12,11,10,9,8
  - $m_{6,6}$ 位置: $12+11+10+9+8+1=51$
  - 实际下标为50

14.C
- 上三角矩阵列优先存储
  - 存储顺序
    - 第1列: 1个元素
    - 第2列: 2个元素
    - 第6列: 6个元素
    - 第7列: 1个元素
  - $m_{7,2}$ 位置计算
    - 前面共 $1+2+3+4+5+6+1=22$ 个元素
    - 数组下标范围 $0\sim21$
    - $m_{2,7}$ 下标为22

15.B
- 二维数组行优先存储
  - 已知条件
    - 每个元素占1个存储单元
    - A[3][3]是第121个元素
  - 计算过程
    - 设每行n个元素
    - $n \times 3 + 4 = 121$
    - 求得 $n = 39$
    - A[5][5]地址: $100+39 \times 5+6-1=300$

16.A
- 稀疏矩阵三元组表存储
  - 存储内容
    - 非零元素的行标、列标、关键字值
    - 矩阵的行数和列数
    - 非零元素个数
  - 重要性说明
    - 仅通过三元组无法判断矩阵大小
    - 需要额外存储矩阵维度信息

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a54777d3f203e604cf3c0c26607b75871ce9c9e6b44ee665c9ba64b1b45637a6.jpg)

# 4.2.5 答案与解析  

# 一、单项选择题  

01.C
- 子串操作分析
  - 从串S中截取第i个字符起长度为l的子串
  - A错误，B、D明显错误

02.B
- KMP算法特点
  - 主串不会回溯
  - 主串指针不会变小

03.C、D
- 时间复杂度分析
  - 简单模式匹配算法
    - 实际应用时间复杂度约为 $O(m+n)$
    - 理论时间复杂度为 $O(mn)$
  - KMP算法时间复杂度为 $O(m+n)$

04.D
- KMP匹配规则
  - 当主串第i个字符和模式串第j个字符不匹配时
    - 主串位指针i不变
    - 将主串第i个字符与模式串第next[j]个字符比较
    - 即 $j = \text{next}[j]$

05.B
- KMP匹配特点
  - 主串第i个字符和模式串第j个字符不匹配时
  - 主串位i不回溯

06.A
1）设next $[1] = 0$, next $[2] = 1$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/324e552c289ad685020a346e6c10b4da169a93c653a6a302719332def4a9e9ae.jpg)

- next数组计算过程
  - j=3时
    - k = next[j-1] = next[2] = 1
    - 比较S[2]与S[1]: S[2] = a, S[1] = a
    - S[2] = S[1]，所以next[j] = k + 1 = 2
  - j=4时
    - k = next[j-1] = next[3] = 2
    - 比较S[3]与S[2]: S[3] = a, S[2] = a
    - S[3] = S[2]，所以next[j] = k + 1 = 3

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fd25b926cb0b642929e708ed40c60eb724b8877345e33bc310a47d3bb1eccf02.jpg)

07.C
- 手工求next数组方法
  - 串s = ababa a ababa a分析
    - a: 前后缀为空，最长相等前后缀长度为0
    - ab: 前缀{a}∩后缀{b} = ∅，长度为0
    - aba: 前缀{a,ab}∩后缀{a,ba} = {a}，长度为1
    - abab: 前缀{a,ab,aba}∩后缀{b,ab,bab} = {ab}，长度为2

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6bea1d1bb4e3b00ee7431d4358ab0208321daf0a7f67dc8347bec33eabce6564.jpg)

08.C
- 解析同上题
- next数组调整说明
  - 是否整体加1需根据题意分析
  - 位序从1开始时需要整体加1
  - 位序从0开始时不需要加1

> attention:  
实际KMP算法中，串的位序从1开始则next数组需整体加1，从0开始则不需要加1。

09.C
- nextval数组计算
  - 从0开始，串位序从1开始
  - 第一步：nextval[1] = next[1] = 0

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0723a252b86c7588ad313efb041b992a9eea1625ac727c4fc5d1fef9bfcac637.jpg)

- 计算步骤详解
  - 从j开始，判断pj是否等于pnext[j]
  - 相等则修正为next[next[j]]
  - 直至两者不相等为止

10.C
- 失配分析
  - 主串和模式串位序从0开始
  - 失配时s[i]≠t[j]，i=5

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7419483a1e17abfc50c7bc83070a668a57165a793d61316e9e9988e89083dc7.jpg)

11.B
- 匹配过程分析
  - 位序从0开始
  - next数组生成

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c41bfc001746badce009efd4560a1d524fa970b8f563698660ab33b0c2137932.jpg)

- 比较过程
  - 第一趟：连续比较6次，5号位失配
  - 第二趟：从模式串2号位开始，比较4次成功
  - 总比较次数：10次

# 二、综合应用题  

01.【解答】
- KMP算法失配情况分析
  - 情况1：模式串第1个字符与主串当前字符不相等
    - next $[1] = 0$，表示模式串右移一位
    - 主串当前指针后移一位，继续比较
  - 情况2：主串第i个字符与模式串第j个字符失配
    - 主串i不回溯
    - 模式串第k个字符与主串第i个字符比较
    - k值满足条件: $1 < k < j$ 且 $p_1\cdots p_{k-1} = p_{j-k+1}\cdots p_{j-1}$
    - k为模式串下次比较位置
    - 取最大k值以最小化右移距离
  - 情况3：其他失配情况
    - 主串指针i不回溯
    - 最坏情况下模式串从第1个字符开始比较

02.【解答】
- 模式串P='aabaac'的next数组生成过程
  - 初始化
    - next $[1] = 0$
    - next $[2] = 1$
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/33da1e25addb096029df22cc29324ca13eb7c1919006d88596b1badec99ab2c3.jpg)
  - j=3时计算
    - k = next[2] = 1
    - 比较S[2]与S[1]均为'a'
    - next[3] = k + 1 = 2
  - j=4时计算
    - k = next[3] = 2
    - 比较S[3]='b'与S[2]='a'不相等
    - k = next[k] = 1
    - 比较S[3]='b'与S[1]='a'不相等
    - k = next[k] = 0
    - next[4] = 1
  - j=5时计算
    - k = next[4] = 1
    - 比较S[4]与S[1]均为'a'
    - next[5] = k + 1 = 2
  - j=6时计算
    - k = next[5] = 2
    - 比较S[5]与S[2]均为'a'
    - next[6] = k + 1 = 3

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/68a30a346398668800b6915c5bbde3ac4b6c3572d849990bcfa280d328ccda81.jpg)

- KMP算法匹配过程
  - 第一趟
    - 从首字符开始比较
    - i=6,j=6时失配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f97f6994a195ed7e0d5c402153422ba83cbe971d14bee5c7d07b5dc42e00979.jpg)
  - 第二趟
    - next[6]=3,从模式串第3个字符继续比较
    - i=9,j=6时失配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/901777c03628ada8b4fed4ed18c04a2a23d27eb6f0e1f59d3b77eb6e68401b87.jpg)
  - 第三趟
    - next[6]=3,从模式串第3个字符继续比较
    - 匹配成功
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dc3881603a934d8d91d42a98e822344d4f2057e15d15fe8a255a756e8e4e8e98.jpg)



  




