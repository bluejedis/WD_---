# 2.1.9 答案与解析  

# 一、单项选择题  

01.C
- 进程映像组成
  - PCB
  - 程序段
  - 数据
  - PCB是进程存在唯一标志

02.A
- 线程CPU现场
  - 包含组件
    - 程序计数器
    - 状态寄存器 
    - 通用寄存器
    - 栈指针
  - 线程特点
    - 是CPU调度基本单位
    - 可独立执行程序
    - 共享所属进程空间
    - 可通过共享存储空间通信

03.C
- 进程地址空间特点
  - 每个进程独立地址空间
  - 地址空间私有性
    - 只能执行自己空间程序
    - 只能访问自己空间数据
  - 进程间通信方式
    - 共享文件
    - 消息传递
    - 共享存储区

04.A
- 进程动态性
  - 是进程最重要特性
  - 区别于静态程序
  - 体现程序执行动态性

05.D
- 并发进程特点
  - 生命周期不连续性
  - 执行速度影响
    - 影响执行顺序
    - 影响内存冲突
  - 结果不确定性
    - 存在竞争和制约
    - 每次运行结果可能不同

06.A
- 进程相关概念
  - 优先级分类
    - 静态优先级
    - 动态优先级
  - 死锁状态
    - 可能全部进程阻塞
    - CPU空闲
  - 就绪态特点
    - 等待处理器调度

07.C
- 并发进程执行
  - 相对速度影响因素
    - 进程调度策略
    - 处理机获取情况
    - 执行时间分配

08.C
- 进程创建原语过程
  - 申请空白PCB
  - 分配唯一标识符
  - 分配资源
    - 内存
    - I/O设备
  - 初始化PCB
  - 插入就绪队列

09.B
- 进程与程序关系
  - 进程特点
    - 可顺序执行多个程序
    - 不能同时执行多个程序
  - 程序特点
    - 可对应多个进程
    - 可产生多个进程
    - 可被多用户同时运行10.D
- 进程创建时机
  - 用户登录：创建登录进程验证身份
  - 高级调度：从后备队列选择作业创建进程
  - 响应用户请求：创建子进程执行任务
  - 打开程序：如打开浏览器时创建新进程

11.B
- PCB特点
  - 系统通过PCB控制进程
  - PCB是进程存在唯一标志
  - PCB常驻内存
  - 包含进程控制信息

12.C
- 进程状态变化关系
  - 可能引起其他进程状态变化
    - 如时间片用完引起其他进程运行
  - 可能不影响其他进程
    - 如阻塞态转就绪态

13.C
- 进程状态组合
  - 单处理器系统不可能10进程同时就绪
  - 可能9个就绪1个运行
  - 可能10个都阻塞

14.C
- 进程状态转换
  - 打印机释放后
    - 等待进程从阻塞态转就绪态
  - I/O操作
    - 完成前为阻塞态
    - 完成后转就绪态

16.C
- 进程状态转换特点
  - 就绪态可由运行态转入
  - 就绪态可由阻塞态转入
    - 时间片到转就绪
    - 资源到达转就绪

17.B
- 分时系统进程状态分布
  - 就绪态进程最多
  - 运行态进程少数
  - 阻塞态进程不多
  - 终止态进程不多

18.D
- 程序封闭性
  - 执行结果只取决于进程本身
  - 不受执行速度影响
  - 失去封闭性导致结果不同

19.B
- 进程撤销特点
  - 有生命周期
  - 不需要显式撤销
  - 时间片结束仅转就绪
  - 可在完成或出错时撤销

20.D
- 进程关系特点
  - 可能相关可能独立
  - 不一定同时执行

21.C
- 线程特点
  - 进程仍是资源分配单位
  - 内核级线程是调度单位
  - 线程共享进程资源
  - 用户级线程切换不需内核支持

22.B
- 多对一线程模型特点
  - 只有一个内核级线程
  - 用户线程对系统透明
  - 一个线程阻塞导致全部阻塞

23.C
- 信箱通信机制
  - 需要两个通信原语
    - 发送原语
    - 接收原语

24.C
- 进程通信方式效率比较
  - 共享内存最快
  - 消息传递需数据拷贝
  - 套接字涉及协议栈
  - 管道需数据拷贝

25.B
- 信箱通信特点
  - 属于间接通信
  - 通过共享数据结构中转
  - 收发方无时间限制

26.A
- 进程概念分析
  - 进程特点
    - 独立运行单位
    - 资源分配和调度基本单位
  - 组成部分
    - PCB
    - 程序
    - 数据
    - 执行栈区
  - 与程序区别
    - 程序是静态的文件
    - 进程是动态的执行实体

27.B、D、D、C、B、A
- C语言程序内存分段
  - 内存段类型
    - 正文段(代码和赋值数据段)
    - 数据堆段
    - 数据栈段
  - 数据存放位置
    - 正文段：二进制代码和常量
    - 堆段：动态分配存储区
    - 栈段：临时变量
  - 具体变量位置
    - 正文段：全局赋值变量、常量
    - 栈段：未赋值局部变量、实参
    - 堆段：动态内存
    - PCB：进程优先级

28.A
- 进程与程序关系
  - 进程特征
    - 包含程序代码、数据和状态
    - 同一程序可形成不同进程
    - 不同进程间无必然联系

29.D
- PCB内容构成
  - 主要数据类型
    - 进程标志信息
    - 进程控制信息
    - 进程资源信息
    - CPU现场信息
  - 注意事项
    - 全局变量不属于PCB
    - 全局变量属于用户代码

30.D
- PCB组成分析
  - 包含内容
    - 进程基本信息
    - 进程状态
    - 程序计数器
    - 寄存器
    - 内存分配情况
    - 文件列表
    - 进程优先级
  - 不包含内容
    - 互斥信号量(存储于内核或共享内存)

31.A
- 进程创建数量限制
  - 决定因素
    - 系统内存大小
  - 无关因素
    - 用户数目
    - 外设数量
    - 文件数量

32.C
- 就绪队列特点
  - 组成形式
    - PCB链表结构
  - 形成条件
    - 资源分配完成
    - 等待CPU调度

33.C
- 并发与并行区别
  - 并发特点
    - 单处理器系统
    - 轮流执行多进程
  - 并行特点
    - 通道设备与CPU同时工作

34.A
- 进程状态转换
  - 自主决定
    - 运行态到阻塞态
  - 被动转换
    - 运行态到就绪态(时间片用完)
    - 就绪态到运行态(调度程序)
    - 阻塞态到就绪态(协作进程)

35.B
- 进程管理实现
  - 通过原语实现
    - 包括创建原语等

36.D
- 线程切换特点
  - 同进程内切换
    - 不引起进程切换
  - 跨进程切换
    - 会引起进程切换

37.B
- 线程特性
  - 基本属性
    - 进程内独立执行单元
    - 不能脱离进程运行
  - 引入目的
    - 减少时空开销
  - 数量关系
    - 一进程可含多线程

38.D
- 线程执行方式
  - 并发执行
    - 交替执行
    - 不一定同时
  - 并行执行
    - 多核CPU同时执行
    - 包含并发特性

39.D
- 线程优缺点
  - 优点
    - 提高系统并发性
    - 节约系统资源
    - 便于进程通信
  - 缺点
    - 不增强进程安全性
    - 线程错误影响整个进程

40.B
- 线程与进程关系分析
  - 归属关系
    - 一个线程只能属于一个进程
    - 一个进程可包含多个线程
  - 资源共享
    - 线程间需同步互斥
    - 避免数据冲突
  - 大小比较
    - 线程不一定比进程小
    - 单线程进程与线程大小相同

41.C
- 键盘输入线程设计
  - 系统特点
    - 单一键盘设备
    - 输入速度较慢
  - 实现方式
    - 单线程处理
    - 满足系统需求

42.D
- 进程状态转换规则
  - 阻塞态转换
    - 获得资源后转就绪态
    - 不能直接转运行态

43.B
- 时间片到期处理
  - 状态转换
    - 运行态转就绪态
    - 等待下一时间片

44.C
- 进程间通信方式
  - 不可用方式
    - 全局变量
      - 进程间独立
      - 无法交换数据
  - 可用方式
    - 管道
    - 共享内存
    - 消息传递

45.D
- 运行态进程状态转换
  - 转换条件
    - 时间片用完
    - 更高优先级进程出现
  - 其他情况
    - 资源获得转就绪
    - 等待事件转阻塞
    - 任务完成被撤销

46.B
- 进程切换机制
  - 触发条件
    - 运行态转就绪态
    - CPU重新调度

47.C
- 进程阻塞原因分析
  - 阻塞态原因
    - I/O操作等待
    - 互斥同步等待
    - 网络数据等待
  - 非阻塞情况
    - CPU调度等待为就绪态

48.A
- 进程唤醒机制
  - 状态变化
    - 进入就绪态
    - 等待CPU调度
  - 优先级处理
    - 按固定算法计算
    - 不一定最大
  - 队列位置
    - 按调度规则确定
    - 不一定队首

49.D
- 进程创建原语功能
  - 基本操作
    - 申请空闲PCB
    - 分配必要资源
    - PCB初始化
    - 插入就绪队列
  - 非创建职责
    - CPU分配由调度程序负责

50.A
- 进程通信方式
  - 主要方式
    - 管道
    - 消息传递
    - 共享内存
    - 文件映射
    - 套接字
  - 非通信方式
    - 数据库
51.B
- 用户级线程特点分析
  - 调度机制
    - 以进程为调度单位
    - 进程A单线程运行时间是进程B(100线程)平均时间的100倍
  - 实现方式
    - 由用户程序或函数库实现
    - 对操作系统透明
    - CPU调度对象仍是进程
  - 错误说法
    - 跨进程线程调度需内核支持

52.A
- 内核级线程特性分析
  - 线程切换
    - 需用户态转核心态
    - 系统开销大
  - CPU调度
    - 以线程为调度单位
    - 支持多CPU并行
  - 系统调用
    - 可直接在内核态执行
    - 直接利用系统服务

53.A
- 用户级线程特点
  - 阻塞影响
    - 一个线程阻塞导致整个进程阻塞
  - 调度优势
    - 在用户空间进行
    - 节省模式切换开销
    - 支持自定义调度算法

54.D
- 用户级线程局限性
  - 不能利用多处理器并行性
  - 操作系统只能看到进程层面

55.D
- 用户级线程切换触发条件
  - 不触发切换情况
    - 系统调用
    - I/O请求
    - 异常处理
  - 触发切换情况
    - 线程同步等待

56.B
- 用户级线程实现特点
  - 不依赖内核实现
  - 创建调度在用户态
  - 对操作系统透明
  - 切换仅涉及用户上下文

57.C
- 线程模型并发性分析
  - 一对一模型优势
    - 充分利用内核级线程
    - 发挥多处理机优势
  - 多对多模型优势
    - 支持同进程多线程并发

58.C
- 多对一模型特点
  - 线程切换不导致进程切换
  - 在用户空间进行切换

59.C
- 进程创建原因分析
  - 主要原因
    - $\textcircled{\scriptsize{1}}$ 用户登录
    - $\circledcirc$ 高级调度
    - $\textcircled{3}$ 系统处理用户请求
    - $\textcircled{4}$ 用户程序应用请求
  - 错误情况
    - 设备分配不需创建进程

60.D
- 进程线程资源分配
  - 进程共享资源
    - 代码段
    - 打开的文件
    - 全局变量
  - 线程独享资源
    - 栈指针(TCB)

61.A
- 线程进程关系
  - 资源分配
    - 进程是基本单位
  - 调度机制
    - 线程是基本单位
  - 地址空间
    - 同进程线程共享
  - 用户级线程特点
    - 线程管理由应用完成
    - 内核无感知

62.A
- 进程状态转换分析
  - 读磁盘操作
    - 等待I/O导致阻塞态
    - I/O完成转就绪态

63.C
- 管道通信特点分析
  - 通信方向
    - 单向通信
    - 双向需两个管道
  - 存储特性
    - 内存中固定大小缓冲区
    - 通常为一页大小
  - 读写操作
    - 满时写操作阻塞
    - 空时读操作阻塞
  - 多进程访问
    - 需同步机制保护
64.D
- 进程状态转换分析
  - P(wait)操作与资源请求
    - 选项A、B、C涉及资源请求导致阻塞态
    - 选项D仅涉及CPU剥夺进入就绪态

65.C
- 进程阻塞态分析
  - 正确情况
    - 等待资源可用(不含CPU)
    - 等待I/O完成
  - 错误情况
    - Ⅲ描述的是就绪态情况

66.C
- 进程唤醒条件分析
  - 正确情况
    - I/O操作完成后唤醒相关进程
    - 临界区退出后唤醒等待进程
  - 错误情况
    - 时间片用完属于就绪态转换

67.B
- 线程管理机制对比
  - 内核级线程特点
    - 应用程序仅有编程接口
    - 系统维护上下文信息
  - 用户级线程特点
    - 控制块由用户空间库函数维护
    - 切换效率高于内核级线程
    - 可在不支持内核级线程的系统实现

68.B
- 父子进程关系分析
  - 正确特性
    - 可以并发执行
    - 各自有独立PCB
    - 临界资源互斥使用
  - 错误说法
    - 不能共享虚拟地址空间

69.B
- 进程创建过程
  - 正确步骤
    - 申请空白PCB
    - 初始化进程信息
    - 设置就绪态等待调度

70.D
- 进程状态转换场景
  - 阻塞态转换情况
    - 读文件等待I/O完成
    - 申请被占用外设
    - wait()操作信号量值≤0
  - 就绪态转换情况
    - 时间片用完等待调度

71.D
- 系统调用与CPU状态
  - 系统调用特点
    - 通过软中断进入内核态
    - 完成后返回用户态
  - 其他操作特点
    - A、B、C在内核态执行
    - 仅中断返回切换用户态

72.C
- 线程状态转换分析
  - 阻塞态情况
    - 等待键盘输入
    - 缺页异常处理
    - wait()未获取资源
  - 就绪态情况
    - 时间片用完等待调度
# 二、综合应用题  

01.【解答】

- 进程地址空间与通信机制
  - 进程特点
    - 是竞争和分配计算机系统资源的基本单位
    - 每个进程有独立地址空间
    - 操作系统利用硬件地址机制保护地址空间
  - 进程通信主要方式
    - 共享内存区
      - 通过系统调用创建和连接
      - 多进程可访问同一区域交换数据 
      - 需要信号量解决同步互斥
    - 消息传递
      - 通过发送/接收消息实现通信
      - 消息在内核缓冲区和消息队列中传递
      - 系统负责消息的复制和传递
    - 管道系统
      - 允许两进程单向通信
      - 采用生产者-消费者模式
      - 系统保证读写顺序一致性

02.【解答】

- 多线程概念
  - 一个程序可定义多个线程并发执行
  - 每个线程执行不同任务
- 多线程与多任务区别
  - 多任务针对操作系统,表示可同时执行的程序数
  - 多线程针对单个程序,表示可同时执行的线程数

03.【解答】

- 进程状态分析
  - CPU空闲情况
    - 就绪队列无进程时可能空闲
    - 系统会快速选择就绪进程运行
  - 就绪队列状态
    - 所有进程可能都处于等待态
    - 可能存在死锁状态
    - 可能因事件未发生而循环等待
  - 进程优先级执行
    - 高优先级进程可能在等待队列
    - 调度会从就绪队列选择进程
    - 被选中进程可能优先级较低

04.【解答】

- 系统调度分析
  - 运行态到就绪队列特点
    - 直接回到队列末尾
    - 采用先来先服务原则
  - 调度算法判断
    - 采用时间片轮转调度
    - 属于交互式操作系统
  - 阻塞队列特点
    - 存在多个阻塞队列
    - 包括打印机输出等待
    - 包括磁盘读取等待

1）根据题意，该系统采用的是时间片轮转法调度进程策略。

2）可能的变化见下表。

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/85947750beb254801005cdfb3f8ce775ecbebd966ad2cf4c146f8de4bad1d6bb.jpg)


# 2.2.8 答案与解析  

# 一、单项选择题  

01.D
- 中级调度分析
  - 主要目的是节省内存
  - 将阻塞或长期不运行进程挂起到外存
  - 腾出空间给其他进程
  - 进程具备运行条件时从外存调回

02.C
- 进程状态转换
  - 创建态到就绪态由高级调度完成
  - 高级调度(作业调度)任务
    - 从后备队列选择作业
    - 创建PCB
    - 分配内存等资源
    - 插入就绪队列

03.C
- 调度算法设计指标
  - 常见指标
    - 公平性
    - 资源利用率
    - 平均周转时间
    - 平均等待时间
    - 平均响应时间
  - 互斥性不属于调度指标
    - 是同步机制
    - 用于避免临界资源访问冲突

04.A
- 时间片轮转特点
  - 主要目的
    - 使多用户得到及时响应
    - 营造用户"独占"计算机感觉
  - 无特殊偏好
  - 系统开销较大
    - 吞吐量和周转时间不如批处理
    - 响应时间快,改善人机交互

05.C
- 进程调度时机影响因素
  - 进程特点
    - CPU繁忙型/I/O繁忙型
    - 优先级
  - 调度策略
    - 优先级调度时优先级起作用
  - CPU占用时间
    - I/O繁忙型频繁放弃CPU
    - CPU繁忙型运行时间长
    - 时间片轮转强制切换

06.D
- 临界区进程调度
  - 可能因中断或抢占导致调度
  - 请求等待资源时主动放弃CPU

07.C
- 进程上下文组成
  - CPU寄存器值(现场信息)
  - 进程状态和控制信息
  - 堆栈内容
  - 中断向量不属于上下文
    - 指向中断处理程序的指针
    - 存放在固定内存位置
08.D
- 上下文切换分析
  - 发生在调度新进程时
  - 程序计数器PC值保存在进程现场
  - 不涉及主存和磁盘数据交换

09.B
- FCFS调度算法特点
  - 有利于长作业和CPU繁忙型
  - 不利于短作业和I/O繁忙型
  - 其他算法分析
    - 时间片轮转对长短作业一视同仁
    - 优先级与作业长度无必然联系

10.D
- 进程调度算法选择准则
  - 公平性:确保CPU合理分配
  - 有效性:提高CPU利用率
  - 响应时间:交互用户体验
  - 周转时间:批处理效率
  - 吞吐量:单位时间处理进程数

11.C
- 实时系统特点
  - 采用高优先级
  - 支持可抢占调度
  - 及时处理紧急事件

12.D
- 进程调度触发条件
  - 当前进程无法继续运行
    - 时间片用完
    - 运行结束
    - 出错
    - 等待事件
    - 自我阻塞
  - 新进程加入就绪队列不直接触发

13.D
- 进程(线程)调度时机
  - 运行完毕
  - 自我阻塞
  - 时间片用完
  - 资源未就绪
  - 出现错误

14.B
- 作业周转时间计算
  - 4个作业周转时间:2h,4h,6h,8h
  - 总周转时间:$2+4+6+8=20h$
  - 平均周转时间:$20/4=5$小时

15.B、E、C、D
- 调度算法选择依据
  - 短作业优先:照顾短作业用户
  - 优先级调度:照顾紧急作业
  - 时间片轮转:实现人机交互
  - 多级反馈队列:兼顾各类用户

16.D
- 优先级调度分类
  - 静态优先级:创建时确定不变
  - 动态优先级:运行过程中可变

17.B
- 短作业优先调度分析
  - 作业执行顺序:$J_1,J_2,J_3$
  - 各作业周转时间
    - $J_1:T_1$
    - $J_2:T_1+T_2$
    - $J_3:T_1+T_2+T_3$
  - 平均周转时间:$(3T_1+2T_2+T_3)/3$
18.D
- 单道方式运行下平均周转时间分析
  - 短作业优先调度效果最好
  - 各选项平均周转时间计算
    - A选项: $(2+7+10)/3 = 19/3$ 小时
    - B选项: $(3+8+10)/3 = 7$ 小时
    - C选项: $(5+7+10)/3 = 22/3$ 小时
    - D选项: $(2+5+10)/3 = 17/3$ 小时

19.C
- 进程状态转换分析
  - 时间片用完转为就绪态
  - 执行完或异常时才会终止

20.C

21.D
- 优先级算法特点
  - I/O繁忙型作业优先于计算繁忙型
  - 系统进程优先于用户进程
  - 动态优先权特点
    - 执行时间增加优先权降低
    - 等待时间增加优先权上升

22.B
- 调度算法抢占性分析
  - 时间片轮转算法
    - 固定时间配额
    - 绝对可抢占
  - 优先级和短进程优先算法
    - 可分为抢占和不可抢占两种

23.B
- 作业与进程区别
  - 作业是用户角度的任务单位
  - 进程是系统资源分配的基本单位

24.B
- 时间片轮转特点
  - 按顺序使用时间片
  - 时间片过大退化为先来先服务

25.D
- 进程调度甘特图分析
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/328b2bcaf07a5073a9bab81d982aa66ed4ab750c88edeeffb1ace1ba6a575a9c.jpg)
  - 非抢占式调度过程
    - P1先运行至结束
    - P3、P5按短进程优先
    - P2、P4按先来先服务
  - 周转时间计算
    - P1: 9-0=9
    - P2: 16-0.4=15.6
    - P3: 10-1=9
    - P4: 20-5.5=14.5
    - P5: 12-7=5
    - 平均周转时间: 10.62
  - 抢占式平均周转时间: 6.8

26.D
- 短作业优先调度分析
  - 平均周转时间计算
    - $[2+(2+4)+(2+4+6)+(2+4+6+8)+(2+4+6+8+10)]/5=14$

27.C
- 进程调度甘特图分析
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ace648c7f7d9d34f252d4c10ff90cc504c234586ef1026a23bc9d890e4bc0163.jpg)
  - 周转时间计算
    - 总周转时间: $4+1+8+12+2=27$ 小时

28.A
- 分时系统调度特点
  - 采用时间片轮转算法
  - 轮流分配处理器时间

29.B
- 先来先服务算法缺点
  - 长进程先到会使短进程等待
  - 对短进程不利

30.B
- 短进程优先算法特点
  - 具有最短平均周转时间
  - 最小化等待时间

31.C
- 多级反馈队列调度特点
  - 需设置多个就绪队列
  - 队列间进程转移和抢占
  - 系统开销大
32.C
- 调度算法系统开销分析
  - 高响应比优先算法
    - 需计算响应比
    - 系统开销较大
  - 多级反馈队列算法 
    - 涉及多队列管理
    - 进程队列间转移
    - 系统开销较大
  - 时间片轮转算法
    - 需分配固定时间片
    - 时间片用完时上下文切换
    - 系统开销不小
  - 先来先服务算法
    - 按进程到达顺序调度
    - 无需判断优先级和时间片
    - 系统开销最小

33.B
- 调度算法饥饿现象分析
  - 不会出现饥饿现象的算法
    - 先来先服务算法
    - 时间片轮转算法
  - 可能出现饥饿现象的算法
    - 短作业优先算法
    - 优先级算法

34.D
- 响应比优先调度分析
  - 响应比计算
    - 响应比 = (等待时间 + 执行时间)/执行时间
  - 调度特点
    - 短进程优先执行提高吞吐量
    - 长进程响应比随等待时间增加而提高
    - 避免进程无法调度情况

35.A
- 进程优先级调整分析
  - 时间片用完时应降低优先级
  - I/O完成后应提高优先级
  - 长期就绪应提高优先级防饥饿
  - 不应在进入就绪队列时降低优先级

36.B
- 高响应比优先算法特点
  - 响应比计算方式
    - 响应比 = (等待时间 + 执行时间)/执行时间
  - 算法优点
    - 满足短任务优先
    - 避免饥饿现象
  - 其他算法对比
    - 先来先服务和时间片轮转不满足短任务优先
    - 非抢占式短任务优先会产生饥饿

37.B
- P2比P1晚5ms到达
- P1先占用CPU
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83659d0237d7fa021ae515f02785544f96cbd48252e57ba146cc3528093a6745.jpg)

38.C
- CPU调度时机分析
  - 可以调度的情况
    - 中断发生
    - 进程抢占
    - 主动放弃CPU
  - 临界区进程调度
    - 可能因中断或抢占导致调度
    - 请求等待资源时主动放弃CPU

39.B
- 进程优先级设置考虑因素
  - 综合考虑CPU时间和I/O时间
  - I/O型作业优先级高于计算型作业
  - 原因
    - I/O操作需及时完成
    - 提高系统资源利用率

40.A
- 调度算法饥饿现象分析
  - 静态优先级调度
    - 高优先级任务持续存在导致低优先级任务饥饿
  - 短任务优先调度
    - 新短任务持续到达导致长任务饥饿

41.B
- CPU、输入设备、输出设备各一个
- 操作步骤不能重叠
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e184e9d5555a33a5f5c7fc161f2c48ba9e0c8616e9f6f67760b2213ad0a36eb.jpg)

42.D
- 系统t=2时开始作业调度
  - J4尚未到达
  - FCFS选择J1(最早到达)
  - SF选择J3(运行时间最短)

43.B
- 进程切换与时间片分析
  - 进程切换开销
    - 切换次数越多开销越大
  - 时间片用完处理
    - 执行态变为就绪态
  - 时钟中断作用
    - 确定时间间隔
    - 实现延时和超时
  - 时间片大小确定
    - 考虑响应时间
    - 考虑系统开销
    - 考虑进程数量和运行时间

44.D
- 进程执行顺序：P2→P3→P1
- 周转时间计算
  - P2: 1+15+24=40μs
  - P3: 18+1+24+1+36=80μs
  - P1: 30+1+24+1+36+1+12=105μs
- 平均周转时间=(40+80+105)/3=75μs

45.C
- 多级反馈队列调度分析
  - 进程入队情况
    - P1、P2依次创建后进入Q1队列
    - 根据时间片调度规则分配10ms CPU时间
    - 两进程执行完一个时间片后转入Q2队列
  - Q2队列调度
    - 采用短进程优先调度算法
    - P1剩余需要20ms CPU时间
    - P2剩余需要10ms CPU时间
    - P2优先调度执行完成
    - P1后续执行完成
  - 运行时序图
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f2517f3609a6ea20844f446ccaf3d483bf403874ce12f677cc817a62ecb964ec.jpg)
  - 平均等待时间计算
    - P1等待时间为20ms
    - P2等待时间为10ms
    - 平均等待时间=(20+10)/2=15ms

46.D
- 多级反馈队列调度算法考虑因素
  - 就绪队列数量影响长进程完成时间
  - 就绪队列优先级影响进程执行顺序
  - 各就绪队列调度算法影响队列内调度顺序
  - 进程迁移条件影响各队列执行时间

47.C
- 时钟中断处理程序功能
  - 负责每个时钟周期结束时操作
    - 更新内核时钟变量值
    - 更新当前进程CPU占用时间
    - 更新时间片剩余执行时间
  - 触发条件
    - 系统定时器固定频率产生中断信号
  - 分时系统时间片轮转调度
    - 检查当前进程时间片是否用完
    - 触发进程调度
    - 修改进程控制块信息

48.D
- 进程调度触发条件
  - 中断处理结束后
    - 返回原程序或重新选择程序运行
  - 当前进程阻塞时
    - 放入阻塞队列
    - 就绪队列不空则调度新进程
  - 进程执行结束
    - 释放CPU
    - 从就绪队列选择新进程
  - 进程时间片用完
    - 让出CPU
    - 选择就绪队列队首进程

49.C
- 进程调度过程分析
  - 0ms：P0获得CPU
  - 10ms：P2抢占获得CPU
  - 15ms：P3抢占获得CPU
  - 25ms：P3完成，P2获得CPU
  - 40ms：P2完成，P0获得CPU
  - 130ms：P0完成，P1获得CPU
  - 190ms：P1完成
  - 总调度次数：6次

50.B
- 抢占式优先权调度执行过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5ce44ec6a52390de7ef0f46af9d4cdca3ac3698844daed1aabc53c655285678d.jpg)
- 周转时间计算
  - P1：115-0=115ms
  - P2：75-20=55ms
  - P3：43-30=13ms
  - 平均周转时间=(115+55+13)/3=61ms

# 二、综合应用题  

01.【解答】
- 多级反馈队列调度算法的用户满足度
  - 终端型作业用户
    - 交互型作业较短小
    - 第1级队列时间片内完成即可满意
  - 短批处理作业用户
    - 类似终端型作业处理
    - 第1级队列完成获得相同响应时间
    - 稍长作业在第2、3级队列各执行一个时间片
    - 周转时间仍较短
  - 长批处理作业用户
    - 依次在第1到n级队列运行
    - 按时间片轮转方式运行
    - 避免作业长期得不到处理

02.【解答】
- 混合调度算法实现
  - 类间优先级调度
  - 类内时间片轮转
  - 调度过程
    - 优先级4进程($P_1,P_2,P_3$)时间片轮转
    - 优先级3进程($P_4,P_5$)时间片轮转
    - 优先级2进程($P_6,P_7,P_8$)时间片轮转
  - 抢占规则
    - 高优先级就绪时当前时间片用完后抢占
    - 返回相应优先级队列继续轮转

03.【解答】

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ef893ef15d6e1de3216a2c57af7eb2d6609d06e4a01d3c27eb0ca16bba0ba319.jpg)

- 周转时间计算
  - P1: $T_1 = 80ms$
  - P2: $T_2 = (10+80)ms = 90ms$
  - P3: $T_3 = (40+50)ms = 90ms$
- 系统性能分析
  - 总运行时间: 90ms
  - CPU运行时间: $[(10+10)+20+30]ms = 70ms$
  - 设备运行时间
    - D1: $(30+20+20)ms = 70ms$
    - D2: $(30+40)ms = 70ms$
  - 设备利用率: 70/90 = 77.8%

04.【解答】

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f67c94154c1ba829e653cbd7c97cb2a5c9b58b1183c6155f2f66af27c8c8c005.jpg)

- 作业执行顺序分析
  - 时刻40: C释放CPU,A获得CPU
  - 时刻60: A释放CPU,B获得CPU
  - 时刻100: B释放CPU,A获得CPU
  - 时刻110: A释放CPU,C获得CPU
  - 时刻130: C释放CPU,B获得CPU
  - 时刻160: B释放CPU,A获得CPU
- 结果分析
  - 最早结束:作业B
  - 最后结束:作业A
  - CPU利用率:180/210 = 85.7%

05.【解答】

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/326cfb4a4eaab7f256c39f71ca3aadd17bb9dee9ffa8e070cc18e4fd20d24dea.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6b71585bcd293f0d842e9b4d5362d4d6850500459a1e0e26d38667a81095cc85.jpg)

- 各算法性能比较
  - FCFS
    - 平均周转时间:13.4
    - 平均加权周转时间:7.26
  - RR
    - 平均周转时间:9.2
    - 平均加权周转时间:2.84
  - SJF
    - 平均周转时间:7
    - 平均加权周转时间:1.74
  - 非剥夺式优先级
    - 平均周转时间:12
    - 平均加权周转时间:6.36

> attention 
SJF的平均周转时间肯定是最短的,计算完毕后可以利用这个性质进行检验

06.【解答】

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ff950fb4fde5db3fce685e9f3c111df0b7aabc6aa6464cc0cdfa05e3e382466f.jpg)

- 作业调度过程
  - 8:00: 作业1进入内存并占用CPU
  - 8:20: 作业2调入内存并抢占CPU
  - 8:30: 作业3到达但内存已满
  - 8:50: 作业2完成,作业4调入
  - 9:10: 作业1完成,作业3调入
- 性能分析
  - 平均周转时间:(70+30+90+90)/4 = 70min

07.【解答】

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/421ad1acda74828e18f0e500ffdb6ee7ed146b3b1971cb99c8d024dc653aad95.jpg)

- 可抢先式短进程优先调度过程
  - 时刻0: P1开始运行
  - 时刻1: P2抢占运行
  - 时刻2-3: P3,P4到达等待
  - 时刻5: P2完成,P4运行
  - 时刻10: P4完成,P1运行
  - 时刻17: P1完成,P3运行
  - 时刻26: P3完成
  - 平均周转时间:13s

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/962f5ccddc9d36e16df793806837b447ba0507e65106e848a32960e8987aaae2.jpg)

- 时间片轮转调度过程
  - 就绪队列顺序:P2,P3,P1
  - 平均周转时间:19.25s

08.【解答】
- 时间片轮转调度算法特点
  - 就绪进程按到达时间排队
  - 选择队首进程运行一个时间片
  - 使用完时间片必须交出处理器
  - 由时钟中断产生的绝对可抢先算法

- 时间片长短影响
  - 过长
    - 退化为先来先服务算法
  - 过短 
    - 进程切换过于频繁
    - 系统开销增大
  - 合适大小
    - 保证好的响应时间
    - 维持较高系统效率

- 题目分析
  1）时钟中断开销计算
    - 每秒120个中断,间隔8.3ms
    - 中断处理耗时500μs
    - 开销比例为6%

  2）进程切换开销计算
    - 每次切换需3ms(调度1ms+切换2ms)
    - 24个时钟为一个时间片(200ms)
    - 切换开销比例为1.5%

  3）优化建议
    - 减少时钟中断次数(120→100次/秒)
    - 增加时间片中断数(24→36个)
    - 减少中断处理时间(500μs→400μs)
    - 优化后总开销约4.8%

09.【解答】
- 作业调度过程
  - 8:00: J₁开始运行
  - 10:00: J₁完成,计算响应比
    - J₂: (90+40)/40 = 3.25
    - J₃: (60+25)/25 = 3.4
    - J₄: (30+30)/30 = 2
    - 选择J₃运行
  - 10:25: J₃完成,计算响应比
    - J₂: (115+40)/40 = 3.875
    - J₄: (55+30)/30 = 2.83
    - 选择J₂运行
  - 11:05: J₂完成,J₄开始运行
  - 11:35: J₄完成

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/258457c8bb1d8ced89c0b804d27f5e9ac44d6944723e8869d091c432ec4665f6.jpg)

- 执行结果
  - 执行顺序:J₁→J₃→J₂→J₄
  - 周转时间:120min,155min,85min,125min
  - 平均周转时间:121.25min

10.【解答】
- 作业调度过程分析

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91e1a17245db07be29c806177e0f7c5dd1e1a531a76e63b225f561719e19bec3.jpg)

- 调度时间线
  - 10:00: J₁调入并执行
  - 10:10: J₂调入,J₁继续执行
  - 10:35: J₁结束,J₄调入并执行
  - 10:55: J₄结束,J₃调入,J₂执行
  - 11:25: J₂结束,J₅调入并执行
  - 11:55: J₅结束,J₃执行
  - 12:40: J₃结束

- 执行结果
  1）各作业执行时间段
    - J₁: 10:00-10:35
    - J₂: 10:55-11:25
    - J₃: 11:55-12:40
    - J₄: 10:35-10:55
    - J₅: 11:25-11:55

  2）周转时间
    - 分别为35min,75min,145min,35min,85min
    - 平均周转时间75min

11.【解答】
- 静态优先级问题
  - 高优先级进程长期占用导致饥饿

- 动态优先级解决方案
  - 计算公式:priority = nice + k₁×cpuTime - k₂×waitTime
  - 参数说明
    - k₁,k₂ > 0:调整比例系数
    - cpuTime增加降低优先级
    - waitTime增加提高优先级
  - 避免饥饿
    - 通过waitTime动态调整优先级
    - 保证长等待进程获得执行机会


# 2.3.9 答案与解析  

# 一、单项选择题  

01.D
- 临界资源与临界区概念
  - 临界资源：一次仅允许一个进程使用的共享资源
  - 临界区：访问临界资源的代码段

02.D
- 多道程序中的信号量机制
  - 实现进程同步和互斥的有效工具
  - 进程前趋关系即同步关系
  - 进程并发执行不需信号量控制

03.A
- 信号量特性
  - 特殊整型变量
  - 只能通过初始化和PV操作改变
  - 分类
    - 互斥量
      - 初值通常为1
      - 表示临界区访问控制
      - 值为0：一进程在临界区内
      - 值小于0：有进程等待进入
    - 资源量
      - 初值可为任意整数
      - 表示可用资源数
      - 值小于0：资源耗尽且有等待进程

04.C
- 进程临界区访问规则
  - 允许进程在临界区内被阻塞
  - 其他进程可继续运行
  - 不允许访问被锁定的临界区

05.C
- 互斥资源示例
  - 飞机票为互斥资源
  - 不能同时售给多个旅客

06.D
- 临界区定义
  - 指访问临界资源的代码程序
  - 包括P/V操作、加减锁等
  - 操作系统关注操作过程而非具体操作

07.D
- 同步机制四准则
  - 空闲让进
  - 忙则等待
  - 让权等待
  - 有限等待

08.B
- 临界资源分类
  - 打印机
  - 共享变量
  - 共享缓冲区
  - 非共享数据不属于临界资源

09.B
- 资源类型区分
  - 临界资源：一次只允许一个进程访问
  - 共享资源：可同时被多进程访问
  - 具体分类
    - 磁盘：共享设备
    - 公用队列：临界资源
    - 私用数据：单进程专用
    - 可重入程序代码：可多进程同时使用
10.C
- 同步概念
  - 多进程相互合作关系
  - 并发进程执行异步性
  - 需要保证操作顺序约束
  - 示例:读写进程对缓冲区操作需同步

11.C
- 并发进程制约关系分类
  - 互斥关系
    - 进程竞争独占型资源产生
  - 同步关系
    - 进程协同工作需要交换信息
    - 相互等待产生的制约
  - 本题分析
    - 进程间为同步关系
    - 进程B需等待进程A放入数据
    - 共享缓冲区需互斥访问

12.D
- P、V操作特性
  - 低级进程通信原语
  - 不可被中断

13.C
- P操作特点
  - 等待资源直到可用
  - 资源不可用时进入阻塞态
  - 执行P操作时处于运行态

14.D
- 原语概念
  - 原子性、不可分割操作
  - 由机器指令构成
  - 执行必须连续
  - 执行中不允许中断

15.A
- 管程定义
  - 定义数据结构
  - 定义并发进程可执行操作
  - 操作可同步进程
  - 可改变管程中数据

16.C
- 进程状态转换
  - 只有就绪进程能获得处理器
  - 被唤醒进程不能直接转运行态

17.B
- 互斥信号量操作
  - 初值为1
  - P操作成功减1
  - V操作成功加1

18.D
- 同步信号量初值设置
  - 互斥信号量初值为1
  - 同步信号量根据情况确定
    - 消息未产生时初值为0
    - 消息已存在时初值为正整数

19.C
- 可重入代码特性
  - 多进程任意时刻共享
  - 中断后继续执行结果不受影响
  - 代码不能被修改
  - 允许多进程同时访问

20.D
- 共享程序段要求
  - 必须可重入编码
  - 实现共享功能

21.D
- 互斥锁特性
  - 可用于多线程或多进程
  - 只有加锁者能解锁
  - 其他进程解锁返回错误

22.C
- 死锁产生条件
  - 两线程对不同互斥锁加锁
  - 加锁顺序相反
  - 形成循环等待

23.D
- P、V操作特性
  - 属于原语操作
  - 不可被中断

24.A
- 信号量取值范围
  - 最大值为2(允许两进程进入)
  - 最小值为-1(最多三个申请)
  - 可取值:{2,1,0,-1}

25.B
- mutex值含义
  - 初值为1
  - 一进程进入且无等待时为0
  - 表示等待进入进程数

26.C
- mutex负值含义
  - 一进程进入且有等待时为-1
  - 绝对值等于等待进程数

27.D
- V操作后mutex值
  - 原值小于等于-1
  - 操作后小于等于0

28.C
- 临界区数量
  - 5个并发进程
  - 共5个访问共享变量的代码段

29.C
- 管程组成
  - 共享变量说明
  - 操作过程组
  - 初始化语句

30.C
- 管程signal操作特点
  - 与V操作不同
  - V操作一定改变信号量值
  - signal针对条件变量
  - 无阻塞进程时无影响

31.A
- 记录型信号量S.value含义
  - S.value > 0
    - 表示可用资源数量
    - P操作请求一个资源
  - S.value ≤ 0
    - 表示资源已用完
    - 绝对值表示等待进程数
32.C
- 就绪队列与阻塞队列分析
  - 就绪队列
    - 系统有n个进程
    - 至少有1个进程在运行
    - 就绪队列最多n-1个进程
  - 阻塞队列
    - 正常情况最多n-1个进程
    - 死锁时可达n个进程
    - 因此最多可有n个进程

33.B
- PV操作特性分析
  - 低级进程通信原语
    - 不是系统调用
  - 原子操作
    - P和V操作不可中断
    - 由两个不可中断过程组成

34.C
- 临界资源与临界区概念
  - 临界资源
    - 每次仅允许一个进程访问
  - 临界区
    - 访问临界资源的代码段
  - 错误概念辨析
    - 银行家算法用于避免死锁
    - 公用队列一次只供一个程序使用
    - 私用数据无临界区问题

35.B
- 信号量操作分析
  - 初始状态
    - 28次P操作和18次V操作
    - S-28+18=0
    - 初值为10
  - 最终状态
    - 15次P操作和2次V操作
    - S=10-15+2=-3
    - 3个进程在等待队列

36.B
- 并发执行结果分析
  - x的可能取值
    - A1,B1执行顺序不定
    - x可能为1或-3
  - 输出结果
    - z可能为3或-1
    - c可能为1或9

37.D
- 并发进程关系
  - 执行时间偶然重合
  - 可能无关
  - 可能有交往

38.C
- 信号量取值分析
  - 允许3个进程进入
  - 可能情况
    - 无进程进入:3
    - 1个进程进入:2
    - 2个进程进入:1
    - 3个进程进入:0
    - 3进入1等待:-1

39.C
- Peterson算法分析
  - (1)处为turn=1
  - (2)处为turn=0

40.A
- flag数组功能
  - 标记进入意愿
    - 想进入置true
    - 退出置false
  - 实现互让机制

41.A
- turn变量作用
  - 指示允许进入的线程
  - 进入机制
    - 置为对方编号表示让对方先进
    - 根据turn决定进入顺序

42.B
- 进程并发问题
  - 不仅包括同步互斥
  - 还包括死锁等问题
  - 生产者-消费者解决同步互斥
  - 共享数据对象涉及互斥访问

43.A
- 生产者-消费者问题
  - 缓冲区为空时
    - 消费者被阻塞
    - 等待生产者生产

44.D
- 生产者消费者唤醒机制
  - 共享缓冲区互斥访问
  - 唤醒可能性
    - 生产者可唤醒生产者或消费者
    - 消费者可唤醒生产者或消费者

45.A
- 互斥信号量特性
  - 临界资源同一时间只允许一个进程使用
  - 互斥信号量初值为1

46.B
- 生产者消费者互斥控制
  - 一次只能一个进程进入缓冲区
  - 使用互斥信号量控制
  - 其他申请者被阻塞

47.C
- 读者-写者问题访问规则
  - 写者与写者互斥
  - 写者与读者互斥
  - 读者与读者可同时访问

48.D
- 哲学家就餐问题分析
  - 右撇子情况
    - 所有哲学家先拿右边筷子
    - 等待左边筷子
    - 形成循环等待链
  - 左撇子情况
    - 部分哲学家先拿左边筷子
    - 打破循环等待链

49.C
- 信号量seat分析
  - 桌子有5个位置
  - 最多4位哲学家同时拿左餐叉
  - seat初值为4可防止死锁

50.C
- 进程并发执行分析
  - 初始阶段
    - P1、P2执行到第一个PV操作前相互无关
  - P2执行P(s1)操作
    - 等待P1执行V(s)
    - x=2,y=3,z=4
  - P1执行V(s1)后
    - 在P(s2)上阻塞
    - P2运行到V(s2)
    - x=5,y=3,z=9
  - 最终结果
    - P1继续运行到结束
    - x=5,y=12,z=9

51.B
- 信号量状态分析
  - K>0情况
    - 表示K个资源可用
    - 当前可用资源数为1
  - K<0情况
    - 表示|K|个进程等待
    - 当前等待进程数为0

52.D
- Peterson算法实现分析
  - 算法机制
    - 设置turn变量控制进入顺序
    - 进程先设置自己标志
    - 再设置turn允许对方进入
  - 进入控制
    - 检测对方状态标志和允许标志
    - 保证互斥访问
    - 先到先入,后到等待

53.C
- x值最终结果分析
  - P1进程情况
    - 初始取值可能为1或0
    - 最终写入值可能为2或1
  - P2进程情况
    - 初始取值可能为1或2
    - 最终写入值可能为0或1
  - 最终x可能值为0、1或2

54.C
- 互斥访问需求分析
  - 需要互斥的情况
    - 同一进程内共享变量的写操作
  - 不需要互斥的情况
    - 线程内部局部变量
    - 不同进程的线程代码段
    - 共享变量的读操作

55.B
- TSL指令实现互斥特点
  - 进程状态
    - 无阻塞态进程
    - 等待进程保持运行态
  - 原子性保证
    - TSL本身是原子操作
    - 通过锁住内存总线实现
  - 不需要关中断

56.A
- 管程特性分析
  - 基本组成
    - 数据及其操作组成软件模块
  - 访问控制
    - 数据只能被管程内过程访问
    - 通过调用内部过程访问共享数据
  - 互斥保证
    - 仅允许一个进程执行内部过程

57.B
- 线程执行结果分析
  - x初始值为0
  - thread1和thread2均对x加1
  - 最终x=2的执行顺序有两种可能

58.D
- 条件变量特性分析
  - 基本功能
    - 类似信号量实现进程同步
  - 管程限制
    - 同一时刻只能一个进程执行
  - 操作机制
    - wait()导致进程阻塞
    - signal()唤醒队首进程

59.C
- 进程同步实现方法比较
  - 硬件方法不能实现让权等待
  - Peterson算法满足有限等待
  - 记录型信号量引入阻塞机制

60.C
- 临界区互斥准则
  - 必须遵循的原则
    - 忙则等待
    - 空闲让进
    - 有限等待
  - 非必须原则
    - 让权等待

# 二、综合应用题  

01.【解答】
- 并发进程执行结果分析
  - 两个进程对变量X的操作结果不确定
    - 情况1: P1执行完再执行P2
      - 结果: x=0, y=1, z=1, t=2, u=2
    - 情况2: P1执行到x=1被中断,P2执行完后再执行P1
      - 结果: x=0, y=0, z=0, t=2, u=2
  - 改进方案
    - 使用信号量s控制互斥访问
    
    semaphore s=1 
    process P1{
      int y,z;
      P(S);
      x=1;
      y=0;
      if(x==1)
        y=y+1;
      V(S);
      z=y;
    }
    process P2{
      int t,u;
      P(S);
      x=0;
      t=t+2;
      V(S);
      u=t;
    }
    

02.【解答】
- 仓库互斥访问控制
  - 信号量设置
    - mutex: 控制仓库互斥访问,初值1
    - Sa: 产品A与B可容纳数量差,初值M-1 
    - Sb: 产品B与A可容纳数量差,初值N-1
  - 代码实现
    
    Semaphore Sa=M-1, Sb=N-1
    Semaphore mutex=1
    process A(){
      while(1){
        P(Sa);
        P(mutex);
        A产品入库;
        V(mutex);
        V(Sb);
      }
    }
    process B(){
      while(1){
        P(Sb);
        P(mutex);
        B产品入库;
        V(mutex);
        V(Sa);
      }
    }
    

03.【解答】
- 面包店叫号系统
  - 变量设置
    - i: 当前取号值
    - j: 当前叫号值
    - mutex_i,mutex_j: 互斥信号量,初值1
  - 代码实现
    
    int i=0, j=0
    semaphore mutex_i=1, mutex_j=1
    Consumer(){
      P(mutex_i);
      取号i;
      i++;
      V(mutex_i);
      等待叫号i并购买面包;
    }
    Seller(){
      while(1){
        P(mutex_j);
        if(j<i){
          叫号j++;
          V(mutex_j);
          销售面包;
        }
        else{
          V(mutex_j);
          休息片刻;
        }
      }
    }
    

04.【解答】
- 生产者-消费者问题
  - 信号量设置
    - empty1,empty2: 货架空闲空间,初值10
    - full1,full2: 货架产品数量,初值0
    - mutex1,mutex2: 货架互斥访问,初值1
  - 代码实现
    
    A车间:
    while(1){
      生产一个产品A;
      P(empty1);
      P(mutex1);
      将产品A存放到货架F1上;
      V(mutex1);
      V(full1);
    }

    B车间:
    while(1){
      生产一个产品B;
      P(empty2);
      P(mutex2);
      将产品B存放到货架F2上;
      V(mutex2);
      V(full2);
    }

    装配车间:
    while(1){
      P(full1);
      P(mutex1);
      从货架F1上取一个A产品;
      V(mutex1);
      V(empty1);
      P(full2);
      P(mutex2);
      从货架F2上取一个B产品;
      V(mutex2);
      V(empty2);
      将取得的A产品和B产品组装成产品;
    }
    

05.【解答】
- 水井-水缸问题
  - 信号量设置
    - well: 水井互斥访问,初值1
    - vat: 水缸互斥访问,初值1
    - empty: 水缸剩余空间,初值10
    - full: 水缸中水量,初值0
    - pail: 可用水桶数,初值3
  - 代码实现
    
    老和尚:
    while(1){
      P(full);
      P(pail);
      P(vat);
      从水缸中打一桶水;
      V(vat);
      V(empty);
      喝水;
      V(pail);
    }

    小和尚:
    while(1){
      P(empty);
      P(pail);
      从井中打一桶水;
      V(well);
      P(vat);
      将水倒入水缸中;
      V(vat);
      V(full);
      V(pail);
    }
    

06.【解答】
- 进程控制与信号量设置
  - 三个进程依次使用输入设备的控制
    - 设置信号量S1、S2、S3
      - S1初值为1
      - S2和S3初值为0
    - 无需设置输入设备互斥信号量
  - 数据状态控制
    - 设置信号量Sb、Sy、Sz
      - 表示数据b是否输入
      - 表示yz是否计算完成
      - 初值均为0
  - 代码实现
    P1() {
      P(S1);
      从输入设备输入数据a;
      V(S2);
      P(Sb);
      x=a+b;
      P(Sy);
      P(Sz);
      使用打印机打印出x,y,z的结果;
    }
    P2() {
      P(S2);
      从输入设备输入数据b;
      V(S3);
      V(Sb);
      y=a*b;
      V(Sy);
      V(Sy);
    }
    P3() {
      P(S3);
      从输入设备输入数据c;
      P(Sy);
      z=y+c-a;
      V(Sz);
    }

07.【解答】
- 单向通行控制
  - 信号量设置
    - bridge信号量控制桥的使用
    - 初值为1
  - 代码实现
    semaphore bridge=1
    NtoS() {
      P(bridge);
      通过桥;
      V(bridge);
    }
    StoN() {
      P(bridge);
      通过桥;
      V(bridge);
    }

- 同向多车控制
  - 变量设置
    - countSN:南北方向车辆数
    - countNS:北南方向车辆数
    - 初值均为0
  - 信号量设置
    - mutexSN:计数保护,初值1
    - mutexNS:计数保护,初值1
    - bridge:桥使用控制,初值1
  - 代码实现
    StoN() {
      P(mutexSN);
      if(countSN==0)
        P(bridge);
      countSN++;
      V(mutexSN);
      过桥;
      P(mutexSN);
      countSN--;
      if(countSN==0)
        V(bridge);
      V(mutexSN);
    }
    NtoS() {
      P(mutexNS);
      if(countNS==0)
        P(bridge);
      countNS++;
      V(mutexNS);
      过桥;
      P(mutexNS);
      countNS--;
      if(countNS==0)
        V(bridge);
      V(mutexNS);
    }

08.【解答】
- 互斥访问分析
  - 无法实现互斥访问原因
    - 初始flag数组元素为FALSE
    - 线程0执行时可能被中断
    - 线程1可进入临界区
    - 线程0恢复后也可进入
    - 导致同时访问临界区
  - 根本原因
    - Enter_Critical_Section函数执行非原子性
    - 标志检查和修改不能整体执行

- 死锁分析
  - 死锁产生过程
    - 初始flag数组为FALSE
    - 线程0执行设置flag[0]为TRUE后中断
    - 线程1设置flag[1]为TRUE后被卡住
    - 线程0恢复执行也被卡住
    - 两线程互相等待形成死锁

09.【解答】
- 工人协作控制
  - 生产消费关系分析
    - 工人1与工人3:生产者消费者
    - 工人2与工人3:生产者消费者
    - 共用缓冲区连接
  - 死锁问题分析
    - 箱子空间占满情况
      - 车架占满导致无法放入车轮
      - 车轮占满导致无法放入车架
  - 死锁预防
    - 限制车架数量不超过N-2
    - 限制车轮数量不超过N-1
  - 信号量设置与代码实现
    semaphore empty=N
    semaphore wheel=0
    semaphore frame=0
    semaphore s1=N-2
    semaphore s2=N-1

    工人1() {
      do {
        加工一个车架;
        P(s1);
        P(empty);
        车架放入箱中;
        V(frame);
      } while(1);
    }

    工人2() {
      do {
        加工一个车轮;
        P(s2);
        P(empty);
        车轮放入箱中;
        V(wheel);
      } while(1);
    }

    工人3() {
      do {
        P(frame);
        箱中取一车架;
        V(empty);
        V(s1);
        P(wheel);
        P(wheel);
        箱中取二车轮;
        V(empty);
        V(empty);
        V(s2);
        V(s2);
        组装为一台车;
      } while(1);
    }

10.【解答】
- P,Q构成消费者-生产者关系
  - 设置三个信号量
    - full,empty,mutex
    - full和empty控制缓冲池状态
    - mutex用来互斥进入
  - R既为消费者又为生产者
    - 执行前判断状态
      - empty=1时执行生产者功能
      - full=1时执行消费者功能
  - 信号量初始化
    - semaphore full=0 //表示缓冲区的产品
    - semaphore empty=1 //表示缓冲区的空位
    - semaphore mutex=1 //互斥信号量
  - 代码实现
    Procedure P {
      while(TRUE) {
        if(empty == 1) {
          P(empty);
          P(mutex);
          Product one;
          V(mutex);
          V(full);
        }
      }
    }
    Procedure Q {
      while(TRUE) {
        P(full);
        P(mutex);
        consume one;
        V(mutex);
        V(empty);
      }
    }
    Procedure R {
      while(TRUE) {
        if(full == 1) {
          P(empty);
          P(mutex);
          product one;
          V(mutex);
          V(full);
        }
      }
    }

11.【解答】
- 控制变量与信号量设置
  - waiting记录等候理发的顾客数
    - 初值为0
    - 进来一名顾客时加1
    - 一名顾客理发时减1
  - 信号量customers记录等候理发的顾客数
    - 用作阻塞理发师进程
    - 初值为0
  - 信号量barbers记录等候顾客的理发师数
    - 用作阻塞顾客进程
    - 初值为0
  - 信号量mutex用于互斥
    - 初值为1
  - 变量初始化
    - int waiting=0 //等候理发的顾客数
    - int chairs=n //为顾客准备的椅子数
    - semaphore customers=0,barbers=0,mutex=1
  - 代码实现
    barber() { //理发师进程
      while(1) {
        P(customers); //若无顾客,理发师睡眠
        P(mutex); //进程互斥
        waiting = waiting-1; //等候顾客数少一个
        V(barbers); //理发师去为一名顾客理发
        V(mutex); //开放临界区
        Cut hair(); //正在理发
      }
    }

    customer() {
      P(mutex);
      if(waiting < chairs) { //若有空椅子,就找到椅子坐下等待
        waiting = waiting+1; //等候顾客数加1
        V(customers); //呼唤理发师
        V(mutex); //开放临界区
        P(barbers); //无理发师,顾客坐着
        get haircut(); //一名顾客坐下等待理发
      }
      else {
        V(mutex); //人满,离开
      }
    }

12.【解答】
- 电影院放映管理
  - 基本条件
    - 一次只能放映一部影片
    - 观众有不同爱好
    - 每次只能满足部分观众需求
  - 信号量设置
    - s0,s1,s2分别为三部影片的信号量
    - 初值均为1
    - 互斥使用电影院
  - 计数器设置
    - 三个计数器统计观众个数
    - 初值都是0
    - 需要互斥使用
  - 变量初始化
    - semaphore s=1,s0=1,s1=1,s2=1
    - int count0=0,count1=0,count2=0
  - 代码实现
    //看第一部影片的观众
    P(s0);
    count0 = count0+1;
    if(count0==1)
      P(s);
    V(s0);
    看影片;
    P(s0);
    count0 = count0-1;
    if(count0==0)
      V(s);
    V(s0);

    //看第二部影片的观众
    P(s1);
    count1 = count1+1;
    if(count1==1)
      P(s);
    V(s1);
    看影片;
    P(s1);
    count1 = count1-1;
    if(count1==0)
      V(s);
    V(s1);

    //看第三部影片的观众
    P(s2);
    count2 = count2+1;
    if(count2==1)
      P(s);
    V(s2);
    看影片;
    P(s2);
    count2 = count2-1;
    if(count2==0)
      V(s);
    V(s2);

13.【解答】
- 汽车行驶过程中的同步关系
  - 基本流程
    - 售票员关车门后发开车信号
    - 驾驶员接信号后启动车辆
    - 行驶中售票员售票
    - 到站驾驶员停车
    - 售票员开门让乘客上下车
  - 同步要求
    - 驾驶员启动与售票员关门同步
    - 售票员开门与驾驶员停车同步
  - 信号量设置
    - S1表示是否允许驾驶员启动汽车(初值为0)
    - S2表示是否允许售票员开门(初值为0)
  - 代码实现
    semaphore S1=0,S2=0

    Procedure driver {
      while(1) {
        P(S1);
        Start;
        Driving;
        stop;
        V(S2);
      }
    }

    Procedure Conductor {
      while(1) {
        关车门;
        V(S1);
        售票;
        P(S2);
        开车门;
        上下乘客;
      }
    }

14.【解答】
- 利用信号量实现前驱关系的同步问题
  - 信号量定义
    - 定义进程执行顺序的信号量 a,b,c,d,e,f,g,h 初值均为0
  - 代码实现

CoBegin
process P1() {
  执行P1的任务;
  V(a); //实现先P1后P2的同步关系
  V(b); //实现先P1后P3的同步关系
}

process P2() {
  P(a); //检查P1是否已运行完成
  执行P2的任务;
  V(c); //实现先P2后P4的同步关系
  V(d); //实现先P2后P5的同步关系
}

process P3() {
  P(b); //检查P1是否已运行完成
  执行P3的任务;
  V(e); //实现先P3后P4的同步关系
  V(f); //实现先P3后P5的同步关系
}

process P4() {
  P(c); //检查P2是否已运行完成
  P(e); //检查P3是否已运行完成
  执行P4的任务;
  V(g); //实现先P4后P6的同步关系
}

process P5() {
  P(d); //检查P2是否已运行完成
  P(f); //检查P3是否已运行完成
  执行P5的任务;
  V(h); //实现先P5后P6的同步关系
}

process P6() {
  P(g); //检查P4是否已运行完成
  P(h); //检查P5是否已运行完成
  执行P6的任务;
}
CoEnd


15.【解答】
- 生产者-消费者问题分析
  - 缓冲区设计
    - 每20个字为一个基本单位
    - 缓冲区共有1000/20=50个空位
  - 信号量设置
    - mutex:互斥访问缓冲区,初值为1
    - full:缓冲区已有数据量,初值为0
    - empty:缓冲区空位数量,初值为50
  - 代码实现

semaphore mutex = 1    //互斥使用缓冲区
semaphore full = 0     //表示缓冲区已有多少个20字数据
semaphore empty = 50   //表示缓冲区还有多少个20字空位

process P() {
  P(empty);
  P(mutex);
  get();
  read();
  comp();
  V(mutex);
  V(full);
  print();
}

process P1/P2() {  //P1、P2完全一样
  P(full);
  P(mutex);
  get();
  V(mutex);
  V(empty);
  print();
}


16.【解答】
- 供应者与抽烟者问题分析
  - 同步关系
    - 供应者与3个抽烟者为同步关系
    - 抽烟动作互斥
  - 信号量设置
    - offer1:烟草和纸组合资源
    - offer2:烟草和胶水组合资源
    - offer3:纸和胶水组合资源
    - finish:抽烟完成信号
  - 代码实现

int num = 0
semaphore offer1 = 0  //烟草和纸组合资源
semaphore offer2 = 0  //烟草和胶水组合资源
semaphore offer3 = 0  //纸和胶水组合资源
semaphore finish = 0  //抽烟完成信号

process P1() {  //供应者
  while(1) {
    num++;
    num = num%3;
    if(num == 0)
      V(offer1);    //提供烟草和纸
    else if(num == 1)
      V(offer2);    //提供烟草和胶水
    else
      V(offer3);    //提供纸和胶水
    任意两种材料放在桌子上;
    P(finish);
  }
}

process P2() {  //拥有烟草者
  while(1) {
    P(offer3);
    拿纸和胶水,卷成烟,抽掉;
    V(finish);
  }
}

process P3() {  //拥有纸者
  while(1) {
    P(offer2);
    拿烟草和胶水,卷成烟,抽掉;
    V(finish);
  }
}

process P4() {  //拥有胶水者
  while(1) {
    P(offer1);
    拿烟草和纸,卷成烟,抽掉;
    V(finish);
  }
}


17.【解答】
- 互斥与同步问题分析
  - 互斥资源
    - 缓冲区互斥访问,设置mutex信号量
  - 同步问题
    - P1,P2因奇数同步,设置odd信号量
    - P1,P3因偶数同步,设置even信号量
    - P1,P2,P3共享缓冲区,设置empty信号量,初值为N
  - 代码实现

semaphore mutex = 1     //缓冲区操作互斥信号量
semaphore odd = 0, even = 0  //奇数、偶数进程的同步信号量
semaphore empty = N     //空缓冲区单元个数信号量

cobegin
Process P1() {
  while(True) {
    x = produce();  //生成一个数
    P(empty);       //判断缓冲区是否有空单元
    P(mutex);       //缓冲区是否被占用
    Put();
    V(mutex);       //释放缓冲区
    if(x%2 == 0)
      V(even);      //若是偶数,向P3发出信号
    else
      V(odd);       //若是奇数,向P2发出信号
  }
}

Process P2() {
  while(True) {
    P(odd);         //收到P1发来的信号,已产生一个奇数
    P(mutex);       //缓冲区是否被占用
    getodd();
    V(mutex);       //释放缓冲区
    V(empty);       //向P1发信号,多出一个空单元
    countodd();
  }
}

Process P3() {
  while(True) {
    P(even);        //收到P1发来的信号,已产生一个偶数
    P(mutex);       //缓冲区是否被占用
    geteven();
    V(mutex);       //释放缓冲区
    V(empty);       //向P1发信号,多出一个空单元
    counteven();
  }
}
coend

18.【解答】
- 互斥与同步分析
  - 互斥资源
    - 取号机(一次只有一位顾客领号)
    - 设置互斥信号量mutex
  - 同步问题
    - 顾客与座位同步
      - 需获得空座位等待叫号
      - 空座位有无影响等待顾客数量
      - 设置信号量empty和full
    - 顾客与营业员同步
      - 顾客需等待叫号和服务
      - 设置信号量service完成同步

- 代码实现
semaphore empty = 10  //空座位数量
semaphore mutex = 1   //取号机互斥
semaphore full = 0    //已占座位数量  
semaphore service = 0 //等待叫号

cobegin
Process 顾客i
  P(empty);    //等空位
  P(mutex);    //申请使用取号机
  从取号机上取号;
  V(mutex);    //取号完毕
  V(full);     //通知营业员有新顾客
  P(service);  //等待营业员叫号
  接受服务;

Process 营业员
  while(True) {
    P(full);     //没有顾客则休息
    V(empty);    //离开座位
    V(service);  //叫号为顾客服务
  }
coend

19.【解答】
- 互斥与同步分析
  - 互斥控制
    - 出入口一次仅允许一人通过
    - 设置互斥信号量mutex,初值为1
  - 容量控制
    - 博物馆最多容纳500人
    - 设置信号量empty,初值为500

- 代码实现
semaphore empty = 500  //最大容纳人数
semaphore mutex = 1    //出入口控制

cobegin
参观者进程i:
  P(empty);    //可容纳人数减1
  P(mutex);    //互斥使用门
  进门;
  V(mutex);
  参观;
  P(mutex);    //互斥使用门
  出门;
  V(mutex);
  V(empty);    //可容纳人数增1
coend

20.【解答】
- 生产者消费者问题分析
  - 在标准模型基础上增加条件
  - 需要新增信号量控制

- 信号量设置
  - mutex1:控制消费者进程周期内访问,初值1
  - mutex2:控制单次互斥访问,初值1
  - empty:缓冲区空位数,初值1000
  - full:缓冲区产品数,初值0

- 代码实现
semaphore mutex1 = 1    //生产者互斥
semaphore mutex2 = 1    //消费者互斥
semaphore empty = 1000  //空缓冲区数
semaphore full = 0      //非空缓冲区数

producer() {
  while(1) {
    生产一个产品;
    P(empty);     //判断缓冲区是否有空位
    P(mutex2);    //互斥访问缓冲区
    把产品放入缓冲区;
    V(mutex2);    //互斥访问缓冲区
    V(full);      //产品数量加1
  }
}

consumer() {
  while(1) {
    P(mutex1)     //连续取10次
    for(int i=0; i<10; ++i) {
      P(full);    //判断缓冲区是否有产品
      P(mutex2);  //互斥访问缓冲区
      从缓冲区取出一件产品;
      V(mutex2);  //互斥访问缓冲区
      V(empty);   //腾出一个空位
      消费这件产品;
    }
    V(mutex1);
  }
}

21.【解答】
- 生产者-消费者问题分析
  - A和B既是生产者又是消费者
  - 需要互斥访问信箱
  - 需要同步控制邮件收发

- 信号量设置
  - 互斥信号量
    - mutexA:A信箱互斥访问
    - mutexB:B信箱互斥访问
  - 同步信号量
    - Full_A:A信箱中邮件数量
    - Empty_A:A信箱可存放邮件数量
    - Full_B:B信箱中邮件数量
    - Empty_B:B信箱可存放邮件数量

- 代码实现
semaphore Full_A = x;
semaphore Empty_A = M-x;
semaphore Full_B = y;
semaphore Empty_B = N-y;
semaphore mutexA = 1;
semaphore mutexB = 1;

Cobegin
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c34afd5dd317c3bf84208a7f1bf2c7e6c0aef00f832b17458d72b59a033a236d.jpg)
Coend

22.【解答】
- 互斥访问分析原则
  - 全局变量互斥访问
    - 只有全局变量需要互斥访问
    - 局部变量不需要互斥访问
  - 进程间互斥关系
    - 需明确具体进程对变量的互斥
    - 不同互斥关系影响并发度

- 本题分析
  - 全局变量
    - x,y,z需要互斥访问
    - 线程1:访问x,y(只读)
    - 线程2:访问y,z(只读)
    - 线程3:访问y,z(读写)
  - 互斥关系
    - 读写互斥原则
      - 读-读不需互斥
      - 读-写需互斥
      - 写-写需互斥

- 代码实现
semaphore mutex_y1 = 1;  //线程1,3对y互斥
semaphore mutex_y2 = 1;  //线程2,3对y互斥
semaphore mutex_z = 1;   //线程2,3对z互斥

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a108dd5c9d2dd333f7bd6a4e4cdbd06c4d6bbe6bbad161311259089d307f081.jpg)

23.【解答】
- 哲学家就餐问题分析
  - 传统问题回顾
    - n名哲学家、n根筷子
    - 限制n-1名哲学家同时抢筷子可避免死锁
  - 本题解决方案
    - 用碗作为限制资源
      - 当m < n时,碗资源量为m
      - 当m ≥ n时,碗资源量为n-1 
    - 碗的资源量 = min{n-1, m}
  - 代码实现
    - 信号量定义
      
      semaphore bowl;        //用于协调哲学家对碗的使用
      semaphore chopsticks[n];//用于协调哲学家对筷子的使用
      
      for(int i=0; i<=n; i++)
        chopsticks[i] = 1;   //设置筷子数量
      bowl = min(n-1,m);     //设置碗数量
      
    - 哲学家进程
      
      CoBegin
        while(TRUE) {
          思考;
          P(bowl);           //取碗
          P(chopsticks[i]);  //取左筷子
          P(chopsticks[(i+1)%n]); //取右筷子
          就餐;
          V(chopsticks[i]);
          V(chopsticks[(i+1)%n]);
          V(bowl);
        }
      CoEnd
      

24.【解答】
- 信号量实现前驱关系分析
  - 执行顺序分析
    - A、B、D无前提条件
    - C需要A、B完成
    - E需要C、D完成
  - 同步关系
    - A→C和B→C
    - C→E和D→E
  - 信号量设置
    - SAC=0:控制A和C
    - SBC=0:控制B和C  
    - SCE=0:控制C和E
    - SDE=0:控制D和E

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6071d447087679f8c154d16afa062c18fee579acef410d9d18ccc5d9d6081ea7.jpg)

- 代码实现
  
  CoBegin
    A() {
      完成动作A;
      V(SAC);
    }
    B() {
      完成动作B;
      V(SBC);
    }
    C() {
      P(SAC);
      P(SBC);
      完成动作C;
      V(SCE);
    }
    D() {
      完成动作D;
      V(SDE);
    }
    E() {
      P(SCE);
      P(SDE);
      完成动作E;
    }
  CoEnd
  

25.【解答】
- 信号量S特性分析
  - 多进程共享变量
  - wait()和signal()需互斥访问
- 方法分析
  - 方法1错误
    - 关中断后死循环
    - 其他进程无法修改S
  - 方法2正确
    - 循环中开中断
    - 允许其他进程修改S
- 用户程序限制
  - 不能使用开/关中断指令
  - 开关中断是特权指令
  - 只能在内核态执行

26.【解答】
- 前驱关系同步分析
  - 进程执行顺序
    - T1:A→E→F
    - T2:B→C→D
  - 同步关系
    - A→C:A完成后C执行
    - C→E:C完成后E执行
  - 信号量实现
    - SAC:控制A和C同步
    - SCE:控制C和E同步

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d63b0eb93e3e5de4d538ca762504d8f7c410c2ed43cc086a6fb06a5ce4da24c5.jpg)

27.【解答】
- 临界区互斥实现分析
  - if语句问题
    - 无法实现互斥访问
    - 需要使用while循环
  - 代码修改
    - 进入区:"while(key=TRUE)swap(key,lock)"
    - 退出区:"lock=FALSE"
- newSwap()并发问题
  - 不能保证原子交换
  - 可能导致多线程同时进入临界区
  - 示例分析
    - 初始lock为FALSE
    - 线程切换导致互斥失效



# 2.4.7 答案与解析  

# 一、单项选择题  

01.C
- 死锁必要条件分析
  - 4个必要条件：互斥、占有并等待、非剥夺和循环等待
  - 循环等待可能导致死锁
  - 不会导致死锁的情况
    - 进程释放资源
    - 进程自己进入死循环(只产生饥饿)
    - 共享型设备允许多进程使用
  - 死锁需要两个以上进程,饥饿可由一个进程导致

02.C
- 哲学家就餐问题分析
  - 信号量机制
    - 可确保临界资源互斥访问
    - 不能完全避免死锁
  - 同时检查两支筷子方法
    - 可预防死锁
    - 会导致资源浪费
    - 不会导致饥饿
  - 限制拿起筷子的哲学家数量
    - 破坏"循环等待"条件
    - 是正确的解决方案
  - 按编号顺序拿筷子
    - 破坏"循环等待"而非"互斥"条件

03.C
- 死锁条件破坏分析
  - 进程执行优先级不能破坏死锁必要条件
  - A项可破坏请求并保持条件
  - B项可破坏互斥条件
  - D项可破坏循环等待条件

04.B
- 一次性资源分配方法分析
  - 原理
    - 进程需要时一次性提出所有请求
    - 全部满足则分配,否则不分配任何资源
  - 优点
    - 打破死锁必要条件
    - 预防死锁
  - 缺点
    - 资源利用率低
    - 可能造成进程"饥饿"

05.A
- 系统死锁原因分析
  - 时间上原因
    - 进程推进顺序不当
    - 调度时机不合适
  - 空间上原因
    - 独占资源分配不当
    - 互斥资源部分分配且不可剥夺
  - 系统资源不足
    - 不是死锁直接原因
    - 只会造成"饥饿"

06.D
- 死锁避免定义
  - 在资源动态分配过程中使用算法限制
  - 防止系统进入不安全状态
  - 避免死锁发生

07.D
- 死锁预防策略分析
  - 资源有序分配可限制循环等待
  - A项为不安全状态判断
  - B项破坏占有请求条件
  - C项破坏非剥夺条件

08.C
- 死锁预防方法分析
  - PV操作不能破坏死锁条件
  - 可能加强互斥和占有并等待条件
  - C项可破坏请求并保持条件
  - D项只能检测不能防止死锁

09.B
- 资源数量与死锁关系分析
  - 9个资源时
    - 三个进程各占三个资源
    - 会发生死锁
  - 10个资源时
    - 至少一个进程能获得4个资源
    - 可顺利执行完成

10.B
- 磁带机分配问题分析
  - 极端情况分析
    - 每个进程已分配两台
    - 只需再分配一台即可满足最大需求
  - 计算方法
    - 满足 $2X+1=11$
    - 解得 $X=5$
    - 或使用死锁公式 $m>n\times(w-1)$
    - 得到 $n<5.5$
  - 结论：最多可并发5个进程不会死锁

11.A
- 死锁可能性分析
  - A项每进程只申请一个资源
    - 破坏请求并保持条件
    - 不会发生死锁
  - 使用死锁公式 $m>n\times(k-1)$
    - B、C、D项均可能死锁

12.D
- 解除死锁方法
  - 剥夺资源法
    - 挂起死锁进程
    - 抢占其资源分配给其他进程
  - 撤销进程法
    - 强制撤销部分或全部死锁进程
    - 剥夺这些进程的资源

13.B
- 死锁解除策略比较
  - 资源剥夺法和撤销进程
    - 都破坏"请求和保持"条件
    - 可解除死锁
  - 拒绝分配新资源
    - 只能维持死锁现状
    - 无法解除死锁

14.B
- 死锁处理算法分类
  - 银行家算法：死锁避免
  - 死锁检测算法：死锁检测
  - 资源分配图化简法：死锁检测
  - 资源有序分配算法：死锁预防

15.C
- 资源分配死锁分析
  - 每个进程分得一个资源
  - 剩余一个资源可满足任意进程
  - 进程可顺利完成并释放资源
  - 不会发生死锁

16.D
- 资源分配图表示规则
  - 申请边：进程指向资源的有向边
  - 分配边：资源指向进程的有向边
  - 矩形框表示资源,圆点表示资源数目
  - 圆圈节点表示进程

17.B
- 死锁预防条件分析
  - 破坏互斥条件
    - 某些资源必须互斥使用
    - 不太可行
  - 其他三个条件
    - 都可以实现预防

18.D
- 系统状态与死锁关系
  - 不安全状态与死锁状态关系
    - 不是所有不安全状态都是死锁状态
    - 可能进入死锁状态
  - 安全状态特点
    - 可避免进入死锁状态
  - 死锁状态必定是不安全状态

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9800216567480688eacd396758c4382c465cb4563cafd65c194dee558db77e78.jpg)

19.A
- 死锁检测方法
  - 资源有向图法和资源矩阵法
  - 前驱图、搜索树、安全图不适用
- 死锁避免和检测的区别
  - 避免是预防死锁发生
  - 检测是发现已出现的死锁

20.D
- 不会导致死锁的情况分析
  - 主动释放资源不会死锁(破坏请求并保持条件)
  - 颠簸是页面调度问题
  - 回退不等于回到之前状态
  - 进程过于"慷慨"导致饥饿

21.C
- 环路与死锁关系分析
  - 有环路只是循环等待必要条件,不一定死锁
  - 无环路一定不会死锁
  - 每种资源只有一个且有环路是死锁充分条件
  - 进程有请求边时,资源充足则不会死锁

22.D
- 死锁相关概念正确性分析
  - 资源分配图表示方法正确
  - 资源使用不当和进程推进顺序不当是死锁原因
  - 有序分配可避免循环等待
  - 资源剥夺和进程撤销都破坏请求并保持条件

23.B
- 单行线问题分析
  - 程序结构
    - 信号量y控制单行线
    - 信号量x1、x2控制车辆数修改
  - 可能出现的问题
    - 一方占据后持续通行
    - 另一方长期等待
  - 结论
    - 不会死锁
    - 会出现饥饿

24.C
- 并发程序执行结果分析
  - 执行顺序可能性
    - 1→2→3→4→5→6→7→8
    - 1..2→5→6→3→4→7→8
    - 5→6→7→8→1→2→3→4
    - 5→6→1→2→7→8→3→4
  - 结果特点
    - x只能是0或1
    - t=u=2必定成立
    - y=z只有0,1两种情况
    - 总共3种结果

25.C
- 资源使用规则
  - 进程获得资源后只能自行释放
  - 系统不能剥夺

26.C
- Need矩阵计算与安全状态分析
  - Need = Max - Allreduce
  - 四种Available情况分析
    - (1,4,0):安全状态
    - (0,6,2):非安全状态
    - (1,1,1):非安全状态
    - (0,4,7):非安全状态

27.C
- 死锁定理用途
  - 用于检测死锁

28.C
- 银行家算法资源分配原则
  - 进程申请最大资源数≤m
  - 极端情况分析
    - n-1个进程申请1个资源
    - 1个进程申请m个资源
    - 总需求量为m+n-1

29.D
- 银行家算法核心思想
  - 保证至少一个进程可获得全部所需资源
  - 确保存在安全序列
  - 避免死锁发生

30.C
- 银行家算法要求
  - 预先声明最大需求量
  - 请求量不超过最大需求量
  - 分配条件
    - 已占有+申请≤最大需求
    - 现存资源满足需求

31.D
- 解除死锁方法
  - 撤销死锁进程
  - 剥夺死锁进程资源
  - 降低优先级无效

32.C
- 打印机分配问题分析
  - 极端情况
    - 每进程占2台打印机
    - 8台打印机分给4个进程
  - 死锁公式推导
    - M≤K×(R-1)
    - 8≤K×(3-1)
    - K≥4
    - 最小K值为4

33.D
- 分析方法
  - 排除法逐个代入分析
    - 剩余资源分配给P1
    - P1执行完后可用资源为(2,2,1)
    - 仅能满足P4需求,排除A、B
    - P4执行完后可用资源为(2,2,2)
    - 无法满足任何进程需求,排除C
  - 银行家算法求解(对选择题过于复杂)

34.D
- 求解步骤
  - 计算需求矩阵Need与可利用资源向量Available
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/049aa6f4cc7b1c2ea6af14f2184881a993af86dd4838e1f9b7cf7c3c76abb5ac.jpg)
  - 初始分析
    - P1与P3可满足需求,排除A、C
    - 尝试分配给P1
      - P1完成后Available为(6,3,6)
      - 无法满足P0需求,排除B
    - 尝试分配给P3
      - P3完成后Available为(4,3,7)
      - 可满足其他所有进程需求
      - P3开头的所有序列都是安全序列

35.B
- 银行家算法分析
  - 是避免死锁的方法,选项A、D错
  - 根据下图,选项B对,选项C错
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8e371671a0668acb751a3a18c41168d4704c02bbc49c359573e921758d2aea1a.jpg)

36.B
- 死锁分析
  - 根据死锁公式
    - 资源数量>各进程所需资源数-1的总和时不发生死锁
    - 三个进程需要3,4,5台设备
    - 资源数量>(3-1)+(4-1)+(5-1)=9时不发生死锁
  - 临界情况分析
    - 9台设备时会死锁
      - 第一个进程分2台
      - 第二个进程分3台 
      - 第三个进程分4台
    - 10台设备可避免死锁
      - 最后1台分给任意进程都可执行完成

37.B
- 死锁处理策略
  - 三种策略
    - 死锁预防
    - 死锁避免
    - 死锁检测和解除
  - 分析判断
    - I分析
      - 前半句属于死锁预防范畴
      - 银行家算法不给出固定申请顺序
    - II、III正确
      - 银行家算法检查安全状态
      - 死锁检测不关心总资源量

38.C
- 资源分配图分析
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/341b307ebd835cb397f3076f00cf27652faddcdc6394e974922984b8480f02a4.jpg)
  - 循环等待分析
    - 至少需3个进程形成环路
    - 两种情况会形成循环等待
      - P1、P2、P3分别拥有R1、R2、R3
      - P1、P2、P3分别拥有R2、R3、R1
  - 死锁进程数分析
    - P4已获取R2:死锁进程数为3
    - P4未获取R2:死锁进程数为4
    - 最少死锁进程数为3

39.A
- 资源分配分析
  - 最后一个同类资源分配情况
    - 分给P1或P2无法正常执行
    - 分给P3执行完成后
      - 释放资源仍无法使P1、P2执行
      - 不存在安全序列

40.B
- 死锁处理分析
  - I正确:剥夺进程资源可解除死锁
  - II正确:死锁预防最严苛,可确保不死锁
  - III错误:银行家算法不能判断是否死锁
  - IV正确:简化资源分配图可检测死锁

41.B
- 需求矩阵计算
$
\mathrm{Need}=\mathrm{Max}-\mathrm{Allocation}=\left[\begin{array}{l l}{4}&{4}\\ {3}&{1}\\ {3}&{4}\end{array}\right]-\left[\begin{array}{l l}{2}&{3}\\ {2}&{1}\\ {1}&{2}\end{array}\right]=\left[\begin{array}{l l}{2}&{1}\\ {1}&{0}\\ {2}&{2}\end{array}\right]
$
- 安全序列分析
  - 初始只能满足P2需求,A错误
  - P2完成后Available(3,1),满足P1
  - P1完成后Available(5,4),满足P3
  - 安全序列为P2,P1,P3,B正确

42.C
- 死锁条件分析
  - 极端情况
    - n个临界资源:每进程占1个会死锁
    - n+1个临界资源:至少1进程可获2个
  - 死锁公式分析
    - $m > n(r-1)$
    - 代入数据:$m > n(2-1)$
    - 需要$m ≥ n+1$避免死锁

43.B
- 安全序列分析
  - 初始可用资源<1,3,2>
    - 只能满足P0需求<0,2,1>
  - P0执行完后
    - 可用资源变为<3,3,3>
    - 可满足P1或P2
  - 两种安全序列
    - P0,P1,P2
    - P0,P2,P1

# 二、综合应用题  

01.【解答】

- 死锁处理方法
  - 4种处理方法：忽略、检测与恢复、避免和预防
  - 处理方法从宽到严，系统并发性由大到小
  - 银行家算法属于避免死锁
  - 资源预分配属于预防死锁
  - 并发性排序：死锁检测方法、银行家算法、资源预分配法

02.【解答】

- 系统死锁分析
  - 会发生死锁的原因
    - 两个账户加锁操作可分割进行
    - P1先锁A再申请B，P2先锁B再申请A，形成死锁
  - 解决方案
    - 资源顺序分配法：按编号从小到大加锁
    - 资源预分配法：一次性申请所有资源

03.【解答】

- 死锁产生场景分析
  - 可能的死锁情况
    - P1获得R1后P2获得R2
    - P1再申请R2被阻塞形成死锁
  - 死锁产生原因
    - 竞争资源
    - 进程推进顺序非法
  - 死锁必要条件
    - 互斥条件
    - 请求并保持条件
    - 不剥夺条件
    - 环路等待条件

04.【解答】

- 死锁避免条件
  - 至少一个进程能获得全部资源并执行完毕
  - 数学表达式：$m{\geqslant}n(k-1)+1$
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c3d506abade50ee94dea9e941ce3871d05d8016cec9e6a7c7c41fb41bb49b30c.jpg)

05.【解答】

- 死锁可能性分析
  - 可能发生死锁的情况
    - P1占有S1申请S3
    - P2占有S2申请S1
    - P3占有S3申请S2
  - 解决方案
    - 采用静态分配：避免占有并等待
    - 采用按序分配：避免循环等待
    - 采用银行家算法：保证系统安全状态

06.【解答】

- T0时刻安全性分析
  - 存在安全序列{P2,P3,P4,P1}
  - 系统状态安全
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b775b65647bfc84efc6dbf5834f5029f8e881cb9da2feba7f872f5e9e526481.jpg)

- P1请求资源分析
  - Request(1,0,1)≤Need(2,2,2)
  - Request(1,0,1)≤Available(2,1,2)
  - 试分配后系统不安全
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/55949f6ab9c884c20713ff78e266be831085c51c55c8a3120148c01b13d7e1be.jpg)

- P2请求资源分析
  - Request2(1,0,1)≤Need2(2,0,2)
  - Request(1,0,1)≤Available(2,1,2)
  - 试分配后系统安全
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dcb74b3b9f0447fafcd746b91f3178db6abb059903d85f208a05504451a52a2f.jpg)
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/290d444863c808336d069517bc45d1aaf100f4bde05966c42013e3ff6531ee55.jpg)

- 两请求同时满足分析
  - 未立即进入死锁状态
  - 进程未提出新资源申请
  - 进程未进入阻塞态
  - 只有全部进程阻塞才是死锁状态
07.【解答】

- Need矩阵计算
  - Need = Max - Allocation
  $
  \operatorname{Ned}=\operatorname{Max}-\operatorname{Allconduction}={\left[\begin{array}{l l l l}{0}&{0}&{1}&{2}\\ {1}&{7}&{5}&{0}\\ {2}&{3}&{5}&{6}\\ {0}&{6}&{5}&{6}\end{array}\right]}-{\left[\begin{array}{l l l l}{0}&{0}&{1}&{2}\\ {1}&{0}&{0}&{0}\\ {1}&{3}&{5}&{4}\\ {0}&{0}&{1}&{4}\end{array}\right]}={\left[\begin{array}{l l l l}{0}&{0}&{0}&{0}\\ {0}&{7}&{5}&{0}\\ {1}&{0}&{0}&{2}\\ {0}&{6}&{4}&{2}\end{array}\right]}
  $

- 系统安全性分析
  - Work向量初始化为Available(1,5,2,0)
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/912f0764235e6b934ff9b996cee4f05e643eb99ad2c44651ba70d03725438ee8.jpg)
  - 存在安全序列 $\mathrm{<}\mathrm{P_{0}},\mathrm{P_{2}},\mathrm{P_{1}},\mathrm{P_{3}}>$
  - 系统处于安全状态

- P1资源请求分析
  - Request $(0,4,2,0)\!<\!\mathrm{Ned}_{1}(0,7,5,0)$
  - Request $\mathbf{\Phi}_{1}(0,4,2,0)\,{<}\,\mathrm{Available}(1,5,2,0)$
  - 试分配后Available $(1,1,0,0)$
  - 系统状态变化如下
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/622242b62b9138e5e7aac0743a0fe10367e86d851c3e3a908653595b278be562.jpg)
  - 安全性分析结果
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8b9cced82868243d76a5fb0b0f0958943f434a1b0b91ad0c228c07f2936e44a8.jpg)
  - 存在安全序列 $\mathrm{<}\mathrm{P_{0}},\mathrm{P}_{2},\mathrm{P}_{1},\mathrm{P}_{3}\mathrm{>}$
  - 系统仍处于安全状态
  - P1请求应该立即满足

08.【解答】

- 初始安全状态分析
  - Need矩阵计算
  $
  \mathrm{Ned}=\mathrm{Max}-\mathrm{Allreduce}={\left[\begin{array}{l l l}{0}&{0}&{4}\\ {1}&{7}&{5}\\ {2}&{3}&{5}\\ {0}&{6}&{4}\\ {0}&{6}&{5}\end{array}\right]}-{\left[\begin{array}{l l l}{0}&{0}&{3}\\ {1}&{0}&{0}\\ {1}&{3}&{5}\\ {0}&{0}&{2}\\ {0}&{0}&{1}\end{array}\right]}={\left[\begin{array}{l l l}{0}&{0}&{1}\\ {0}&{7}&{5}\\ {1}&{0}&{0}\\ {0}&{6}&{2}\\ {0}&{6}&{4}\end{array}\right]}
  $
  - Work = Available(1,4,0)可满足P2需求
  - P2结束后Work(2,7,5)可满足其他进程
  - 系统处于安全状态

- 非安全状态分析
  - 初始Work = Available(0,6,2)
  - 可满足P0,P3需求
  - 释放后Work(0,6,7)仅可满足P4
  - P4结束后Work(0,6,8)无法满足剩余进程
  - 系统处于非安全状态

> attention 

- 银行家算法计算分析
  - 系统安全状态计算优化
    - 不需要逐个进程分析
    - 情况一分析
      - 当P₂结束并释放资源时
      - 系统空闲资源可满足任意进程最大需求
      - 无需考虑后续执行顺序
      - 系统处于安全状态
        - 任意分配进程最大需求资源
        - 执行结束释放后空闲资源增加
        - 可继续满足其他进程需求
    
    - 情况二分析  
      - 系统可满足P₀、P₃需求
      - 可直接推进至P₀、P₃执行完成
      - 释放资源后系统出现死锁
        - 此时空闲资源达到最大值
        - 其他推进方式仍会死锁
  
  - 计算简化方法
    - 每步将可满足需求的进程作为集合
    - 同时执行并释放资源
    - 简化银行家算法计算过程

09.【解答】

- 死锁状态分析
  - 初始死锁状态
    - 两个进程执行第一步后
    - P₁和P₂各申请到一个R₁资源
    - 系统进入不安全状态
  
  - 死锁形成过程
    - 情况一
      - P₁占有:一个R₁资源和一个R₂资源
      - P₂占有:一个R₁资源
      - 系统无空闲资源
      - 两进程继续申请资源导致死锁
    
    - 情况二  
      - P₂占有:一个R₁资源和一个R₂资源
      - P₁占有:一个R₁资源
      - 系统无空闲资源
      - 两进程继续申请资源导致死锁

  - 死锁点示例
    - 假定P₁成功执行第二步
    - 资源分配如下图所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2441625f538d0e9674621c268ee5c791ce4448a35dab77f6caa5acae77d96cc7.jpg)

# 3.1.8 答案与解析  

# 一、单项选择题  

01.D
- 内存管理硬件支持
  - A、B项错误
  - C项：编址空间大小由硬件访存能力决定
    - 主要由地址总线宽度决定
  - D项：虚拟内存管理需要硬件和软件支持
    - 请求分页页表机制
    - 缺页中断机构
    - 地址变换机构

02.D
- 内存物理存取速度
  - 由硬件决定,非操作系统管理
  - 操作系统可通过以下方式提高逻辑存取速度:
    - 虚拟内存
    - 缓存技术
  - 不能改变内存物理特性

03.B
- 内存保护实现
  - 需要硬件和软件配合
  - CPU中需设置以下寄存器:
    - 上下限寄存器
    - 重定位寄存器
    - 界地址寄存器
  - 用于记录进程内存合法范围

04.C
- 内存保护特点
  - 是内存管理的一部分
  - 是操作系统任务
  - 必须由硬件实现
  - 需要操作系统和硬件机构合作

05.C
- 硬件地址变换机构应用
  - 用于动态重定位
  - 不需要的情况:
    - 单一连续分配
    - 固定分区分配
  - 需要的情况:
    - 页式存储管理
    - 动态分区分配
    - 页式虚拟存储管理

06.B
- 固定分区分配特点
  - 分区大小在系统启动时确定
  - 不随作业长度变化
  - 分区大小可以不同或相同
  - 确定后不可改变

07.D
- 空闲区合并规则
  - 合并上邻、下邻和回收区为一个空闲区
  - 空闲区数减少一个
  - 仅有上邻或下邻时空闲区数不变

08.C
- 最佳适配算法
  - 寻找满足空间需求的最小空闲分区
  - 可产生最小内存空闲分区
  - 本例选择60KB空闲分区
  - 首地址为$330\mathrm{K}$

09.B
- 段式地址转换
  - 段号为2
  - 首地址为480K
  - 段长度20K > 154
  - 物理地址计算:$480\mathrm{K}+154$

10.D
- 装入方式比较
  - 静态装入:编程阶段计算物理地址
  - 可重定位:装入时转换地址,装入后不可改变
  - 动态重定位:
    - 执行时决定装入地址
    - 可能换出
    - 物理地址可变
    - 通过地址变换机构实现

11.B
- 动态重定位特点
  - 允许程序在内存中移动
  - 系统只有一个重定位寄存器
  - 进程切换时需保存恢复寄存器值
  - 不为每个进程分配重定位寄存器

12.C
- 重定位过程
  - 可重定位装入程序执行重定位
  - 重定位寄存器存放进程基地址
  - 地址变换机构计算物理地址
  - 动态重定位不依赖目标程序

13.B
- 重定位方式比较
  - 动态重定位:
    - 可在加载或运行时修改地址
    - 适应程序位置变化
  - 静态重定位:
    - 只能加载时修改一次
    - 程序位置改变会出错
  - 动态/静态分配与重定位无关

14.A
- 静态重定位应用
  - 只能进行一次地址修改
  - 适用于固定分区方式
  - 不适用情况:
    - 程序位置可能改变
    - 其他三种方案均不适用

15.A
- 地址转换与指令执行速度
  - 需要硬件地址变换结构支持
    - 增设重定位寄存器存放程序在内存中的始址
    - 真实内存地址 = 相对地址 + 重定位寄存器地址
  - 单个重定位寄存器原因
    - 处理器同一时刻只能执行一条指令
    - 多个寄存器成本高且不现实
    - 程序道数无法预估
    - 切换程序时重置寄存器内容即可

16.A
- 可变分区管理中回收空闲区采用拼接技术进行合并

17.A
- 页表地址转换
  - 逻辑地址0对应块号2
  - 页大小4KB
  - 物理地址计算: $2{\times}4\mathrm{K}=8\mathrm{K}=8192$

18.B
- 不同存储管理方式的碎片情况
  - 分页式存储管理:内部碎片
  - 分段式存储管理:外部碎片
  - 固定分区存储管理:内部碎片
  - 段页式存储管理:内部碎片

19.B
- 多进程执行的内存保护机制
  - 页式管理:页地址越界保护
  - 段式管理:段地址越界保护

20.A
- 首次适应法特点
  - 从链首开始顺序查找
  - 找到满足大小要求的分区即分配
  - 剩余空间保留在空闲链中
  - 无需对空闲区链排序
  - 按地址递增顺序链接即可

22.C
- 首次适应算法空闲分区按地址递增排列

23.D
- 内存分配算法分类
  - 基于顺序搜索
    - 首次适应算法
    - 循环首次适应算法
    - 最佳适应算法
    - 最坏适应算法
  - 基于索引搜索
    - 快速适应算法
    - 伙伴系统
    - 哈希算法

24.A
- 页式管理优点
  - 避免连续分配的碎片问题
  - 离散装入提高内存利用率

25.D
- 页表建立特点
  - 由操作系统在程序装入时建立
  - 记录逻辑地址与物理地址对应关系
  - 每个页表项包含物理页框号、有效位等信息

26.A
- 段式存储管理中的共享段表
  - 用于描述多进程共享的段
  - 避免在每个进程段表中重复保存
  - 节省内存空间
  - 便于共享段的更新维护

27.C
- 段表建立原则:每个进程一张段表,每个段对应一个表项

28.C
- 用户物理地址空间特点
  - 总空间减去页表或段表长度
  - 由于表长不确定,空间大小不确定

29.B
- 分页管理对上层透明性
  - 在硬件和操作系统层面实现
  - 对用户、编译系统等不可见

30.D
- 页表实现机制
  - 由专门存储器实现
  - 始址存放在页表基址寄存器(PTBR)
  - 保证地址转换速度

31.C
- 页式存储管理地址转换过程
  - CPU分解虚拟地址为页号和偏移量
  - 通过页表寄存器和MMU转换
  - 拼接得到物理地址
  - 由硬件自动完成

32.B
- 分段定义:用户编程时按逻辑划分的程序段

33.A
- 分段存储管理优势
  - 符合程序逻辑结构
  - 有利于动态链接

34.B、C
- 逻辑地址空间概念
  - 编译后程序的地址范围
  - 用于访问信息的地址单元集合
  - 相对始址"0"的编译地址
  - 也称相对地址

35.D
- 可重入程序特点
  - 通过共享使用同一存储空间
  - 通过动态链接映射程序段
  - 减少程序段调入/调出
  - 减少对换数量

36.A
- 不同存储管理方式特点
  - 分页、分段、段页式
    - 需特定数据结构支持
    - 需硬件支持
    - 成本高
  - 分区存储管理
    - 简单
    - 适合微型设备

37.A
- 动态分区管理特点
  - 系统启动后除操作系统外为大空闲区
  - 按需分配内存给作业
  - 作业完成后回收分区
38.C
- 页面大小与系统开销分析
  - 页面大时
    - 管理页面的页表较少
    - 页内碎片较大
  - 页面小时
    - 管理页面的页表较大
    - 页内碎片较小
  - 需通过计算获得较优页面大小

39.B
- 页面大小确定因素
  - 考虑进程平均大小
  - 考虑页表占用长度
  - 页面等长(取2的整数幂)便于管理

40.A
- 段式存储管理的主要目的
  - 方便编程
  - 分段共享
  - 分段保护
  - 动态链接
  - 动态增长

41.B
- 主存访问特点
  - 以字节或字为单位
  - 需要页内偏移量

42.A
- 单用户连续分配管理特点
  - 仅适用于单用户单任务系统
  - 不适用于多道程序设计

43.A
- 分页存储管理的地址分配
  - 逻辑地址按页分配
  - 物理地址按内存块分配

44.C
- 段式分配访存过程
  - 第一次:查找段表
  - 第二次:访问内存数据
  - 共需2次内存访问

45.B
- 段页式分配访存过程
  - 第一次:查找段表
  - 第二次:查找页表
  - 第三次:访问内存数据
  - 共需3次内存访问

46.B
- 段页式存储管理地址结构
  - 包含段号、段内页号、页内地址
  - 用户只需指定段号位数
  - 地址结构仍为二维

47.B
- 存储管理地址空间维度
  - 分页:一维线性地址空间
  - 分段:二维地址空间
    - 需段名和段内地址

48.C
- 段页式系统划分方式
  - 先划分为段
  - 每段再划分为页

49.A
- 多进程页表管理
  - 页表多数驻留内存
  - 系统设置一个页表寄存器
  - 进程调度时装入页表信息
  - 每进程有独立页表

50.A
- 分段存储管理特点
  - 以段为分配单位
  - 每段连续存储
  - 段长不等
  - 段间可不连续

51.D
- 分段方式可见性
  - 对低级语言程序员可见
  - 对编译器可见
  - 可按逻辑结构划分命名

52.B
- 段页式存储管理特点
  - 结合页式和段式优点
  - 分段管理用户地址空间
  - 分页管理物理存储空间
  - 系统开销较大

53.D
- 碎片产生分析
  - 固定分配产生内部碎片
  - 不固定分配产生外部碎片
  - 固定优先产生内部碎片
  - III、III、IV产生内部碎片

54.C
- TLB与页式存储管理
  - 关闭TLB需两次访存
  - 固定分区有内部碎片
  - 页式对用户透明
  - 不适用静态重定位

55.B
- 地址转换计算
  - 主存容量: $2^{18} = 256\mathrm{KB}$
  - 页面大小: $2^{11} = 2048\mathrm{B}$
  - 主存页数: $2^7 = 128$个
  - 物理地址计算: $2 \times 2048 + 1500 = 5596$

56.D
- 页框地址计算
  - 主存容量:1MB
  - 页框数:256
  - 页框大小:4KB
  - 始址计算: $1 \times 4096 = 4096$

57.D
- 分段与分页目的比较
  - 分段:满足用户需求
    - 实现模块化
    - 实现保护
  - 分页:提高内存利用率
    - 实现离散分配

58.D
- 多级页表设计
  - 逻辑地址空间: $256\mathrm{TB} = 2^{48}\mathrm{B}$
  - 页面大小: $4\mathrm{KB} = 2^{12}\mathrm{B}$
  - 页表项大小:8B
  - 需要4级页表

59.A
- 页表共享机制
  - 不同页表项指向同一页帧
  - 支持可重入代码共享
  - 实现内存"复制"
  - 支持进程间通信

60.A
- 地址越界保护
  - 每个进程拥有独立进程空间
  - 地址越界检查
    - 硬件检查访问权限
    - 允许则执行
    - 否则产生地址越界中断

61.C
- 分段存储管理地址结构
  - 32位地址长度
  - 段号占8位
  - 位移量占24位
  - 最大段长为 $2^{24}\mathrm{B}$

62.B
- 最佳适配算法分析
  - 为作业分配最小满足需求的空闲分区
  - 产生最小的内存空闲分区
  - 主存空间变化过程如图所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9fe0aa92cbdbc5068db750e52efc21a7936e8d1845d0edebce7502dfa412c203.jpg)

- 最大空闲分区为9MB

63.B
- 页表结构分析
  - 页大小为 $2^{10}\mathrm{B}$
    - 页内偏移量占10位
  - 页表项大小为2B
    - 一页可存放 $2^{9}$ 个页表项
    - 页号占9位
  - 页目录结构
    - 页目录号占7位
    - 页目录表至少包含128个表项

64.C
- 程序链接与地址转换
  - 编译链接过程
    - C程序经预处理→编译→汇编→链接
    - 链接前生成可重定位目标文件
  - 地址分配
    - 目标模块逻辑地址从0开始
    - 链接形成完整逻辑地址空间
  - 示例
    - file1.o逻辑地址:0~1023
    - main.o逻辑地址:0~1023
    - 链接后file1.o地址:1024~2047

65.D
- 多级页表特点
  - 不会加快地址变换速度
  - 不会减少缺页中断次数
  - 不会减少页表项字节数
  - 可减少页表连续内存空间

66.D
- 分段系统地址变换过程
  - 从逻辑地址提取段号S和偏移量W
  - 比较段号与段表长度
  - 查询段表获取段长C
  - 计算物理地址E
- 越界判断
  - 段号2段长300
  - 段内地址400超出段长
  - 发生越界异常

67.B
- 内存回收过程
  - 回收60K起始的140KB分区
  - 与相邻分区合并
  - 形成20K起始的380KB分区
  - 剩余3个空闲分区
  - 按分区大小重新排序

68.B
- 段共享机制
  - 通过段表项指向同一物理副本
  - 不同进程中逻辑段号可能不同
  - 共享段物理地址唯一
  - 需确保使用完毕才能删除

69.A
- 地址转换分析
  - 十六进制转二进制对应
  - 地址结构划分
    - 前10位:页目录号
    - 11~20位:页号
    - 21~32位:页内偏移
  - 转换结果
    - 页目录号:081H
    - 页号:101H

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0298e566881cd7f4510cf7dd8ed995956355a620ef2c4dacf77396d3aab213b7.jpg)

70.C
- 最佳适应算法特点
  - 匹配最接近需求的空闲分区
  - 每次分配产生小碎片
  - 容易产生最多内存碎片

71.B
- 多级页表基址寄存器
  - 存放顶级页表起始物理地址
  - 即一级页表起始物理地址

72.C
- 进程共享数据特点
  - 映射同一共享内存段
  - 物理内存位置(页框号)相同
  - 地址空间位置(页号)可不同
  - f1和f2必须相等
# 二、综合应用题  

01.【解答】

- 首次适应算法分析
  - 作业分配过程
    - 96KB作业进入4号空闲分区
    - 20KB作业进入1号空闲分区
    - 200KB作业无法满足分配要求

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c3a4eb1874ec8c83b76398fc26490f3f2d439a3230b26dd7b6054fb349f8907.jpg)

- 最佳适应算法分析
  - 作业分配过程
    - 作业序列分别进入5、1、4号空闲分区
    - 可以满足全部请求

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f48faed61ac067d2d8c6a59434c7ab0545b1a5d201098fbab21d15986d30daee.jpg)

02.【解答】

- 最先适配分析
  - 分配情况如图(a)所示
  - 空闲块情况
    - 第一块：始址290K，大小10KB
    - 第二块：始址400K，大小112KB

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8f0f785b240728845dd0a689a927786ea556313eba22fe5b85d1ebddc5cdb361.jpg)

- 最佳适配分析
  - 分配情况如图(b)所示
  - 空闲块情况
    - 第一块：始址240K，大小60KB
    - 第二块：始址450K，大小62KB

- 80KB申请分析
  - 最先适配可以分配成功
  - 最佳适配无法分配
  - 原因：最先适配保留了高地址大空闲区

03.【解答】

- 地址结构分析
  - 页/段最大个数：$2^5=32$
  - 左图分析
    - 段始址12加偏移586超过段界限
    - 判定为页式变换
  - 右图为段式变换
  - 页大小为2KB

- 物理地址计算
  - 页式地址：$12 \times 2048 + 586 = 25162$
  - 段式地址：$4000 + 586 = 4586$

04.【解答】

- 段表地址转换分析
  - 第0段(0,430)
    - 始址210，段长500
    - 合法地址，物理地址640
  - 第1段(1,10)
    - 始址2350，段长20
    - 合法地址，物理地址2360
  - 第2段(2,500)
    - 始址100，段长90
    - 非法地址(超段长)
  - 第3段(3,400)
    - 始址1350，段长590
    - 合法地址，物理地址1750
  - 第4段(4,112)
    - 始址1938，段长95
    - 非法地址(超段长)
  - 第5段(5,32)
    - 不存在，非法地址

05.【解答】

- 地址结构分析
  - 页面大小1KB：低10位为页内偏移
  - 用户空间32页：高5位为虚页号
  - 主存16页：高4位为物理块号

- 地址转换过程
  - 0AC5H
    - 二进制：000101011000101B
    - 虚页号2映射至物理块4
    - 物理地址12C5H
  - 1AC5H
    - 二进制：001101011000101B
    - 虚页号6不在映射表
    - 产生缺页中断
  - 3AC5H
    - 二进制：011101011000101B
    - 页号14超出范围
    - 产生越界中断

> attention 

当将十六进制地址转换为二进制地址时，我们可能习惯性地写为16位，这是容易犯错的细节。
例如，题中的逻辑地址为15位，物理地址为14位。
逻辑地址0AC5H的二进制表示为000101011000101B，对应物理地址12C5H的二进制表示为 $01\,0010\,1100\,0101\mathrm{B}.$
06.【解答】
- 页面大小与进程总长度计算
  - 页面大小为 $(64/16)\mathrm{KB}=4\mathrm{KB}$
  - 进程共4页,总长度为 $4\times4\mathrm{KB}=16\mathrm{KB}$

- 地址结构分析
  - 页面大小4KB,低12位为页内偏移
  - 主存16块,高4位为主存块号
  - 各页面在内存中的始址
    - 页号0: 1001000000000000B(9000H)
    - 页号1: 0000000000000000B(0000H) 
    - 页号2: 0001000000000000B(1000H)
    - 页号3: 1110000000000000B(E000H)

- 逻辑地址转换
  - (0,0) → (9,0) = 1001 0000 0000 0000B(9000H)
  - (1,72) → (0,72) = 0000 0000 0100 1000B(0048H)
  - (2,1023) → (1,1023) = 0001 0011 1111 1111B(13FFH)
  - (3,99) → (14,99) = 1110 0000 0110 0011B(E063H)

07.【解答】
- 地址转换注意事项
  - 逻辑地址进制转换
    - 十进制:整数除法和求余得页号和偏移
    - 其他进制:转二进制后按地址结构划分

- 页面与地址结构
  - 页面大小64B,页内位移6位
  - 代码段702B,需11页(0~10)

- 地址转换过程
  - 0105(八进制)
    - 二进制:001000101B
    - 页号1,快表命中,页帧号F1
    - 物理地址(F1,5)
  - 0217(八进制)
    - 二进制:010001111B
    - 页号2,快表命中,页帧号F2
    - 物理地址(F2,15)
  - 0567(八进制)
    - 二进制:1 0111 0111B
    - 页号5,页表查找,页帧号F5
    - 物理地址(F5,55)
  - 01120(八进制)
    - 二进制:0010 0101 0000B
    - 页号9,页表查找,页帧号F9
    - 物理地址(F9,16)
  - 02500(八进制)
    - 二进制:0101 0100 0000B
    - 页号21超过最大页号,越界中断

> attention 

根据题中条件无法得知逻辑地址位数，所以在其二进制表示中，其位数并不一致，只是根据八进制表示进行转换。
若已知逻辑地址空间大小或位数，则二进制表示必须保持一致。

08.【解答】
- 页表在主存的访问过程
  - 需访问主存两次
    - 第一次访问页表获取物理地址
    - 第二次根据物理地址访问数据

- 存取时间计算
  - 无快表: $1.5\times2=3\mu s$
  - 有快表(命中率85%): $0.2+1)\times85\%+(0.2+1+1)\times(1-85\%)=1.35\mu s$

09.【解答】
- 不同存储管理方式的访存次数
  - 页式存储管理:2次
  - 段式存储管理:2次
  - 段页式存储管理:3次
  - N级页表:N+1次
  - 有快表且命中:1次

- 有效存取时间计算
  - 85%命中率: $(0.2+1)\times85\%+(0.2+1+1)\times(1-85\%)=1.35\mu s$
  - 50%命中率: $(0.2+1)\times50\%+(0.2+1+1)\times(1-50\%)=1.7\mu s$

10.【解答】
- 位示图与页表分析
  - 系统参数
    - 页大小1KB
    - 主存256KB,共256个盘块
    - 作业长5.2KB,需6页

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7beea1f4e84ca67f163eefb86f268ca31123048b960b5d070bb0855d7a74d28d.jpg)

- 内存碎片计算
  - 最后一页占0.2KB
  - 碎片大小: $1\mathrm{KB}-0.2\mathrm{KB}=0.8\mathrm{KB}$

- 位示图大小计算
  - 64MB内存,4KB页大小
  - 物理盘块数: $64\mathrm{K}\times1\mathrm{K}/4\mathrm{K}=2^{14}$
  - 位示图大小: $2^{14}$位=2KB

11.【解答】
- 页表大小计算
  - 页大小: $2^{12}\mathrm{B}=4\mathrm{KB}$
  - 页表项数: $2^{32}/4\mathrm{K}=2^{20}$
  - 一级页表最大: $2^{20}\times4\mathrm{B}=4\mathrm{MB}$

- 地址转换计算方法
  - 页目录号计算
    - 方法1:逻辑右移22位与3FF按位与
    - 方法2:$\mathrm{LA}/2^{22}$取高10位
  - 页表索引计算
    - 方法1:逻辑右移12位与3FF按位与
    - 方法2:$(\mathrm{LA}/2^{12})\%2^{10}$

- 物理地址计算
  - 代码页面1逻辑地址:0000 8000H
  - 第8个页表项物理地址
    - 页表始址 + 8×页表项字节数
    - 0020 0000H + 8×4 = 0020 0020H

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b4180952128f9338437907466522276c8d43ae459be9ca432abead540f1a61b6.jpg)






# 3.2.11 答案与解析  

# 一、单项选择题  

01.B
- 顺序执行程序缺页中断分析
  - 缺页中断次数等于访问页帧数
  - 页面尺寸增大导致
    - 程序所需页面数减少
    - 缺页中断次数减少

02.B
- 缺页中断处理
  - 由访存指令引起
  - 页面不在内存中时发生
  - 调入所需页面后重新执行访存指令

03.B
- 虚拟存储技术特点
  - 未实际扩充内存和外存
  - 采用技术相对扩充主存

04.B
- 虚拟存储器与非虚拟存储器区别
  - 非虚拟存储器要求
    - 作业全部装入内存
    - 运行过程中一直驻留
  - 虚拟存储器特点
    - 作业不必全部装入
    - 运行时可不驻留内存

05.A
- 存储系统特征对比
  - 虚拟内存特征
    - 多次性
    - 对换性
    - 离散性
  - 传统存储特征
    - 一次性

06.C
- 虚拟存储技术基础
  - 基于程序局部性原理
  - 局部性越好系统效果越好

07.B
- 请求分页与基本分页区别
  - 请求分页采用虚拟技术
    - 运行时无需全部装入
  - 基本分页需要一次性装入

08.C
- 存储保护功能
  - 防止程序间越界访问
  - 保证多程序共享主存安全
  - 确保系统正常运行

09.C
- 页式虚拟存储管理特点
  - 逻辑地址与物理地址不一致
  - 物理地址运行时确定
  - 程序链接必须运行时进行
  - 支持动态链接技术

10.A
- 内存访问机制
  - 程序使用虚拟地址
  - 操作系统负责地址转换

11.D
- 缺页中断次数计算
  - 数组大小 $128\times128$
  - int型数据占4B
  - 每页框存一行数据
  - 每访问一个元素发生缺页
  - 总次数 $128\times128=16384$

12.C
- 缺页中断分析
  - 数组大小 $64\times64$
  - 每页框存两行数据
  - 每访问两个元素发生一次缺页
  - 总次数 $4096/2=2048$

13.B
- 平均访存次数计算
  - TLB命中直接得到物理地址
  - TLB未命中需2次访存
  - 平均次数 $=0.75\times1+(1-0.75)\times3=1.5$

14.D
- CLOCK算法特点
  - 选择最近未使用页面置换
  - 又称NRU算法

15.C
- 页面置换特点
  - 首次访问必然缺页
  - 缺页次数不小于n

16.D
- FIFO算法特点
  - 可能产生Belady异常
  - 页帧数增加时缺页次数变化不定

17.D
- 虚拟存储器容量决定因素
  - 由计算机地址结构决定
  - 与主存外存容量无关
  - 虚拟地址空间为 $2^{32}$B

18.C
- 页表项数量计算
  - 页面大小512B
  - 页内偏移量9位
  - 虚拟地址32位
  - 页号23位
  - 页表项数量 $2^{23}$

19.B
- 地址转换计算
  - 页面大小1KB
  - 页内偏移量10位
  - 页号6位
  - 0A6FH转换过程
    - 逻辑页号2(000010)
    - 页框号11(001011)
    - 物理地址2E6FH

20.D
- 页面大小影响分析
  - 页面越小
    - 页表项数量越多
    - 页表空间越大
    - 缺页率越高
    - 换入换出更频繁
    - 内存利用率更高

21.B
- 虚拟存储器容量特点
  - 实际可用内存扩大到内外存之和
  - 理论上限由地址结构决定
  - 64位系统可达 $2^{64}$B

22.C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6a34f50cb38443a41a05b0d63af2feae963e2152e26a8bd5d38bf37da9b44ff0.jpg)
- LRU置换过程分析
  - 在访问第1、2、4、6、11、17个页面时产生中断
  - 共产生6次中断
23.D
- LRU算法分析
  - 需要记录所有页最近访问时间
  - 涉及排序查找时间最久页面
  - 开销大
  - 需要增加LRU位
  - 选项A是结果,D是原因

24.A
- 页表项合法位作用
  - 显示页面是否在内存中
  - 决定是否发生页面故障

25.D
- 抖动问题
  - 表现为频繁页面调度
  - 所有页面调度策略都不能完全避免

26.C
- 基于局部性原理的虚拟存储管理
  - 装入特点
    - 不必全部装入内存
    - 只需装入当前执行部分
  - 执行过程
    - 缺页时由OS调入所需页面
    - 继续执行程序
  - 优点
    - 扩充地址空间
    - 内存调换代价小

27.B
- 请求分页存储管理特点
  - 解决内存容量不足
  - 基于局部性原理
  - 以时间换空间
  - 间接扩充内存

28.C
- 页面置换算法
  - 根据修改位和访问位选择调出页面

29.B
- 驻留集与工作集关系
  - 驻留集是分配的物理页面集合
  - 工作集是实际访问的页面集合
  - 工作集不一定是驻留集子集
  - 工作集完全包含于驻留集才能避免缺页

30.B
- 平均访存时间计算
  - 计算公式:命中率×快表访问时间+不命中率×(快表访问时间+页表访问时间)+内存访问时间
  - TLB命中率85%时:$0.85{\times}0.2+0.15{\times}(1+0.2)+1=1.35{\upmu}s$
  - TLB命中率50%时:$0.5{\times}0.2+0.5{\times}(1+0.2)+1=1.7{\upmu\mathrm{s}}$

31.D
- 页面置换优化
  - 建立已修改页面链表
  - 延迟写回策略
    - 等待一定数量再集中写回
    - 减少换出开销
  - 重用优化
    - 直接从链表获取
    - 减少换入开销
  - CPU与内存交换速度不影响效率

32.B
- 全局置换特点
  - 不受驻留集大小限制
  - 可从任何页框选择置换

33.B
- 页面置换算法特点
  - FIFO为队列类算法,有Belady现象
  - 堆栈类算法不会有Belady现象

34.B
- 页式虚拟存储管理特点
  - 装入比例10%~30%
  - 不要求连续区域
  - 需要缺页中断处理
  - 需要页面置换
  - 基于页或段调入调出
  - 需要请求机制支持
36.C
- 内存映射文件特点
  - 将文件映射到进程虚拟地址空间
  - 按需加载文件部分
    - 节省空间
    - 方便处理大文件
  - 多进程共享文件实现
    - 通过页表映射到相同物理内存

37.C
- 缺页中断处理流程
  - 寻找空闲物理块
  - 使用页面置换算法决定淘汰页面
  - 调出淘汰页面
  - 调入欲访问页面

38.C
- 页表级数计算
  - 页面大小:4KB,页内偏移12位
  - 虚拟地址48位,虚页号36位
  - 每页表项容量计算
    - 每页容纳页表项数:$4\mathrm{KB}/8\mathrm{B}=512=2^{9}$
    - 需要级数:$36/9=4$级

39.B
- FIFO算法分析
  - 可能产生Belady现象
    - 例:页面走向$1,2,3,4,1,2,5,1,2,3,4,5$
    - 3帧:9次缺页中断
    - 4帧:10次缺页中断
- 最近最少使用法特点
  - 不会产生Belady现象
- 缺页中断规律
  - 页面在内存中不会产生缺页中断

40.D
- 系统状态分析
  - 交换空间磁盘利用率97.7%
  - 其他设备利用率5%
  - CPU利用率20%
  - 判断:物理内存严重短缺

41.B
- 改进CPU利用率方法分析
  - 有效方法
    - 增大内存容量
    - 减少多道程序度数
  - 无效方法
    - 增大磁盘交换区容量
    - 增加多道程序度数
    - 使用更快速磁盘交换区
    - 使用更快速CPU

42.A
- TLB命中率影响因素
  - 增大TLB容量:提高命中率
  - 多级页表:无影响
  - 页面大小
    - 增大:提高命中率
    - 降低:降低命中率

43.D
- 缺页中断处理步骤
  - 分配空闲页框
  - 调用设备驱动程序做磁盘I/O
  - 修改页表
    - 设置有效位
    - 填入物理页框号
  - 修改其他相关表项

44.A
- 外存分区
  - 文件区:存放文件
  - 对换区:存放换出进程
- 抖动现象
  - 原因:频繁页面置换
  - 解决:撤销部分进程

45.B
- 虚拟内存实现特点
  - 基于离散分配内存管理
  - 实现方式
    - 请求分页
    - 请求分段
    - 请求段页式
  - 容量限制
    - 实际容量:受外存和内存容量和限制
    - 最大容量:由地址位数决定

46.B
- 缺页中断处理
  - 可能操作
    - 置换页面
    - 分配内存
  - 越界检查特点
    - 发生在查询页表前
    - 已产生缺页中断说明无越界错误

47.C
- 虚实地址转换加速方法
  - 增大快表容量
  - 页表常驻内存
  - 增大交换区无影响

48.A
FIFO Belady

49.C
- 页面置换策略
  - 固定分配:不可能全局置换
  - 其他常见策略:A、B、D选项

50.A
- 页面淘汰分析
  - 从后向前计数4个不同数字
  - 停止数字为淘汰页号2

51.A
- 改进型CLOCK置换算法步骤
  - 选择第一个(A=0,M=0)帧
  - 若失败则扫描(A=0,M=1)帧
  - 若再失败则重置使用位重复以上步骤
- 淘汰次序:(0,0),(0,1),(1,0),(1,1)

52.A
- 工作集计算
  - 窗口大小:6
  - 最近访问页面:6,0,3,2,3,2
  - 工作集:{6,0,3,2}

53.C
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1d44771be91e0e119a53f6191b770e30008e8814d8442c0be980f853ad090f64.jpg)
- 页面置换分析
  - LRU算法特点:换出最久未使用页面
  - 置换过程
    - 访问5:换出页面1
    - 访问3:换出页面2
  - 总置换次数:5次

54.D
- 平均访存时间影响因素
  - 缺页中断频率
  - 缺页中断处理时间
  - 页表访问时间
  - 目标物理地址访问时间

55.C
- 地址转换过程
  - 页面大小:4KB,低12位为页内偏移
  - 虚拟地址:02A01H,页号02H
  - 页框分配:固定为2
  - Clock算法:选择3号页换出
  - 最终物理地址:60A01H

56.A
- 缺页异常处理
  - 从磁盘调页到内存
  - 建立页框对应关系
  - 修改存在位
  - 空闲页框时无需淘汰

57.D
- 缺页率影响因素
  - 页置换算法
  - 工作集大小
  - 进程数量
  - 页缓冲队列长度不影响

58.D
- 虚拟地址空间特点
  - 大小由虚拟内存管理机制和操作系统决定
  - 与内存和硬盘大小无关
  - 包含堆区存放动态分配变量
# 二、综合应用题  

01.【解答】
- 页大小与地址结构分析
  - 页大小: 32B
  - 逻辑地址结构: 低5位为页内位移,高位为页号
- 地址转换分析
  - 101(八进制)情况
    - 二进制: 001000001
    - 页号: 2
    - 物理地址: (f3,1)
  - 204(八进制)情况
    - 二进制: 010000100 
    - 页号: 4
    - 物理地址: (f5,4)
    - 需更新相联存储器
  - 576(八进制)情况
    - 二进制: 101111110
    - 页号: 11
    - 结果: 产生越界中断

02.【解答】
- 访问时间分析
  - 关联寄存器命中(80%)
    - 耗时: $1\upmu\mathrm{s}$
  - 关联寄存器未命中(18%)
    - 耗时: $(1+1)\upmu\mathrm{s}$
  - 缺页中断(2%)
    - 耗时: $(1\upmu\mathrm{s}+1\upmu\mathrm{s}+20\mathrm{ms})$
  - 有效访问时间计算
    - 公式: $80\%\times1+18\%\times2+2\%\times(1\times2+20\times1000)=401.2\upmu\mathrm{s}$

> attention 

- 关联寄存器命中与未命中分析
  - 关联寄存器命中情况
    - 获取页框号和物理地址
    - 访问一次内存取页面
    - 耗时: $1\upmu\mathrm{s}$
  - 关联寄存器未命中情况
    - 从主存取页表项
      - 耗时: $1\upmu\mathrm{s}$
    - 将页表项存入关联寄存器
    - 根据物理地址访问内存取页面
      - 耗时: $1\upmu\mathrm{s}$

- 缺页中断处理流程
  - 发生条件
    - 关联寄存器未命中(20%中的10%)
    - 页面不在主存
  - 处理过程
    - 查找内存获取物理地址
      - 耗时: $1\upmu\mathrm{s}$
    - 产生缺页中断调入页面
      - 耗时: $20\mathrm{ms}$
    - 恢复中断前状态
    - 重新执行指令访问页面
      - 耗时: $1\upmu\mathrm{s}$
> attention 

建议读者结合《计算机组成原理考研复习指导》中的"虚拟存储器"小节进行复习。希望读者在完成本题的基础上总结出求解该类题型的方法，以使在以后遇到类似的题目时得心应手。读者应做到基础扎实、注意细节、触类旁通。

03.【解答】
- 页故障分析
  - 故障原因
    - 访问页不在主存
    - 需要调入主存
  - 故障次数范围
    - 下限: n次(首次进入主存)
    - 上限: p次(每次访问都不在主存)
  - 示例分析
    - 当m=3,p=12,n=4时
      - 访问串1112233344: 页故障数为4(下限n)
      - 访问串123412341234: 页故障数为12(上限p)

04.【解答】
1）最佳置换算法分析
- 物理块数为3时
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ab105367adae7b27145eabd25389f8dcb1197c67a55aa339a338e083c63cfd2.jpg)
  - 缺页率: 7/12
- 物理块数为4时
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6f94bc56809a877355bde3e85ae658d8fb3d261a8e024c3a1b0809e81f7b1c49.jpg)
  - 缺页率: 6/12
  - 结论: 增加内存块数可降低缺页率

2）先进先出算法分析
- 物理块数为3时
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/97c1909366021c7ec6438a6fa2b577a392e3703b9385f4e47ef3987e38b9bd57.jpg)
  - 缺页率: 9/12
- 物理块数为4时
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5dd15ff58b0c9a0e6c87c825e903ad2dbced455948a11a0a9ab7d27ee8089c07.jpg)
  - 缺页率: 10/12
  - 结论: 出现Belady现象

3）LRU算法分析
- 物理块数为3时
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d1cd2242ea53ae41abd12d9975616e4f7995f1e531bb4e8ad15627bf4ad7d7c.jpg)
  - 缺页率: 10/12
- 物理块数为4时
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/630941f9425d6c7d1cf06c04db5053701b2fb3d7734096a5f1cf8fa219fe9f18.jpg)
  - 缺页率: 8/12
  - 结论: 增加内存块数可降低缺页率

05.【解答】
- CPU利用率分析
  - 系统出现"抖动"现象
    - 增加并发进程数会恶化系统性能
    - 页式虚拟存储系统未能充分发挥功用
  - 系统正常
    - 不需采取措施
  - CPU未充分利用
    - 应增加并发进程数

06.【解答】
- 缺页中断处理时间分析
  - 基本访问时间
    - 未缺页时直接访问内存: $1\upmu\mathrm{s}$
    - 缺页且未修改: $8\upmu\mathrm{s}+1\upmu\mathrm{s}$
    - 缺页且修改: $20\upmu\mathrm{s}+1\upmu\mathrm{s}$
  - 最大缺页中断率计算
    - 计算公式: $(1-p)\times1\upmu\mathrm{s}+(1-70\%)\times p\times(1\upmu\mathrm{s}+8\upmu\mathrm{s})+70\%\times p\times(1\upmu\mathrm{s}+20\upmu\mathrm{s})=2\upmu\mathrm{s}$
    - 结果: $p\approx0.061=6.1\%$

07.【解答】
- 多级页表分析
  - 页表级数确定
    - 页内偏移12位
    - 虚页号36位
    - 每页表项数 $2^9$
    - 需要4级页表
  - 页面访问时间计算
    - TLB命中率98%时: $112\mathrm{ns}$
    - 二级页表访问时间: $114\mathrm{ns}$
  - 快表命中率要求
    - 满足条件: $p\times(10+100)+(1-p)\times(10+100+100+100)\leqslant120\mathrm{ns}$
    - 结果: $p\geqslant95\%$
  - 段页式结构分析
    - 段号16位
    - 段内地址32位
    - 需要3级页表

> attention 

在采用多级页表的页式存储管理中，若快表命中，则只需要一次访问内存操作即可存取指令或数据，这一点需要注意和理解。以本题1）中假设的条件为例，不考虑分段时，需要4级页表。若快表未命中，则需要从虚拟地址的高位起，每9位逐级访问各级页表，第5次才能访问到指令或数据所在的内存页面。  

若快表命中，则首先考虑快表中的实际内容：快表存放经常被访问的页面对应的页表项，页表项中是完整的 $48-12\,=\,36$ 位页面号，所以根据快表可以直接对虚拟地址进行转换。因此多级页表中，快表命中时同样只需要一次访问内存操作。根本原因在于，快表提供了进行地址转换的完整的页面号，而不是某一级的页面号。

08.【解答】
- 缺页率分析
  - 物理块数为3时
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1a0c3660714236188c89226fdbdfc0cbcb91d802c0f70b60c6c39db185e43ccf.jpg)
    - 缺页次数: 6
    - 缺页率: $6/12=50\%$
  - 物理块数为4时
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8e7f72d437f9cac31c1397c8421ae062e3bb779b4b11c29ef89c325a4900a647.jpg)
    - 缺页次数: 4
    - 缺页率: $4/12=33\%$

> attention 

当分配给作业的物理块数为4时，注意到作业请求页面序列中只有4个页面，可以直接得出缺页次数为4，而不需要按表列出缺页情况。

09.【解答】
- 页面置换算法分析
  - FIFO算法
    - 置换最先进入的3号页帧中的3号虚页
  - LRU算法
    - 置换1号页帧中的1号虚页
  - 改进型CLOCK算法
    - 第一轮扫描淘汰访问位和修改位都为0的页面
    - 淘汰1号页面
  - LRU算法缺页情况
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6bd52f1b1b73374a418584b74277b4a567482472d9c4b0bd3e35dd73adf70d11.jpg)
    - 缺页次数为3次

10.【解答】
- FIFO与LRU算法一致性分析
  - 要求条件
    - 替换页面选择一致
    - 最先进入主存的页面在缺页前不能再被访问
  - 访问串要求
    - 不连续的页面号均不相同
    - 连续访问相同页面不影响替换选择

11.【解答】
- 页面置换算法选择分析
  - FIFO算法
    - 选择最先进入内存的第2页
  - LRU算法
    - 选择最长时间未使用的第1页
  - 简单CLOCK算法
    - 扫描选择访问位为0的第0页
  - 改进型CLOCK算法
    - 选择未被访问和修改的第0页
12.【解答】
- 程序访问数组元素的缺页分析
  - 程序1按行优先访问
    - 每页可存200个数组元素
    - 每访问两行产生一次缺页
    - 总共产生50次缺页
  - 程序2按列优先访问 
    - 每页存两行元素
    - 每访问两个元素产生一次缺页
    - 总共产生5000次缺页
  - 页面大小减小时的影响
    - 每页只能存100个整数时
      - 程序1产生100次缺页
      - 程序2产生10000次缺页
    - 结论
      - 缺页次数与数据存放方式和访问顺序相关
      - 缺页少时页面大小影响小
      - 缺页多时减小页面大小影响大

13.【解答】
- 多级页表分析
  - 页表参数
    - 页面大小4KB
    - 页表项大小4B
    - 每个页表1024项
    - 每级索引10位
    - 页内偏移12位
  - 逻辑地址结构
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dcbd3a7d14b033cd815c942a49d3f487fe6ee3b817ac2b75d61a930a394d34f5.jpg)
  - 可访问虚拟空间大小为 $2^{42}\mathrm{B}=4\mathrm{TB}$
  - 最大页面大小计算
    - 页面大小为 $2^{Y}$
    - 每页可含 $2^{Y-3}$ 个页表项
    - 每级索引位 $Y-3$ 位
    - 满足 $4(Y-3)+Y\leqslant64$
    - 得到 $Y=15$
    - 最大页面大小为32KB

14.【解答】
- 访问时间分析
  - 2362H访问
    - 页号P=2
    - 访问快表10ns
    - 访问页表100ns
    - 访问主存100ns
    - 总计210ns
  - 1565H访问
    - 页号P=1
    - 快表访问10ns
    - 页表访问100ns
    - 缺页中断 $10^8$ns
    - 再次快表访问10ns
    - 主存访问100ns
    - 总计100000220ns
  - 25A5H访问
    - 页号P=2
    - 快表命中10ns
    - 主存访问100ns
    - 总计110ns
- 缺页处理
  - 1565H产生缺页中断
  - 淘汰0号页面
  - 页框号为101H
  - 物理地址为101565H

15.【解答】
- 地址空间分析
  - 空间大小64KB
  - 页大小1K
  - 地址格式
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/950e1f4aaa9e66520c016254b3ffa150360909f08689aa0b428182084aaeb7ef.jpg)
  - 17CAH页号计算
    - 二进制=0001 0111 1100 1010B
    - 页号=000101B=5
- 置换算法分析
  - FIFO算法
    - 置换0号页面
    - 页框号为7
    - 物理地址=1FCAH
  - CLOCK算法
    - 从2号页框开始扫描
    - 选择访问位为0的页框
    - 物理地址=0BCAH

16.【解答】
- 页框分配分析
  - 第一次分配
    - 页框号为21
    - 从空闲链表第三个取出
  - 第二次分配
    - 页框号为32
    - 第三轮扫描重新访问
  - 第三次分配
    - 页框号为41
    - 从空闲链表头取出
  - 策略评价
    - 适合时间局部性好的程序
    - 重用页框机会大

17.【解答】
- 页式管理参数分析
  - 基本参数
    - 页大小4KB
    - 虚拟地址空间 $2^{20}$ 页
  - 页表占用空间
    - 页目录占1页
    - 页表占1024页
    - 总共1025页
  - 地址访问特点
    - 0100 0000H和0111 2048H
    - 共用同一二级页表

18.【解答】
- 函数代码分析
  - f1代码特点
    - 指令在同一页中
    - 仅占用1页
  - pushebp指令分析
    - 页目录号=00 0000 0001
    - 页表索引=00 0000 0001
  - 进程状态转换
    - scanf执行时阻塞
    - 输入完成后就绪
    - 调度后运行
    - CPU用户态转内核态

19.【解答】
- 地址结构分析
  - 32位总长度
    - 高20位虚页号
    - 低12位页内地址
  - 二进制展开
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ed14497c2083f272801b3e39537ceafbe89caa90f0f06adbce5a84c0291499ba.jpg)
  - 十六进制表示0180 6008H
- PDBR特性
  - 进程切换时变化
  - 线程切换时不变
  - 与地址空间对应
- 置换算法需求
  - 需要使用位
  - 需要修改位

20.【解答】
- 数组存储分析
  - 基本参数
    - 页面大小4KB
    - 每页存1024个元素
    - 按行优先存放
  - 地址计算
    - a[1][2]虚拟地址
    - 页目录号042H
    - 页号001H
  - 物理地址转换
    - 页目录项地址0020 1108H
    - 页框号00301H
    - 页表项地址00301 004H
- 数组特性
  - 虚拟地址连续
  - 物理地址可不连续
- 访问局部性
  - 按行遍历局部性好
  - 同行元素在同页
  - 同列元素在不同页

