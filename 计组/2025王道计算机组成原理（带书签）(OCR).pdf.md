# 2025年  

# 计算机组成原理考研复习指导  

王道论坛组编王道官方版本，仅限内部使用！  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ee77f36bdcb450fc0adb9d23126aea28325b96c7e9b255b2597bfa2e308b085e.jpg)  
Publishing House of Electronics Industry 北京·BEIJING  
# 内容简介  

本书是计算机专业硕士研究生入学考试“计算机组成原理”课程的复习用书，内容包括计算机系统概述、数据的表示和运算、存储系统、指令系统、中央处理器、总线、输入/输出系统等。全书严格按照最新计算机考研大纲计算机组成原理部分的要求，对大纲所涉及的知识点进行集中梳理，力求内容精练、重点突出、深入浅出。本书精选各名校的历年考研真题，给出详细的解题思路，力求实现讲练结合、灵活掌 握、举一反三的功效。  

本书可作为考生参加计算机专业硕士研究生入学考试的复习用书，也可作为计算机专业学生学习计算机组成原理课程的辅导用书。  

未经许可，不得以任何方式复制或抄袭本书之部分或全部内容。  

版权所有，侵权必究。  

# 图书在版编目（CIP）数据  

2025年计算机组成原理考研复习指导/王道论坛组编.一北京：电子工业出版社，2024.1ISBN978-7-121-46735-6  

I. $_{\odot2}$ "ⅡI. $\textcircled{\scriptsize{1}}$ 王.Ⅲ. $\textcircled{\scriptsize{1}}$ 计算机组成原理一研究生一入学考试一自学参考资料IV. $\circledcirc$ TP301中国国家版本馆CIP数据核字（2023）第223519号  

责任编辑：谭海平  

印刷：山东华立印务有限公司  

装订：山东华立印务有限公司  

出版发行：电子工业出版社  

北京市海淀区万寿路173信箱邮编：100036开本： $787\!\times\!1092$ 1/16印张：21.75字数：612.5千字  

版次：2024年1月第1版  

印次：2024年1月第1次印刷  

定价：71.00元  

凡所购买电子工业出版社图书有缺损问题，请向购买书店调换。若书店售缺，请与本社发行部联系，联系及邮购电话：（010）88254888，88258888。质量投诉请发邮件至zlts@phei.com.cn，盗版侵权举报请发邮件至dbqq@phei.com.cn。本书咨询联系方式：（010）88254552，tan02@phei.com.cn  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ab32a6ade81fbae83d308fa75ef0cb007910e726ea8edbc95aee1fdf7f59013.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a364ac1fa6760e6b9cd4e2b42bb56df938eb6794b5a6d11b814e14d97ed5ea52.jpg)  
【关于兑换配套课件的说明】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f4301796fe43625dadc39be7aac676c619c825d8430767e8d6f9bd79a56bc299.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6cec5c7f029f1c152a80f63aa1e6b27bb7f1262dde877ae28233bf7993bc3e73.jpg)  

# 配套资源内容  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9b10c86aac96c4dae5c2b3910a4116b6e2f764b62acbf248b05c2787ae2eb98c.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/871117d2080a589c061b49e75ab96a89df89344b4bd80ee34f9f74d10755043a.jpg)  

1.凭兑换码兑换相应课程部分选择题的视频以及B站免费课程的课件。2.B站免费课程不是2025版付费课程，但差别不大，详情请咨询客服。3.兑换码贴于封面右下角，刮开涂 层可见。4.兑换截止时间为2024年12月31日。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8df4aca741f78bcf36bdbaa45b7a78225221a1cf29d167ebb36eb05a4a056f4b.jpg)  

1.盗版书无兑换码请勿购买。

2.免费视频非王道最新网课。

3.免费视频不包含答疑服务。  
# 前言  

由王道论坛（cskaoyan.com）组织名校状元级选手编写的“王道考研系列”辅导书，不仅参考了国内外的优秀教辅资料，而且结合了高分选手的独特复习经验，包括对考点的讲解以及对习题的选择和解析。“王道考研系列”单科辅导书共有如下四本：  

《2025年数据结构考研复习指导》《2025年计算机组成原理考研复习指导》《2025年操作系统考研复习指导》《2025年计算机网络考研复习指导》  

我们还围绕这套书开发了一系列赢得众多读者好评的计算机考研课程，包括考点精讲、习题详解、暑期强化训练营、冲刺串讲、伴学督学和全程答疑服务等，读者可扫描封底的二维码加客服微信咨询。对于基础较为薄弱的读者，相信这些课程和服务能助你一臂之力。此外，我们在B站免费公开了本书配套的基础课程，读者可凭兑换码获取课程的课件及部分选择题的讲解视频。基础课程升华了单科辅导书中的考点讲解，强烈建议读者结合使用。  

在冲刺阶段，我们还将出版如下两本冲刺用书：·《2025年计算机专业基础综合考试冲刺模拟题》·《2025年计算机专业基础综合考试历年真题解析》  

深入掌握专业课的内容没有捷径，考生也不应抱有任何侥幸心理。只有扎实打好基础，踏实敌题巩固，最后灵活致用，才能在考研时取得高分。我们希望本套辅导书能够指导读者复习，但是学习仍然要靠自己，高分无法建立在空中楼阁之上。对想要继续在计算机领域深造的读者来说，认真学习和扎实掌握计算机专业的四门重要专业课是最基本的前提。  

“王道考研系列”是计算机考研学子口碑相传的辅导书，自2011版首次推出以来，始终占据同类书销量的榜首，这就是口碑的力量。有这么多学长的成功经验，相信只要读者合理地利用输导书，并且采用科学的复习方法，就一定能够收获属于自已的那份回报。  

“不包就业、不包推荐，培养有态度的程序员。”王道训练营是王道团队打造的线下魔鬼式编程训练营。打下编程功底、增强项目经验，彻底转行入行，不再迷茫，期待有梦想的你！  

参与本书编写工作的人员主要有赵霖、罗乐、徐秀瑛、张鸿林、赵淑芬、赵淑芳、罗庆学、赵晓宇、喻云珍、余勇、刘政学等。予人玫瑰，手有余香，王道论坛伴你一路同行！  

对本书的任何建议，或发现有错误，欢迎扫码联系我们，以便及时改正优化。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b6e7031c0252ae8ebbb12dc6ef83b28d080d1edf35b366861d333eba8f849080.jpg)  
# 致读者  

# 关于王道单科辅导书使用方法的道友建议  

我是“二战考生”，2012年第一次考研成绩333分（专业代码408，成绩81分），痛定思痛后决心再战。潜心复习了半年后终于以392分（专业代码408，成绩124分）考入上海交通大学计算机系，这半年里我的专业课成绩提高了43分，成了提分主力。从未达到录取线到考出比较满意的成绩，从蒙头乱撞到有了首己明确的复习思路，我想这也是为什么风华哥从诸多高分选手中选择我给大家介绍经验的一个原因吧。  

整个专业课的复习是围绕王道辅导书展开的，从一遍、两遍、三遍看单科辅导书的积累提升，到做8套模拟题时的强化巩固，再到看思路分析时的醍醐灌顶。王道辅导书能两次押中算法原题固然有运气成分，但这也从侧面说明编者的编写思路和选题方向与真题很接近。  

下面说一说我的具体复习过程。  

每天划给专业课的时间是3～4小时。第一遍仔细看课本，看完一章做一章单科辅导书上的习题（红笔标注错题），这一遍共持续2个月。第二遍主攻单科辅导书（红笔标注重难点），辅看课本。第二遍看单科辅导书和课本的速度快了很多，但感觉收获更多，常有温故知新的感觉，理解更深刻。（风华注：建议这里再速看第三遍，特别针对错题和重难点。模拟题做完后再跳看第四遍。）  

以上是打基础阶段，注意：单科辅导书和课本我仔细精读了两遍，以便尽量弄懂每个知识点和习题。大概11月上旬开始做模拟题和思路分析，期间遇到不熟悉的地方不断回头查阅单科辅导书和课本。8套模拟题的考点覆盖得很全面，所以大家做题时如果忘记了某个知识点，千万不要慌张，赶紧回去看这个知识点，最后的模拟就是查漏补缺。模拟题一定要严格按考试时间（3小时）去做，注意应试技巧，做完试题后再回头研究错题。算法题的最优解法不太好想，如果实在没思路，建议直接“暴力”解决，结果正确也能有10分，总比苦拼出15分来而将后面比较好拿分的题耽误了好（这是我第一次考研的切身教训）。最后剩了几天看标注的错题，第三遍跳看单科辅导书，考前一夜浏览完网络，踏实地睡着了·…·  

考完专业课，走出考场终于长舒一口气，考试情况也心中有数。回想这半年的复习，耐住了寂寞和诱惑，雨雪风霜从未间断地跑去自习，考研这人生一站终归没有辜负我的良苦用心。佛教徒说世间方物生来平等，都要落人春华秋实的代谢中去：辩证唯物主义认为事物作为过程存在，凡是存在的终归要结束。你不去为活得多姿多彩而拼搏，真到了和青春说再见时，你是否会可惜虚柱了青春？风华哥说过，我们都是有梦想的青年，我们正在逆袭，你呢？  

感谢风华哥的信任，给我这个机会为大家分享专业课复习经验，作为一个铁杆道友在王道受益匪浅，也借此机会回报王道论坛。祝大家金榜题名！  
# 王道训练营  

王道是道友们考研路上值得信赖的好伙伴，十多年来陪伴了数百万计算机考研人，不离不弃。王道尊重的不是考研这个行当，而是考研学生的精神和梦想。考研可能是同学们实现梦想的起点，但专业功底和学习能力更是受用终生的资本，它决定了未来在技术道路上能走多远。从考研图书，到辅导课程，再到编程培训，王道只专注于计算机考研及编程领域。  

计算机专业是一个靠实力吃饭的专业。王道团队中很多人的经历或许和现在的你们相似，也经历过本科时的迷茫，无非是自知能力太弱，以致底气不足。学历只是敲门砖，同样是名校硕 士，有人如鱼得水，最终成为“Offer帝”，有人却始终难入“编程与算法之门”，再次体会迷茫的痛苦。我们坚信一个写不出合格代码的计算机专业学生，即便考上了研究生，也只是给未来的失业判了个“缓期执行”。我们也希望所做的事情能帮助同学们少走弯路。  

考研结束后的日子，或许是一段难得的提升编程能力的连续时光，趁着还有时间，应该去弥补本科期间应掌握的能力，缩小与“科班大佬们”的差距。  

把参加王道训练营视为一次对自己的投资，投资自身和未来才是最好的投资。  

# 王道训练营简介  

# 1.面向就业  

希望转行就业，但编程能力偏弱的学生。  

考研并不是人生的唯一出路，努力拼搏奋斗的经历总是难忘的，但不论结果如何，都不应有太大的遗憾。不少考研路上的“失败者”在王道都到达了自己在技术发展上的新里程碑，我们相信一个肯持续努力、积极上进的学生一定会找到自已正确的人生方向。  

再不抓住当下，未来或将持续迷茫，逝去了的青春不复返。在充分竞争的技术领域，当前的能力决定了你能找一份怎样的工作，踏实的态度和学习的能力决定了你未来能走多远。  

王道训练营致力于给有梦想、肯拼搏、敢奋斗的道友提供最好的平台！  

# 2.面向硕士  

希望提升能力，刚考上计算机相关专业的准硕士  

考研逐年火爆，能考上名校确实是重要的转折，但硕士文凭早已不再稀缺。考研高分并不等于高薪Offer，学历也不能保证你拿到好Offer，名校的光环能让你获得更多面试机会，但真正要拿到好Ofer，比拼的是实力。同为名校硕士，Ofer的成色可能干差万别，有人轻松拿到腾讯、阿里、抖音、百度等优秀公司的Ofer，有人面试却屡屡碰壁，最后只能“将就”签约。  

人生中关键性的转折点不多，但往往能对自己的未来产生深远的影响，甚至决定了你未来的走向，高考、选专业、考研、找工作都是如此，把握住关键转折点需要眼光和努力。  

# 3.报名要求  

·具有本科学历，愿意通过奋斗去把握自己的人生，愿意重回高三冲刺式的学习状态。·完成开课前的作业，用作业考察态度，合格者才能获得最终的参加资格，宁缺滥！对于意志不够坚定的同学而言，这些作业也算是设置的一道门槛，决定了是否有参加的资格。  
作业完成情况是最重要的考核标准，我们不会歧视跨度大的同学，坚定转行的同学往往会更努力。跨度大、学校弱这些是无法改变的标签，唯一可以改变的就是通过持续努力来提升自身的技能，而通过高强度的短期训练是完全有可能逆袭的，太多的往期学员已有过证明。  

# 4.学习成效  

迅速提升编程能力，结合项目实战，逐步打下坚实的编程基础，培养积极、主动的学习能力。以动手编程为驱动的教学模式，解决你在编程、思维上的不足，也为未来的深入学习提供方向指导，掌握学习编程的方法，引导进入“编程与算法之门”。  

道友们在训练营里从“菜鸟”逐步成长，训练营中不少往期准硕士学员后来陆续拿到了阿里、腾讯、抖音、百度、美团、小米等一线互联网大厂的Offer。这就是竞争力！  

# 王道训练营优势  

这里都是道友，他们信任王道，乐于分享与交流，氛围好而纯粹。  

一起经历过考研训练的生活、学习，大家很快会成为互帮互助的好战友，相互学习、共同进步，在转行的道路上，这就是最好的圈子。正如某期学员所言：“来了你就发现，这里无关程序员以外的任何东西，这是一个过程，一个对自己认真、对自己负责的过程。”  

考研绝非人生的唯一出路，给自已换一条路走，去职场上好好发展或许会更好。即便考上研究生也不意味着高枕无忧，人生的道路还很漫长。  

王道团队成员皆具有扎实的编程功底，他们用自己的技术和态度去影响训练营的学员，尽可能指导学员走上正确的发展道路是对道友信任的回报，也是一种责任！  

王道训练营是一个平台，网罗王道论坛上有梦想、有态度的青年，并为他们的梦想提供土壤和圈子。王道始终相信“物竞天择，适者生存”，这里的生存不是指简简单单地活着，而是指活得有价值、活得有态度！  

# 王道训练营课程  

王道训练营开设4种班型：  

LinuxC和 $\mathrm{C++}$ 短期班（ $.40{\sim}45$ 天，初试后开课，复试冲刺）·JavaEE方向（4个月，武汉校区）Linux $\mathrm{C}/\mathrm{C++}$ 方向（4个月，武汉校区)·Python大数据方向（3个半月，直播授课或深圳校区）  

短期班的作用是在初试后及春节期间，快速提升学员的编程水平和项目经验，给复试、面试加成。其他3科班型既面向有就业需求的学员，又适合想提升能力或打算继续考研的学员。  

要想了解王道训练营，可以关注王道论坛“王道训练营”版面，或者扫码加老师微信。  
# 目录  

# 第1章计算机系统概述  

\*1.1计算机发展历程  

\*1.1.1计算机硬件的发展 $^{*}1.1.2$ 计算机软件的发展  

1.2计算机系统层次结构  

1.2.1计算机系统的组成1.2.2计算机硬件1.2.3计算机软件1.2.4计算机系统的层次结构61.2.5计算机系统的工作原理1.2.6 本节习题精选 8 1.2.7 答案与解析 10  

# 1.3计算机的性能指标  

1.3.1计算机的主要性能指标121.3.2 几个专业术语 15 1.3.3 本节习题精选 15 1.3.4 答案与解析 19  

1.4本章小结  

1.5常见问题和易混淆知识点  

# 第2章数据的表示和运算  

# 2.1数制与编码  

2.1.1进位计数制及其相互转换262.1.2定点数的编码表示·292.1.3整数的表示312.1.4C语言中的整数类型及类型转换322.1.5 本节习题精选 34 2.1.6 答案与解析 ·36  

# 2.2运算方法和运算电路  

2.2.1基本运算部件392.2.2 定点数的移位运算 41 2.2.3 定点数的加减运算 41 2.2.4 定点数的乘除运算 44 2.2.5本节习题精选462.2.6 答案与解析 50 2.3浮点数的表示与运算55  
2.3.1浮点数的表示 55 2.3.2 浮点数的加减运算 59 2.3.3C语言中的浮点数类型602.3.4数据的大小端和对齐存储612.3.5 本节习题精选 62 2.3.6 答案与解析 69  

2.4本章小结  

2.5常见问题和易混淆知识点  

# 第3章存储系统80  

# 3.1存储器概述 80  

3.1.1存储器的分类803.1.2存储器的性能指标 81 3.1.3多级层次的存储系统823.1.4本节习题精选 83 3.1.5 答案与解析 84  

# 3.2主存储器  

3.2.1SRAM芯片和DRAM芯片 85 3.2.2 只读存储器 88 3.2.3主存储器的基本组成893.2.4 多模块存储器 90 3.2.5本节习题精选923.2.6 答案与解析 96  

# 3.3主存储器与CPU的连接 101  

3.3.1 连接原理 ·101 3.3.2 主存容量的扩展 ·101 3.3.3存储芯片的地址分配和片选1033.3.4存储器与CPU的连接1043.3.5 本节习题精选 104 3.3.6 答案与解析 106  

# 3.4外部存储器 109  

3.4.1磁盘存储器 109 3.4.2 固态硬盘 111 3.4.3 本节习题精选 112 3.4.4答案与解析 113  

3.5高速缓冲存储器  

3.5.1 程序访问的局部性原理 115 3.5.2Cache的基本工作原理·1173.5.3 Cache和主存的映射方式 118 3.5.4 Cache中主存块的替换算法 122 3.5.5Cache的一致性问题1233.5.6本节习题精选 124 3.5.7答案与解析 130  
3.6虚拟存储器 3  

3.6.1虚拟存储器的基本概念1373.6.2 页式虚拟存储器 138 3.6.3 段式虚拟存储器· 141 3.6.4 段页式虚拟存储器 142 3.6.5 虚拟存储器与Cache的比较 142 3.6.6 本节习题精选 142 3.6.7 答案与解析 148  

# 3.7本章小结 53  

3.8常见问题和易混淆知识点  

# 第4章指令系统155  

# 4.1指令系统155  

4.1.1指令集体系结构1554.1.2指令的基本格式1564.1.3 定长操作码指令格式 157 4.1.4 扩展操作码指令格式 158 4.1.5 指令的操作类型 158 4.1.6 本节习题精选 159 4.1.7 答案与解析 161  

# 4.2指令的寻址方式64  

4.2.1指令寻址和数据寻址1644.2.2常见的数据寻址方式1654.2.3 本节习题精选 169 4.2.4答案与解析 177  

# 4.3程序的机器级代码表示183  

4.3.1 常用汇编指令介绍 184 4.3.2选择语句的机器级表示1894.3.3循环语句的机器级表示1904.3.4过程调用的机器级表示1914.3.5 本节习题精选 194 4.3.6 答案与解析 198  

# 4.4CISC和RISC的基本概念200  

4.4.1复杂指令系统计算机（CISC）2014.4.2精简指令系统计算机（RISC）2014.4.3 CISC RISC 201 4.4.4 本节习题精选 202 4.4.5 答案与解析 203  

4.5本章小结 203  

4.6常见问题和易混淆知识点204  
# 第5章中央处理器205  

# 5.1CPU的功能和基本结构205  

5.1.1CPU的功能2055.1.2CPU的基本结构2065.1.3 CPU的寄存器 206 5.1.4 本节习题精选 207 5.1.5 答案与解析 209  

# 5.2指令执行过程  

5.2.1指令周期 212 5.2.2指令周期的数据流2135.2.3 指令执行方案 214 5.2.4本节习题精选 215 5.2.5答案与解析 217  

# 5.3数据通路的功能和基本结构218  

5.3.1数据通路的功能 ·218 5.3.2 数据通路的组成 ·218 5.3.3数据通路的基本结构2195.3.4 数据通路的操作举例 220 5.3.5 本节习题精选 221 5.3.6 答案与解析 228  

# 5.4控制器的功能和工作原理234  

5.4.1控制器的结构和功能·2345.4.2硬布线控制器2355.4.3微程序控制器2355.4.4 本节习题精选 239 5.4.5 答案与解析 243  

# 5.5异常和中断机制 24  

5.5.1异常和中断的基本概念2475.5.2异常和中断的分类2475.5.3 异常和中断响应过程 249 5.5.4本节习题精选 249 5.5.5 答案与解析 ·251  

# 5.6指令流水线  

5.6.1指令流水线的基本概念2525.6.2流水线的基本实现2535.6.3 流水线的冒险与处理 ·254 5.6.4 流水线的性能指标 258 5.6.5高级流水线技术2585.6.6 本节习题精选 259 5.6.7 答案与解析 265  

5.7多处理器的基本概念273  
5.7.1SISD、SIMD、MIMD的基本概念2735.7.2硬件多线程的基本概念2745.7.3多核处理器的基本概念2745.7.4共享内存多处理器的基本概念2755.7.5 本节习题精选 276 5.7.6 答案与解析· 277  

5.8本章小结 278

 5.9常见问题和易混淆知识点279  

# 第6章总线280  

# 6.1总线概述 280  

6.1.1总线基本概念2806.1.2总线的分类2816.1.3系统总线的结构282 $^{*}6.1.4$ 常见的总线标准2826.1.5 总线的性能指标 283 6.1.6 本节习题精选 284 6.1.7 答案与解析 287  

# 6.2总线事务和定时 290  

6.2.1 总线事务 290 6.2.2 总线定时 290 6.2.3 本节习题精选 292 6.2.4 答案与解析 294  

6.4常见问题和易混淆知识点296  

# 第7章输入/输出系统  

#  $^{*7.1}$ I/O系统基本概念  

$^{*7.1.1}$ 输入/输出系统297 $^{*7.1.2}$ 1/0控制方式298\*7.1.3外部设备298\*7.1.4本节习题精选 299  $^{*7.1.5}$  答案与解析 300  

# 7.21/0接口 300  

7.2.11/0接口的功能3007.2.2I/O接口的基本结构3007.2.3 I/O接口的类型· 301 7.2.4I/O端口及其编址3017.2.5本节习题精选3027.2.6 答案与解析 304  

# 7.31/0方式 305  

7.3.1程序查询方式305  
7.3.2程序中断方式3077.3.3DMA方式3117.3.4 本节习题精选 315 7.3.5答案与解析 323 7.4本章小结 332 7.5常见问题和易混淆知识点332  

参考文献34  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1662a3073ceeab5913e1d2ec2dbea6badde6479827f63d16e833f13ab9be15da.jpg)  
# 第1章计算机系统概述  

# 【考纲内容】  

（一）计算机系统层次结构  

计算机系统的基本组成计算机硬件的基本组成计算机软件和硬件的关系  

计算机系统的工作原理：“存储程序”方式：高级语言程序与机器语言程序的转换；程序和指令的执行过程  

（二）计算机性能指标  

吞吐量；响应时间：CPU时钟周期：主频：CPI；CPU执行时间；MIPS:MFLOPS:GFLOPS:TFLOPS:PFLOPS:EFLOPS:ZFLOPS  

# 【复习提示】  

本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。  

学习本章时，请读者思考以下问题：  

1）计算机由哪几部分组成？以哪部分为中心？2）主频高的CPU一定比主频低的CPU快吗？为什么？3）翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？4）不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。  

#  $^{*1.1}$ 计算机发展历程  

# \*1.1.1计算机硬件的发展  

1.计算机的四代变化  

1946（Electronic Numerical Integrator And Computer，ENIAC）问世以来，计算机的发展已经经历了四代。  

1）第一代计算机（1946一1957年）一电子管时代。特点：逻辑元件采用电子管；使用机  
器语言进行编程：主存储器用延迟线或磁鼓存储信息，容量极小：体积庞大，成本高：运算速度较低，一般只有几千次到几万次每秒。  

2）第二代计算机（1958一1964年）一一晶体管时代。特点：逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存储器使用磁芯存储器；计算机软件也得到了发展，开始出现了高级语言及其编译程序，有了操作系统的雏形。  

3）第三代计算机（1965一1971年）一中小规模集成电路时代。特点：逻辑元件采用中小规模集成电路：半导体存储器开始取代磁芯存储器；高级语言发展迅速，操作系统也进一步发展，开始有了分时操作系统。  

4）第四代计算机（1972年至今）一超大规模集成电路时代。特点：逻辑元件采用大规模集成电路和超大规模集成电路，产生了微处理器；诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中。  

# 2.计算机元件的更新换代  

1）摩尔定律。当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。也就是说，我们现在和18个月后花同样的钱买到的CPU，后者的性能是前者的两倍。这一定律揭示了信息技术进步的速度。  

2）半导体存储器的发展。1970年，美国仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代：单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB和现在的1GB。  

3）微处理器的发展。自1971年Intel公司开发出第一个微处理器Intel4004至今，微处理器经历了Intel8008（8位）、Intel8086（16位）、Intel80386（32位）、Pentium（32位）、PentiumIll（64位）、Pentium4（64位）、Corei7（64位）等。这里的32位、64位指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。  

#  $^{*1.1.2}$ 计算机软件的发展  

计算机软件技术的蓬勃发展，也为计算机系统的发展做出了很大的贡献。  

计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的FORTRAN、结构化程序设计的PASCAL到面向对象的 $\mathrm{C++}$ 和适应网络环境的Java。  

与此同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如Windows、UNIX、Linux等。  

# 1.2计算机系统层次结构  

# 1.2.1计算机系统的组成  

硬件系统和软件系统共同构成了一个完整的计算机系统。硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档。  

计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。对某一功能来说，若其既可以用软件实现，又可以用硬件实现，则称为软/硬件在逻辑功能上是等价的。在设计计算机系统时，要进行软/硬件的功能分配。通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。  
# 1.2.2计算机硬件  

# 1.冯·诺依曼机基本思想  

命题追踪 冯·诺依曼计算机的特点（2019）  

冯·诺依曼在研究EDVAC机时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机统称冯·诺依曼机，其特点如下：  

1）采用“存储程序”的工作方式。  

2）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成3）指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。  

4）指令和数据均用二进制代码表示。  

5）指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。  

“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存储器后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。  

# 2.计算机的功能部件  

# 命题追踪  

# MAR和MDR位数的概念和计算（2010、2011）  

（1）输入设备  

输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等。  

# （2）输出设备  

输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。最常用、最基本的输出设备是显示器、打印机。输入/输出设备（简称1/O设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。  

# （3）存储器  

存储器分为主存储器（也称内存储器或主存）和辅助存储器（也称外存储器或外存）。CPU能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存储器后，才能为CPU所访问。主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。  

主存储器的最基本组成如图1.1所示。存储体存放二进制信息，存储器地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元。存储器数据寄存器（MDR）用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/36517a18494fdeb8a07395f328a28abdfbd453d9dab3e6d2c9c8c828b2a23076.jpg)  
图1.1主存储器逻辑图  
存储体由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进 制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这事代码为存储字，称这事代码的位数为存储字长，存储字长可以是1B（8bit）或是字节的偶数倍。  

MAR用于寻址，其位数反映最多可寻址的存储单元的个数，如MAR为10位，则最多有 $2^{10}\!=\!1024$ 个存储单元，记为1K。MAR的长度与PC的长度相等。  

MDR的位数通常等于存储字长，一般为字节的2次幂的整数倍。  

# 注意  

MAR与MDR虽然是存储器的一部分，但在现代计算机中却是存在于CPU中的；另外，后文提到的高速缓存（Cache）也存在于CPU中。  

# (4）运算器  

运算器是计算机的执行部件，用于进行算术运算和逻辑运算。算术运算是按算术运算规则进行的运算，如加、减、乘、除；逻辑运算包括与、或、非、异或、比较、移位等运算。  

运算器的核心是算术逻辑单元（ArithmeticandLogicUnit，ALU）。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前三个寄存器是必须具备的。  

运算器内还有程序状态寄存器（PSW），也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。  

# （5）控制器  

控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成。  

PC用来存放当前欲执行指令的地址，具有自动加1的功能（这里的“1”指一条指令的长度），即可自动形成下一条指令的地址，它与主存储器的MAR之间有一条直接通路。  

IR用来存放当前的指令，其内容来自主存储器的MDR。指令中的操作码OP（IR)送至CU，用以分析指令并发出各种微操作命令序列：而地址码Ad（IR)送往MAR，用以取操作数。  

一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU)。CPU和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O设备等）统称外部设备，简称外设。  

图1.2所示为冯·诺依曼结构的模型机。CPU包含ALU、通用寄存器组GPRs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改PC以得到下一条指令的地址，可以控制ALU执行什么运算，可以控制主存储器是进行读操作还是写操作（读/写控制信号）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5599c11147c84255a3bcb6e68a0e63ecce4c3c670d01ea80490c4c98da2c745.jpg)  
图1.2冯·诺依曼结构的模型机  
CPU和主存储器之间通过一组总线相连，总线中有地址、控制和数据3组信号线。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存储器存储单元；控制线中有读/写信号线，指出数据是从CPU写入主存储器还是从主存储器读出到CPU，根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MIDR中。  

# 1.2.3计算机软件  

# 1.系统软件和应用软件  

软件按其功能分类，可分为系统软件和应用软件。  

系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等。  

应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。  

在本学科范畴内，编写诸如操作系统、编译程序等各种系统软件的人员称为系统程序员；利用计算机及所支持的系统软件来编写解决具体应用问题的人员称为应用程序员。  

# 2.三个级别的语言  

# 命题追踪三种机器语言的特点（2015）  

1）机器语言。也称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。2）汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。3）高级语言。高级语言（如C、 $C++$ 、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。  

# 命题追踪各种翻译程序的概念（2016）  

因此计算机无法直接理解和执行高级语言程序，所以需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称翻译程序。翻译程序有以下三类：  

1）汇编程序（汇编器）。将汇编语言程序翻译成机器语言程序。2）解释程序（解释器）。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。3）编译程序（编译器）。将高级语言程序翻译成汇编语言或机器语言程序。  

# 3.软件和硬件的逻辑功能等价性  

硬件实现的往往是最基本的算术和逻辑运算功能，而其他功能大多通过软件的扩充得以实现。对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为软/硬件逻辑功能的等价性。例如，浮点数运算既可以用专门的浮点运算器硬件实现，又可以通过一段子程序实现，这两种方法在功能上完全等效，不同的只是执行时间的长短而已，显然硬件实现的性能要优于软件实现的性能。  

软件和硬件逻辑功能的等价性是计算机系统设计的重要依据，软件和硬件的功能分配及其界面的确定是计算机系统结构研究的重要内容。当研制一台计算机时，设计者必须明确分配每一级的任务，确定哪些功能使用硬件实现，哪些功能使用软件实现。软件和硬件功能界面的划分是由设计目标、性能价格比、技术水平等综合因素决定的。  
# 1.2.4计算机系统的层次结构  

计算机是一个硬软件组成的综合体。因为面对的应用范围越来越广，所以必须有复杂的系统软件和硬件的支持。由于软/硬件的设计者和使用者从不同的角度、用不同的语言来对待同个计算机系统，因此他们看到的计算机系统的属性对计算机系统提出的要求也就各不相同。  

计算机系统的多级层次结构的作用，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。  

关于计算机系统层次结构的分层方式，目前尚无统一的标准，这里采用如图1.3所示的层次结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba10a968e6fa79eefcc9bdc76353183bb076480dd94dd122497668c14bb47a43.jpg)  
图1.3计算机系统的多级层次结构  

第1级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。第2级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统  

第3级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。  

第4级是汇编语言层，这一层由汇编程序支持和执行，借此可编写汇编语言源程序。  

第5级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。在高级语言层之上，还可以有应用程序层，它由解决实际问题的处理程序组成，如文字处理软件、多媒体处理软件和办公自动化软件等。  

没有配备软件的纯硬件系统称裸机。第3层～第5层称为虚拟机，简单来说就是软件实现的机器。虚拟机器只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层的语言来了解和使用计算机，而不必关心下层是如何工作的。  

层次之间的关系紧密，下层是上层的基础，上层是下层的扩展。  

软件和硬件之间的界面就是指令集体系结构（ISA），ISA定义了一台计算机可以执行的所有指令的集合，每条指令规定了计算机执行什么操作，以及所处理的操作数存放的地址空间和操作数类型。可以看出，ISA是指软件能感知到的部分，也称软件可见部分。  

本门课程主要讨论传统机器M1和微程序机器M0的组成原理及设计思想。  
# 1.2.5计算机系统的工作原理  

# 1.“存储程序”工作方式  

“存储程序”工作方式规定，程序执行前，需要将程序所含的指令和数据送入主存储器，一旦程序被启动执行，就无须操作人员的干预，自动逐条完成指令的取出和执行任务。如图1.4所示，一个程序的执行就是周而复始地执行一条一条指令的过程。每条指令的执行过程包括：从主存储器中取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92147f3b866cf96839105ec932140b0e4ff184d56cbe32653f7a5a310837bacb.jpg)  
图1.4程序执行过程  

程序执行前，先将程序第一条指令的地址存放到PC中，取指令时，将PC的内容作为地址访问主存储器。在每条指令执行过程中，都需要计算下条将执行指令的地址，并送至PC。若当前指令为顺序型指令，则下条指令地址为PC的内容加上当前指令的长度；若当前指令为转跳型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据PC的内容到主存储器中取出的是下一条将要执行的指令，因而计算机能周而复始地自动取出并执行一条一条的指令。  

# 2.从源程序到可执行文件  

# 命题追踪翻译过程的四个阶段（2022）  

在计算机中编写的C语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。  

以UNIX系统中的GCC编译器程序为例，读取源程序文件hello.c，并把它翻译成一个可执行自标文件hello，整个翻译过程可分为四个阶段完成，如图1.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/32b38423c35a842f0ba819ce89774db99c0a25717ce5fb9005ae757f21a9a38b.jpg)  
图1.5源程序转换为可执行文件的过程  

1）预处理阶段：预处理器（cpp）对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以i为扩展名的源文件hello.i。  

2）编译阶段：编译器（cc1）对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。  
3）汇编阶段：汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位自标文件hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。  

4）链接阶段：链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，简称可执行文件。本例中，链接器将hello.o和标准库函数printf所在的可重定位目标模块printf.o合并，生成可执行文件hello。最终生成的可执行文件被保存在磁盘上。  

# 3.指令执行过程的描述  

可执行文件代码段是由一条一条机器指令构成的，指令是用0和1表示的一串0/1序列，用来指示CPU完成一个特定的原子操作。例如，取数指令从存储单元中取出一个数据送到CPU的寄存器中，存数指令将CPU寄存器的内容写入一个存储单元，ALU指令将两个寄存器的内容进行某种算术或逻辑运算后送到一个CPU寄存器中，等等。指令的执行过程在第5章中详细描述。下面以取数指令（送至运算器的ACC中）为例来说明，其信息流程如下：  

# 1）取指令：PC→MAR→M→MDR-IR  

根据PC取指令到IR。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存储器根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。  

2）分析指令：OP(IR)→CU  

指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR中是取数指令，因此读控制信号被送到总线的控制线上。  

3）执行指令：Ad(IR)→MAR→M→MDR→ACC  

取数操作。将IR中指令的地址码送MAR，MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存储器中读出操作数，并通过数据线送至MIDR，再传送到ACC中。  

每取完一条指令，还须为取下条指令做准备，计算下条指令的地址，即 $(\mathrm{PC})+1{\rightarrow}\mathrm{PC}$  

# 注意  

(PC)指程序计数器PC中存放的内容。 $\mathsf{P C}\!\to\!\mathsf{M A R}$ 应理解为 $(\mathrm{PC}){\rightarrow}\mathrm{MAR}$ ，即程序计数器中的值经过数据通路送到MAR，也即表示数据通路时括号可省略（因为只是表示数据流经的途径，而不强调数据本身的流动）。但运算时括号不能省略，即 $(\mathrm{PC})+1{\rightarrow}\mathrm{PC}$ 不能写为 $\mathrm{PC}+1{\rightarrow}\mathrm{PC}.$ 当题目中(PC)→MAR的括号未省略时，考生最好也不要省略。  

# 1.2.6 本节习题精选  

单项选择题  

01.完整的计算机系统应包括（）  

A.运算器、存储器、控制器B.外部设备和主机C.主机和应用程序D.配套的硬件设备和软件系统  

02.冯·诺依曼机的基本工作方式是（）  

A.控制流驱动方式B.多指令多数据流方式C.微程序控制方式D.数据流驱动方式  

03.下列（）是冯·诺依曼机工作方式的基本特点。  

A.多指令流单数据流B.按地址访问并顺序执行指令C.堆栈操作 D.存储器按内容选择地址  

04.以下说法错误的是（）  
A.硬盘是外部设备B.软件的功能与硬件的功能在逻辑上是等价的C.硬件实现的功能一般比软件实现具有更高的执行速度D.软件的功能不能用硬件取代  

05.存放当前执行指令的寄存器是（）  

A.MAR B.PC C.MDR D.IR  

06.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（）。  

A.PC B.MAR C.MDR D.IR  

07.CPU不包括（）。  

A.地址寄存器B.指令寄存器（IR）C.地址译码器D.通用寄存器  

08.MAR和MDR的位数分别为（）  

A.地址码长度、存储字长B.存储字长、存储字长C.地址码长度、地址码长度D.存储字长、地址码长度  

09.在运算器中，不包含（）  

A.状态寄存器B.数据总线C.ALUD.地址寄存器  

10.下列关于CPU存取速度的比较中，正确的是（）  

A.Cache  $>$  内存  $>$  寄存器 B.Cache  $>$  寄存器  $>$  内存 C.寄存器  $>$  Cache  $>$  内存 D.寄存器  $>$  内存  $>$  Cache  

11.若一个8位的计算机系统以16位来表示地址，则该计算机系统有（）个地址空间。A.256 B.65535 C.65536 D.131072

 12.（）是程序运行时的存储位置，包括所需的数据。A.数据通路B.主存C.硬盘D.操作系统

13.关于编译程序和解释程序，下列说法中错误的是（）  

A.编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序B.编译程序编译时间较长，运行速度较快C.解释程序方法较简单，运行速度也较快D.解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句  

14.可以在计算机中直接执行的语言和用助记符编写的语言分别是（）I.机器语言II.汇编语言III.高级语言IV.操作系统原语V.正则语言A.II、IIIB.II、IVC.I、ⅡID. 1、V  

15.只有当程序执行时才将源程序翻译成机器语言，并且一次只能翻译一行语句，边翻译边执行的是（）程序，把汇编语言源程序转变为机器语言程序的过程是（）  

I.编译II.目标III.汇编IV.解释 A.I、IIB.IV、IIC.IV、ID.IV、III

16.下列关于各种级别语言的描述中，错误的是（）  

A.可用高级语言和低级语言编写出功能等价的程序B.低级语言的执行效率一般情况下高于高级语言C.机器语言源程序可在机器上直接执行，而高级语言和汇编语言源程序不可以D.汇编语言与机器结构无关  

17.下列关于机器指令和汇编指令的叙述中，错误的是（）A.可以直接用机器语言（机器指令）编写程序B.汇编指令和机器指令都能被计算机直接执行 C.汇编语言和机器语言都与计算机系统结构相关 D.汇编指令和机器指令一一对应，功能相同  
18.下列叙述中，正确的是（）。  

I.实际应用程序的测试结果能够全面代表计算机的性能II1.系列机的基本特性是指令系统向后兼容III.软件和硬件在逻辑功能上是等价的  

A.ⅡIB.IIIC.Ⅱ和IⅢID.I、ⅡI和ⅢI  

19.在CPU的组成中，不包括（）。  

A.运算器B.存储器C.控制器D.寄存器  

20.关于相联存储器，下列说法中正确的是（）  

A.只可以按地址寻址B.只可以按内容寻址C.既可按地址寻址又可按内容寻址D.以上说法均不完善  

21.【2015统考真题】计算机硬件能够直接执行的是（）I.机器语言程序II.汇编语言程序III.硬件描述语言程序A.仅IB.仅I、ⅡC.仅I、IⅢID.I、IIⅢI22.【2016统考真题】将高级语言源程序转换为机器级目标代码文件的程序是（）A.汇编程序 B.链接程序 C.编译程序 D.解释程序 23.【2019统考真题】下列关于冯·诺依曼计算机基本思想的叙述中，错误的是（）  

A.程序的功能都通过中央处理器执行指令实现B.指令和数据都用二进制数表示，形式上无差别C.指令按地址访问，数据都在指令中直接给出D.程序执行前，指令和数据需预先存放在存储器中  

24.【2022统考真题】将高级语言源程序转换为可执行目标文件的主要过程是（）  

A.预处理→编译→汇编→链接B.预处理→汇编→编译→链接C.预处理→编译→链接→汇编 D.预处理→汇编→链接→编译  

# 1.2.7 答案与解析  

单项选择题  

01.D A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。  

02.A  

冯·诺依曼机的基本工作方式是控制流驱动方式，也就是按照指令的执行序列，依次读取指令，然后根据指令所含的控制信息，调用数据信息进行处理。因此，在执行程序的过程中，始终以控制信息流为驱动工作的因素，而数据信息流则是被动地被调用处理。  

03.B  

A是不存在的机器，B是对“存储程序”的阐述，因此正确。C是与题干无关的选项。D是相联存储器的特点。  

04.D 软件和硬件具有逻辑功能上的等价性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性。执行频繁、硬件实现代价不是很高的功能通常由硬件实现。  
05.D  

IR存放当前执行的指令代码，PC存放下一条指令的地址，不要将它们混淆。此外，MAR用来存放待访问的存储单元地址，MDR则用来存放取处存储单元的数据。  

06.A 在CPU中，PC用来跟踪下一条要执行的指令在主存储器中的地址。  

07. C  

地址译码器是主存储器的构成部分，不属于CPU。地址寄存器虽然一般属于主存储器，但现代计算机中绝大多数CPU内集成了地址寄存器。  

08.A  

地址寄存器（MAR）存放访存地址，因此位数与地址码长度相同。数据寄存器（MDR）用于暂存要从存储器中读或写的信息，因此位数与存储字长相同。  

09. D  

运算器的核心是ALU。地址寄存器位于CPU内，但并未集成到运算器与控制器中。地址寄存器用来保存当前CPU所访问的内存单元的地址。因为内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止。  

10.C  

寄存器在CPU内部，速度最快。Cache采用高速的SRAM制作，而内存常用DRAM制作，其速度较Cache慢。本题也可根据存储器层次结构的速度关系得出答案。  

11.C 8位计算机表明计算机字长为8位，即一次可以处理8位的数据；而16位表示地址码的长度，因此该机器有 $2^{16}\!=\!65536$ 个地址空间。  

12.B 计算机只能从主存储器中取指令与操作数，不能直接与外存交换数据。  

13.C  

编译程序是先完整编译后运行的程序，如C、 $\mathrm{C++}$ 等；解释程序是逐句翻译且边翻译边执行的程序，如JavaScript、Python等。由于解释程序要边翻译成机器语言边执行，因此一般速度较编译程序慢。为增加对该过程的理解，附C语言编译链接的过程：源程序(. c) C编译器 $\rightarrow$ 汇编源程序—汇编程序 $\rightarrow$ 目标程序—链接程序 $\rightarrow$ 可执行程序  

14.C  

机器语言是计算机唯一可以直接执行的语言，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。  

15.D  

解释程序的特点是翻译一句执行一句，边翻译边执行；由高级语言转化为汇编语言的过程称为编译，把汇编语言源程序翻译成机器语言程序的过程称为汇编。  

16.D  

在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编程序转换成机器指令。特定的汇编语言与特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。  

17.B 计算机只能直接执行机器指令，而汇编指令需要通过汇编程序转换成机器指令才能被计算机直接执行。  
18.C  

全面代表计算机性能的是实际软件的运行情况。向后兼容是指时间上向后兼容，即新机器兼容使用以前机器的指令系统。软件和硬件在逻辑功能上是等价的，如浮点运算即可以用专门的浮点运算器实现，也可以通过编写一段子程序实现。  

19.B  

CPU由运算器和控制器两个部件组成，而运算器和控制器中都含有寄存器。存储器是一个独立的部件。  

20.C  

相联存储器既可以按地址寻址又可以按内容（通常是某些字段）寻址，为与传统存储器区别，也称按内容寻址的存储器。  

21.A  

硬件能直接执行的只能是机器语言（二进制编码），汇编语言是增强机器语言的可读性和记忆性的语言，经过汇编后才能被执行。  

22. C  

翻译程序是指把高级语言源程序转换成机器语言程序的软件。翻译程序有两种：一种是编译程序，它将源程序一次全部翻译成目标程序，并且会生成目标代码文件。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，翻译一句执行一句，并且不会生成目标代码文件。汇编程序也是一种翻译程序，它把汇编语言源程序翻译为机器语言程序。  

23.C  

冯·诺依曼结构计算机的功能部件包括输入设备、输出设备、存储器、运算器和控制器，程序的功能都通过中央处理器（运算器和控制器）执行指令，A正确。指令和数据以同等地位存放于存储器内，形式上无差别，只在程序执行时具有不同的含义，B正确。指令按地址访问，数据由指令的地址码指出，除立即寻址外，数据均存放在存储器内，C错误。在程序执行前，指令和数据需预先存放在存储器中，中央处理器可以从存储器存取代码，D正确。  

24.A  

将源程序转换为可执行目标文件的过程分为预处理、编译、汇编、链接四个阶段。  

# 1.3计算机的性能指标  

# 1.3.1计算机的主要性能指标  

1.机器字长  

命题追踪与机器字长位数相同的部件（2020、2021）  

通常所说的“某16位或32位机器”，其中的16、32指的是机器字长，简称字长。字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、ALU有关。因此，字长一般等于通用寄存器的位数或ALU的宽度，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8位）的整数倍。  

# 注意  

机器字长、指令字长和存储字长的关系（见章末的常见问题3）  
2.数据通路带宽  

数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。  

# 注意  

各个子系统通过数据总线连接形成的数据传送路径称为数据通路。  

3.主存容量  

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 $\times$ 字长（如 $512\mathrm{K}{\times}16$ 位）来表示存储容量。其中，MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长。例如，MAR为16位，表示 $2^{16}\!=\!65536$ ，即此存储体内有65536个存储单元（可称为64K内存， $1\mathrm{K}=1024$ ），若MDR为32位，则表示存储容量为 $64\mathrm{K}\!\times\!32$ 位。  

# 4.运算速度  

# 命题追踪提高系统性能的综合措施（2010）  

（1）吞吐量和响应时间。  

·吞吐量。指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存储器，因此系统吞吐量主要取决于主存储器的存取周期。·响应时间。指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/0操作、操作系统开销等的时间）。（2）主频和CPU时钟周期。  

# 命题追踪时钟脉冲信号和时钟周期的相关概念（2019）  

）CPU时钟周期。机器内部主时钟脉冲信号的宽度，它是CPU工作的最小时间单位  

时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成。时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定。时钟周期也以指令流水线的每个流水段的最大延迟时间确定。  

# 命题追踪主频和时钟周期的转换计算（2013）  

·主频（CPU时钟频率）。机器内部主时钟的频率，即时钟周期的倒数，它是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。主频最直观的理解就是每秒有多少个时钟周期。  

# 注意  

CPU时钟周期 $=1/$ 主频，主频通常以Hz（赫兹）为单位， $10\mathrm{Hz}$ 表示每秒10次。（3）CPI（Cycle Per Instruction），。  

# 命题追踪IPS的相关计算（2023）  

不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其CPI指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，此时CPI是一个平均值。  
·IPS（Instructions Per Second），即每秒执行多少条指令， ${\mathrm{IPS}}=$ 主频/平均CPI。（4）CPU执行时间。指运行一个程序所花费的时间。  

命题追踪CPU执行时间的相关计算（2012、2013、2014、2017、2022、2023）CPU执行时间 $=$ CPU时钟周期数/主频 $=$ （指令条数 $\times\mathrm{CPI}$ 主频  

上式表明，CPU的性能（CPU执行时间）取决于三个要素：主频、CPI和指令条数。主频、CPI和指令条数是相互制约的。例如，更改指令集可以减少程序所含的指令条数，但同时可能引起CPU结构的调整，从而可能会增加时钟周期的宽度（降低主频）。  

【例1.1】假定计算机M1和M2具有相同的指令集体系结构，M1的主频为 $2\mathrm{GHz}$ ，程序P在M1上的运行时间为 $10s$ 。M2采用新技术可使主频大幅提升，但平均CPI也增加到M1的1.5倍。则M2的主频至少提升到多少才能使程序P在M2上的运行时间缩短为6s？  

# 解：  

程序P在M1上的时钟周期数 $=$ 指令条数 $\times\mathrm{CPI}=$ CPU执行时间 $\times$ 主频 $=10\mathrm{s}{\times}2\mathrm{GHz}=2{\times}10^{10}$ M2的平均CPI为M1的1.5倍，因此程序P在M2上的时钟周期数 $=1.5{\times}2{\times}10^{10}\!=3{\times}10^{10}$  

要使程序P在M2上的运行时间缩短到6s，则M2的主频至少应为程序P所含时钟周期数-CPU执行时间 $=3{\times}10^{10}{\div}6\mathrm{s}=5\mathrm{GHz}$ 由此可见，M2的主频是M1的2.5倍，但M2的速度却只是M1的1.67倍。（5）MIPS（Million Instructions Per Second），。  

# 命题追踪MIPS相关的计算（2012、2013）  

$\mathrm{{MIPS}=}$  指令条数÷(执行时间  $\times10^{6})=$  主频  $_\div(\mathbf{CPI}\times10^{6})$  

MIPS对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也就不同，比如在机器M1上某条指令的功能也许在机器M2上要用多条指令来完成；不同机器的CPI和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。  

（6）FLOPS（Floating-point Operations Per Second），。命题追踪浮点数运算指标的概念（2011、2021）  

·MFLOPS（Million FLOPS），即每秒执行多少百万（ $10^{6}$ ）次浮点运算。·GFLOPS（GigaFLOPS），即每秒执行多少十亿（ $10^{9}$ ）次浮点运算。·TFLOPS（TeraFLOPS），即每秒执行多少万亿（ $10^{12}$ ）次浮点运算。·PFLOPS（PetaFLOPS），即每秒执行多少千万亿（ $10^{15}$ ）次浮点运算。·EFLOPS（ExaFLOPS），即每秒执行多少百京（ $(10^{18}$ ）次浮点运算（1京 $=1$ 亿亿 $=10^{16}$ )。·ZFLOPS（ZettaFLOPS），即每秒执行多少十万京（ $10^{21}$ ）次浮点运算。  

# 注意  

在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如 $1\mathrm{Kb}=2^{10}\mathrm{b}$ 在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如 $1\,\mathrm{{kb}/\mathrm{{s}=10^{3}\mathrm{{b}/\mathrm{{s}.}}}}$ 通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。  

# 5.基准程序  

基准程序（Benchmarks）是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。  
使用基准程序进行计算机性能评测也存在一些缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或编译器开发者可能会针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得不到准确的性能评测结果。  

# 1.3.2几个专业术语  

1）系列机。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。2）兼容。指软件或硬件的通用性，即运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。3）固件。将程序固化在ROM中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于ROM中）。  

# 1.3.3 本节习题精选  

# 一、单项选择题  

01.关于CPU主频、CPI、MIPS、MFLOPS，说法正确的是（）。  

A.CPU主频是指CPU系统执行指令的频率，OPI是执行一条指令平均使用的频率B.CPI是执行一条指令平均使用CPU时钟的个数，MIPS描述一条CPU指令平均使用的CPU时钟数C.MIPS是描述CPU执行指令的频率，MFLOPS是计算机系统的浮点数指令D.CPU主频指CPU使用的时钟脉冲频率，CPI是执行一条指令平均使用的CPU时钟数  

02.存储字长是指（）  

A.存放在一个存储单元中的二进制代码组合B.存放在一个存储单元中的二进制代码位数C.存储单元的个数D.机器指令的位数  

03.以下说法中，错误的是（）  

A.计算机的机器字长是指数据运算的基本单位长度B.寄存器是由触发器构成的C.计算机中一个字的长度都是32位D.磁盘可以永久性存放数据和程序  

04.下列关于机器字长、指令字长和存储字长的说法中，正确的是（）  

I.三者在数值上总是相等的ⅡI.三者在数值上可能不等II.存储字长是存放在一个存储单元中的二进制代码位数IV.机器字长就是MDR的位数  

A.I、ⅢB.1、IVC.ⅡI、D.II、IV05.下列关于机器字长的叙述中，错误的是（）。  

A.机器字长是指CPU中定点运算的数据通路宽度B.机器字长一般与OPU中通用寄存器的位数有关C.机器字长决定了数据的表示范围和表示精度  
D.机器字长对计算机硬件的造价没有影响  

06.32位微机是指该计算机所用CPU（）。  

A.具有32位寄存器B.能同时处理32位的二进制数C.具有32个寄存器D.能处理32个字符  

07.在用于科学计算的计算机中，标志系统性能的最有用的参数是（）  

A.主时钟频率B.主存容量C.MFLOPSD.MIPS  

08.在计算机M1和计算机M2上分别运行功能完全相同的高级语言程序，程序在M1和M2上的平均CPI相等，则对于该类程序而言（）  

A.M1和M2执行速度相等 B.M1和M2中主频高的计算机执行速度快C.M1和M2中主频低的计算机执行速度快D.无法确定哪台机器的执行速度快  

09.若一台计算机的机器字长为4B，则表明该机器（）  

A.能处理的数值最大为4位十进制数B.能处理的数值最多为4位二进制数C.在CPU中能够作为一个整体处理32位的二进制代码D.在CPU中运算的结果最大为 $2^{32}$  

10.在CPU的寄存器中，（）对用户是完全透明的。  

A.程序计数器B.指令寄存器C.状态寄存器D.通用寄存器  

11.计算机操作的最小单位时间是（）  

A.时钟周期B.指令周期C.CPU周期D.中断周期  

12.计算机中，CPU的CPI与下列（）因素无关。  

A.时钟频率B.系统结构C.指令集D.计算机组织  

13.从用户观点看，评价计算机系统性能的综合参数是（）  

A.指令系统B.吞吐率C.主存容量D.主频率  

14.当前设计高性能计算机的重要技术途径是（）  

A.提高CPU主频B.扩大主存容量C.采用非冯·诺依曼体系结构D.采用并行处理技术  

15.下列关于“兼容”的叙述，正确的是（）  

A.指计算机软件与硬件之间的通用性，通常在同一系列不同型号的计算机间存在B.指计算机软件或硬件的通用性，即它们在任何计算机间可以通用C.指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用D.指软件在不同系列计算机中可以通用，而硬件不能通用  

16.若某基准测试程序在机器A上运行需要的时间是20s，而在机器B上的运行时间是16s，那么，相对来说，下列给出的结论中，（）是正确的。  

A.所有程序在机器A上都比在机器B上运行速度慢B.机器B的速度是机器A的1.25倍C.机器A的速度是机器B的1.25倍D.机器A比机器B慢1.25倍  

17.机器A的主频为 $800\mathrm{MHz}$ ，某程序在A上运行需要12s。现在硬件设计人员想设计机器B，希望该程序在B上的运行时间能缩短为8s，使用新技术后可使B的主频大幅度提高，但在B上运行该程序所需的时钟周期数为在A上的1.5倍。则机器B的主频至少应为（）  
A.800MHz B.1.2GHz C.1.5GHz D.1.8GHz

 18.下列可用于评价计算机系统性能的指标是（）  

I.MIPSII.IPCIII.CPIIV.字长A.I、ⅢIB.I、IⅢ和IVC.I、II和IⅢID.全部  

19.计算机的机器字长与下列（）指标最为密切相关。A.运算速度B.存取速度C.内存容量D.运算精确度  

20.假定编译器对高级语言的某条语句可以编译生成两种不同的指令序列，A、B和C三类指令的CPI和两种不同序列所含的三类指令条数如下表所示，两个指令序列都在时钟周期为2ns的机器上运行，则下列结论中正确的是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42508ee622372182918a53060f2507cdf4ffecfadff40d332a36735daf917596.jpg)  

A.序列一的MIPS数比序列二多50，序列一的执行速度比序列二快10nsB.序列一的MIPS数比序列二多50，序列二的执行速度比序列一快10nsC.序列二的MIPS数比序列一多50，序列一的执行速度比序列二快10nsD.序列二的MIPS数比序列一多50，序列二的执行速度比序列一快10nS  

21.下列给出了改善计算机性能的4种措施：  

1.用更快的处理器来替换原来的慢速处理器11.增加同类处理器个数，使得不同的处理器同时执行程序I1I.优化编译生成的代码，使得程序执行的总时钟周期数减少IV.减少指令执行过程中访问内存的时间对于某个特定的程序，在以上措施中，能缩短其执行时间的措施是（）  

A.I、Ⅱ和IⅢIB.I、II和IVC.I、III和IVD.全部

22.【2010统考真题】下列选项中，能缩短程序执行时间的措施是（）  

I.提高CPU时钟频率II.优化数据通路结构III.对程序进行编译优化A.仅I和ⅡIB.仅I和IIIC.仅II和IⅢID.I、II、Ⅲ  

23.【2011统考真题】下列选项中，描述浮点数操作速度指标的是（）A.MIPS B.CPI C.IPC D.MFLOPS  

24.【2012统考真题】假定基准程序A在某计算机上的运行时间为100s，其中90s为CPU时间，其余为I/O时间。若CPU速度提高 $50\%$ ，I/0速度不变，则运行基准程序A所耗费的时间是(）。  

A.55s B.60s C.65s D.70s  

25.【2013统考真题】某计算机的主频为 $1.2\mathrm{GHz}$ ，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/145bf5c945d7fee5f92c6610d61273eb4efd744297d3ec788210814e82b4eacf.jpg)  
A.100 B.200 C.400 D.600  

26.【2014统考真题】程序P在机器M上的执行时间是 $20s$ ，编译优化后，P执行的指令数减少到原来的 $70\%$ ，而CPI增加到原来的1.2倍，则P在M上的执行时间是（）。  

A.8.4s B.11.7s C.14s D.16.8s  

27.【2017统考真题】假定计算机M1和M2具有相同的指令集体系结构（ISA），主频分别为1.5GHz和 $1.2\mathrm{GHz}_{\circ}$ ：在M1和M2上运行某基准程序P，平均CPI分别为2和1，则程序P在M1和M2上运行时间的比值是（）。  

A.0.4 B.0.625 C. 1.6 D.2.5

 28.【2020统考真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是（）。  

1.ALUII.指令寄存器III.通用寄存器IV.浮点寄存器A.仅I、ⅡIB.仅I、IⅢIIC.仅Ⅱ、IⅢID.仅IⅡ、IIⅢI、IV  

29.【2021统考真题】2017年公布的全球超级计算机T0P500排名中，我国“神威·太湖之光”超级计算机蝉联第一，其浮点运算速度为93.0146PFLOPS，说明该计算机每秒完成的浮点操作次数约为（）。  

A. $9.3\!\times\!10^{13}$ 次B. $9.3\!\times\!10^{15}$ 次C.9.3千万亿次D.9.3亿亿次  

30.【2022统考真题】某计算机主频为 $1\mathrm{GHz}$ ，程序P运行过程中，共执行了10000条指令，其中， $80\%$ 的指令执行平均需1个时钟周期， $20\%$ 的指令执行平均需10个时钟周期。程序P的平均CPI和CPU执行时间分别是（）。  

A. $2.8,28\upmu\mathrm{s}$ B. 28, $28\upmu\mathrm{s}$ C. 2.8, $28\mathrm{ms}$ D.28,28ms  

31.【2023统考真题】若机器M的主频为 $1.5\mathrm{GHz}$ ，在M上执行程序P的指令条数为 $5{\times}10^{5}$ P的平均CPI为1.2，则P在M上的指令执行速度和用户CPU时间分别为（）。  

A.0.8GIPS,  $0.4\mathrm{ms}$  B.0.8GIPS,  $0.4\upmu\mathrm{s}$  C. 1.25GIPS,  $0.4\mathrm{ms}$  D. 1.25GIPS,  $0.4\upmu\mathrm{s}$  

# 二、综合应用题  

01.设主存储器容量为  $64\mathrm{K}\!\times\!32$  位，且指令字长、存储字长、机器字长三者相等。写出如下 图所示各寄存器的位数，并指出哪些寄存器之间有信息通路【本题涉及第5章的内容】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a0c9740efc4ebf4b21fced2f6f6cc5d29eddc6900a189d5d2cdcf614d79cc105.jpg)  

02.用一台 $40\mathrm{MHz}$ 的处理器执行标准测试程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的CPI、MIPS速率和程序的执行时间（I为程序的指令条数）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/973c168ec15fafe9df247db46ed537f013cf86bd2427da28f24326ab382d2dee.jpg)  

03.微机A和B是采用不同主频的CPU芯片，片内逻辑电路完全相同。1）若A机的CPU主频为 $8\mathrm{MHz}$ ，B机为 $12\mathrm{MHz}$ ，则A机的CPU时钟周期为多少？2）若A机的平均指令执行速度为0.4IMIPS，则A机的平均指令周期为多少？3）B机的平均指令执行速度为多少？  
04.某台计算机只有LOAD/STORE指令能对存储器进行读/写操作，其他指令只对寄存器进行操作。根据程序跟踪试验结果，已知每条指令所占的比例及CPI数如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80cf06badb789b5628aa94a987c2c3d6d5adedd422f8ec2a635f0c671b1076ff.jpg)  

求上述情况下的平均CPI。  

假设程序由 $M$ 条指令组成。算术逻辑运算中 $25\%$ 的指令的两个操作数中的一个已在寄存器中，另一个必须在算术逻辑指令执行前用LOAD指令从存储器中取到寄存器中。因此有人建议增加另一种算术逻辑指令，其特点是一个操作数取自寄存器，另一个操作数取自存储器，即寄存器-存储器类型，假设这种指令的CPI等于2。同时，转移指令的CPI变为3。求新指令系统的平均CPI。  

# 1.3.4 答案与解析  

# 一、单项选择题  

01.D  

CPU主频指CPU的时钟脉冲频率，CPI是执行一条指令平均使用的CPU时钟数。  

02.B  

存储体由许多存储单元组成，每个存储单元又包含若干存储元件，每个存储元件能寄存一位二进制代码“0”或“1”。可见，一个存储单元可存储一串二进制代码，称这串二进制代码为一个存储字，称这串二进制代码的位数为存储字长。  

03.C  

计算机中一个字的长度可以是16、32、64位等，一般是8的整数倍，不一定都是32位。  

04. C  

机器字长、存储字长和指令字长，三者在数值上可以相等也可以不等，视不同机器而定。机器字长等于CPU内部的运算器位数和通用寄存器宽度。一个存储单元中的位数称为存储字长，它等于MDR的位数。指令字长取决于指令的功能和格式，可以是单字长、半字长或双字长。  

05.D  

机器字长会影响硬件的造价。它将直接影响加法器（或ALU），内部总线宽度及寄存器的位数。所以机器字长不能只从数据的精度和表示范围来考虑，还要考虑硬件成本和效率。  

06.B  

计算机的位数是指机器字长，也就是计算机一次能处理的二进制数的长度，通常等于ALU的宽度或通用寄存器的位数。操作系统的位数是指操作系统可寻址的位数，它与机器字长不同。  

07.C  

MFLOPS是指每秒执行多少百万次浮点运算，该参数用来描述计算机的浮点运算性能，而用于科学计算的计算机主要评估浮点运算的性能。  

08.D  

CPU执行时间 $=$ 指令条数 $\times\mathrm{CPI}\times$ 时钟周期的长度，程序在M1和M2上的平均CPI相等，但影响CPU执行时间的因素还有指令条数和时钟周期的长度，此外相同的高级语言程序在不同计算机上编译生成的机器指令条数可能不同，因此无法确定哪台机器执行该类程序的速度快。  
09.C  

机器字长是CPU一次可以处理的二进制代码的位数，因此该机一次可处理 $4{\times}8=32$ 位的二进制代码。计算机的数据表示格式有多种，不同的表示方式所能表示的数据范围不同。  

10.B  

汇编程序员可以通过JIMP指令来设置PC的值。状态寄存器、通用寄存器只有为汇编程序员可见，才能实现编程，而IR、MAR、MDR是CPU的内部工作寄存器，对程序员均不可见。  

11.A  

时钟周期即CPU频率的倒数，是最基本的时间单位，其余选项均大于时钟周期。另外，CPU周期也称机器周期，它由多个时钟周期组成。  

12.A  

CPI是执行一条指令所需的时钟周期数，系统结构、指令集、计算机组织都会影响CPI，而时钟频率并不会影响CPI，但可加快指令的执行速度。例如，执行一条指令需要10个时钟周期，则一台主频为1GHz的CPU，执行这条指令要比一台主频为 $100\mathrm{MHz}$ 的 CPU快。  

13.B  

主频、主存储器容量和指令系统（间接影响CPI）并不是综合性能的体现。吞吐率指系统在单位时间内处理请求的数量，是评价计算机系统性能的综合参数。  

14.D  

提高CPU主频、扩大主存储器容量对性能的提升是有限度的。采用并行技术是实现高性能计算的重要途径，现今超级计算机均采用多处理器来增强并行处理能力。  

15.C  

兼容是指计算机软件或硬件的通用性，因此A、D错误。对于B，它们在任何计算机间可以通用，错误。对于C，兼容通常在同一系列的不同型号计算机间，正确。  

16.B  

机器的速度与基准程序在该机器上的运行时间呈相反关系，因此可知：机器B的速度/机器A的速度 $=$ 基准程序在机器A上的运行时间/基准程序在机器B上的运行时间 $=20\mathrm{s}\dot{\cdot}16\mathrm{s}=1.25$ 因此，可以说，机器B的速度是机器A的1.25倍，或者机器A的速度是机器B的0.8倍。  

17.D  

该程序在机器A上需要的时钟周期数为 $12\!\times\!800\mathrm{M}=9600\mathrm{M}$ ，因为在机器B上运行该程序所需的时钟周期数为在A上的1.5倍，所以在B上需要的时钟周期数为 $9600\mathbf{M}\!\times\!1.5\:=\:14400\mathbf{M}\:=$ 14.4G，要求运行时间为8s，故B的时钟频率为 $14.4\mathrm{G}\dot{\cdot}8=1.8\mathrm{GHz}\circ$  

18.D  

显然，MIPS、CPI、字长都是评价计算机系统的性能指标。IPC表示每个时钟周期运行多少条指令，它是CPI的倒数。  

19.D  

机器字长越长，数据的位数越多，定点数或浮点数所表示及运算的精度就越高，D正确。机器字长与运算速度的关系不大，机器字长与存取速度和内存容量基本没有关系。  

20.D  

$\mathrm{{MIPS}=}$ 主频 $_{(\mathrm{CPI}\times10^{6})}$ ，主频 $=$ 1/时钟周期 $=1/2\mathrm{ns}\,{=}\,500\mathrm{M}$ ，序列一的 $\mathrm{CPI}=(1{\times}1+1{\times}2+4{\times}3){\div}6=$  $15\dot{\cdot}6=2.5$ ，序列二的 $\mathrm{CPI}=(2{\times}1+1{\times}2+2{\times}3){\div}5=10{\div}5=2$ ，故序列一的 $_\mathrm{MIPS}=500\mathrm{M}+(2.5{\times}10^{6})=200$ 序列二的 $\mathrm{MIPS}=500\mathbf{M}+(2\times10^{6})=250\circ$ CPU执行时间 $=$ 指令条数 $\mathbf{\times}\mathbf{CPI\times}$ 时钟周期 $=$ 程序的时钟周期数 $\times$ 时钟周期，序列一所需的时钟周期数是15，序列二所需的时钟周期数是10，故序列一的执行时间为 $15{\times}2\mathrm{ns}\,{=}\,30\mathrm{ns}$ ，序列二的执行时间为 $10{\times}2\mathrm{ns}\,{=}\,20\mathrm{ns}$  
21.D  

采用更快的处理器，可以减少单条指令的执行时间：增加处理器的个数，可以增加程序执行的并行性，缩短程序的执行时间；优化编译代码，可以减少指令之间的各种冲突；访存时间占指令执行的大部分时间，减少访存时间同样可以大大加快指令的执行时间。  

22.D  

CPU时钟频率（主频）越高，完成指令的一个执行步骤所用的时间就越短，执行指令的速度就越快，I正确。数据通路的功能是实现CPU内部的运算器和寄存器及寄存器之间的数据交换，优化数据通路结构，可以有效提高计算机系统的吞吐量，从而加快程序的执行，Ⅱ正确。计算机程序需要先转化成机器指令序列才能最终得到执行，通过对程序进行编译优化可以得到更优的指令序列，从而使得程序的执行时间也越短，ⅢI正确。  

23. D  

MIPS是每秒执行多少百万条指令，适用于衡量标量机的性能。CPI是平均每条指令的时钟周期数。IPC是CPI的倒数，即每个时钟周期执行的指令数。MFLOPS是每秒执行多少百万条浮点数运算，用来描述浮点数运算速度，适用于衡量向量机的性能。  

24.D  

程序A的运行时间为100s，除去CPU时间 $90s$ ，剩余10s为I/O时间。CPU提速 $50\%$ 后运行基准程序A所耗费的时间是 $T\,{=}\,90{\div}\,1.5+10=70s\,\mathrm{c}$  

误区：CPU速度提高 $50\%$ ，而误认为CPU时间减少一半，从而误选A。  

25.C  

基准程序的 $\mathrm{CPI}=2{\times}0.5+3{\times}0.2+4{\times}0.1+5{\times}0.2=3$ 。计算机的主频为1.2GHz，即1200MHz，因此该机器的 $\mathrm{MIPS}=1200\div3=400.$  

26.D  

假设原来的指令条数为 $x$ ，则原CPI为 $20f/x$  $(f$ 为CPU的时钟频率），经过编译优化后，指令条数减少到原来的 $70\%$ ，即指令条数为 $0.7x$ ，而CPI增加到原来的1.2倍，即 $24f/x$ ，则现在P在M上的执行时间就为：（指令条数 $\times\mathrm{CPI})/f{=}\,(0.7x{\times}24{\times}f/x)/f{=}\,24{\times}0.7{=}\,16.8\mathrm{s}$  

27. C  

运行时间 $=$ 指令数 $\times\mathrm{CPI}/\$ 主频。MI的时间 $=$ 指令数 $\times2\dot{\cdot}1.5$ ，M2的时间 $=$ 指令数 $\times1/1.2$ 两者之比为 $(2/1.5){\cdot}(1/1.2)=1.6$  

28.B  

机器字长是指CPU内部用于整数运算的数据通路的宽度。数据通路是指数据在指令执行过程中所经过的路径及路径上的部件，主要是CPU内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致才能相互匹配。因此，机器字长等于ALU位数和通用寄存器宽度。  

29.D  

PFLOPS $=$ 每秒1000万亿（ $10^{15}$ ）次浮点运算。故93.0146PFLOPS $\approx$ 每秒 $9.3{\times}10^{16}$ 次浮点运算，即每秒9.3亿亿次浮点运算。  

30.A  

CPI指平均每条指令的执行需要多少个时钟周期。由于 $80\%$ 的指令执行平均需要1个时钟周期， $20\%$ 的指令执行平均需要10个时钟周期，因此 $\mathrm{CPI}=80\%\!\times\!1+20\%\!\times\!10=2.8$ 6计算机主频为1GHz，程序P共执行10000条指令，平均每条指令需要2.8个时钟周期，因此，CPU执行时间 $=$  $(10000\times2.8){\div}10^{9}\!=\!2.8{\times}10^{-5}\,\mathrm{s}=28\upmu\mathrm{s}.$  
31.C  

程序P的指令条数为 $5{\times}10^{5}$ ，平均CPI为1.2，程序P的总时钟周期数为 $5{\times}10^{5}{\times}1.2=6{\times}10^{5}$ 主频1.5GHz说明1s有 $1.5\mathrm{G}\,=\,1.5{\times}10^{9}$ 个时钟周期。因此，指令执行速度 $=$ 主频/平均CPI $=$  $1.5\mathrm{G}{\div}1.2=1.25\mathrm{G}\mathrm{IPS}$ ，用户CPU时间 $\mathbf{\Sigma}=6{\times}10^{5}\mathbf{\dot{\Sigma}}(1.5{\times}10^{9})\mathbf{s}=4{\times}10^{4}\mathbf{s}=0.4\mathbf{ms}.$  

# 二、综合应用题  

01.【解答】  

因为主存储器容量为 $64\mathrm{K}\!\times\!32$ 位，且 $2^{16}\,{=}\,64\mathrm{K}$ ，所以地址总线宽度为16位，32位表示数据总线宽度，于是MAR为16位，PC为16位，MDR为32位。  

因为指令字长 $=$ 存储字长 $=$ 机器字长，所以IR、ACC、MQ、X均为32位。  

寄存器之间的信息通路有：  

PC→MAR Ad（IR)→MAR MDR→IR 取数：MDR→ACC，存数：ACC→MDRMDR→X  

02.【解答】  

CPI即执行一条指令所需的时钟周期数。本标准测试程序共包含4种指令，则CPI就是这4种指令的数学期望，即  

$$
\mathrm{CPI}=1\times60\%+2\times18\%+4\times12\%+8\times10\%=2.24
$$  

MIPS即每秒执行的百万条指令数。已知处理器时钟频率为 $40\mathrm{MHz}$ ，即每秒包含 $40\mathrm{M}$ 个时钟周期，因此  

$$
{\mathrm{MIPS}}=40/{\mathrm{CPI}}=40{\div}2.24=17.9
$$  

程序的执行时间 $T=\mathrm{CPI}{\times}\mathrm{T\_IC}{\times}I,$ ，其中T_IC是一个CPU时钟的时间长度，是CPU时钟频率 $f$ 的倒数，因此有  

$$
T\!=\!\mathrm{CPI}\!\times\!\mathrm{T\_IC}\!\times\!I\!=\!\mathrm{CPI}\!\times\!(1/f)\!\times\!I\!=5.6\!\times\!10^{-8}\!\times\!I
$$  

本题中的 $I$ 对于解题应无作用，程序的执行时间应是指令的期望即CPI乘以时钟的时间长度，即  $T\!=\!\mathrm{CPI\!\times\!T\!_{\!\_\mathrm{IC}}}$  

03.【解答】  

1）A机的CPU主频为8MHz，所以A机的CPU时钟周期 $=1\dot{-}8\mathrm{MHz}=0.125\upmu\mathrm{s}$  

2）A机的平均指令周期 $=1\div0.4\mathrm{MIPS}=2.5\upmu\mathrm{s}$  

3）A机平均每条指令的时钟周期数 $=2.5\upmu\mathrm{s}\dot{\cdot}0.125\upmu\mathrm{s}=20.$  

因微机A和B的片内逻辑电路完全相同，所以B机平均每条指令的时钟周期数也为20。  

因为B机的CPU主频为 $12\mathrm{MHz}$ ，所以B机的CPU时钟周期 $=1\dot{\cdot}12\mathrm{MHz}=1/12\upmu\mathrm{s},$  

B机的平均指令周期 $=20\!\times\!(1/12)\!=\!5/3\upmu\mathrm{s}$ B机的平均指令执行速度 $=1\div(5/3)\upmu\mathrm{s}\,{=}\,0.6\mathrm{MIPS}\,\mathrm{s}$  

【另解】B机的平均指令执行速度 ${\mathbf{\tau}}=\operatorname{A}$ 机的平均指令执行速度 $\times(12/8)=0.4\mathrm{MPS}\times(12/8)=$ 0.6MIPS  
04.【解答】  

$\textcircled{\scriptsize{1}}$ 本处理机共包含4种指令，则CPI就是这4种指令的数学期望，即  

$$
\mathrm{CPI}=1\times43\%+2\times21\%+2\times12\%+2\times24\%=1.57
$$  

$\circledcirc$ 设原指令总数为 $M$ ，由于新增的算术操作有取操作数的功能，替代了LOAD的功能，所以新指令总数为  

$$
M+(0.25\times0.43M)^{-}(0.25\times0.43M)^{-}(0.25\times0.43M)^{=}0.8925M
$$  

增加另一种算术逻辑指令后，每种指令所占的比例及CPI数如下表所示：  

所以 $\mathrm{CPI}^{\prime}\!=\!1\!\times\!0.3613+2\!\times\!0.1204+2\!\times\!0.1149+2\!\times\!0.1345+3\!\times\!0.2689\!=\!1.9076$ 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2485e9a7c459ad22743446bd533d8f53aaf1c7a8f5213475fbbacea781d73eac.jpg)  

# 1.4 本章小结  

本章开头提出的问题的参考答案如下。  

1）计算机由哪几部分组成？以哪部分为中心？  

计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称中央处理器。  

在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的发展，同时计算机需要处理、加工的信息量也与日俱增，大量I/O设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已发展为以存储器为中心，使I/O操作尽可能地绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。  

2）主频高的CPU一定比主频低的CPU快吗？为什么？  

衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。  

3）翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？  

见常见问题和易混淆知识点1。  

4）不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？  

机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言编写的程序可以被硬件直接执行。  
# 1.5常见问题和易混淆知识点  

1.翻译程序、解释程序、汇编程序、编译程序的区别和联系是什么？  

翻译程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无须重新翻译。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。  

汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。  

编译程序与汇编程序的区别：若源语言是诸如C、 $\mathrm{C++}$ 、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。  

# 2.什么是透明性？透明是指什么都能看见吗？  

在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。  

在CPU中，IR、MAR和MDR对各类程序员都是透明的。3.字、字长、机器字长、指令字长、存储字长的区别和联系是什么？  

字长是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如 $\mathrm{x86}$ 机器中将一个字定义为16位。  

指令字长：一个指令字中包含的二进制代码的位数。  

存储字长：一个存储单元存储的二进制代码的位数。  

它们都必须是字节的整数倍。  

指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令：若指令字长等于存储字长，则取指令周期等于机器周期。  

早期的存储字长一般与指令字长、字长相等，因此访问一次主存储器便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。  

4.计算机体系结构和计算机组成的区别和联系是什么？  

计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。  

计算机组成是指如何实现计算机体系结构所体现的属性，它包含许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器的指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，则完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。  
5.基准程序执行得越快说明机器的性能越好吗？  

一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。  
# 第2章数据的表示和运算  

# 【考纲内容】  

（一）数制与编码进位计数制及其相互转换；定点数的编码表示  

（二）运算方法和运算电路  

基本运算部件：加法器：算术逻辑单元（ALU）加/减运算：补码加/减运算器：标志位的生成乘/除运算：乘/除法运算的基本原理：乘法电路和除法电路的基本结构  

（三）整数的表示和运算  

无符号整数的表示和运算：有符号整数的表示和运算  

（四）浮点数的表示和运算  

浮点数的表示：IEEE754标准：浮点数的加/减运算  

# 【复习提示】  

本章内容较为繁杂，由于计算机中数的表示和运算方法与人们日常生活中的表示和运算方法不同，因此理解也较为困难。纵观历年统考真题，unsigned、short、int、long、float、double等在C语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、IEEE754浮点数的表示以及浮点数的运算，都是考研考查的重点，需要牢固掌握。  

在学习本章时，请读者思考以下问题：  

1）在计算机中，为什么要采用二进制来表示数据？2）计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？  

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 2.1数制与编码  

# 2.1.1进位计数制及其相互转换  

命题追踪采用二进制编码的原因（2018）  

在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。1）二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，  
制造成本比较低，例如用高低电乎或电荷的正负极性都可以很方便地表示0和1。  

2）二进制位1和0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。3）二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。  

# 1.进位计数法  

常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。  

在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 $10\ (0{\sim}9)$ 每个数位计满10就向高位进位，即“逢十进一”。十进制数101，其个位的1显然与百位的1所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。  

一个 $r$ 进制数（ $K_{n}K_{n-1}...K_{0}K_{-1}...K_{-m}$ ）的数值可表示为  

$$
K_{n}r^{n}+K_{n-1}r^{n-1}+\dots+K_{0}r^{0}+K_{-1}r^{-1}+\dots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
$$  

式中， $r$ 是基数； $r^{j}$ 是第 $i$ 位的位权； $K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。  

1）二进制。计算机中用得最多的是基数为2的计数制，即二进制。二进制只有0和1两种数码，计数“逢二进一”。它的任意数位的权为 $2^{i},\textit{i}$ 为所在位数。2）八进制。基数为8，有 $_{0\sim7}$ 共8个不同的数码。计数逢八进一。因为 $r\!=\!8\!=\!2^{3}$ ，所以把二进制中的3位数码编为一组就是1位八进制数码，两者之间的转换极为方便。3）十六进制。基数为16，有 $_{0\sim9}$ 、A～F共16个不同的数码，其中 $\scriptstyle\mathrm{A}\sim\operatorname{F}$ 分别表示 $10{\sim}15$ 计数逢十六进一。因为 $r\!=\!16\!=\!2^{4}$ ，所以4位二进制数码与1位十六进制数码相对应。  

可以用后缀字母标识一个数的进位计数制，用B表示二进制，用O表示八进制，用D表示十进制（通常直接省略），用H表示十六进制，有时也用前缀0x表示十六进制数。  

# 2.不同进制数之间的相互转换  

（1）二进制数转换为八进制数和十六进制数  

对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。其整数部分，从小数点开始往左数，将一串二进制数分为3位（八进制）一组或4位（十六进制）一组，在数的最左边可根据需要加“0”补齐；对于小数部分，从小数点开始往右数，也将一串二进制数分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为3或4的整数倍，然后分别用对应的八进制数或十六进制数取代。  

【例2.1】将二进制数1111000010.01101分别转换为八进制数和十六进制数。  

解：  

高位补0，凑足3位分界点低位补0，凑足3位↓ ↓ ↓ 001 111 000 010 011 010  

所以，对应的八进制数为 $(1702.32)_{8}\!=\!(1111000010.01101)_{2}\!\circ$  

所以，对应的十六进制数为 $(3C2.68)_{16}\!=\!(1111000010.01101)_{2}.$  
同样，由八进制数或十六进制数转换为二进制数，只需将每位改为3位或4位二进制数即可（必要时去掉整数最高位或小数最低位的0）。八进制数和十六进制数之间的转换也能方便地实现，十六进制数转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较方便。  

（2）任意进制数转换为十进制数  

将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。例如， $(11011.1)_{2}\!=\!1\!\times\!2^{4}+1\!\times\!2^{3}+0\!\times\!2^{2}+1\!\times\!2^{1}+1\!\times\!2^{0}+1\!\times\!2^{-1}\!=\!27.5.$  

（3）十进制数转换为任意进制数  

# 命题追踪十进制小数转换为二进制小数（2021、2022）  

一个十进制数转换为任意进制数，通常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分采用除基取余法，对小数部分采用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。  

# 【例2.2】将十进制数123.6875转换成二制数。  

解：  

除基取余法（整数部分）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为0时结束。  

整数部分：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/196d6836af60c957474613cc5ddd3a50ef583549c205aab5dacf92ff151c2a8d.jpg)  

因此整数部分 $123\,{=}\,(1111011)_{2},$  

乘基取整法（小数部分）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为1.0（或满足精度要求）时结束。  

小数部分：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54b7b8f03f6b150f058aee1bb6d9ab852907ade2d8ae065083cd2a78b401736d.jpg)  

因此小数部分 $0.6875\!=\!(0.1011)_{2}$ ，所以 $123.6875\!=\!(1111011.1011)_{2}.$  

# 注意  

关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合 $r$ 进制数的数值表示公式思考，而不应死记硬背。  
# 注意  

在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示，希望读者引起重视。  

# 2.1.2定点数的编码表示  

# 1.真值和机器数  

在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如+15、 $^{-8}$ 等。这种带“ $^+$ ”或“-”符号的数称为真值。真值是机器数所代表的实际值。  

在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。常用的有原码、补码和反码表示法。如0,101（这里的逗号“”仅为区分符号位与数值位）表示 $^{+5}$  

# 2.机器数的定点表示  

根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。在现代计算机中，通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分，历年统考真题的命题信息也主要落在这个范畴之内。  

定点表示法用来表示定点小数和定点整数。  

1）定点小数。定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。若数据 $X$ 的形式为 $X=x_{0}.x_{1}x_{2}...x_{n}$ （其中 $x_{0}$ 为符号位， $x_{1}{\sim}x_{n}$ 是数值的有效部分，也称尾数， $x_{1}$ 为最高有效位），则在计算机中的表示形式如图2.1所示。  

2）定点整数。定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。若数据 $X$ 的形式为 $X\,=\,x_{0}x_{1}x_{2}...x_{n}$ （其中 $x_{0}$ 为符号位， $x_{1}{\sim}x_{n}$ 是尾数， $x_{n}$ 为最低有效位)，则在计算机中的表示形式如图2.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4dd1fb5972f1ed936d1fc0ddfb38f8f045ee71a4c4d74334f59f8240e1e90456.jpg)  
图2.2定点整数表示  

事实上，在机器内部并没有小数点，只是人为约定了小数点的位置。因此，在定点数的编码和运算中不用考虑对应的定点数是小数还是整数，而只需关心它们的符号位和数值位即可。  

定点数的编码表示法主要有以下4种：原码、补码、反码和移码。  

# 3.原码、补码、反码、移码  

（1）原码表示法  

用机器数的最高位表示数的符号，其余各位表示数的绝对值。原码的定义如下。  

O,x, 0≤x<2" [x]原 =  $\cdot_{x}$  是真值，字长为  $n+1$  [2"-x=2"+[x], -2"<x≤0  

例如，若 $x_{1}\!=\!+1110$ ， $x_{2}\,{=}\,{-}1110$ ，字长为8位，则其原码表示为 $[x_{1}]_{\mathbb{R}}=\mathbf{0},$ 0001110, $[x_{2}]_{\mathbb{R}}=2^{7}+$  $1110=1,0001110$ ，其中最高位是符号位。  

若字长为 $n+1$ ，则原码整数的表示范围为- $\scriptstyle\cdot(2^{n}-1)\leqslant x\leqslant2^{n}-1$ （关于原点对称）。  
# 注意  

零的原码表示有正零和负零两种形式，即 $[+0]_{\#}=\mathbf{0}0000000$ 和[ $-0]_{\#}=10000000.$  

原码表示的优点： $\textcircled{\scriptsize{1}}$ 与真值的对应关系简单、直观，与真值的转换简单； $\circledcirc$ 用原码实现乘除运算比较简便。缺点： $_{\odot0}$ 的表示不唯一，有 $\pm0$ 两个编码； $\circledcirc$ 原码加减运算比较复杂。在原码加减运算中，对于两个不同符号数的加法（或同符号数的减法），先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要为结果选择合适的符号。  

（2）补码表示法  

补码表示法中的加减运算统一采用加法操作实现。正数的补码和原码相同，负数的补码等于模 $(n+1$ 位补码的模为 $2^{n+1}$ ）与该负数绝对值之差。补码的定义如下：  

$$
[x]_{\#}={\binom{0,x}{2^{n+1}+x=2^{n+1}-\left|x\right|}},\ \ -2^{n}\leqslant x<2^{n}{\pmod{2^{n+1}}}
$$  

综合上述定义可知，无论是正数还是负数， $[x]_{*}\!=\!2^{n+1}\!+x$  $-2^{n}\!\leqslant\!x\!<\!2^{n}$ ，mod $2^{n+1}$ )  

例如，若 $x_{1}\,{=}\,{+}1010$  $x_{2}\!=\!-1101$ ，字长为8位，则其补码表示为 $[x_{1}]_{*}\!=\!\mathbf{0}{,}0001010$ ， $[x_{2}]_{*}=2^{8}$  $0{,}0001101=1{,}1110011$  

命题追踪补码的表示范围（2010、2013、2014、2022）若字长为 $n+1$ ，则补码整数的表示范围为 $-2^{n}\!\leqslant\!x\!\leqslant\!2^{n}\!-1$ （比原码多表示“ $"-2"$ ”）。  

·几个特殊数据的补码表示1) $[+0]_{*}\!=[-0]_{*}\!=0,\!00...0$ （含符号位共 $n+1$ 个0），说明0的补码表示是唯一的。2) $[-1]_{"}=2^{n+1}\!-\!1=1,\!11...1$ （含符号位共 $n+1$ 个1)。3） $[2^{n}\!-\!\!1]_{*}\!=0,11\dots1$ (n个1)，即 $n+1$ 位补码能表示的最大整数。4） $[-2^{\prime\prime}]_{*}\!=1,\!00...0$  $_{,n}$ 个0)，即 $n+1$ 位补码能表示的最小整数。  

·模运算  

在模运算中，一个数与它除以“模”后得到的余数是等价的，如A、B、 $M$ 满足 $A=B+K{\times}M$  $.K$ 为整数），则记为 $A\!\equiv\!B$ (mod $M)$ ，即 $A,\ B$ 各除以 $M$ 后的余数相同。在补码运算中， $[A]_{\#}-$  $[B]_{*}=[A]_{*}+M-[B]_{*}$ ，而 $M-[B]_{*}=[-B]_{*}$ ，因此补码可以借助加法运算来实现减法运算。  

补码与真值之间的转换  

# 命题追踪补码和真值的相互转换（2020、2023）  

真值转换为补码：对于正数，与原码的方式一样。对于负数，符号位取1，其余各位由真值“各位取反，末位加1”得到。补码转换为真值：若符号位为0，与原码的方式一样。若符号位为1，真值的符号为负，数值部分各位由补码“各位取反，末位加1”得到。  

，变形补码  

变形补码是一种采用双符号位的补码表示，也称模4补码。假定变形补码的位数为 $n+1$ (其中符号位占2位，数值位占 $n-1$ 位），则整数变形补码的表示为  

$$
[x]_{\#\#}=\left\{\begin{array}{l l}{00,x,\qquad\qquad\qquad\qquad\quad0\leqslant x<2^{n-1}}\\ {2^{n+1}+x=2^{n+1}-\big|x\big|,\quad\;-2^{n-1}\leqslant x<0}\end{array}\;(\,\mathrm{mod}\,\,\,2^{n+1}\,)\right.
$$  

模4补码双符号位00表示正，11表示负，用在执行算术运算的ALU中。  
（3）反码表示法（了解）  

负数的补码可采用“各位取反，末位加1”的方法得到，若仅各位求反而末尾不加1，则是负数的反码表示，因此负数反码的定义就是在相应的补码表示中再末位减1。  

正数反码的定义和相应的补码（或原码）表示相同。  

反码表示存在以下几个方面的不足： $\textcircled{\scriptsize{1}}$ 0的表示不唯一（即存在 $\pm0$ )； $\circledcirc$ 表示范围比补码少一个最小负数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。  

（4）移码表示法  

移码常用来表示浮点数的阶码，它只能表示整数。  

移码就是在真值 $X$ 上加上一个常数（偏置值），通常这个常数取 $2^{n}$ ，相当于 $X$ 在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。移码的定义如下。  

$[x]_{\#}\,=2^{n}+x$  $-2^{n}\leqslant x<2^{n}$ ，其中机器字长为 $n+1$  

例如，若正数 $x_{1}\,{=}\,{+}10101$  $x_{2}\!=\!-10101$ ，字长为8位，则其移码表示为 $[x_{1}]_{\#}\!=2^{7}\,+\,10101\!=1,$ 0010101; $[x_{2}]_{\mathrm{i}\mathrm{g}}\,{=}\,2^{7}\,{+}\,(-10101)\,{=}\,0$ ,1101011。  

移码具有以下特点：  

$\textcircled{\scriptsize{1}}$ 移码中零的表示唯一， $[+0]_{\#}=2^{n}+0=[-0]_{\#}=2^{n}-0=100...0$ （n个 $"0")$  

$\circledcirc$ 一个真值的移码和补码仅差一个符号位， $[x]_{\#}$ 的符号位取反即得 $[x]_{\theta}$ （“1”表示正，“ $0$  

表示负，这与其他机器数的符号位取值正好相反），反之亦然。  

$\circledast$ 移码全0时，对应真值的最小值 $-2^{n}$ ：移码全1时，对应真值的最大值 $2^{n}{-}1$  

$^{(4)}$ 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。  

原码、补码、反码和移码这4种编码表示的总结如下：  

# 命题追踪补码大小的判断（2015）  

$\textcircled{\scriptsize{1}}$ 原码、补码、反码的符号位相同，正数的机器码相同。  

$\circledcirc$ 原码、反码的表示在数轴上对称，二者都存在 $_{+0}$ 和-0两个0。  

$\textcircled{3}$ 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。  

$\textcircled{4}$  整数的补码、移码的符号位相反，数值位相同。  

$\circledast$ 负数的补码、反码末位相差1。  

$^\mathrm{\textregistered}$ 原码很容易判断大小。而负数的补码、反码很难直接判断大小，可采用如下规则快速判  

断：对于负数，数值位部分越小，其绝对值越大，即负得越多。  

# 2.1.3整数的表示  

# 1.无符号整数的表示  

# 命题追踪机器码与补码、无符号数之间的转换（2021）  

当一个编码的全部二进制位均为数值位而没有符号位时，该编码表示就是无符号整数，简称无符号数。此时，默认数的符号为正。因为无符号整数省略了一位符号位，所以在字长相同的情况下，它能表示的最大数比有符号整数能表示的大。一般在全部是正数运算且不出现负值结果的场合下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。  

例如，对于8位无符号整数，最小数为00000000（值为0），最大数为11111111（值为 $2^{8}\!-1\!=$ 255），即表示范围为 $_{0\sim255}$ ：而对于8位有符号整数，最小数为 $1000\ 0000$ （值为 $-2^{7}\!=-128)$ ，最大数为01111111（值为 $2^{7}\!-1=127)$ ），即表示范围为- $\cdot128\!\sim\!127$  
# 2.有符号整数的表示  

将符号数值化，并将符号位放在有效数字的前面，就组成了有符号整数。虽然前面介绍的原码、补码、反码和移码都可以用来表示有符号整数，但补码表示有其明显的优势：  

$\textcircled{\scriptsize{1}}$ 与原码和反码相比，0的补码表示唯一。  

$\textcircled{2}$ 与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算。  

$\textcircled{3}$ 与原码和反码相比，补码比原码和反码多表示一个最小负数。  

计算机中的有符号整数都用补码表示，故 $n$ 位有符号整数的表示范围是 $-2^{n-1}{\sim}2^{n-1}$ -1。  

# 2.1.4C语言中的整数类型及类型转换  

统考大纲要求考生具有对高级程序设计语言（如C语言）中相关问题进行分析的能力，而C语言变量之间的类型转换是统考中经常出现的题目，需要读者深入掌握这一内容。  

# 1.C语言中的整型数据类型  

# 命题追踪int型数据的表示范围（2017、2019）  

C语言中的整型数据就是定点整数，根据位数的不同，可分为字符型（char，8位）、短整型（short或shortint，16位）、整型（int，32位）、长整型（long或longint，在32位机器中为32位，在64位机器中为64位）。char是整型数据中比较特殊的一种，其他如short/int/long等不指定signed/unsigned时都默认是有符号整数，但char默认是无符号整数。无符号整数（unsignedshort/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。  

signed/unsigned整型数据都是按补码形式存储的，只是signed型的最高位代表符号位，而在unsigned型中表示数值位，因此这两者所表示的数据范围也有所不同。  

# 2.有符号数和无符号数的转换  

# 命题追踪有符号数与无符号数的相互转换（2011、2016、2019）  

C语言允许在不同的数据类型之间做类型转换。强制类型转换格式为“TYPE $\boldsymbol{\mathrm{b}}\!=\!(\mathrm{TPE})$ a”，强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。  

先看由short型转换到unsignedshort型的情况。考虑如下代码片段：  

int main(){ short  $\mathrm{x}{=}{-}\,4321$  unsigned short  $\mathbb{Y}^{=}$  (unsigned short)x; printf(' $\scriptstyle{\mathrm{'}}_{\mathrm{X}}=\frac{9}{8}\mathrm{d}$ ， $\tt y=\tt S$ u\n"，x，y);  

有符号数 $_\mathrm{x}$ 是一个负数，而无符号数y的表示范围显然不包括x的值。  

在采用补码的机器上，上述程序会输出如下结果： $\texttt{x}=\,-4321$ ， $\texttt{y}=\ 61215$  

输出的结果中，得到的y值似乎与原来的x没有一点关系。不过将这两个数转换为二进制表示时，我们就会发现其中的规律，如表2.1所示。  

表2.1y与x的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea75c374ba8836e0e20e1d2fbf17389368b80728623490a6848a5ac33303d2d0.jpg)  
观察可知，将short型强制转换为unsignedshort型只改变数值，而两个变量对应的每位都是 一样的。通过本例可知，强制类型转换的结果是保持位值不变，仅改变了解释这些位的方式。  

再看由unsignedshort型转换到short型的情况。考虑如下代码片段：  

int main(）{ unsigned short  $\scriptstyle{\mathrm{x}=65535}$  short  $\mathtt{y}^{=}$  (short)x; printf $("x=\S u$ ， $\mathtt{y}{=}\mathtt{\frac{3}{6}}$ d\n"，x，y）；  

同样在采用补码的机器上，上述程序会输出如下结果：X=65535， $\texttt{y}=\texttt{-1}$  

把这两个数转换为二进制表示，同样可以证实之前的结论。因此，有符号数转换为等长的无符号数时，符号位解释为数值的一部分，负数转换为无符号数时数值将发生变化。同理，无符号数转换为有符号数时最高位解释为符号位，也可能发生数值的变化。  

# 注意  

若同时有无符号数和有符号数参与运算，则C语言标准规定按无符号数进行运算。  

# 3.不同字长整数之间的转换  

命题追踪无符号数的零扩展（2012）  

另一种常见的运算是在不同字长的整数之间进行类型转换。  

先看大字长变量向小字长变量转换的情况。考虑如下代码片段：  

int main(）{ int  $_\mathrm{x=165537}$  ，  $\mathrm{u}{=}{-}34991$  //int型占用4B short  $\mathtt{y}^{=}$  (short)x,  $\scriptstyle{\mathbb{T}}=$  (short)u; //short型占用2B printf $("x=\S\,\mathrm{d}$ y=8d\n"，x，y）；printf $\scriptstyle{\mathcal{C}}^{\bullet}\cup=\mathrm{{s}}\,\mathrm{{d}}$  $\uptau=$ d\n”，u，v）;  

运行结果如下：  

$\texttt{x}=\texttt{165537}$ ， $\texttt{Y}=\,-31071$  $\mathrm{~u~}=\ -34991$ ， $\texttt{v}=\,30545$  

其中x,y，u,v的十六进制表示分别为0x000286al，0x86a1，0xfmf7751，0x7751，观察上述数字很容易得出结论，当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位部分直接赋值，因此也是一种保持位值的处理方法。  

再看小字长变量向大字长变量转换的情况。考虑如下代码片段：  

int main(){ short  $\mathrm{x}{=}{-}\,4321$  int  $\mathtt{y}^{=\mathtt{x}}$  unsigned short  $\mathrm{u}{=}$  (unsigned short)x; unsigned int  $\scriptstyle{\mathrm{even}}$  printf  $("x=\S\,\mathrm{d}$   $\mathtt{y}{=}\mathtt{\xi}$  d\n"，x，y）; printf  $\scriptstyle{"{\mathfrak{u}}={\mathfrak{s}}{\mathfrak{u}}}$   $\mathrm{v}{=}$  u\n",u，v）;  

运行结果如下：  

$\textsl{x}=\textsl{-4321}$ ， $\texttt{Y}=\texttt{--}4321$  $\mathrm{~u~}=~61215$ ， $\textsuperscript{v}=~61215$  
# 命题追踪无符号数的零扩展（2012），补码的符号扩展（2021）  

x，y，u,v的十六进制表示分别为0xef1f0xffffeflf0xeflf0x0000ef1f。由本例可知，小字长到大字长的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。若原数字是无符号整数，则进行零扩展，扩展后的高位部分用0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。这与之前的三个例子都不一样，从位值与数值的角度看，前三个例子的转换规则都是保证相应的位值相等，而小字长向大字长的转换，在位值相等的条件下还要补充高位的符号位，可以理解为数值的相等。注意，char型为8位无符号整数，其在转换为int型时高位补0即可。  

# 2.1.5 本节习题精选  

# 单项选择题  

01.若十进制数为137.5，则其八进制数为（）A.89.8 B.211.4 C.211.5 D.1011111.101 02.一个16位无符号二进制数的表示范围是（）  

A.  $0{\sim}65536$  B.0\~65535 C.-32768\~32767 D.-32768\~32768  

03.下列说法有误的是（）  

A.任何二进制整数都可以用十进制表示B.任何二进制小数都可以用十进制表示C.任何十进制整数都可以用二进制表示D.任何十进制小数都可以用二进制表示  

04.对真值0表示形式唯一的机器数是（）  

A.原码B.补码和移码C.反码D.以上都不对  

05.若  $[X]_{*}\,{=}\,1.1101010$  ，则  $[X]_{*}=\mathrm{~(~\mathcal~)~},$  

A.1.0010101 B.1.0010110 C.0.0010110 D.0.1101010  

06.若 $X$ 为负数，则由[X]求 $[-X]*$ 是将（）  

A.  $[X]$  补各值保持不变 B. $[X]_{+}$ 符号位变反，其他各位不变C. $[X]*$ 除符号位外，各位变反，末位加1D.[X]连同符号位一起变反，末位加1  

07.8位原码能表示的不同数据有（）个。  

A.15 B.16 C.255 D.256  

08.一个 $n+1$ 位整数 $x$ 原码的数值范围是（）  

A.  $-2^{n}+1<x<2^{n}-1$  B.  $-2^{n}+1\leqslant x<2^{n}-1$  C.  $-2^{n}+1<x\leq2^{n}-1$  D.  $-2^{n}+1\leqslant x\leqslant2^{n}-1$  

09. $n$ 位定点整数（有符号）表示的最大值是（）A.  $2^{n}$  B.  $2^{n}\mathbf{-}1$  C.  $2^{n-1}$  D.2-1-1  

10.对于相同位数（设为 $N$ 位，不考虑符号位）的二进制补码小数和十进制小数，二进制小数能表示的数的个数/十进制小数所能表示数的个数为（）  

A.  $(0.2)^{N}$  B.  $\left(0.2\right)^{N-1}$  C.(0.02) D.  $\left(0.02\right)^{N-1}$  

11.若定点整数为64位，含1位符号位，则采用补码表示的绝对值最大的负数为（）。  
A.  $-2^{64}$  B.  $-(2^{64}-1)$  C.  $-2^{63}$  D.-(263-1)  

12.下列关于补码和移码关系的叙述中，（）是不正确的。  

A.相同位数的补码和移码表示具有相同的数据表示范围B.0的补码和移码表示相同C.同一个数的补码和移码表示，其数值部分相同，而符号相反D.一般用移码表示浮点数的阶码，而补码表示定点整数  

13.若 $[x]_{*}\!=1,x_{1}x_{2}x_{3}x_{4}x_{5}x_{6}$ 其中 $x_{i}$ 取 $0$ 或1，若要 $x>-32$ ，应当满足（）。  

A. $x_{1}$ 为 $0$ ，其他各位任意B. $x_{1}$ 为1，其他各位任意C. $x_{1}$ 为1， $x_{2}\cdots x_{6}$ 中至少有一位为1D. $x_{1}$ 为 $0$  $x_{2}\cdots x_{6}$ 中至少有一位为1  

14.设 $x$ 为整数， $[x]_{*}\!=1,\!x_{1}\!x_{2}\!x_{3}\!x_{4}\!x_{5}$ ，若要 $x<-16$  $x_{1}\sim x_{5}$ 应满足的条件是（）。  

A. $x_{1}\sim x_{5}$ 至少有一个为1B. $x_{1}$ 必须为0， $x_{2}\sim x_{5}$ 至少有一个为1C.  $x_{1}$  必须为0，  $x_{2}\sim x_{5}$  任意 D.  $x_{1}$  必须为1，  $x_{2}\sim x_{5}$  任意  

15.设 $x$ 为真值， $x^{*}$ 为其绝对值，满足 $[-x^{*}]_{**}=[-x]_{**},$ 当且仅当（）。A. $x$ 任意B. $x$ 为正数C. $x$ 为负数D.以上说法都不对  

16.假定一个十进制数为 $-66$ ，按补码形式存放在一个8位寄存器中，该寄存器的内容用十六进制表示为（）。  

A.C2H B.BEH C.BDH D.42H  

17.设机器数采用补码表示（含1位符号位），若寄存器内容为9BH，则对应的十进制数为(CO。  

A.-27 B.-97 C.-101 D.155

 18.若寄存器内容为10000000，若它等于-0，则为（）。A.原码B.补码C.反码D.移码

19.若寄存器内容为11111111，若它等于 $+127$ ，则为（）A.反码B.补码C.原码D.移码

20.若寄存器内容为11111111，若它等于-1，则为（）A.原码B.补码C.反码D.移码

21.若寄存器内容为00000000，若它等于-128，则为（）A.原码B.补码C.反码D.移码

22.若二进制定点小数真值是-0.1101，机器表示为1.0010，则为（）A.原码B.补码C.反码D.移码

23.下列为8位移码机器数 $[x]_{\theta}$ ，求 $[-x]_{\vartheta}$ 时，（）将会发生溢出。A.11111111 B.00000000 C.10000000 D.01111111  

24.一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则下列说法中正确的是（）。  

A.若采用移码表示，偏置值为127，则此整数最小为-64B.若采用移码表示，偏置值为128，则此整数最大为123C.若采用补码表示，则此整数最小为-96D.若采用补码表示，则此整数最大为252  

25.计算机内部的定点数大多用补码表示，以下是一些关于补码特点的叙述：  

I.零的表示是唯一的II.符号位可以和数值部分一起参加运算IIIL.和其真值的对应关系简单、直观IV.减法可用加法来实现 在以上叙述中，（）是补码表示的特点。  
A.I和ⅡI B.I和ⅢI C.I和II和ⅢI D.I和II和IV

 26.在计算机中，通常用来表示主存地址的是（）A.移码B.补码C.原码D.无符号数

27.16位补码0x8FA0扩展为32位应该是（）A.0x00008FA0 B.0xFFFF8FA0 C.OxFFFFFFAO D.0x80008FA0  

28.【2012统考真题】假定编译器规定init型和short型长度分别为32位和16位，执行下列 C语言语句：unsigned short  $\mathrm{x}\!=\!65530$  unsigned int  $\tt y=x$  得到y的机器数为（）。  

A.00007FFAH B.0000FFFAH C.FFFF7FFAH D.FFFFFFFAH  

29.【2015统考真题】由3个“1”和5个 $"0"$ 组成的8位二进制补码，能表示的最小整数是()。  

A.-126 B.-125 C.-32 D.-3  

30.【2016统考真题】有如下C语言程序段：shorts  $\textrm{s i}=\textrm{--}32767$  unsigned short us  $\mathrm{~i~}=\mathrm{~s~i~}$  执行上述两条语句后，usi的值为（）  

A.-32767 B.32767 C.32768 D.32769

 31.【2018统考真题】冯·诺依曼结构计算机中的数据采用二进制编码表示，其主要原因是（）。  

I.二进制的运算规则简单II.制造两个稳态的物理器件较容易1.便于用逻辑门电路实现算术运算  

A.仅I、IIB.仅I、IC.仅II、IIID.I、II和III  

32.【2019统考真题】考虑以下C语言代码：unsigned short usi  $=$  65535; shortsi  $=$  usi; 执行上述程序段后，Si的值是（）  

A.-1 B.-32767 C.-32768 D.-65535  

33.【2021统考真题】已知有符号整数用补码表示，变量  $x,\,y,\,z$  的机器数分别为FFFDH FFDFH，7FFCH，下列结论中，正确的是（）。  

A.若  $x,y$  和  $z$  为无符号整数，则  $z<x<y$  B.若  $x,y$  和  $z$  为无符号整数，则  $x<y<z$  C.若  $x,y$  和  $z$  为有符号整数，则  $x<y<z$  D.若  $x,y$  和  $z$  为有符号整数，则  $y<x<z$  

34.【2022统考真题】32位补码所能表示的整数范围是（）。  

A.  $-2^{32}\!\sim\!2^{31}\!-1$  B.  $-2^{31}\sim2^{31}-1$  C.  $-2^{32}\sim2^{32}\ -1$  D.  $-2^{31}\sim2^{32}-1$  

# 2.1.6 答案与解析  

# 单项选择题  

01.B  

十进制数转换成八进制数，整数部分采用除基取余法：将整数除以8，所得余数即为转换后的八进制数的个位数码，再将商除以8，余数为八进制数十位上的数码，如此反复进行，直到商是0为止。小数部分采用乘基取整法：将小数乘以8，所得积的整数部分即为八进制数十分位上的数码，再将此积的小数部分乘以8，得到百分位上的数码，如此反复直到积是1.0为止。经转换得到的八进制数为211.40。  
02.B 一个16位无符号二进制数的表示范围是 $0{\sim}2^{16}\mathrm{-}1$ ，即 $0{\sim}65535$  

U3.D  

A、B、C明显正确，二进制整数和十进制整数可以相互转换，仅仅是每位的位权不同而已。而二进制的小数位只能表示 $1/2,1/4,1/8,\cdots,1/2^{n}$ ，因此无法表示所有的十进制小数，D错误。  

04.B 假设位数为5位(含1位符号位)， $[+0]_{\#}=00000,\,[-0]_{\#}=10000,\,[+0]_{\#}=00000,\,[-0]_{\#}=11111,$  $[+0]_{*}=[-0]_{*}=00000$  $[+0]_{\#}=[-0]_{\#}=10000$ 。可知，0的补码和移码的表示是唯一的。  

05.B 若 $X$ 为负数，则其补码转换成原码的规则是“符号位不变，数值位取反，末位加1"，即 $[X]_{i i}\!=$  $0010101+1=0010110.$  

06.D 不论 $X$ 是正数还是负数，由 $[X]_{+}$ 求[-X]的方法是连同符号位一起，每位取反，末位加1。  

07. C  

8个二进制位有 $2^{8}\!=\!256$ 种不同表示。原码中0有两种表示，因此原码能表示的不同数据为 $2^{8}\mathrm{-}1=255$ 个。由于〇在反码中也有两种表示，因此若题目改为反码，答案也为C。0在补码与移码中只有一种表示，因此题目若改为补码或移码，答案为D。  

08.D  $n+1$   $-2^{n}+1{\leqslant}x{\leqslant}2^{n}-1$  

09.D  $n$ 位二进制有符号定点整数，数值位只有 $n-1$ 位最高位为符号位，所以最大值为 $2^{n-1}$ -1。  

10.A  $N$ 位二进制小数共有 $2^{N}$ 种状态，每种状态都能表示一个不同的小数，而十进制小数能表示的数的个数为 $10^{N}$ ，二者的商为 $(0.2)^{N}$ 。这也是为何在计算机的运算中会出现误差情况的原因，它表明仅有 $(0.2)^{N}$ 概率的十进制数可以精确地用二进制表示。  

11. C 对于长度为 $n+1$ （含1位符号位）定点整数 $x$ ，用补码表示时， $x_{\sqrt[[object Object]]{x}}\!=\!-2^{n}$ ，这里 $n\!=\!63$  

12.B 以机器字长5位为例， $[0]_{\#}\!=\!00000$  $[0]_{\#}=2^{4}+0=10000$  $[0]_{\#}\neq[0]_{\#}$ ，表示不相同，但在补码或移码中的表示形式是唯一的。  

13. C  

对于此类题型，先写出特定值的机器码表示，然后根据机器数判断大小的规则来推导数值位的特点（若条件允许，也可以取特殊值来推断）。 $-32$ 的补码为1,100000，根据负数补码判断大小的规则：数值位部分越小，其绝对值越大，即负得越多。因此，若要 $\scriptstyle{x\,>\,-32}$ ，数值位 $x_{1}x_{2}x_{3}x_{4}x_{5}x_{6}$ 需大于100000，即 $x_{1}$ 必须为1，而 $x_{2}\cdots x_{6}$ 中至少有一位为1。  

【特殊值法】对于A，取1,000000，真值为-64，错误。对于B，取1,100000，真值为-32，错误。对于C，取1,100001，真值为-31，符合。对于D，取1.000001，真值为-63，错误。  
14.C  

解题思路与上题类似（也可以采用特殊值解法，请读者自行思考）， $-16$ 的补码为110000根据负数补码判断大小的规则：数值位部分越小，其绝对值越大，即负得越多。因此，若要 $x<-16$ 数值位 $x_{1}x_{2}x_{3}x_{4}x_{5}$ 需小于10000，即 $x_{1}$ 必为0，而 $x_{2}{\sim}x_{5}$ 任意。  

15.D  

当 $x$ 为0或为正数时，满足 $[-x^{*}]_{\#}=[-x]_{\#}$ ，B为充分条件，因此B错误。而 $x$ 为负数时， $-x$ 为正数，而 $-x^{*}$ 为负数，补码的表示是唯一的，显然二者不等，因此C错误。  

16.B  $x\!=\!-66$ 用二进制表示， $[x]_{^{18}}=11000010$ ，则有 $[x]_{*}=10111110=\mathrm{BH}$  

17.C  $\mathrm{9BH}\,{=}\,(1001\ 1011)_{2}$ ，最高位的1表示负数，故其真值为 $(11100101)_{2}\,{=}\,{-}(64+32+4+1)\,{=}\,{-}101$  

18.A  

值等于-0说明只可能是原码或反码（因为补码和移码表示 $0$ 时是唯一的，没有 $+0$ 和-0之分）， $[-0]_{\mathbb{R}}=10000000$ ， $[-0]_{\bar{\kappa}}=$ 11111111。  

19. D  

这里寄存器长度为8， $[+127]_{^{11}\!}=[+127]_{^{12}\!}=[+127]_{^{1*}}\!=0111111$ ，又知同一数值的移码和补码除最高位相反外，其他各位相同，则 $[+127]_{\mathfrak{C}}=11111111$ 或 $[+127]_{\mathrm{\#}}=2^{7}+01111111=1111111\,\mathrm{.}$  

20.B 这里寄存器长度为8， $[-1]_{\#}=[10000001]_{\#}=$ 11111111.  

21.D 这里寄存器长度为8， $[-128]_{\#}=2^{7}+(-10000000)=00000000.$  

22.C 真值-0.1101，对应的原码表示为1.1101，补码表示为1.0011，反码表示为1.0010，移码通常用于表示阶码，不用来表示定点小数。  

23.B 选项B对应8位最小的值-128，而- $-x=128$ 发生溢出，因此无法表示其移码。  

24.A  

若采用补码表示，要使得数值最大，就要让符号位为0，且把“1”放在高位，得到的补码为0111 $1110\mathbf{B}=126$ ：要使得数值最小，就要让符号位为1，且把“1”放在低位，得到的补码为 $1001\ 1111\mathrm{B}=-97.$ 。若采用移码表示，偏置值为128时，要使得数值最大，就要把“1”放在高位，得到的移码为 $1111\ 1100\mathbf{B}-1000\ 0000\mathbf{B}=252-128=124$ ：偏置值为127时，要使得数值最小，则应把“1”放在低位，得到的移码为 $0011\ 1111\mathbf{B}-0111\ 1111\mathbf{B}=1100\ 0000\mathbf{B}=-64$ ，A正确。  

25. D  

$[+0]*$ 和[-0]是相同的，所以1正确。在进行补码定点数的加减运算时，符号作为数的一部分参加运算，Ⅱ正确， $[A]_{*}-[B]_{*}=[A]_{*}+[-B]_{*}$ ，即将减法采用加法实现，IV正确。实际上，补码和其真值的对应关系远不如原码和其真值的对应关系简单直观，Ⅲ错误。  

26.D 主存地址都是正数，因此不需要符号位，因此直接采用无符号数表示。  

27.B  

16位扩展为32位，符号位不变，附加位是符号位的扩展。该数是一个负数，需用1来填补。A是一个正数，C的数值位发生变化，D用0来填充附加位，均不正确。  
28.B  

将一个16位unsignedshort型数转换成32位unsignedint型数时，因为都是无符号数，新表示形式的高位用0填充。16位无符号整数所能表示的最大值为65535，其十六进制表示为FFFFH，因此×的十六进制表示为FFFFH-5H $=$ FFFAH，所以y的十六进制表示为0000FFFAH。  

排除法：先直接排除C、D，然后分析余下选项的特征。由于A、B的值相差几乎近1倍，因此可以算出 $0001\;0000\mathrm{H}$ （接近B且好算的数）的值后，再推断出答案。  

29.B  

原码很容易判断大小。而负数的补码很难直接判断大小，可采用如下规则快速判断：对于负数，数值位部分越小，其绝对值越大，即负得越多。采用补码整数表示时，负数的符号位为1，因此剩下的两个“1”放在末位时其值最小，补码形式为 $1000\;0011$ ，转换为真值为-125。此外，考虑负数的补码转换为原码的方法，从右向左找到第一个数值为1的位，之后的每位进行取反操作，符号位不变，不难发现，当符号位为1，剩下的两个“1”放在末位时，补码的绝对值最大。  

30.D  

因C语言中的数据在内存中为补码表示形式，si对应的补码二进制表示为1000000000000001B，最前面的一位“1”为符号位，表示负数，即-32767。由signed型转换为等长的unsigned型数据时，符号位成为数据的一部分，即负数转换为无符号数（即正数）时，其数值将发生变化。usi对应的补码二进制表示与si的表示相同，但表示正数，为32769。  

31.D  

对于I，二进制只有0和1两种数值，运算规则较简单，都通过ALU转换成加法运算。对于IⅡI，二进制只需要高电平和低电平两个状态就可表示，这样的物理器件很容易制造。对于Ⅲ，二进制与逻辑量相吻合。二进制的0和1正好与逻辑量的“真”和“假”相对应，因此用二进制数表示二值逻辑显得十分自然，采用逻辑门电路很容易实现运算。  

32.A  

unsigned short，长度为2字节，unsigned short usi码即1111111111111111。short型为短整型，长度为2字节，在采用补码的机器上，shortsi的二进制代码为1111111111111111，因此si的值为-1。  

33.D  

若 $x,y$ 和 $z$ 均为无符号整数，则 $x>y>z$ ，A和B错误。若 $x,y$ 和 $z$ 均为有符号整数，补码的最高位是符号位，0表示正数，1表示负数，因此 $z$ 为正数，而 $x$ 和 $y$ 为负数。对于 $x$ 和 $y$ 的比较，数值位取反加1，可知 $x\!=\!-3$ ， $y=-33$ ，故 $x\!>\!y$ 。D正确。  

34.B  

$n$ 位补码整数的最小值是 $1{,}00_{\dots}0$ （即 $-2^{n-1}$ )；最大值是 $0{,}11{\ldots}1$ （即 $2^{n-1}-1)$ 。 $n$ 位补码整数所能表示的范围是 $-2^{n-1}\sim2^{n-1}-1$ ，32位补码整数所能表示的范围是 $-2^{31}\!\sim\!2^{31}\!-\!1$ 。  

# 2.2运算方法和运算电路  

# 2.2.1基本运算部件  

在计算机中，运算器由算术逻辑单元（ArithmeticLogicUnit，ALU）、移位器、状态寄存器（PSW）和通用寄存器组等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。ALU的核心部件是加法器。  
# 1.带标志加法器  

无符号数加法器只能用于两个无符号数相加，不能进行有符号整数的加/减运算。为了能进行有符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息。图23是带标志加法器的实现电路。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b08b1b2e0864197bdd1d72ef2052e0df883af964dc46d02ed1cabeaf47084dfc.jpg)  
图2.3用全加器实现 $n$ 位带标志加法器的电路  

在图2.3中，溢出标志的逻辑表达式为 ${\mathrm{OF}}=C_{n}\oplus C_{n-1}$ ：符号标志就是和的符号，即 $\mathrm{SF}=F_{n-1}$ 零标志 $\mathrm{ZF}=1$ 当且仅当 $F\!=\!0$ ：进位/借位标志 $\mathrm{CF}=C_{\mathrm{out}}\oplus C_{\mathrm{in}^{\mathrm{c}}}$  

# 2.算术逻辑单元（ALU）  

ALU是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。由于加、减、乘、除运算最终都能归结为加法运算，因此ALU的核心是带标志加法器，同时也能执行“与”“或”“非”等逻辑运算。ALU的基本结构如图2.4所示，其中 $A$ 和 $B$ 是两个 $n$ 位操作数输入端， $C_{\mathrm{in}}$ 是进位输入端，ALUop是操作控制端（发出控制信号），用来决定ALU所执行的处理功能。例如，ALUop选择Add运算，ALU就执行加法运算，输出的结果就是 $A$ 加 $B$ 之和。ALUop的位数决定了操作的种类。例如，当位数为3时，ALU最多只有8种操作。  

图2.5给出了能够完成3种运算“与”“或”和“加法”的一位ALU结构图。其中，一位加法用一个全加器实现，在ALUop的控制下，由一个多路选择器（MUX）选择输出3种操作结果之一。这里有3种操作，所以ALUop至少要有两位。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cdde373a0e9aac54e8a3252d040b0625dc2982eaa7ffb7b834dd4a5f48a2d34.jpg)  
图2.4ALU的基本结构  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/446801d26dabb23d19fea7dea7846e8892b38051dc1408e8f16cf0921912b209.jpg)  
图2.5一位ALU的结构  

同时，ALU也可以实现左移或右移的移位操作。  
# 2.2.2 定点数的移位运算  

当计算机中没有乘/除法运算电路时，可以通过加法和移位相结合的方法来实现乘/除法运算。对于任意二进制整数，左移一位，若不产生溢出，相当于乘以2（与十进制数的左移一位相当于乘以10类似)；右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。  

根据操作数的类型不同，移位运算可以分为逻辑移位和算术移位。  

1.逻辑移位  

# 命题追踪逻辑移位运算（2018）  

逻辑移位将操作数视为无符号整数。逻辑移位的规则：左移时，高位移出，低位补0；右移时，低位移出，高位补0。对于无符号整数的逻辑左移，若高位的1移出，则发生溢出。  

# 2.算术移位  

# 命题追踪算术移位运算（2012、2017、2018）  

算术移位需要考虑符号位的问题，即将操作数视为有符号整数。  

计算机中的有符号整数都是用补码表示的，因此对于有符号整数的移位操作应采用补码算术移位方式。算术移位的规则：左移时，高位移出，低位补0，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出；右移时，低位移出，高位补符号位，若低位的1移出，则影响精度。例如，补码1001和0101左移时会发生溢出，右移时会丢失精度。  

# 2.2.3 定点数的加减运算  

# 1.补码的加减法运算  

命题追踪不同字长补码的加法运算（2009）、补码和无符号数的减法运算（2011、2017）  

补码加减运算规则简单，易于实现。补码加减运算的公式如下（设机器字长为 $n+1)$  $\begin{array}{r l}&{[A+B]_{*}=[A]_{*}+[B]_{*}\ (\bmod2^{n+1})}\\ &{[A-B]_{*}=[A]_{*}+[-B]_{*}\ (\bmod2^{n+1})}\end{array}$  

补码运算的特点如下。  

1）按二进制运算规则运算，逢二进一。2）若做加法，两个数的补码直接相加；若做减法，则将被减数与减数的负数补码相加。3）符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。4）最终运算结果的高位丢弃，保留 $_{n+1}$ 位，运算结果亦为补码。  

【例2.3】设字长为8位（含1位符号位）， $A=15$  $B=24$ ，求 $[A+B]*$ 和 $[A-B]*$ 解：  

$A=+15=+0001111$ ， $B=+24=+0011000$ ：得 $[A]_{*}\,{=}\,00001111$ ， $[B]_{*}\,{=}\,00011000$  

求得  $[-B]_{*}=11101000$  。所以  

$[A+B]_{*}=00001111+00011000=00100111$ 符号位为0，对应真值为 $+39$  $[A-B]_{*}=[A]_{*}+[-B]_{*}=00001111+1110\,1000=11110\,1111$ ，符号位为1，对应真值为-9。  

2.溢出判别方法  

命题追踪补码加减运算后的溢出判断（2010、2011、2014、2018、2021）  

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为1（结果为负）；一个负数减去一个正数，结果的符号位却为0（结果为正）。  
补码定点数加减运算溢出判断的方法有3种。  

（1）采用一位符号位  

由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数的符号相同，结果又与原操作数的符号不同，则表示结果溢出。  

设 $A$ 的符号为 $A_{s}$ ， $B$ 的符号为 $B_{s}$ ，运算结果的符号为 $S_{s}$ ，则溢出逻辑表达式为  

$$
V=A_{\mathrm{s}}B_{\mathrm{s}}\overline{{S_{\mathrm{s}}}}+\overline{{A_{\mathrm{s}}B_{\mathrm{s}}}}S_{\mathrm{s}}
$$  

若 $V\!=\!0$ ，表示无溢出；若 $V\!=\!1$ ，表示有溢出。  

（2）采用双符号位  

双符号位法也称模4补码。运算结果的两个符号位 $S_{s1}S_{s2}$ 相同，表示未溢出：运算结果的两个符号位 $S_{s1}S_{s2}$ 不同，表示溢出，此时最高位符号位代表真正的符号。  

符号位 $S_{s1}S_{s2}$ 的各种情况如下  

$\textcircled{\scriptsize{1}}$  $S_{s1}S_{s2}=00$ ：表示结果为正数，无溢出。 $\circledcirc$  $S_{s1}S_{s2}=01$ ：表示结果正溢出。 $\textcircled{3}$  $S_{s1}S_{s2}=10$ ：表示结果负溢出。 $\textcircled{4}$  $S_{s1}S_{s2}=11$ ：表示结果为负数，无溢出。  

溢出逻辑判断表达式为 $V\!=\!S_{s1}\oplus S_{s2}$ ，若 $V\!=\!0$ ，表示无溢出：若 $V\!=\!1$ ，表示有溢出。  

（3）采用一位符号位根据数值位的进位情况判断溢出  

若符号位（最高位）的进位 $C_{n}$ 与最高数位（次高位）的进位 $C_{n-1}$ 相同，说明无溢出，否则说明有溢出。溢出逻辑判断表达式为 $V=C_{n}\oplus C_{n-1}$ ，若 $V=0$ ，表示无溢出； $V=1$ ，表示有溢出。  

# 3.加减运算电路  

# 命题追踪无符号数与有符号数加/减运算能用同一个加法器实现的理由（2011）  

已知一个数的补码表示为Y，则这个数的负数的补码为 $\overrightharpoon{Y}+1$ ，因此，只要在原加法器的Y输入端加 $n$ 个反向器以实现各位取反的功能，然后加一个2选1多路选择器，用一个控制端Sub来控制，以选择是将 $Y$ 输入加法器还是将 $\overrightharpoon{Y}$ 输入加法器，并将Sub同时作为低位进位送到加法器（做减法时实现末位加1），如图2.6所示。该电路可实现模 $2^{n}$ 补码加减运算。当Sub为1时，做减法，实现 $X+\overline{{{Y}}}+1=[x]_{*}+[-y]_{*}$ ：当Sub为O时，做加法，实现 $X+Y=[x]_{*}+[y]_{*}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca2c5205d971573b48f8360dfee06c31fc7050362e076fdddeb45c514b1d2093.jpg)  
图2.6加减运算部件  

无符号整数相当于正整数的补码表示，因此图2.6的电路同时也能实现无符号数的加/减运算，对于有符号数 $x$ 和 $y$ ，图中 $X$ 和 $Y$ 分别是 $x$ 和 $y$ 的补码表示：对于无符号数 $x$ 和 $y$ ，图中 $X$ 和 $Y$ 分别是 $x$ 和 $y$ 的二进制表示。不论是补码减法还是无符号数减法，都是用被减数加上减数的负数的补码（即 $\overrightharpoon{Y}+1$ ）来实现的。  
# 注意  

运算器本身无法识别所处理的二进制串是有符号数还是无符号数。例如， $0-1=\,00...0+$  $11\ldots1\!=\!11\ldots1,$ 若解释为有符号数，对应值为-1，结果正确；若解释为无符号数，对应值为 $2^{n}{-}1$  $n$ 位无符号数的最大值），结果出错。此类易混点是统考极易考查的内容。  

可通过标志信息来区分有符号整数运算结果和无符号整数运算结果。  

# 命题追踪  

无符号数、有符号数加减运算后CF和OF的值（2011、2018、2023）；SF和OF的逻辑表达式（2022）  

零标志ZF： $Z\mathrm{F}=1$ 表示结果F为O。对于无符号数和有符号数的运算，ZF都有意义。  

溢出标志OF：判断有符号数运算是否溢出，它是符号位进位与最高数位进位的异或结果即 ${\mathrm{OF}}=C_{n}\oplus C_{n-1}$ 。对于无符号数运算，OF没有意义，通俗地说，就是根据OF无法判断无符号数运算是否溢出。例如，无符号数加法 $010+011=101$ ，此时 $\mathrm{OF}=1$ ，但结果未溢出。  

符号标志SF：表示结果的符号，即F的最高位。对于无符号数运算，SF没有意义。  

进/借位标志CF：表示无符号数运算时的进位/借位，判断是否发生溢出。加法时， $\mathrm{CF}{=}1$ 表示结果溢出，因此CF等于进位输出 $C_{\mathrm{out}}$ 。减法时， $\mathrm{CF}=1$ 表示有借位，即不够减，故CF等于进位输出 $C_{\mathrm{out}}$ 取反。综合可得 $\mathrm{CF}\,{=}\,\mathrm{Sub}\oplus C_{\mathrm{out}}.$ 。例如，无符号数加法 $110+011$ 最高位产生进位，无符号数减法  $000-111$  最高位产生借位，结果均发生溢出（即  $\mathrm{CF}\,=\,1)$  。对于有符号数运算，CF 没有意义，也就是说，根据CF无法判断有符号数运算是否溢出。  

（1）无符号数大小的比较  

对于无符号数的运算，零标志ZF、进/借位标志CF才有意义。假设有两个无符号数 $A$ 和 $B$ 下面以执行 $A-B$ 为例来说明ZF、CF标志的几种可能情况。  

若 $A^{=}B$ ，如 $A-B=011-011=000$ ，此时结果为零 $Z\mathrm{F}=1$ ，无借位 $\mathrm{CF}=0$  

若 $A>B$ ，如 $A-B=010-001=001$ ，此时结果非零 $Z\mathrm{F}=0$ ，无借位 $\mathrm{CF}=0$  

若 $A<B$ ，如 $A-B=000-001=(1)000-001=111$ ，此时 $\mathrm{ZF}\!=0$ ，有借位 $\mathrm{CF}=1$  

当ZF=1时，说明 $\scriptstyle\mathcal{A}\equiv\mathcal{B}$ 。当ZF $\underline{{\underline{{\mathbf{\Pi}}}}}\,\underline{{\underline{{\mathbf{\delta\pi}}}}}\,\underline{{\underline{{\mathbf{\delta\pi}}}}}$ 且CF $\l_{\infty}^{\prime}0$ 时，说明 $\scriptstyle\mathcal{A}\geq\mathcal{B}\mathfrak{c}$ 当CF $=1$ 时，说明 $\underline{{A}}\le\underline{{B}}$  

（2）有符号数大小的比较  

对于有符号数的运算，零标志ZF、溢出标志OF、符号标志SF才有意义。假设两个有符号数 $A$ 和 $B$ ，用补码表示，以执行 $[A]_{*}-[B]_{*}$ 为例来说明ZF、OF、SF标志的几种可能情况。  

若 $A\,{=}\,B$ ，如 $![A]_{*}-[B]_{*}=011-011=[A]_{*}+[-B]_{*}=011+101=(1)000,$ ，此时结果为零 $\mathrm{ZF}=1$ 最高位进位与次高位进位的异或结果 $\mathrm{OF}=C_{3}\oplus C_{2}=0$ ，结果的最高位 $\mathrm{SF}=0$  

若  $A\!>B$   $l!\!\!1[A]_{*}-[B]_{*}=010-001=010+111=(1)001$  ，此时  $\mathrm{ZF}=0,~\mathrm{OF}=0,~\mathrm{SF}=0$  ；又  $999[A]*-[B]*=011-101=011+011=110$ ，此时 $\mathrm{{ZF}=0,\,\ O F=1,\,\ S F=1}\,.$  

若 $A<B$ ，如 $[A]_{*}-[B]_{*}\,=000-001=000+111=111$ ，此时 $\mathrm{ZF}=0,~\mathrm{OF}=0,~\mathrm{SF}=1$ 。又 $991[A]_{*}-[B]_{*}\ =101-011=101+101=(1)010$ ，此时 $\mathrm{{ZF}}=0,\;\;\mathrm{{OF}}=1,\;\;\mathrm{{SF}}=0.$  

当ZF $=$ 1时，说明 $\scriptstyle{\mathcal{A}}={\mathcal{B}}$ 。当 $Z\mathrm{F}=0$ 且未发生溢出时，即 $\mathrm{OF}\,{=}\,0$ 时，若 $\mathrm{SF}=0$ ，则表示结果非负，说明 $A>B$ ：当发生溢出时，即 $\mathrm{OF}=1$ 时，若 $\mathrm{SF}=1$ ，则必然是正数减去负数发生溢出导致结果为负，因此，当OF $=$ SF（或OFSF $\lneq0$ ）且ZF $=\!0$ 时，说明 $\scriptstyle\mathcal{A}\geq\mathcal{B}$ 。当 $Z\mathrm{F}=0$ 且未发生溢出时，即 $\mathrm{OF}=0$ 时，若 $\mathrm{SF}=1$ ，则表示结果为负，说明 $A<B$ ；当发生溢出时，即 $\mathrm{OF}=1$ 时，若 $\mathrm{SF}=0$ ，则必然是负数减去正数发生溢出导致结果为正，因此，当OFSF（或OFSF=1）HZF $=\!0$ 时，说明 $\scriptstyle A\leq B$  
# 4.原码的加减法运算（了解）  

在原码加减运算中，将符号位和数值位分开处理，具体的规则如下。  

加法规则：遵循“同号求和，异号求差”的原则，先判断两个操作数的符号位。具体来说，符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出；符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。  

减法规则：先将减数的符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。  

# 注意  

原码的加减运算规则比较复杂，因此计算机采用的大多是补码加减运算。  

# 2.2.4 定点数的乘除运算  

1.定点乘法运算  

（1）乘法运算的基本原理  

# 命题追踪如何用加、减、移位指令实现乘法指令（2020）；用软/硬件实现乘法指令的速度对比（2020）  

原码乘法的特点是符号位与数值位是分开求的，原码乘法运算分为两步： $\textcircled{\scriptsize{1}}$ 乘积的符号位由两个乘数的符号位“异或”得到： $\circledcirc$ 乘积的数值位是两个乘数的绝对值之积。两个定点数的数值部分之积可视为两个无符号数的乘积。下面是两个无符号数相乘的手算过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e9db16b99b4414f5ea84bd89e7c11ec1810c2c66dcab7d40d3de91283d2f650b.jpg)  

上述过程可写成数学推导过程：  

$$
\begin{array}{r l}&{X{\times}Y{=}X{\times}y_{4}{\times}2^{-4}+X{\times}y_{3}{\times}2^{-3}+X{\times}y_{2}{\times}2^{-2}+X{\times}y_{1}{\times}2^{-1}}\\ &{\qquad=2^{-1}\{2^{-1}[\ 2^{-1}(2^{-1}(0+X{\times}y_{4})+X{\times}y_{3})+X{\times}y_{2}]+X{\times}y_{1}\}}\end{array}
$$  

更普遍地， $n$ 位无符号数乘法 $X{\times}Y$ 可递归地定义如下。  

$$
\begin{array}{l}{{P_{1}=2^{-1}(P_{0}+X\times y_{n})}}\\ {{P_{2}=2^{-1}(P_{1}+X\times y_{n-1})}}\\ {{{}}}\\ {{P_{n}=2^{-1}(P_{n-1}+X\times y_{1})}}\end{array}
$$  

其递推公式为  

$$
P_{i+1}=2^{-1}(P_{i}+X\times y_{n-i}\ )\quad(\,i=0,\,1,\,2,\cdots,\,n-1\,)
$$  

最终乘积为  
$$
P_{n}{=}X{\times}Y
$$  

由上述分析可知，乘法运算可用加法和移位运算来实现（乘以 $2^{-1}$ 相当于做一次右移），两个 $n$ 位无符号数相乘共需进行 $n$ 次加法和 $n$ 次移位运算。原码乘法运算的过程可归纳如下：  

$\textcircled{\scriptsize{1}}$ 被乘数和乘数均取绝对值参加运算，视为无符号数，符号位为 $x_{s}\oplus y_{s}$  

$\circledcirc$ 部分积 $P_{i}$ 是乘法运算的中间结果，初值 $P_{0}\!=\!0$ 。从乘数的最低位 $y_{n}$ 开始，将前面所得的部分积 $P_{i}$ 加上 $X{\times}y_{n-i}$ ，然后右移一位，此步骤重复 $n$ 次。  

# 注意  

由于参与运算的是两个数的数值位，因此运算过程中的右移操作均为逻辑右移，  

（2）乘法运算电路  

# 命题追踪乘法电路中控制逻辑的作用（2020）  

图2.7是32位无符号数乘法运算的逻辑结构图。部分积和被乘数 $X$ 做无符号数加法时，可能产生进位，因此设置一个专门的进位位 $C$ 。乘积寄存器 $P$ 初始置0。计数器 $C_{n}$ 初值为32，每循环一次减1。ALU是乘法器的核心部件，对乘积寄存器 $P$ 和被乘数寄存器 $X$ 的内容做“无符号加法”运算，结果送回寄存器 $P$ ，进位存放在 $C$ 中。每次循环都对进位位 $C_{\backprime}$ 寄存器 $P$ 和寄存器Y实现同步“逻辑右移”，此时，进位位 $C$ 移人寄存器 $P$ 的最高位，寄存器 $Y$ 的最低位移出。每次从寄存器Y移出的最低位都被送到控制逻辑，以决定被乘数是否“加”到部分积上。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8b2f2efb8fb8e06dba5d1e1515aadb7d8ddaed5027b92202ab8b99fb2db85ef1.jpg)  
图2.732位无符号数乘法运算的逻辑结构图  

# 命题追踪无符号数和有符号数乘法指令的溢出判断（2019、2020、2021）  

在字长为32位的计算机中，对于两个int型变量 $x$ 和 $y$ 的乘积，若乘积高32位的每一位都相同，且都等于乘积低32位的符号，则表示不溢出，否则表示溢出。当 $x$ 和 $y$ unsigned in t型变量时，若乘积的高32位全为0，则表示不溢出，否则表示溢出。  

# 2.除法运算  

（1）除法运算的基本原理  

原码的除法运算与乘法运算很相似，都是一种移位和加减运算迭代的过程，但比乘法运算更复杂。 $n$ 位定点数的除法运算，需统一为：一个 $2n$ 位的数除以一个 $n$ 位的数，得到一个 $n$ 位的商，因此需要对被除数进行扩展。对于定点正小数（即原码小数），只需在被除数低位添 $n$ 个0即可。对于定点正整数（即无符号数），只需在被除数高位添 $n$ 个0即可。做整数除法时，若除数为0，则发生“除数为0”异常，此时需调出操作系统相应的异常处理程序进行处理。  

下面以两个无符号数为例说明手算除法步骤。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b22578c8487627eb2d6a4c43646e4c36db3f32c45ffb58d5a241672596cd920b.jpg)  

上述除法运算的过程可归纳如下：  

$\textcircled{\scriptsize{1}}$ 被除数与除数相减，够减则上商为1，不够减则上商为0  

$\circledcirc$ 每次得到的差为中间余数，将除数右移后与上次的中间余数比较。用中间余数减除数，  

够减则上商为1，不够减则上商为0。如此重复，直到商的位数满足要求为止。  

若是 $2n$ 位除以 $n$ 位的无符号数，商的位数为 $n+1$ 位，当第一次试商为1时，则表示结果溢出（即无法用 $n$ 位表示商），如 $1111\ 1111/1111=1\ 0001$ 。若是两个 $n$ 位的无符号数相除，则第一位商为0，且结果肯定不会溢出，如两个4位数相除的最大商为 $0000\;1111/0001=1111.$ 对于浮点数尾数的原码小数相除，第一次试商为1，则说明尾数部分有溢出，可通过右规消除。  

计算机内部的除法运算与手算除法一样，通过被除数（中间余数）减除数来得到每一位商，够减上商1，不够减上商0。原码除法运算也要将符号位和数值位分开处理，商的符号位是两个数的符号位的“异或”结果，商的数值位是两个数的绝对值之商。  

（2）除法运算电路  

图2.8是一个32位除法逻辑结构图。寄存器 $Y$ 存放除数：寄存器 $R$ 初始时存放扩展被除数的高32位，运算过程中存放中间余数的高位部分，结束时存放的是余数；寄存器 $\mathcal{Q}$ 初始时存放扩展被除数的低32位，运算过程中部分存放中间余数的低位部分、部分存放商，结束时存放的是32位商。ALU是除法器的核心部件，对寄存器 $R$ 和Y的内容做加/减运算，运算结果被送回寄存器 $R$ 。计数器 $C_{n}$ 初值为32，每循环一次减1。每次循环，寄存器 $R$ 和 $\mathcal{Q}$ 实现同步左移，左移时， $\mathcal{Q}$ 的最高位移入R的最低位， $\mathcal{Q}$ 中空出的最低位被上商。从低位开始，遂次把商的各个数位左移到 $\mathcal{Q}$ 中。每次由控制逻辑根据ALU运算结果的符号来决定上商是0还是1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99e080eafaeaa56c6e3b0cb75bcae35c36ab081b32783fa2a18c159d18a06bda.jpg)  
图2.832位除法运算的逻辑结构图  

若是两个32位int型整数相除，则除了 $-2^{31}/{-1}$ 会溢出，其余情况都不会溢出。  

# 2.2.5本节习题精选  

# 一、单项选择题  

01.ALU作为运算器的核心部件，其属于（））A.时序逻辑电路B.组合逻辑电路C.控制器D.寄存器  
02.组成一个运算器需要多个部件，但下面的（）不是组成运算器的部件。A.状态寄存器B.数据总线C.ALUD.地址寄存器

03.算术逻辑单元（ALU）的功能一般包括（）  

A.算术运算 B.逻辑运算 C.算术运算和逻辑运算 D.加法运算  

04.补码定点整数01010101算术左移两位后的值为（）A.01000111 B.01010100 C.01000110 D.01010101

 05.下列四个补码整数存放于8位寄存器中，算术左移不会发生溢出的是（）A.80H B.90H C.BOH D.COH

 06.补码定点整数10010101右移一位后的值为（））A.01001010 B.010010101 C.10001010 D.11001010

 07.两个机器数7E5H和4D3H相加，得（）A.BD8H B.CD8H C.CB8H D.CC8H  

08.设机器数字长8位（含1位符号位），若机器数BAH为补码，算术左移1位和算术右移1位分别得（）。  

A.F4H,EDH B.B4H,6DH C.74H,DDH D.B5H,EDH

 09.在定点运算器中，无论是采用双符号位还是采用单符号位，必须有（）  

A.译码电路，它一般用“与非”门来实现B.编码电路，它一般用“或非”门来实现C.溢出判断电路，它一般用“异或”门来实现 D.移位电路，它一般用“与或非”门来实现  

10.机器运算发生溢出的根本原因是（）  

A.寄存器的位数有限 B.运算中将符号位的进位丢弃 C.运算中将符号位的借位丢弃D.数据运算中发生错误  

11.假定有两个整数用8位补码分别表示为 $r_{1}=\mathrm{F}5\mathrm{H}$  $r_{2}=\mathrm{EEH}_{\mathrm{e}}$ 若将运算结果存放在一个8位寄存器中，则下列运算会发生溢出的是（）。  

A.  $r_{1}+r_{2}$  B.  $r_{1}-r_{2}$  C.  $r_{1}\!\times\!r_{2}$  D.  $r_{1}/r_{2}$  

12.关于模4补码，下列说法正确的是（）。  

A.模4补码和模2补码不同，它更容易检查乘除运算中的溢出问题B.每个模4补码存储时只需一个符号位C.存储每个模4补码需要两个符号位D.模4补码，在算术与逻辑单元中为一个符号位  

13.若采用双符号位，则两个正数相加产生溢出的特征时，双符号位为（）A.00 B.01 C.10 D.11  

14.判断加减法溢出时，可采用判断进位的方式，若符号位的进位为 $C_{0}$ ，最高位的进位为 $C_{1}$ ，则产生溢出的条件是（）。  

1. $C_{0}$ 产生进位II. $C_{1}$ 产生进位Ⅲ. $C_{0}$  $C_{1}$ 都产生进位IV. $C_{0}$  $C_{1}$ 都不产生进位V. $C_{0}$ 产生进位， $C_{1}$ 不产生进位VI. $C_{0}$ 不产生进位， $C_{1}$ 产生进位  

A.1和lI B.1I XC.IV D.V和VI  

15.在补码的加减法中，用两位符号位判断溢出，两位符号位 $S_{\mathrm{s}1}S_{\mathrm{s}2}=10$ 时，表示（）。A.结果为正数，无溢出B.结果正溢出C.结果负溢出D.结果为负数，无溢出  
16.若 $[X]_{*}\!=\!X_{0}.X_{1}X_{2}\cdots X_{n}$ 其中 $X_{0}$ 为符号位， $X_{1}$ 为最高数位。若（），则当补码左移时，将会发生溢出。  

A.  $X_{0}\!=\!X_{1}$  B.  $X_{0}\!\neq\!X_{1}$  C.  $X_{1}\,{=}\,0$  D.  $X_{1}=1$  

17.原码乘法是（）  

A.先取操作数绝对值相乘，符号位单独处理B.用原码表示操作数，然后直接相乘C.被乘数用原码表示，乘数取绝对值，然后相乘D.乘数用原码表示，被乘数取绝对值，然后相乘  

18.在原码乘法中，（）。  

A.符号位参加运算B.符号位不参加运算0.符号位参加运算，并根据运算结果改变结果中的符号位D.符号位不参加运算，并根据运算结果确定结果中的符号  

19.原码乘法时，符号位单独处理乘积的方式是（）  

A.两个操作数的符号相“与”B.两个操作数的符号相“或”C.两个操作数的符号相“异或”D.两个操作数中绝对值较大数的符号  

20.下列关于移位运算的说法中，正确的是（）  

1.补码算术左移时，高位移出，低位补0，若左移前后的符号位不同，则发生溢出I1.无符号数逻辑左移时，若最高位移出的是1，则发生溢出I1.逻辑左移和算术左移的结果都一样，都是移出最高位，并在低位补0  

A.I、ⅢIB.仅ⅡIC.只有IIID.I、I、Ⅲ  

21.某计算机字长为8位，CPU中有一个8位加法器。已知无符号数 $x\!=\!69$  $y\!=\!38$ ，若在该加法器中计算 $x-y$ ，则加法器的两个输入端信息和输入的低位进位信息分别为（）。  

A.01000101.00100110、0B.01000101、11011001、1C.01000101、11011010、0D.01000101、11011010、1  

22.某计算机中有一个8位加法器，有符号整数 $x$ 和y的机器数用补码表示， $[x]_{*}\!=\!\mathrm{F}5\mathrm{H}$  $[y]_{\#}\!=\!7\mathrm{EH}$ ，若在该加法器中计算 $x-y$ ，则加法器的低位进位输入信息和运算后的溢出标志OF分别是（）。  

A.11B.1、0C. 0、1D.0.0  

23.某8位计算机中， $x$ 和 $y$ 是两个有符号整数，用补码表示， $[x]_{^{\#}}\,{=}\,44\mathrm{H},\;\;[y]_{^{\#}}\,{=}\,\mathrm{DCH}$ ，则 $x/2+2y$ 的机器数及相应的溢出标志OF分别是（）。  

A.CAH、0B.CAH、1C.DAH、0D.DAH、1  

24.某8位计算机中， $x$ 和 $y$ 是两个有符号整数，用补码表示， $[x]_{\mathrm{#}}\,{=}\,44\mathrm{H}$  $[y]_{*}\!=\!\mathrm{DCH}$ ，则 $x^{-}2y$ 的机器数及相应的溢出标志OF分别是（）。  

A.8CH、1B.8CH、0C.68H、1D.68H、0  

25.【2009统考真题】一个C语言程序在一台32位机器上运行。程序中定义了三个变量 $\mathrm{{x,y,}}$ Z，其中x和z为int型，y为short型。当 $\mathrm{x}=127,\mathrm{y}=-9$ 时，执行赋值语句 ${\bf z}={\bf x}+{\bf y}$ 后， $\mathbf{\boldsymbol{x}},\mathbf{\boldsymbol{y}},\mathbf{\boldsymbol{z}}$ 的值分别是（）。  

A.  $\mathrm{x}=0000007\mathrm{FH}$  ，  $\mathbf{y}=$  FFF9H,  $\mathrm{z}=00000076\mathrm{H}$  B.  $\mathrm{x}=0000007\mathrm{FH}$   $\mathbf{y}=\mathrm{FF9H}$   $\mathbf{Z}=$  FFFF0076H C.  $\mathrm{x}=0000007\mathrm{FH}$   $\mathrm{y}=\mathrm{FF}7\mathrm{H}$   $\mathbf{Z}=$  FFFF0076H D. $\mathrm{\DeltaX=0000007FH}$ ， $\mathrm{y}=\mathrm{FF7H}$  $\mathrm{\DeltaZ=00000076H}$  
26.【2010统考真题】假定有四个整数用8位补码分别表示： $r_{1}=\mathrm{FEM},\;\;r_{2}=\mathrm{F2H},\;\;r_{3}=90\mathrm{H},$  $r_{4}=\mathrm{F}8\mathrm{H}$ ，若将运算结果存放在一个8位寄存器中，则下列运算会发生溢出的是（）。  

A.  $r_{1}\!\times\!r_{2}$  B.  $r_{2}\!\times\!r_{3}$  C.   $r_{1}\!\times\!r_{4}$  D.  $r_{2}\!\times\!r_{4}$  

27.【2013统考真题】某字长为8位的计算机中，已知整型变量 $x,\,y$ 的机器数分别为[x=11110100， $[y]_{*}=1\ 0110000$ 。若整型变量 $z=2x+y/2$ ，则 $z$ 的机器数为（）。  

A.11000000B.00100100C.10101010D.溢出  

28.【2014统考真题】若 $x=103,\ y=-25,$ ，则下列表达式采用8位定点补码运算实现时，会发生溢出的是（）。  

A.  $x+y$  B.  $-x+y$  C.  $x-y$  D.  $-x-y$  

29.【2018统考真题】假定有符号整数采用补码表示，若int型变量  $_\mathrm{x}$  和y的机器数分别是 FFFFFFDFH和 $0000\,0041\mathrm{H}$ ，龙则 $_\mathrm{x}$ 、y的值及 $_\mathrm{x-y}$ 的机器数分别是（）。  

A. $\mathbf{x}=-65,\mathbf{y}=41$  $\mathrm{x-y}$ 的机器数溢出B.  $\mathrm{x}=-33,\mathrm{y}=65,\mathrm{x}-\mathrm{y}$  FFFFFF 9 DH C.  $\mathbf{X}=-33$   $\upy=65$  X-y FFFFFF 9 EH D.  $\mathrm{x}=-65,\mathrm{y}=41,\mathrm{x}-\mathrm{y}$  的机器数为FFFFFF96H  

30.【2018统考真题】整数  $_\mathrm{x}$  的机器数为11011000，分别对  $_\mathrm{x}$  进行逻辑右移  $^{1}$  位和算术右移 1位操作，得到的机器数各是（）  

A.11101100、11101100B.01101100、11101100C.11101100、01101100 D.01101100、01101100  

31.【2018统考真题】减法指令“subR1,R2,R3”的功能为“(R1) $^{-}\,(\mathbb{R}2)\rightarrow$ R3”，该指令执行后将生成进位/借位标志CF和溢出标志OF。若(R1) $=$ FFFFFFFFH, $(\mathbb{R}2)=$ FFFFFFFOH，则该减法指令执行后，CF与OF分别为（）。  

$$
\mathrm{CF}=0,\,\mathrm{OF}=0\quad\mathrm{B}.\quad\mathrm{CF}=1,\,\mathrm{OF}=0\quad\mathrm{~C}.\quad\mathrm{CF}=0,\,\mathrm{OF}=1\quad\mathrm{~D}.\quad\mathrm{CF}=1,\,\mathrm{OF}=1
$$  

32.【2023统考真题】已知 $\mathrm{x,y}$ 为int类型，当 $\mathbf{x}=100$  $\mathbf{y}=200$ 时，执行“ $_\mathrm{x}$ 减y”指令得到的溢出标志OF和借位标志CF分别为0，1，那么当 $\mathbf{x}=10$  $\mathbf{y}=-20$ 时，执行该指令得到的OF和CF分别为（）。  

$$
=0,\mathrm{CF}=0\quad\mathrm{B}.\quad\mathrm{OF}=0,\mathrm{CF}=1\quad\mathrm{~C}.\quad\mathrm{OF}=1,\mathrm{CF}=0\quad\mathrm{~D}.\quad\mathrm{OF}=1,\mathrm{CF}=1
$$
 A.  

# 二、综合应用题  

01.已知  $A=-1001$  、  $B\,{=}\,{-}0101$  ，求  $[A+B]_{*}\not\approx[A-B]_{\#*}$  

02.已知32位寄存器R1中存放的变量 $x$ 的机器码为 $8000\ \mathrm{0004H}$ ，unsigned in t  

采用逻辑移位操作，int型的乘除法采用算术移位操作，请问：1）当 $x$ unsigned in t， $x$ 的真值是多少？ $x/2$ 存放在R1中的机器码是什么？ $x/2$ 的真值是多少？ $_{2x}$ 存放在R1中的机器码是什么？ $_{2x}$ 的真值是多少？2）当 $x$ 是int型时， $x$ 的真值是多少 $\textsuperscript{?}x/2$ 存放在R1中的机器码是什么？ $x/2$ 的真值是多少 $?\ 2x$ 存放在RI中的机器码是什么 $?\ 2x$ 的真值是多少？  

03.假设有两个整数 $x\!=\!-68$  $\scriptstyle{y=-80}$ ，采用补码形式（含1位符号位）表示， $x$ 和 $y$ 分别存放在寄存器A和B中。另外，还有两个寄存器C和D。A、B、C、D都是8位的寄存器。请回答下列问题（要求最终用十六进制表示二进制序列）：1）寄存器A和B中的内容分别是什么？  
2) $x$ 和 $y$ 相加后的结果存放在寄存器C中，则寄存器C中的内容是什么？此时，溢出标志OF、符号标志SF各是什么？3） $x$ 和y相减后的结果存放在寄存器D中，寄存器D中的内容是什么？此时，溢出标志OF、符号标志SF各是什么？  

04.【2011统考真题】假定在一个8位字长的计算机中运行如下C程序段：  

unsigned int  $_\mathrm{z=134}$  unsigned int  $\mathtt{y=}246$  int  $\scriptstyle{\mathbb{m}}=\times$  int  $\tt n{=y}$  unsigned int  $\scriptstyle{z1=x-y}$  unsigned int  $_{z2=x+y}$  int  $_{k1=1-\mathrm{n}}$  int  $\scriptstyle\mathrm{k}2=\mathtt{m}+\mathtt{n}$  

若编译器编译时将8个8位寄存器R1\~R8分别分配给变量x,y,m,n,z1,z2,k1和k2。请回答下列问题（提示：有符号整数用补码表示）。  

1）执行上述程序段后，寄存器R1、R5和R6的内容分别是什么（用十六进制表示）？2）执行上述程序段后，变量 $\mathrm{m}$ 和k1的值分别是多少（用十进制表示）？3）上述程序段涉及有符号整数加减、无符号整数加减运算，这四种运算能否利用同一个加法器辅助电路实现？简述理由。4）计算机内部如何判断有符号整数加减运算的结果是否发生溢出？上述程序段中，哪些有符号整数运算语句的执行结果会发生溢出？  

05.【2020统考真题】有实现 $_{x\times y}$ 的两个C语言函数如下：  

intimul（intx,int y）{return x\*y;} 假定某计算机M中的ALU只能进行加减运算和逻辑运算。请回答下列问题。1）若M的指令系统中没有乘法指令，但有加法、减法和位移等指令，则在M上也能实现上述两个函数中的乘法运算，为什么？2）若M的指令系统中有乘法指令，则基于ALU、位移器、寄存器及相应控制逻辑实现乘法指令时，控制逻辑的作用是什么？3)针对以下三种情况：a）没有乘法指令；b）有使用ALU和位移器实现的乘法指令：c）有使用阵列乘法器实现的乘法指令，函数umul(在哪种情况下执行的时间最长？在哪种情况下执行的时间最短？说明理由。4） $n$ 位整数乘法指令可保存 $2n$ 位乘积，当只取低 $n$ 位作为乘积时，其结果可能会发生溢出。当 $n=32,x=2^{31}\!-1,y=2$ 时，有符号整数乘法指令和无符号整数乘法指令得到的 $_{x\times y}$ 的 $2n$ 位乘积分别是什么（用十六进制表示）？此时函数umul(和imul()的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低 $n$ 位作为乘法结果时，如何用 $2n$ 位乘积进行溢出判断？  

# 2.2.6 答案与解析  

# 一、单项选择题  

01.B  

ALU是由组合逻辑电路构成的，最基本的部件是并行加法器。由于单纯的ALU不能够存储运算结果和中间变量，因此往往将ALU和寄存器或暂存器相连。  
02.D  

ALU为运算器核心，C正确；数据总线供ALU与外界交互数据使用，B正确；溢出标志即为一个状态寄存器，A正确。地址寄存器不属于运算器，而属于存储器，D错误。  

03. C  

ALU既能进行算术运算又能进行逻辑运算。  

04.B  

该数是一个正数（最高位为0），按照补码算术移位规则，算术左移两位后，移出了最高位01，低位补0，因此算术左移两位后的结果是 $0101\;0100$ 。虽然移位后该数的符号位仍为0，但是移出了有效位1，所以本次算术移位发生了溢出。  

05.D  

$80\mathrm{H}\!=\!(1000\,0000)\!<<\!1=\!000000000,$ ，左移前的符号位为1，左移后的符号位为0，溢出。 $\mathrm{90H\!=\!(1001}$  $0000\!\ll\!1\!=\!0010\,0000,$ ，左移前的符号位为1，左移后的符号位为0，溢出。 $\mathrm{B0H}\,{=}\,(1011\;0000)\,{<}\,1\,{=}\,0110$ 0000，左移前的符号位为1，左移后的符号位为0，溢出。  $\mathrm{C0H}=(1100\,0000)<<1=10000000$  ，左 移前的符号位为1，左移后的符号位为1，未溢出，D正确。  

06. D  

该数是一个负数（最高位为1），按照算术补码移位规则，负数右移添1，负数左移添0，所以10010101右移一位后的值为 $1100\ 1010$  

07.C 在十六进制数的加减法中，逢十六进一，因此有7E5 $\mathrm{H}+4\mathrm{D}3\mathrm{\,H}\!=\!\mathrm{C}\mathrm{B}8\mathrm{\,H}.$ 08.C 算术左移时，低位补0；算术右移时，高位补符号位。 $\mathrm{BAH}=(1011\;1010)_{2}$ ，算术左移 $1$ 位得(0111 $0100)_{2}=74\mathrm{H}$ ，左移前后的符号位不同，溢出；算术右移1位得 $(1101\;1101)_{2}=\mathrm{{DOH}}$ 09.C  

三种溢出判别方法，均须有溢出判别电路，可用“异或”门来实现。  

10.A 机器运算发生溢出的根本原因是计算机的字长有限，所以不能表示超过一定范围的数据。  

11. C  

首先将 $r_{1}$ 和 $r_{2}$ 转换为真值， $\mathrm{F}5\mathrm{H}=1111\ 0101$ ，转换为原码是10001011，真值为-11；EEH $=$ 11101110，转换为原码是 $1001\ 0010$ ，真值为-18，8位补码的表示范围为[-128，127)， $r_{1}\!\times\!r_{2}$ 的结果为198，超出了8位补码的表示范围，发生溢出。  

12.B  

模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题，A错误。需要注意的是，存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的，B正确。只在把两个模4补码的数送往ALU完成加减运算时，才把每个数的符号位的值同时送到ALU的双符号位中，即只在ALU中采用双符号位，C、D错误。  

13.B  

采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出。若第二位和第一位符号相同，则未溢出；若不同，则溢出。若发生正溢出，则双符号位为01，若发生负溢出，则双符号位为10。  
14.D  

采用进位位来判断溢出时，当最高有效位进位和符号位进位的值不相同时才产生溢出。两正数相加，当最高有效位产生进位（ $C_{1}=1$ ）而符号位不产生进位（ $C_{0}\!=\!0$ ）时，发生正溢出；两负数相加，当最高有效位不产生进位（ $C_{1}\!=\!0$ ）而符号位产生进位（ $C_{0}\!=\!1$ ）时产生负溢出。因此溢出条件为 $\overline{{{C_{0}}}}C_{1}+C_{0}\overline{{{C_{1}}}}=C_{0}\oplus C_{1}.$  

15. C  

用两位符号位判断溢出时，两个符号位不同时表示溢出，即01时表示正溢出；10时表示负溢出；两个符号位相同时（11或00）表示未溢出。  

16.B  

补码左移时，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出。补码左移时， $X_{0}$ 移出， $X_{1}$ 取代 $X_{0}$ 成为新的符号位，因此若 $X_{0}\!\neq\!X_{1}$ ，则表示发生了溢出。  

17.A  

原码一位乘法中，符号位与数值位是分开进行运算的。运算结果的数值部分是乘数与被乘数数值位的乘积，符号是乘数与被乘数的符号位的异或。  

18.B  

在原码一位乘法中，符号位不参加运算，符号位单独处理，同号为正，异号为负。  

19.C  

原码的符号位为1表示负数，为0表示正数。原码乘法时，符号位单独处理，乘积的符号是两个操作数的符号相“异或”的结果，同号为正，异号为负。  

20.D  

对于左移操作，逻辑左移和算术左移的结果都一样，高位移出，低位补0。逻辑移位不考虑符号位的问题，逻辑左移时，若最高位移出的是1，表示发生溢出。算术左移时，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，表示发生溢出。因此I、ⅡI、Ⅲ均正确。  

21.B  

不管是补码减法，还是无符号数减法，都是用被减数加上减数的负数的补码来实现的。根据求补公式，减数 $y$ 的负数的补码 $[-y]_{\#}\!=\!\overline{{Y}}+1$ ，因此，在加法器的Y'输入端用一个反向器实现，并用控制端Sub控制多路选择器是否将 $y$ 的各位取反后，输入Y'端，同时将Sub作为低位进位送到加法器。当Sub为1时，做减法， ${\mathrm{Sub}}=1$ 控制将 $\overrightharpoon{Y}$ 输入到加法器Y端，即实现“各位取反”功能；同时将 $\mathrm{Sub}\,=\,1$ 作为低位进位送到加法器，实现“末位加1”功能。69的二进制数为01000101；38的二进制数为00100110，各位取反得 $1101\;1001$ 。做减法时，低位进位为Sub，即为1。  

# 注意  

若仅记忆补码加减运算的过程，而未掌握加法电路的原理，则本题易误选 $\mathrm{D}$  

22.A  

对于补码减法运算，控制端Sub为1，故低位进位输入位 $\mathrm{\Delta=\Delta u b=l\,,}$  $[x]_{*}\,{=}\,1111\,0101$  $[y]_{\#}\!=\!0111$ 1110，  $[-y]_{*}=1000\,0001+1$   $[x]_{*}-[y]_{*}=[x]_{*}+[-y]_{*}=1111\,0101+1000\,\,0010=0111\,0111$  ，进位丢 掉，参与运算的两个数的符号均为1，结果的符号位为0，故溢出标志0F为1。  

23.C  

[x/2  $+2y]_{*}=[x]_{*}>>1+[y]_{*}<<1=0100\,0100>>1+1101\,1100<<1=0010\,0010+\,1011\,1000=$   $101\ 1010=\mathrm{D}$ AH。 $x$ 右移移出了0，没有溢出或损失精度； $y$ 为负数，左移后，符号位仍为1，没有溢出；且从最后一步加法操作来看，一个正数和一个负数相加，必然不会溢出。  
24.A  

$[x]_{^{\#}}=44\mathrm{H}=0100\;0100$  $[y]_{+}=\mathrm{DCH}=1101\ 1100$ 。执行 $x-2y$ 时，先将 $y$ 算术左移一位，得到10111000，未溢出，然后各位取反，再与 $x$ 相加，做减法时sub $=1$ ，即 $0100\,0100+0100\,0111+1=$ 10001100(8CH)，两个加数的符号都为0，而结果的符号为1，因此发生了溢出，即 $\mathrm{OF}=1$  

25.D  

C语言中的整型数据为补码形式，int型为32位，short型为16位，因此 $\mathbf{X}_{\mathbf{Y}}$ y的机器数写为0000007F、FFF7H。执行 ${\mathrm{z=x+y}}$ 时，由于 $_\mathrm{x}$ 为int型，y为short型，因此需将y的类型强制转换为int型，在机器中通过符号位扩展实现，由于y的符号位为1，因此在y的前面添加16个1，即可将y强制转换为int型，其十六进制形式为FFFFFFF7H。然后执行加法，即0000007FH $^+$ FFFFFFF7H $=00000076\mathrm{H}$ ，其中最高位的进位1自然丢弃。  

26.B  

本题的真正意图是考查补码的表示范围，采用补码乘法规则计算出四个选项是费力不讨好的做法，且极易出错。8位补码所能表示的整数范围为- $-128\!\sim\!+127$ 。将四个数全部转换为十进制数： $r_{1}\,{=}\,{-}2$ ， $r_{2}\,{=}\,{-}14$ ， $r_{3}\,{=}\,{-}112$ ， $r_{4}\,{=}\,{-}8$ ，得 $r_{2}\!\times\!r_{3}=1568$ ，远超出了表示范围，发生溢出。  

27. A  

$x^{*}2$ ，将 $x$ 算术左移一位为11101000； $y/2$ ，将 $y$ 算术右移一位为11011000，均无溢出或丢失精度。补码相加为 $1\ 1101000+1\ 1011000=1\ 1000000$ ，亦无溢出。  

28.C  

8位定点补码表示的数据范围为- $\cdot128\!\sim\!127$ ，若运算结果超出这个范围，则会溢出。对于A， $x+$  $y\,{=}\,103-25\,{=}\,78,$ ，符合范围。对于B， $-x+y=-103-25=-128$ ，符合范围。对于D， $-x\!-\!y\!=\!-103+$  $25=-78$ ，符合范围。对于C， $x-y=103+25=128$ ，超过127。  

29.C  

利用补码转换成原码的规则：负数的符号位不变数值位取反加1：正数补码等于原码。两个机器数对应的原码是 $[x]_{\mathrm{I\!I}}=8000002\,\mathrm{I\!H}$ ，对应的数值是-33， $[y]_{\#}\,{=}\,[y]_{*}\,{=}\,0000041\mathrm{H}\,{=}\,65$ 。排除A、D。 $x-y$ 直接利用补码减法准则， $[x]_{^{\#}}-[y]_{^{\#}}=[x]_{^{\#}}+[-y]_{^{\#}}$  $-y$ 的补码是连同符号位取反加1，最终减法变成加法，得出结果为FFFFFF9EH。  

30.B  

逻辑移位：左移和右移空位都补0，且所有数字参与移动；补码算术移位：仍然是所有数字参与移动，右移空位补符号位，左移空位补0。根据该规则，轻松选出B。  

31.A  

$[x]_{^{\#}}-[y]_{^{\#}}=[x]_{^{\#}}+[-y]_{^{\#}}$  $[-\mathrm{R}2]_{\#}=0000010\mathrm{H}$ ，很明显R1 $]*+[-\mathrm{R}2]$ 补的最高位进位和符号位进位都是1（当最高位进位和符号位进位的值不相同时才产生溢出），可以判断溢出标志0F为0。同时，减法操作只需判断借位标志，R1大于R2，所以借位标志为0。  

32.B  

ALU生成标志位时只负责计算，而不管运算对象是有符号数还是无符号数， $\mathrm{CF}\,=\,1$ 表示当作无符号数运算时溢出， $\mathrm{OF}=1$ 表示当作有符号数运算时溢出。当作有符号数时， $x=10$  $\scriptstyle{y=-20}$  $x-y=30$ ，未超过32位有符号数范围，不溢出， $\mathrm{OF}=0$ 。当作无符号数时， $x^{\prime}\!=10,\;\;y^{\prime}\!=2^{32}\!-20$ （符号位读作数值位）， $x^{\prime}-y^{\prime}=30-2^{32}$ ，为负，超过32位无符号数范围，溢出， $\mathrm{CF}=1$  

# 二、综合应用题  

01.【解答】  

为判断溢出，采用双符号位。  
因为 $A\,{=}\,-1001\,,\,\,\,B\,{=}\,-0101$ ，所以 $[A]_{*}=11,0111$ ， $[B]_{*}\!=\!11$ ,1011, $[-B]_{*}\,{=}\,00,0101$  

则 $[A]_{*}+[B]_{*}=11$  $0111+11$  $1011=11$ ,0010。  

则  $[A]_{*}-[B]_{*}=[A]_{*}+[-B]_{*}=11,0111+00,0101=11,1100\,.$  

加/减运算结果的两个符号位都相同，无溢出，结果正确。  

02.【解答】  

1）对于无符号数，所有二进制位均为数值位。乘以2和除以2运算，相当于无符号数的逻辑左移和逻辑右移。 $x$ 的真值为 $2^{31}+2^{2}$ 。R1中的机器码逻辑右移一位（高位补0）为40000002H，相当于除以2，故 $x/2$ 的真值为 $2^{30}\!+2$ 。R1中的机器码逻辑左移一位（低位补0）为 $\ensuremath{0000\,0008}\mathrm{H}$ ，相当于是乘以2，高位丢1，结果溢出， $_{2x}$ 的真值为 $2^{3}$ （溢出）。  

2）对于有符号数（补码），最高位为符号位。乘以2和除以2运算，相当于补码的算术左移和算术右移。 $8000\ \mathrm{\Omega}0004\mathrm{H}$ 对应二进制数的最高位为1，即为负数，其真值为- $(2^{31}\!-\!2^{2})$ 。R1中的机器码算术右移一位（高位补1）为 $\mathrm{C000\,0002H}$ ，相当于除以2， $x/2$ 的真值为 $\cdot(2^{30}\!-\!2)$ R1中的机器码算术左移一位（低位补0）为 $0000\,0008\mathrm{H}$ ，相当于乘以2，移位前后的符号位不同，表示溢出， $_{2x}$ 的真值为- $(2^{31}\!-2^{3})$ （溢出）。  

03.【解答】  

1）因为  $x\!=\!-68\!=\!-(100~0100)_{2}$  ，则  $[-68]_{*}=1011\ 1100=\mathrm{BCH}$  ：因  $y\!=\!-80\!=\!-(101~0000)_{2}$  ，则  $[-80]_{\#}=1011\ 0000=\mathrm{B0H}$ ，所以寄存器A和 $\mathrm{B}$ 中的内容分别是BCH、 $\mathrm{B0H}$  

2) $[x+y]_{*}=[x]_{*}+[y]_{*}=1011\ 1100+1011\ 0000=(1)\,0110\ 1100=6\mathrm{CH}\,.$ ，所以寄存器C中的内容是6CH，其真值为108。此时，溢出标志OF为1，表示溢出，说明寄存器C中的内容不是正确结果；符号标志SF为0，表示结果为正数（OF为1，说明SF也是错的）。  

3） $[x-y]_{*}=[x]_{*}+[-y]_{*}=1011\ 1100+0101\ 0000=(1)\ 0000\ 1100=0\mathrm{CH}$ ，最高位前面的一位被丢弃（取模运算），结果为12，所以寄存器D中的内容是0CH，其真值为12。此时，溢出标志OF为0，表示不溢出，也就是说，寄存器D中的内容是正确的结果；符号标志SF为0，表示结果为正数。  

# 04.【解答】  

1）因为 $134=128+6=1000\ 0110\mathrm{B}$ ，所以 $x$ 的机器数为10000110B，因此R1的内容为 $86\mathrm{H}$  $246\,{=}\,255\,{-}\,9\,{=}\,1111\;\;0110\mathrm{B}$ ，所以 $y$ 的机器数为11110110B， $x\!-\!y\!=\!1000\ 0110\ +\ 0000$  $1010\,{=}\,(0)1001\;0000$ ，括号中为加法器的进位，因此R5的内容为 $90\mathrm{H}$ 。 $x+y=1000\,0110+$  $1111\ 0110\,{=}\,(1)0111\ 1100$ ，括号中为加法器的进位，因此R6的内容为7CH。2） $m$ 的机器数与 $x$ 的机器数相同，皆为 $86\mathrm{H}=1000\,0110\mathrm{B}$ ，解释为有符号整数 $m$ （用补码表示）时，其值为一 $111\ 1010\mathrm{B}\!=\!-122$ 。 $m-n$ 的机器数与 $x-y$ 的机器数相同，皆为 $90\mathrm{H}\,{=}\,1001$ 0000B，解释为有符号整数 $_{\mathrm{kl}}$ （用补码表示）时，其值为 $-111\ 0000\mathbf{B}\!=\!-112$ 3）能。 $n$ 位加法器实现的是模 $2^{n}$ 无符号整数加法运算。对于无符号整数 $a$ 和 $^b$ ， $a+b$ 可以直接用加法器实现，而 $a-b$ 可用 $^a$ 加- $\cdot b$ 的补数实现，即 $a-b=a+[-b]*$ (mod $2^{n}$ ），所以 $n$ 位无符号整数加减运算都可在 $n$ 位加法器中实现。因为有符号整数用补码表示，补码加减运算公式为 $[a+b]_{*}\!=[a]_{*}+[b]_{*}\,\,(\mathrm{mod}\,2^{n}),\,\,[a-b]_{*}\!=$  $[a]_{*}+[-b]_{*}$ (mod $2^{n}$ ），所以 $n$ 位有符号整数加减运算都可在 $n$ 位加法器中实现。4）有符号整数加减运算的溢出判断规则为：若加法器的两个输入端（加法）的符号相同，且不同于输出端（和）的符号，则结果溢出，或加法器完成加法操作时，若次高位（最高数位）的进位和最高位（符号位）的进位不同，则结果溢出。最后一条语句执行时会发生溢出。因为 $1000\ 0110+1111\ 0110\,{=}\,(1)0111\ 1100$ ，括号中为加法器的进位，根据上述溢出判断规则可知结果溢出。或者，因为两个有符号整数均为  
负数，它们相加之后，结果小于8位二进制所能表示的最小负数。  

# 05.【解答】  

1）乘法运算可以通过加法和移位来实现。编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法和移位等指令实现乘法运算。  

2）控制逻辑的作用是控制循环次数，控制加法和移位操作。  

3）a最长，c最短。对于a，需要用循环程序段实现乘法操作，因而需要反复执行很多条指令，而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长；对于b和c，都只需用一条乘法指令实现乘法操作，不过b中的乘法指令需要多个时钟周期才能完成，而c中的乘法指令可在一个时钟周期内完成，所以c的执行时间最短。  

4）当 $n=32$  $x=2^{31}\!-1,y=2$ 时，有符号整数和无符号整数乘法指令得到的64位乘积都是00000000FFFFFFFEH。int型的表示范围为 $[-2^{31}$  $2^{31}\mathrm{-}1]$ ，故函数imulO的结果溢出；unsigned in t[ $),2^{32}\!-\!1]$ ，故函数umulO的结果不溢出。对于无符号整数乘法，若乘积高 $n$ 位全为0，即使低 $n$ 位全为1也正好是 $2^{32}\!-1$ ，不溢出，否则溢出。  

注意，无论是无符号数还是有符号数，用 $2n$ 位来表示两个 $n$ 位整数的相乘结果都不会溢出，因为 $2n$ 位可以完整地存储两个 $n$ 位整数的乘积。但是，若只用低 $n$ 位来表示结果，则可能溢出。因此，要保证低 $n$ 位转换成的真值与 $2n$ 位转换成的真值相等才算是不溢出。对于无符号数，只要高 $n$ 位全为0，就不会溢出，因为高 $n$ 位在转换成真值后不会影响低 $n$ 位的值。对于有符号数，要考虑符号位的影响。当结果是正数时，符号位为0，要求高 $n$ 位也全为0，且低 $n$ 位的最高位也为0（否则正数变负数）。当结果是负数时，符号位为1，要求高 $n$ 位也全为1，且低 $n$ 位的最高位也为1（否则负数变正数）。因此，在有符号数的情况下，高 $n+1$ 位相同表示不溢出。  

# 浮点数的表示与运算  

# 2.3.1浮点数的表示  

浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量 $(9{\times}10^{-28}\mathrm{g})$ ）或太阳的质量（ $(2\!\times\!10^{33}\mathrm{g})$ ）是非常不方便的。  

# 1.浮点数的表示格式  

通常，浮点数表示为  

$$
N{=}(-1)^{S}{\times}M{\times}R^{E}
$$  

式中， $S$ 取值0或1，用来决定浮点数的符号； $M$ 是一个二进制定点小数，称为尾数，一般用定点原码小数表示： $E$ 是一个二进制定点整数，称为阶码或指数，用移码表示。 $R$ 是基数（隐含），可以药定为2、4、16等。可见浮点数由符号、尾数和阶码三部分组成。  

图2.9是一个32位短浮点数格式的例子。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1b7a71d10d028b99f2e5658ea6e33dcdc0d30ea436288f4013315ca9d3ac5ff.jpg)  
图2.9浮点数格式的例子  

其中，第0位为符号 $S$ ：第 $1\!\sim\!7$ 位为移码表示的阶码 $E$ （偏置值为64）；第 $8\!\sim\!31$ 位为24位二进制原码小数表示的尾数 $M$ ：基数 $R$ 为2。阶码的值反映浮点数的小数点的实际位置：阶码的位数反映浮点数的表示范围：尾数的位数反映浮点数的精度。  
# 2.浮点数的表示范围  

原码是关于原点对称的，敌浮点数的范围也是关于原点对称的，如图2.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b69c0bc872d03974bb8a0faff59a9536bc3766b1475dc6f2288fb16f9676567b.jpg)  
图2.10浮点数的表示范围  

运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机将其当作机器零处理。  

# 3.浮点数的规格化  

为了在浮点数运算过程中尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位必须在运算过程中对浮点数进行规格化操作。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高数位上保证是一个有效值。  

左规：当运算结果的尾数的最高数位不是有效位，即出现 $^{\pm0.0...0\times...\times}$ 的形式时，需要进行左规。左规时，尾数每左移一位、阶码减1（基数为2时）。左规可能要进行多次。  

右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规，右规只需进行一次。将尾数右移一位、阶码加1（基数为2时）。右规时，阶码增加可能导致溢出。  

基数为2的原码规格化尾数 $M$ 应满足 $1/2\!\leqslant\!|M|<1$ ，形式如下： $\textcircled{\scriptsize{1}}$ 正数为 $0.1\times...\times$ 的形式，最大值为0.11...1，最小值为0.100...0，表示范围为 $1/2\!\leqslant\!M\!\leqslant\!(1-2^{-n})$ ： $\textcircled{2}$ 负数为 $1.1\times...\times$ 的形式，最大值为1.10...0，最小值为1.11..1，表示范围为一 $(1-2^{-n}){\leqslant}M{\leqslant}-1/2$  

基数不同，浮点数的规格化形式也不同。当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1。当基数为4时，原码规格化数的尾数最高两位不全为0。  

# 4.IEEE754标准  

# 命题追踪IEEE754单精度数大小的比较（2014）  

按照IEEE754标准，常用的浮点数的格式如图2.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b05317cc38d69e199cbfe63befd2efce159619079739354914b91a50fa5ab65.jpg)  
图2.11IEEE754标准浮点数的格式  

IEEE754标准规定常用的浮点数格式有32位单精度浮点数（短浮点数、float型）和64位双精度浮点数（长浮点数、double型），其基数隐含为2，见表2.2。  
表2.2IEEE754浮点数的格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ca31a6a712a028a5cadc8997f2d0ee5e30453ac3a0d7a755db034c662d63b9a.jpg)  

单精度格式中包含1位符号 $s,\ 8$ 位阶码 $e$ 和23位尾数 $f_{1}$ ：双精度格式包含1位符号 $s$ 、11位阶码 $e$ 和52位尾数 $f_{\circ}$ 基数隐含为2；尾数用原码表示。对于规格化的二进制浮点数，尾数的最高位总是1，为了能使尾数多表示一位有效位，将这个1隐藏，称为隐藏位，因此23位尾数实际表示了24位有效数字。IEEE754规定隐藏位1的位置在小数点之前，例如， $(12)_{10}\!=\!(1100)_{2}$ 将它规格化后结果为 $1.1\!\times\!2^{3}$ ，其中整数部分的“1”将不存储在23位尾数内。  

# 注意  

单精度与双精度浮点数都采用隐藏尾数最高位的方法，因而使浮点数的精度更高。  

在IEEE754标准中，指数用移码表示，但偏置值并不是通常 $n$ 位移码所用的 $2^{n-1}$ ，而是 $2^{n-1}{-1}$ ，因此，单精度和双精度浮点数的偏置值分别为127和1023。在存储浮点数阶码之前，偏置值要先加到阶码真值上。上例中，阶码值为3，因此在单精度浮点数中，移码表示的阶码为 $127+3=130(82\mathrm{H})$ 在双精度浮点数中，阶码为 $1023+3=1026$ (402H)。  

IEEE754标准中，规格化单精度浮点数的真值为  

$$
(-1)^{s}{\times}1.f{\times}2^{e-127}
$$  

规格化双精度浮点数的真值为  

$$
(-1)^{s}{\times}1.f{\times}2^{e{-}1023}
$$  

式中，规格化单精度浮点数的阶码 $e$ 的取值范围为 $1\!\sim\!254$ （8位）：规格化双精度浮点数的阶码 $e$ 的取值范围为 $1\!\sim\!2046$ （11位）。1EEE754规格化浮点数的表示范围见表2.3。  

命题追踪IEEE754单精度数的表示范围和有效位（2017、2018）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e09dbec5860d7cec7c801ef49119346c4db36645552b736a3f51caead1e3a23.jpg)  

对于EEE754格式的浮点数，阶码全为0或全为1时，有其特别的解释，如表2.4所示。命题追踪IEEE754标准中阶码全为0或全为1时的特殊意义（2017、2023）  

表2.4阶码全为0或全为1时IEEE754浮点数的解释
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5cab272967bd8b58b3d1903235f5ed69c303bb77df5afa2deea36e8c30238b4d.jpg)  
(续表) 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a466833be1246442271c1562278ccba92a69b86a821388a52a08a2ecffff59b4.jpg)  

1）全0阶码全0尾数： $+0/-0$ 。零的符号取决于符号 $s$ ，一般情况下 $+0$ 和-0是等效的。  

2）全1阶码全0尾数： $+\infty/-\infty$ 。 $+\infty$ 在数值上大于所有有限数， $-\infty$ 则小于所有有限数。引入无穷大数的目的是，在计算过程出现异常的情况下使得程序能继续进行下去。  

3）全1阶码非0尾数：NaN（NotaNumber）。表示一个没有定义的数，称为非数。  

4）全0阶码非0尾数：非规格化数。非规格化数的特点是阶码为全0，尾数高位有一个或几个连续的0，但不全为0。因此，非规格化数的隐藏位为0，且单精度和双精度浮点数的指数分别为-126或-1022。非规格化数可以用于处理阶码下溢。  

命题追踪实数与1EEE754单精度数的相互转换（2011、2013、2020、2022、2023）  

【例2.5】将十进制数-8.25转换为IEEE754单精度浮点数格式表示。  

解：  

IEEE754规定：单精度浮点数的偏置值是127；尾数最高位的“1”是被隐藏的。  

先将-8.25转换成二进制数，即 $-1000.01\!=\!-1.000\:01\!\times\!2^{3}$ ，再计算阶码 $E$  $E-127=3$ ，因此 $E\!=$ 130，转换成二进制数为10000010。  

IEEE754单精度浮点数格式：符号（1位） $^+$ 阶码（8位） $^+$ 尾数（23位)。因此，单精度格式表示为  

即  

【例2.6】求IEEE754单精度浮点数 $\mathrm{C640\,\,0000H}$ 的值是多少。  

# 解：  

先将 $\mathrm{C640\,0000H}$ 按二进制展开为  

11000110010000000000000000000000  

其对应IEEE754单精度浮点数的格式如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7a584d8be78918f4c203a6b65fcbebbfc1fbd6fb5150e3de3722237aab3bc05.jpg)  

因此，符号 $=1$ 表示负数；阶码值为 $1000\ 1100-0111\ 1111=0000\ 1101=13$ ：尾数值为1.5（注意其有隐藏位，要加1)。因此，浮点数的值为一 $\cdot1.5\!\times\!2^{13}$  

# 5.定点、浮点表示的区别  

（1）数值的表示范围若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围远大于定点表示法  

(2) 精度对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。  

（3）数的运算浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。  
（4）溢出问题  

在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。  

# 2.3.2 浮点数的加减运算  

浮点数运算的特点是阶码运算和尾数运算分开进行，浮点数加减运算分为以下几步。命题追踪float型能否通过左移实现乘以2运算（2017）；浮点数的加减运算（2009）  

# 1.对阶  

对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶码差，然后以小阶码向大阶码看齐的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。尾数右移时，若舍弃有效位会产生误差，影响精度。为了保证运算的精度，尾数石移时，低位移出的位不要去掉，应保留并参加尾数部分的运算。  

# 注意  

若采用大阶码向小阶码看齐的原则，则尾数需要左移，最高有效位被移出，导致结果出错。  

2.尾数加减  

将对阶后的尾数按定点原码小数的加（减）运算规则进行运算。因为IEEE754浮点数尾数中有一个隐藏位，因此在进行尾数加减时，必须将隐藏位还原到尾数部分。运算后的尾数不一定是规格化的，因此，浮点数的加减运算需要进一步进行规格化处理。  

# 3.尾数规格化  

IEEE754规格化尾数的形式为 $\pm1.\times...\times_{\circ}$ 尾数相加减后会得到各种可能结果，例如：  

$$
1.\times...\times+1.\times...\times=\pm1\times...\times...\times
$$  

$$
1.\times_{...}\times-1.\times_{...}\times=\pm0.0...01\times_{...}\times
$$  

1）右规：当结果为 $|\pm1\times.\times\ldots\times$ 时，需要进行右规。尾数右移一位，阶码加1。尾数右移时，最高位1被移到小数点前一位作为隐藏位，最后一位移出时，要考虑舍入。2）左规：当结果为 $\pm0.0...01\times...\times$ 时，需要进行左规。尾数每左移一位，阶码减1。可能需要左规多次，直到将第一位1移到小数点左边。  

# 注意  

$\textcircled{\scriptsize{1}}$ 左规一次相当于乘以2，右规一次相当于除以2； $\textcircled{2}$ 需要右规时，只需进行一次。  

4.舍入  

在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将移出的部分低位保留下来，参加中间过程的运算，最后再将运算结果进行舍入，还原表示成IEEE754格式。  

IEEE754提供了以下4种可选的舍入模式。  

1）就近舍入：舍人为最近的可表示数。当运算结果是两个可表示数的非中间值时，实际上是“0舍1入”方式（类似于十进制的“四舍五入”法）：当运算结果正好在两个可表示数的中间时，则选择结果为偶数。例如，计算 $1.24{\times}10^{5}+5.04{\times}10^{2}$ （假定科学记数法的精度保留两位小数），若只采用2位保留位，则结果是 $1.2400{\times}10^{5}+0.0050{\times}10^{5}=1.2450{\times}10^{5}$  
这个结果在两个可表示数 $1.24\!\times\!10^{5}$ 和 $1.25\!\times\!10^{5}$ 的中间，采用就近舍入方式到偶数，则结果应该是 $1.24\!\times\!10^{5}$ ：若采用3位保留位，则结果是 $1.24000{\times}10^{5}+\ 0.00504{\times}10^{5}\ =$  $1.24504{\times}10^{5}$ ，这个结果就不在 $1.24\!\times\!10^{5}$ 和 $1.25\!\times\!10^{5}$ 的中间，而更接近于 $1.25\!\times\!10^{5}$ ，采用就近舍入方式，则结果应该是 $1.25\!\times\!10^{5}$ 。显然，后者更为精确。  

2）正向舍入：朝数轴 $+\infty$ 方向舍入，即取右边最近的可表示数。3）负向舍入：朝数轴-方向舍入，即取左边最近的可表示数。  

4）截断法：直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单。对正数或负数来说，都是取更接近原点的那个可表示数，是一种趋向原点的舍入。  

# 5.溢出判断  

# 命题追踪浮点数运算时的溢出判断（2015）  

在尾数规格化和尾数舍入时，可能会对结果的阶码执行加/减运算。因此，必须考虑指数溢出问题。若一个正指数超过了最大允许值（127或1023），则发生指数上溢，产生异常。若一个负指数超过了最小充许值（-149或-1074）°，则发生指数下溢，通常把结果按机器零处理。  

1）右规和尾数舍入。数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶码。右规时阶码加1，导致阶码增大，因此需要判断是否发生了指数上溢。当调整前的阶码为11111110时，加1后，会变成11111111而发生指数上溢。2）左规。左规时阶码减1，导致阶码减小，因此需要判断是否发生了指数下溢。其判断规则与指数上溢类似，左规一次，阶码减1，然后判断阶码是否为全0来确定指数是否下溢。由此可见，浮点数的溢出并不是以尾数溢出来判断的，尾数溢出可以通过右规操作得到纠正。  

管结里县不送出主亚丢结里的指数县不发生了上送，因此县中指数上送来判断的  

# 注意  

某些题目中可能会指定尾数或阶码采用补码表示。通常可以采用双符号位，当尾数求和结果溢出（如尾数为 $10.\times\times...\times...$ 或 $01.\times\times...\times$ ）时，需右规一次；当结果出现 $00.0\times\times_{...}\times$ 或 $11.1\times\times_{...}\times$ 时，需要左规，直到尾数变为 $00.1\times\times...\times$ 或 $11.0\times\times_{...}\times_{i}$  

# 2.3.3C语言中的浮点数类型  

# 命题追踪不同类型数据转换后数值的变化（2010）  

C语言中的float型和double 型分别对应于IEEE754单精度浮点数和双精度浮点数。longdouble型对应于扩展双精度浮点数，但longdouble型的长度和格式随编译器和处理器类型的不同而有所不同。在C程序中，等式的赋值和判断会导致强制类型转换，以char→int→long→double和float一double最为常见，从前到后范围和精度都从小到大，转换过程没有损失。  

不同类型数的混合运算时，遵循的原则是“类型提升”，即较低类型转换为较高类型。如long型与int型一起运算时，需先将int型转换为long型，然后进行运算，结果为long型。若float型和double型一起运算，虽然两者同为浮点型，但精度不同，则仍需先将float型转换为double型后再进行运算，结果亦为double型。所有这些转换都是系统自动进行的，这种转换称为隐式类型转换。  

# 命题追踪int型和float型的精度和范围的分析（2017）  

1）int型转换为float型时，虽然不会发生溢出，但float型尾数连隐藏位共24位，当int型  
数的第 $24\!\sim\!31$ 位非0时，无法精确转换成24位浮点数的尾数，需舍入处理，影响精度。2）int型或float型转换为double型时，因double型的有效位数更多，因此能保留精确值。3）double型转换为float型时，因float型的表示范围更小，因此大数转换时可能会发生溢出。此外，由于尾数有效位数变少，因此高精度数转换时会发生舍入。4）float型或double型转换为int型时，因int型没有小数部分，因此数据会向O方向截断（仅  

保留救数部分）发生全入，另外、因int型的表示范围更小，因业大数桂换时可能会送出在不同数据类型之间转换时，往往隐藏着一些不容易察觉的错误，编程时要非常小心。  

# 2.3.4数据的大小端和对齐存储  

# 1.数据的“大端方式”和“小端方式”存储  

在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节（LSB）和最高有效字节（MSB）来分别表示数据的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为01234567H，其最高有效字节 $\mathrm{MSB}=01\mathrm{H}$ ，最低有效字节 $\mathrm{LSB}=67\mathrm{H}$  

# 命题追踪数据的大小端存储（2016、2018、2019）  

现代计算机基本都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，如int型和float型占4字节，double型占8字节等，而程序中对每个数据只给定一个地址。假设变量i的地址为 $08\ \mathrm{~00H}$ ，字节01H、 $^{23\mathrm{H}}$ 、45H、67H应各有一个内存地址，那么4字节在内存中应如何排列呢？根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式：大端方式（bigendian）和小端方式（lileendian），如图2.12所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84b38180f8e3e94007c8d5d059202ea50bd801817d21a778faa66e4c344005dc.jpg)  
图2.12采用大端方式和小端方式存储数据  

# 命题追踪根据存放顺序判断大小端方式（2019、2023）  

1）大端方式：先存储高位字节，后存储低位字节。字中的字节顺序和原序列的相同。2）小端方式：先存储低位字节，后存储高位字节。字中的字节顺序和原序列的相反。  

在检查底层机器级代码时，需要分清各类型数据字节序列的顺序，例如，以下是由反汇编器（汇编的逆过程，即将机器代码转换为汇编代码）生成的一行机器级代码的文本表示：  

4004d3:010564940408 addeax,0x8049464  

其中，“4004d3”是十六进制数表示的地址，‘ $\lceil01\;05\;64\;94\;04\;08$ ”是指令的机器代码，“addeax,0x8049464”是指令的汇编形式，该指令的第二个操作数是一个立即数 $0{\mathrm{x}}8049464$ 。执行指令时，从指令代码的后4字节中取出该立即数，立即数存放的字节序列为 $64\mathrm{H}$ 、94H、04H、08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到08049464H，去掉开头的0，得到值0x8049464，在阅读以小端方式存储的机器代码时，要注意字节是按相反顺序显示的。  

# 2.数据按“边界对齐”方式存储  

现代计算机都是按字节编址的，假设字长为32位，数据按边界对齐方式存放要求其存储地址是自身大小的整数倍，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取 的数据是字节、半字还是字，均可一次访存取出。当所存数据不满足上述要求时，可通过填充空白字节使其符合要求。这样做虽然会浪费一些存储空间，但可以提高存取数据的速度。当数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能得到所需数据，从而影响了系统的效率。  
例如，“字节1、字节2、字节3、半字1、半字2、半字3、字1”的数据按序存放在存储器中，按边界对齐方式和按边界不对齐方式存储时，格式分别如图2.13和图2.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/67830ff4aa95539687716a65b4721775d480669d1061978c1db29d559d02a9d6.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1d6304976238bbf3f89570e9a0865f42e06a2cef809c11fe4381efd07032597.jpg)  
图2.14按边界不对齐方式存储  

# 命题追踪结构体的小端、边界对齐存储（2012、2020）  

在C语言的struct类型中，“边界对齐”有两个重要要求： $\textcircled{\scriptsize{1}}$ 每个成员按其类型的大小对齐，char型的对齐值为1，short型的对齐值为2，int型的对齐值为4，单位为字节；  $\circledcirc$  struct的长度 必须是成员中最大对齐值的整数倍（不够就补空字节）。这样就能保证struct数组的每项都满足边界对齐的条件。  

先来看两个例子（32位，x86环境，GCC编译器）：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a106cd6e73c0cca59a16d1068d7eab6ca420beac8d815b1685e0a3f75e177bd6.jpg)  

结果却是：  $\mathrm{sizeof}\mathrm{(A)}=8$  ，  $\mathrm{sizeof}(\mathrm{B})=12$  

之所以出现上面的结果，是因为编译器要使结构体成员在空间上对齐。为此必须满足： $\textcircled{\scriptsize{1}}$ 每个成员存储的“起始地址 $.\%$ 该成员的长度 $=0$ ”，而结构体中的成员都是按定义的先后顺序排放的。 $\textcircled{2}$ 结构体的长度也必须是最大成员长度的整数倍，即结构体也要对齐排放。  

设B从地址 $0x0000$ 开始，第一个成员b的对齐值是1，其存放地址符合 $0\mathrm{x}0000\%1=0$ ：第二个成员a的对齐值是4，只能存放在从0x0004到 $\mathrm{0x0007}$ 这四个字节中，满足 $0\X{000}{4\%{4=0}}$ 且紧邻第一个成员；第三个成员c的对齐值是2，可以存放在从 $\mathrm{0x0008}$ 到 $0{\bf x}0009$ 这两个字节中。此外，结构体长度必须是最大对齐值的整数倍，故 $\mathrm{0x000A}$ 到 $\mathrm{0x000B}$ 也为B所占用，共12字节。  

设A也从地址 $0x0000$ 开始，第一个成员a的对齐值是4，存放在从 $0x0000$ 到 $0\mathbf{x}0003$ 这四个字节中；第二个成员b的对齐值是1，存放在 $0x0004$ 中；第三个成员c的对齐值是2，为满足“起始地址 $\%N\!=\!0$ ”的条件，只能存放在从 $0x0006$ 到 $0x0007$ 这两个字节中，结构体共占用8字节。  

边界对齐方式相对边界不对齐方式是一种空间换时间的思想。精简指令系统计算机RISC通常采用边界对齐方式，因为边界对齐方式取指令时间相同，因此能适应指令流水。  

# 2.3.5 本节习题精选  

# 一、单项选择题  

01.在C语言的不同类型的数据混合运算中，要先转换成同一类型后进行运算。设一表达式  
中包含有int型、long型、char型和double型的变量与数据，则表达式最后的运算结果是（），这4种类型数据的转换规律是（）。  

A. long,int→char→double→long B.long，char→int→long→double C.double,char→int→long→double D. double, char→int→double→long  

02.长度相同但格式不同的两种浮点数，假设前者阶码长、尾数短，后者阶码短、尾数长，其他规定均相同，则它们可表示的数的范围和精度为（）  

A.两者可表示的数的范围和精度相同B.前者可表示的数的范围大但精度低C.后者可表示的数的范围大且精度高D.前者可表示的数的范围大且精度高  

03．长度相同、格式相同的两种浮点数，假设前者基数大，后者基数小，其他规定均相同，则它们可表示的数的范围和精度为（）。  

A.两者可表示的数的范围和精度相同B.前者可表示的数的范围大但精度低C.后者可表示的数的范围大且精度高D.前者可表示的数的范围大且精度高  

04.下列说法中正确的是（）  

A.采用变形补码进行加减法运算可以避免溢出B.只有定点数运算才可能溢出，浮点数运算不会产生溢出C.定点数和浮点数运算都可能产生溢出D.两个正数相加时一定产生溢出  

05.在规格化浮点运算中，若某浮点数为 $2^{5}{\times}1.10101$ ，其中尾数为补码表示，则该数（）。  

A.不需规格化 B.需右移规格化 C.需将尾数左移一位规格化D.需将尾数左移两位规格化  

06.某浮点机，采用规格化浮点数表示，阶码用移码表示（最高位代表符号位），尾数用原码表示。下列（）的表示不是规格化浮点数。  

A 11111111,1.1000...00 B.0011111,1.0111...01 C.1000001,0.1111...01 D.0111111,0.1000...10  

07.下列关于对阶操作说法正确的是（）  

A.在浮点加减运算的对阶操作中，若阶码减小，则尾数左移 B.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移；若阶码减小，则尾数左移 C.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移 D.以上都不对  

08.浮点数的IEEE754标准对尾数编码采用的是（））A.原码B.反码C.补码D.移码  

09.在1EEE754标准规定的64位浮点数格式中，符号位为1位，阶码为11位，尾数为52位，则它所能表示的最小规格化负数为（）。  

A.  $^{-}(2-2^{52}){\times}2^{-1023}$  B.  $^{-(2-2^{-52})\times2^{+1023}}$  C.  $-1\!\times\!2^{-1024}$  D.  $-(1-2^{-52}){\times}2^{+2047}$  

10.按照IEEE754标准规定的32位单精度浮点数 $41\mathrm{A}4\mathrm{C}000\mathrm{H}$ 对应的十进制数是（）。A.4.59375 B.-20.59375 C.-4.59375 D.20.59375

 11.在浮点数编码表示中，（）在机器数中不出现，是隐含的。A.阶码B.符号C.尾数D.基数  

12.若某单精度浮点数、某原码、某补码、某移码的32位机器数均为  $\mathrm{0xF0000000}$  ，则这些 数从大到小的顺序是（）。A.浮原补移 B.浮移补原 C.移原补浮 D.移补原浮  
13.采用规格化的浮点数最主要是为了（）  

A.增加数据的表示范围B.方便浮点运算C.防止运算时数据溢出D.增加数据的表示精度  

14.下列说法中，正确的是（）  

I.在计算机中，表示的数有时会发生溢出，根本原因是计算机的字长有限I1.一个正数的补码和这个数的原码表示一样，而正数的反码是原码各位取反III.设有两个正的规格化浮点数  $N_{1}\,{=}\,2^{m}{\times}M_{1}$  和  $N_{2}\!=\!2^{n}{\times}M_{2}$  ，若  $m\!>\!n$  ，则有  $N_{1}\!>\!N_{2}$  

A.IB.IIIC.I、II、IID.I、III  

15.在浮点运算中，下溢指的是（）  

A.运算结果的绝对值小于机器所能表示的最小绝对值B.运算的结果小于机器所能表示的最小负数C.运算的结果小于机器所能表示的最小正数D.运算结果的最低有效位产生的错误  

16.判断浮点数运算是否溢出，取决于（）  

A.尾数是否上溢B.尾数是否下溢C.阶码是否上溢D.阶码是否下溢  

17.假定采用IEEE754标准中的单精度浮点数格式表示一个数为45100000H，则该数的值是()。  

A.  $(+1.125)_{10}{\times}2^{10}$  B.  $(+1.125)_{10}{\times}2^{11}$  C.  $(+0.125)_{10}{\times}2^{11}$  D.  $(+0.125)_{10}{\times}2^{10}$  

18.已知float型采用IEEE754单精度浮点格式，若x、y为float型变量，且  $\mathrm{x}=-126,\mathrm{y}=15.75$  则执行语句 $\mathbf{\Delta}_{\mathbf{Z}}=\mathbf{X}+\mathbf{y}$ 时，在浮点运算单元中进行对阶操作后的结果是（）。  

A.x不变，y为010000101，0.001111110..0 B.x不变，y为010000110.0.001111110...0 C.y不变，x为110000101,0.001111110...0 D.y不变，x为110000110.0.001111110..0  

19.在IEEE754标准浮点格式中，非规格化浮点数表示为（）  

A.阶码为0，尾数为任意非0的二进制数B.阶码为255，尾数全为0 C.阶码为255，尾数为任意非0的二进制数D.阶码为0，尾数全为0  

20.在规格化的浮点数中，将阶码部分的 $n$ 位移码表示改为 $n$ 位补码表示，其他不变，则浮点数的表示范围（）。  

A.增大 B.减小 C.不变 D.都不对  

21.设浮点数共12位。其中阶码含1位阶符共4位，以2为底，补码表示；尾数含1位符号共8位，补码表示，规格化。则该浮点数所能表示的最大正数是（）。  

A.  $2^{7}$  B.  $2^{8}$  C.  $2^{8}\mathrm{-}1$  D.  $2^{7}\mathrm{-}1$  

22.计算机在进行浮点数的加减运算之前先进行对阶操作，若 $x$ 的阶码大于 $y$ 的阶码，则应将（）。  

A. $x$ 的阶码缩小至与 $y$ 的阶码相同，且使 $x$ 的尾数部分进行算术左移B. $x$ 的阶码缩小至与 $y$ 的阶码相同，且使 $x$ 的尾数部分进行算术右移C. $y$ 的阶码扩大至与 $x$ 的阶码相同，且使y的尾数部分进行算术左移D. $y$ 的阶码扩大至与 $x$ 的阶码相同，且使 $y$ 的尾数部分进行算术右移  
23.若浮点数的尾数用补码表示，则下列（）中的尾数是规格化数形式。  

A.1.11000 B.0.01110 C.0.01010 D.1.00010  

24.设浮点数的基数为4，尾数用原码表示，则以下（）是规格化的数。  

A.1.001101 B.0.001101 C.1.011011 D.0.000010  

25.下列关于舍入的说法，正确的是（）  

1.不仅仅只有浮点数需要舍入，定点数在运算时也可能要舍入II.在浮点数舍入中，只有左规格化时可能要舍入IIIL.在浮点数舍入中，只有右规格化时可能要舍入IV.在浮点数舍入中，左、右规格化均可能要舍入V.舍入不一定产生误差  

A.I、III、VB.I、II、VC.VD.I、IV

26.计算机中的信息按边界对齐方式存储的含义是（）。  

A.信息的字节长度必须是整数B.信息单元的字节长度必须是整数C.信息单元的存储地址必须是整数D.信息单元的存储地址是其字节长度的整数倍  

27.假设已定义三个int型变量x、y和z，  ${\mathrm{sizeofint}})\,{=}\,4$  double IEEE 754 点数格式，变量dx、dy和dz的声明和初始化如下：  

double dx $=$ (double）x;double dy  $=$  (double)y; doubledz $=$ (double）z;则下列关系表达式中永远为真的是（）  

1.  $\mathrm{dx}+\mathrm{dy}=\mathrm{(double)}\;\mathrm{(x+y)}$  I1.  $\mathtt{d x\times d x}>=0$  IⅢ.  $\mathrm{{d}x/d x=d y/d y}$  IV.!  $(\mathrm{dx}+\mathrm{dy})+\mathrm{dx}=\mathrm{dx}+(\mathrm{dy}+\mathrm{dx})$  

A.I和ⅡI B.II和II C.和IV D.II和IV  

28.在按字节编址的计算机中，采用小端方式存储数据，某静态二维数组b的声明如下：static short  $\mathfrak{b}\left[2\right]\left[4\right]~=~\{\,\{\,2\,,9\,,-1\,,5\}\,,\,\{\,3\,,1\,,-6\,,2\}\,\}$  若b的首地址为 $0\mathrm{x}8049820$ ，采用按行优先存储，地址0x804982c中的内容是（）  

A.FAH B.FFH C.00H D.05H  

29.在按字节编址的计算机中，数据在存储器中以小端方式存放。假定imt型变量i的地址为08000000H，i的机器数为01234567H，地址08000000H单元的内容是（）。  

A.01H B.23H C.45H D.67H  

30.在按字节编址的32位计算机中，按边界对齐方式为以下结构型变量x分配存储空间：struct cont in foi charid; unsigned post; charphone; }X;  

若x的首地址为0x8049820，则成员变量phone的起始地址为（）。A.0x8049828 B.0x8049826 C.0x8049825 D.0x8049822  
31.在按字节编址、采用大端方式的16位计算机中，执行完下列C语言程序片段后，m的低字节地址的内容为（）  

int  $\texttt{n}=$  0xA1B6; unsigned int  $\mathrm{~m~}=\mathrm{~n~}$   $\texttt{m}=\texttt{m}>>1$  

A.50H B.AIH C.B6H D.DBH  

32.假定变量i、f的数据类型分别是int、float。已知 $\mathrm{i}=12345$  $\mathrm{f}=1.2345{\times}2^{3}$ ，则在一个32位机器中执行下列表达式时，结果为“假”的是（）。  

A.  $\mathrm{i}=$  (int)(double)i B.  $\mathrm{f}\!=$  (float)(double)f C.  $\mathrm{i}=$  (int)(float)i D.  $\mathrm{f}\!=$  (float)（int)f  

33.有以下C语言代码段：  

int  $\scriptstyle{\mathrm{m}}=13$  float  $\mathsf{a}\!=\!\mathrm{1}\,2\,,\mathsf{6}\,,\mathrm{x}$   $\scriptstyle{\mathrm{x}=\mathrm{m}/2+\mathrm{a}/2}$  printf（"gf\n",x）;  

执行上述代码后，输出的 $_\mathrm{x}$ 值为（）  

A.12.000000 B.12.300000 C.12.800000 D.12  

34.【2009统考真题】浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7（均含2位符号位）。若有两个数 $\!X\!=\!2^{7}\!\times\!29/32$ 和 $Y\!=\!2^{5}\!\times\!5/8$ 则用浮点加法计算 $X+Y$ 的最终结果是()。  

A.001111100010B.001110100010C.010000010001D.发生溢出  

35.【2010统考真题】假定变量i、f和d的数据类型分别为int、float和double（int型用补码表示，float型和double型分别用IEEE754单精度和双精度浮点数格式表示），已知 $\mathrm{i}=$ 785、 $\mathrm{f}=1.5678\mathrm{E}3$  $\mathrm{d}=1.5\mathrm{E}100$ ，若在32位机器中执行下列关系表达式，则结果为“真”的是()。  

$\mathrm{i\,{=}\,(i n t)(f l o a t)i}$  Ⅱ.  $\mathrm{f}\!=$  （float)(int)fm.  $\mathrm{f}\!=\!\!($  float)(double)fV.  $\mathrm{(d+f)-d=f}$  

A.仅I和ⅡI B.仅I和IⅢI C.仅II和IⅢI D.仅ⅢI和IV  

36.【2011统考真题】float型数据通常用IEEE754单精度格式表示。若编译器将float型变量X分配在一个32位浮点寄存器FR1中，且 $\mathbf{x}=-8.25$ ，则FR1的内容是（）  

A.C1040000H B.C2420000H C.C1840000H D.C1C20000H  

37.【2012统考真题】float型（即TEEE754单精度浮点数格式）能表示的最大正整数是（））  

A  $2^{126}-2^{103}$  B.  $2^{127}\!-2^{104}$  C.  $2^{127}\!-2^{103}$  D.  $2^{128}\mathrm{-}\,2^{104}$  

38.【2012统考真题】某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定int型和short型长度分别为32位和16位，并且数据按边界对齐存储。某C语言程序段如下：  

struct{ int a; char b; short C; }record; record.  $a\ =\ 273$  

若record变量的首地址为 $\mathrm{0xC008}$ ，地址 $\mathrm{0xCO08}$ 中的内容及record.c的地址分别为（）。A.0x00,  $\mathrm{0xC00D}$  B.0x00,0xC00E C.0x11,0xC00D D.0x11,0xC00E  
39.【2013统考真题】某数采用1EEE754单精度浮点数格式表示为 $\mathrm{C640~\,0000H}$ ，则该数的值是（）。  

A.  $-1.5{\times}2^{13}$  B.  $-1.5{\times}2^{12}$  C.  $-0.5{\times}2^{13}$  D.  $-0.5{\times}2^{12}$  

40.【2014统考真题】float型数据常用IEEE754单精度浮点格式表示。假设两个float型变量x和y分别存放在32位寄存器fl1和f2中，若 $\mathrm{\ddot{f}(f l)=C C90\ 0000H}$  $(\mathrm{f}2)=\mathrm{B0C0\,0000H}$ 则x和V之间的关系为（）。  

A. $\mathrm{x}<\mathrm{y}$ 且符号相同B. $\mathbf x<\mathbf y$ 且符号不同C. $\mathbf{x}>\mathbf{y}$ 且符号相同D. $\mathbf{\Delta}\mathbf{x}>\mathbf{y}$ 且符号不同  

41.【2015统考真题】下列有关浮点数加减运算的叙述中，正确的是（）  

1.对阶操作不会引起阶码上溢或下溢 II.右规和尾数舍入都可能引起阶码上溢 I11.左规时可能引起阶码下溢IV.尾数溢出时结果不一定溢出  

A.仅II、IⅢIB.仅I、ⅡI、IVC.仅I、III、IVD.I、ⅡI、II、IV  

42.【2016统考真题】某计算机字长为32位，按字节编址，采用小端方式存放数据。假定有一个double型变量，其机器数表示为1122334455667788H，存放在以 $0000\ 8040\mathrm{H}$ 开始的连续存储单元中，则存储单元 $0000\ 8046\mathrm{H}$ 中存放的是（）。  

A.22H B.33H C.77H D.66H

 43.【2018统考真题】IEEE754单精度浮点格式表示的数中，最小的规格化正数是（）。A.  $1.0{\times}2^{-126}$  B.  $1.0{\times}2^{-127}$  C.  $1.0{\times}2^{-128}$  D.  $1.0{\times}2^{-149}$  

44.【2018统考真题】某32位计算机按字节编址，采用小端方式。若语句“int $\mathrm{i}=0$ ”对应指令的机器代码为 $"\mathrm{C}7\,45\;\mathrm{FC}\,00\,00\,00\,00"$ ，则语句 $\mathrm{{`inti=-64}}$ ”对应指令的机器代码是()。  

A.C 745 FCC 0 FFFFFF B.C 745 FC 0 C FFFFFF C.C 745 FC FFFFFF C 0 D.C 745 FC FFFFFF 0 C  

45.【2020统考真题】在按字节编址、采用小端方式的32位计算机中，按边界对齐方式为以下C语言结构型变量a分配存储空间：  

struct record{ short x1; int  $\times2$  a;  

若a的首地址为2020FE00H，a的成员变量 $_{\mathrm{x}2}$ 的机器数为 $1234\;0000\mathrm{H}$ ，则其中34H所在存储单元的地址是（）  

A.2020FE03H B.2020FE04H C.2020FE05H D.2020FE06H  

46.【2020统考真题】已知有符号整数用补码表示，float型数据用IEEE754标准表示，假定变量 $x$ 的类型只可能是int或float，当 $x$ 的机器数为 $\mathrm{C800\,0000H}$ 时， $x$ 的值可能是（）  

A.  $-7{\times}2^{27}$  B.  $-2^{16}$  C.  $2^{17}$  D.  $25\!\times\!2^{27}$  47.【2021统考真题】下列数值中，不能用1EEE754浮点格式精确表示的是（）。A.1.2B.1.25C.2.0D.2.5

48.【2022统考真题】-0.4375的1EEE754单精度浮点数表示为（）A.BEE0 0000H B.BF600000H C.BF700000H D.C0E00000H  

49.【2023统考真题】若short型变量 $\mathbf{X}=-8190$ ，则 $\mathbf{X}$ 的机器数是（）A.E002H B.E001H C.9FFFH D.9FFEH  
50.【2023统考真题】已知float型变量用IEEE754单精度浮点数格式表示。若float型变量X的机器数为 $8020\,0000\mathrm{H}$ ，则 $_\mathrm{x}$ 的值是（）。  

A. $-2^{-128}$ B. $-1.01\!\times\!2^{-127}$ C. $-1.01\!\times\!2^{-126}$ D.非数（NaN）  

# 二、综合应用题  

01.现有一计算机字长32位 $(\mathrm{~D~}_{31}\sim\mathrm{D}_{0}$ ），符号位是第31位。对于二进制 $1000\ 1111\ 1110\ 1111\ 1100\ 0000\ 0000\ 00000$ 1）表示一个补码整数，其十进制值是多少？2）表示一个无符号整数，其十进制值是多少？3）表示一个IEEE754标准的单精度浮点数，其值是多少？  

02.假定变量i是一个32位的int型整数，f和d分别为float型（32位）和double型（64位）实数。分析下列各布尔表达式，说明结果是否在任何情况下都是“trule”  

1)  $\mathrm{i}=$  (int) ((double)i) 2)  $\mathrm{f}\!=$  (float) ((int) f) 3)  $\mathrm{f}\!=$  (float)((double)f) 4) ${\mathsf{d}}=$ (double)((float)d）  

03.已知两个实数 $\mathrm{x}=-68,\ \mathrm{y}=-8.25$ ，它们在C语言中定义为float型变量，分别存放在寄存器A和B中。另外，还有两个寄存器C和D。A、B、C、D都是32位的寄存器。请问（要求用十六进制表示二进制序列）：  

1）寄存器A和B中的内容分别是什么？2）x和y相加后的结果存放在C寄存器中，寄存器C中的内容是什么？3）x和y相减后的结果存放在D寄存器中，寄存器D中的内容是什么？  

04.对下列每个IEEE754单精度数值，解释它们所表示的是哪种数字类型（规格化数、非规格化数、无穷大、0）。当它们表示某个具体数值时，请给出该数值。  

1）0000 0000 0000 0000 0000 0000 0000 0000 2)0100 0010 0100 0000 0000 0000 0000 0000 3）1000 0000 0100 0000 0000 0000 0000 0000 4）1111 1111 1000 0000 0000 0000 0000 0000  

05.【2017统考真题】已知 $f(n)=\sum_{i=0}^{n}2^{i}=2^{n+1}-1=\overbrace{11\cdots1\mathrm{B}}^{n+1\mathrm{B}}$ ，计算 $f(n)$ 的C语言函数fl如下：  

int fl（unsigned n)（ int sum  $_{;=1}$  ,power  $_{:=1}$  for(unsigned  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\mathrm{i}}<=\mathrm{n}-1$   $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  power  $\star_{=~2}$  sum  $+=$  power; return sum;  

将f1中的int都改为float，可得到计算f（n）的另一个函数f2。假设unsigned型和int型数据都占32位，float型数据采用IEEE754单精度标准。请回答下列问题：1）当 $\mathrm{n}=0$ 时，fl会出现死循环，为什么？若将fl中的变量i和n都定义为int型，则f1是否还会出现死循环？为什么？  
2）f1(23)和f2(23)的返回值是否相等？机器数各是什么（用十六进制表示）？3）f1(24)和f2(24)的返回值分别为33554431和33554432.0，为什么不相等？4) $\mathrm{f}(31)=2^{32}-1$ ，而fl(31)的返回值却为-1，为什么？若使fl(n)的返回值与f(n)相等，则最大的n是多少？5）f2（127)的机器数为 $7\mathrm{F}80\ 0000\mathrm{H}$ ，对应的值是什么？若使f2(n)的结果不溢出，则最大的n是多少？若使f2(n)的结果精确（无舍入），则最大的n是多少？  

# 2.3.6 答案与解析  

# 一、单项选择题  

01.C  

不同类型的数据混合运算时，遵循的原则是“类型提升”，即较低类型转换为较高类型，最double。4 char→int→long→double。  

例如，long型数据与int型数据一起运算时，需先将int型转换为long型，然后两者再进行运算，结果为long型。float型数据和double型数据一起运算时，虽然它们同为实型，但两者精度不同，仍要先将float型转换成double型再进行运算，结果亦为double型。所有这些转换都是由系统自动进行的，这种转换通常称为隐式转换。  

注意在强制类型转换中，从int型转换为float型时，虽然不会发生溢出，但因尾数位数的关系，可能有数据舍入，而转换为double型则能保留精度。double型转换为float型时亦是如此。从float型或double型转换为int型时，小数部分被截断，且由于int型的表示范围更小，还可能发生溢出。  

02.B  

在浮点数总位数不变的情况下，阶码位数越多，尾数位数越少；即表示的数的范围越大，精度越差（数变稀疏）。  

03.B  

基数是浮点数的进制，决定了阶码变化的权重。基数越大，阶码每变化一位，尾数小数点需要移动的位数越多，表示的数的绝对值就越大，范围就越大。但是，在浮点数的总位数不变的情况下，能表示的不同状态个数是一定的。若范围增大，则意味着浮点数的离散程度增大，相邻两个浮点数之间的间隔就越大，精度就越低。例如，假设符号为S、尾数为 $M_{\sun}$ 阶码为 $E$ ，则基数为2时的浮点数表示形式为 $(-1)^{S}{\times}M{\times}2^{N}$ ，基数为4时的浮点数表示形式为 $(-1)^{S}{\times}M{\times}4^{N}$ ，显然基数为4时的表示范围大，但数据的离散程度也增大，精度降低。  

04. C  

变形补码，即用两个二进制位来表示数字的符号位，其余与补码相同，所以并不能避免溢出，A错误。定点数和浮点数运算都可能产生溢出，但是溢出判断有区别，因此B错误、C正确。在定点运算中，当运算结果超出数的表示范围时，就发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出，D错误。  

05.C  

考查浮点数的规格化。当尾数为补码表示，且为 $1.0\times\times\times\times$ 形式时为规格化数，因此该尾数需左移一位，阶码同时应减1，才为规格化数。  

06.B  

原码表示时，正数的规格化形式为 $0.1\times_{...}\times$ ，负数的规格化形式为 $1.1\times_{...}\times$ ，因此B错误。  

07.C  
对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况，因而A、B错误。  

08.A  

IEEE754标准中尾数采用原码表示，阶码部分用移码表示。  

09.B  

长浮点数，其阶码11位，尾数52位，采取隐藏位策略，因此其最小规格化负数为阶码取最大值 $2^{+1023}$  $1023=2^{11-1}(-1)$ ，尾数取最大值 $2-2^{-52}$ （注意其有隐藏位要加1)，符号位为负。  

10.D  

在IEEE754单精度浮点数中，最高位为符号位；其后是8位阶码，以2为底，用移码表示，阶码的偏置值为127：其后23位是尾数数值位。对于规格化的二进制浮点数，数值的最高位总是“1”，为了能使尾数多表示一位有效值，将这个“1”隐藏，因此尾数数值实际上是24位。隐藏的“1”是一位整数。在浮点格式中表示出来的23位尾数是纯小数，用原码表示。41A4C000H写成二进制为 $0100\,0001\,1010\,0100\,1100\,0000\,0000\,0000$ ，第一位为符号位0，表示是正数。之后的8位10000011表示阶码，真值为（ $100)_{\mathrm{B}}$ ，即4。剩下的是隐藏了最高1的尾数，故而为1.01001001100000000000000，数值左移四位后整数部分10100表示为20。  

11.D  

浮点数表示中基数的值是约定好的，因此将其隐含。  

12.D  

这个机器数的最高位为1，对于原码、补码、单精度浮点数而言为负数，对于移码而言为正数，所以移码最大，而补码为 $-2^{28}$ ，原码为· $-(2^{30}+2^{29}+2^{28})$ ，单精度浮点数为一 $\cdot1.0\times2^{97}$ ，大小依次递减。  

13.D  

与非规格化浮点数相比，采用规格化浮点数的目的主要是为了增加数据的表示精度。14.D I正确；正数的原码、反码和补码都相同，Ⅱ错误；因为是规格化正浮点数，所以 $M_{1}$ 、 $M_{2}$ 均为 $0.1x x$ 形式，有 $N_{1}$ 阶码至少比 $N_{2}$ 大1，所以 $N_{1}>N_{2}$ ，ⅢI正确。  

15.A  

运算结果在0至规格化最小正数之间时称为正下溢，运算结果在 $0$ 至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。  

16.C  

判断浮点数运算是否溢出，取决于阶码是否上溢。阶码下溢可以通过非规格化数来表示。尾数上溢或下溢，可以通过左移或右移进行调整。  

17.B  

写成二进制表示为 $0100\;0101\;0001\;0000\;0000\;0000\;0000\;0000$ ，第一位为符号位，0表示正数，随后8位（float型）10001010是用移码表示的阶码，因此减去01111111后得十进制数11，而IEEE754标准中单精度浮点数在阶码不为0时隐藏1，因此尾数为 $(1.0010)_{\mathrm{B}}\,{=}\,(1.125)_{\mathrm{D}}$ ，因此该数值为 $(+1.125)_{10}{\times}2^{11}$  

18.A  

规格化IEEE754浮点数尾数部分的数值范围为[1,2)， $\mathrm{x}=-111110\mathrm{B}=-1.111110\mathrm{B}{\times}2^{6},$  $\mathbf{y}=$  $1111.11\mathrm{B}=1.1111\mathrm{B}{\times}2^{3}$ ，故浮点数x、y的阶数分别为6和3。对阶操作是小阶向大阶看齐，即y的阶数变为6，移码表示为 $6+127=133$ ，即10000101B，y的尾数右移3位，变为0.00111111B。  

19.A  
在IEEE754标准格式中，阶码全为0，尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行下去。  

20.C  

在位数相同的条件下，移码和补码的表示范围是相同的，故阶码的表示范围不变，因此浮点数的表示范围不变，只是改变了浮点数的表示形式。  

21.D  

为使浮点数取正数最大，可使尾数取正数最大，阶码取正数最大。尾数为8位补码（含符号位），正值最大为0.1111111，即 $1-2^{-7}$ ，阶码为4位补码（含符号位），正值最大为0111，即7，则最大正数为 $(1-2^{-7}){\times}2^{7}\!=2^{7}\!-1$  

22.D  

浮点数加减运算时，首先要进行对阶，根据对阶的规则，阶码和尾数将进行相应的操作。  

对阶的规则是小阶码向大阶码看齐，即阶码小的数的尾数算术右移，每右移一位，阶码加1，直到两数的阶码相等为止。  

23. D  

补码的规格化表示是小数点后一位与符号位不同。  

24.C 原码表示的规格化小数是小数点后2位（基数为4，用2位表示）不全为0的小数。  

25.C  

舍入是浮点数的概念，定点数没有舍入的概念。浮点数舍入的情况有两种：对阶、右规格化。舍入不一定产生误差，如向下舍入11.00到11.0时是没有误差的。  

26.D  

信息在存储器中按边界对齐方式存储的含义是信息单元的存储地址是其字节长度的整数倍。这样可以保证对一个字长数据的读/写只需要一次存储器访问，提高了访存效率，但有时会导致存储空间的浪费。因此，这是一种以空间换时简的办法。  

27.D  

1非永真，因为 $\mathrm{x+y}$ 可能会溢出，而dx+dy不会溢出。ⅡI永真，double型采用IEEE754表示，尾数采用原码小数，符号和数值部分分开计算，不管结果是否溢出，都不会影响乘积的符号。IⅢI非永真，dx和dy中只要有一个为0、另一个不为0就不相等。IV永真，因为dx、dy和dz是由32位int型转换得到的，double型可以精确地表示int型，且对阶时尾数移动位数不会超过52位，因此尾数不会舍入，因而不会发生大数吃小数的情况。  

28.A  

二维数组b的元素是short型，占2字节，采用按行优先存储，b[0]I0]的地址为0x8049820，b[0][1]的地址为0x8049822，以此类推，b[1][2]的地址为 $\mathrm{0x804982c}$ 。b[1][2]的值为-6，补码表示为1111111111111010，采用小端方式存储，因此地址0x804982c存放的是低位字节FAH。  

29.D  

小端方式是将最低有效字节存储在最小位置。在数01234567H中，最低有效字节为 $67\mathrm{H}$  

30.A  

结构体按边界对齐存放的要求：数据成员的起始地址是其数据类型大小的整数倍，char型占1字节，char型的起始地址必须是1字节的整数倍；unsigned型占4字节，故unsigned型的起始 地址必须是4字节的整数倍。据此分析，id的起始地址为0x8049820，p0st的起始地址为0x8049824，故phone的起始地址为0x8049828。结构体x的存放方式如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/44bbb5f9a4bf2cebbda8e70f5ef9ba1dbea27c70cec06ce1d17ccb04c07d2a7a.jpg)  

# 31.A  

int型强制转换为unsignedint型后，两个变量对应的每一位都是一样的，强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。因此，m的值仍为AIB6H，逻辑移位后的值为50DBH，由于采用大端方式，内存的低地址存放高位字节，因此低字节地址的内容为 $50\mathrm{H}$  

32.D  

对于A和B，int型的有效位数不会超过31位，float型的有效位数比double型的小得多，因此都能精确转换为具有53位有效位的double型。对于C， $12345<1024{\times}16=2^{14}$ ，因此12345对应的二进制的位数一定小于14，因此可精确转换为具有24位有效位的float型。对于 $\mathrm{D},\mathrm{f}=1234.5$ 转换为int型后，小数点后面的数字丢失，因此与原来的f不相等。  

# 33.B  

整数与整数运算，结果为整数，所以  $\mathrm{m}/2$  的结果为6。实数与整数运算，结果为实数，所以  $\mathrm{a}/2$ 的结果为6.3，相加为12.3。C语言的输出格式可使输出值保留小数点后6位，输出为12.300000。  

# 34.D  

$X$ 的浮点数格式为00,111;00,11101（分号前为阶码，分号后为尾数），Y的浮点数格式为00101；00，10100。然后根据浮点数的加法步骤进行运算。  

$\textcircled{\scriptsize{1}}$ 对阶。 $X_{\backprime}$ Y阶码相减，即 $00,111-00,101=00,111+11,011=00,010$ ，可知 $X$ 的阶码比Y的价码大2（这一步可直接目测）。根据小阶码向大阶码看齐的原则，将 $Y$ 的阶码加2，尾数右移2位，将 $Y$ 变为00,111;00,00101。 $\circledcirc$ 尾数相加。即 $00,11101+00$  $00101=01$ ，00010，尾数相加结果符号位为01，因此需要右规。 $\textcircled{3}$ 规格化。将尾数右移1位，阶码加1，得 $X+Y$ 为01,000;00,10001。 $\textcircled{4}$ 判断溢出。阶码符号位为01，说明发生溢出。  

本题容易误选B、C，因为B、C本身并无计算错误，只是它们不是最终结果，B少了第3步和第4步，C少了第4步。  

# 35.B  

题中三种数据类型强制类型转换的顺序为int一float $\rightarrow$ double。float in t，小数位部分会被舍去，int型是精确到32位的整数，而float型只保存到 $1\!+23$ 位，因此一个32位的int型整数在转换为float型时可能会有损失，具体判断方法如下：先将int型整数转换成二进制真值，然后将真值写为 $\pm1.x...x{\times}2^{n}$ 的形式，若小数点后的位数超过23位，则转换为float型会发生精度损失。本题中 $\mathrm{i}=785$ ，转换成二进制真值为 $1.100010001{\times}2^{9}$ ，小数点后只有9位，不会发生精度损失，I正确。对于ⅡI，将float型的f转换为int型，小数点后的数位丢失，结果非真。double型的精度和范围都比float型的大，float型转换为double型不会有损失，Ill正确。对于IV，初看似乎没有问题，但浮点运算d+f时需要对阶，对阶后f的尾数有效位被舍去而变为0，因此d+f仍然为d，再减去d后结果为0，结果非真。注意，从int型转换为float型时，虽然不会发生溢出，但由于尾数位数的关系，可能有数据舍入，影响精度，而转换为double型则能保留精度。  
36.A  

本题的目的在于考查IEEE754单精度浮点数的表示。首先先将 $\mathbf{X}$ 转换成二进制为- $\cdot1000.01=$  $-1.000~01{\times}2^{3}$ ，然后计算阶码 $E$ ，根据IEEE754单精度浮点数格式，有 $E-127=3$ ，因此 $E=130$ 转换成二进制为 $1000\,0010$ 。最后，根据IEEE754标准，最高位的“1”是被隐藏的。  

IEEE754单精度浮点数格式：符号（1位） $^+$ 阶码（8位） $^+$ 尾数（23位）。  

因此FRI的内容为 $\textsf{J l;}1000\,0010;\,0000\,1000\,0000\,0000\,0000\,0000$  

即  $1100\;0001\;0000\;0100\;0000\;0000\;0000={\mathrm{C}}104\;0000{\mathrm{H}}_{\odot}$  

本题易误选D，未考虑IEEE754标准隐藏最高位1的情况，把偏置值认为是128。  

37.D  

IEEE754单精度浮点数是尾数用采取隐藏位策略的原码表示，且阶码用移码（偏置值为127）表示的浮点数。规格化短浮点数的真值为 $!(-1)^{S_{\times}}\!1.m{\times}2^{E-127}$ ，其中 $S$ 为符号位，阶码 $E$ 的取值为 $1\!\sim$ 254（8位表示），尾数 $m$ 为23位，共32位；因此，float类型能表示的最大整数是 $1.111...1\times2^{254-127}{}=$  $2^{127}\times(2-2^{-23})=2^{128}-2^{104}$  

【另解】IEEE754单精度浮点数的格式如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0236cda08b6b16996b5379d1ba9b1656d27d754fb8d87587b7d9c89a6a53d209.jpg)  

表示最大正整数时：符号取0；阶码取最大值127；尾数部分隐藏了整数部分的“1”，23位尾数全取1时尾数最大，为 $2-2^{-23}$ ，此时浮点数的大小为 $(2-2^{-23}){\times}2^{127}=2^{128}-2^{104}$  

38.D  

尽管record大小为7B（成员a有4B，成员b有1B，成员c有2B），由于数据按边界对齐方式存储，因此record共占用 $^{88}$ 。record.a的十六进制表示为 $0\mathrm{x}00000111$ ，由于采用小端方式存放数据，因此地址 $\mathrm{0xC008}$ 中的内容应为低字节0xll；record.b只占1B，后面的1B留空；record.c占2B，因此其地址为 $\mathrm{0xCO0E}$ 。各字节的存储分配如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f5351bf45f96323cd5f75907c05404bf54817a27e004f2ffd4a3c328e8609f0.jpg)  

39.A  

IEEE754单精度浮点数格式为  $\mathrm{C640~\,0000H}$  ，二进制格式为110001100100000000000000 00000000，转换为标准的格式为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1b3fe6adbb2ebd90953acc28cd63a2280d5c40dc3f273dc94da1fc43adcedb3.jpg)  

符号为1表示负数；阶码值为 $1000\ 1100-0111\ 1111=0000\ 1101=13$ ：尾数值为1.5（注意其有隐藏位，要加1)。因此，浮点数的值为一 $\cdot1.5\!\times\!2^{13}$  

40.A  

(f1)和(f2)对应的二进制分别是( $(110011001001...)_{2}$ 和(101100001100...)2，根据IEEE754浮点数标准，可知(f1)的符号为1，阶码为10011001，尾数为1.001，而(f2)的符号为1,阶码为01100001，尾数为1.1，可知两数均为负数，符号相同，B、D排除；（f1)的绝对值为 $1.001\!\times\!2^{26}$ ，(f2）的绝对值为 $1.1\!\times\!2^{-30}$ ， (fl)的绝对值比(f2)的绝对值大，而符号为负，真值大小相反，即(fI)的真值比(f2)的真值小，即 $\mathbf x<\mathbf y$  

41.D  
对阶是较小的阶码向较大的阶码对齐，所以对阶后的阶码是当前那个较大的阶码而不会导致阶码溢出，I正确。右规和尾数舍入过程，阶码加1而可能上溢，ⅡI正确，同理ⅢI也正确。尾数溢出时可能仅产生误差，结果不一定溢出，IV正确。  

42.A  

大端方式：一个字中的高位字节存放在内存中这个字区域的低地址处。小端方式：一个字中的低位字节存放在内存中这个字区域的低地址处。各字节的存储分配如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31089bcbd5b7eed2faf310d6328ba4a33abfc1670c921a2fd7161a6201a0bb6b.jpg)  

从而存储单元 $0000\ 8046\mathrm{H}$ 中存放的是 $22\mathrm{H}$  

43. A  

IEEE754单精度浮点数的符号位、阶码位、尾数位（省去正数位1）所占的位数分别是1、8、23。最小正数，符号位取0，移码的取值范围是 $1\!\sim\!254$ ，取1，得阶码值 $1-127\!=\!-126$ (127为我们规定的偏置值），尾数取全0，最终推出最小规格化正数为A。  

44.A  

按字节编址，采用小端方式，低位的数据存储在低地址位、高位的数据存储在高地址位，并且按照一字节相对不变的顺序存储。由题意，存储0的位数是后32位，则我们只需要把-64的补码按字节存储在其中即可，而-64表示成32位的十六进制是FFFFFFC0，根据小端方式的特点，低位字节存储在低地址，就是COFFFFFF。  

45.D  

在32位计算机中，按字节编址，根据小端方式和按边界对齐的定义，变量a的存放方式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80ff7c6f8d324c2640621c9861d81dd4e54116bc12873d7b61cec657125553a1.jpg)  

于是，34H所在存储单元的地址为2020FE06H。  

46. A  

$\mathrm{C800\,\,0000H}\,{=}\,1100\,\,1000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,$  

将其转换为对应的float型或int型。  

1）若为float型，则尾数隐藏最高位1，符号为1表示负数，阶码 $1001\;0000\!=\!2^{7}\!+2^{4}\!=\!128+16$ 再减去偏置值127得到17，算出 $x$ 值为 $\cdot2^{17}$  

2）若为int型，则有符号补码，为负数，数值部分取反加1，得 $011\;1000\;0000\;0000\;0000\;0000$ 00000000，算出 $x$ 值为 $-7\!\times\!2^{27}$  

47.A  

使用排除法。选项B： $1.25\!=\!1.01\mathbf{B}\!\times\!2^{\scriptscriptstyle0}$ ；选项C： $2.0=1.0{\bf B}{\times}2^{1}$ ；选项D： $2.5=1.01\mathrm{B}{\times}2^{1}$ 。因此，B、C和D均可以用IEEE754浮点格式精确表示。选项A的十进制小数1.2转换成二进制的结果是无限循环小数 $1.001100110011...$ ，无法用精度有限的IEEE754格式精确表示。  

48. A  
IEEE754单精度浮点数格式中依次为符号1位、阶码8位（偏置值127）、尾数23位（隐藏1位)。  $-\,0.4375=-\,1.75\times2^{-2}$  ，保证小数点前是1。根据单精度浮点数格式，符号为1；阶码为移 码表示， $-2\ +\ 127=125$ ，写成8位二进制数为01111101；尾数隐藏小数点前的1，剩下的0.75写成二进制数为0.11，所以尾数部分是 $1100\cdots0$ 。该浮点数的二进制格式为1011111011100000 $0000\:0000\:000\:0000$ ，对应的十六进制格式为BEE0 $\mathrm{0000H}$  

49.A  

short型变量是补码表示的16位有符号整数。x是负数，可先求出8190的机器数， $8190=8192\,-$  $2=2^{13}-2^{1}$ ，8190的机器数为 $\mathrm{0010~0000~0000~0000B-0000~0000~0000~0010B=0001}$ 1111 11111110B，因此-8190的机器数为 $1110\ 0000\ 0000\ 0010\mathbf{B}=\mathrm{E}002\mathrm{H}$ （按位取反，末位加1）。  

50.A  

把x的机器数按二进制展开， $8020\ 0000\mathrm{H}=\underline{{1000\ 0000\ 0010\ 0000\ 0000\ 0000\ 0000\ 0000B}}$ ，符号为负，阶码全为0，尾数不全为0，由下表可知，这是非规格化数，对于32位非规格化负数，若尾数的二进制为f，则真值为  $-2^{-126}{\times}0.f{=}-2^{-126}{\times}0.01{=}-2^{-128}{\mathrm{e}}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0928cf9558746fb8b10be920e780e68c65160cbe0e30ea91e4ff460c74226f07.jpg)  

# 二、综合应用题  

01.【解答】  

1）最高位为符号位，符号位为1，表示是一个负数，对应真值的二进制为 $-111\;0000\;0001\;0000\;0100\;0000\;0000\;0000$ （数值位取反，末位加1）  

对应的十进制值为- $(2^{30}+2^{29}+2^{28}+2^{20}+2^{14})$  

2）全部32位均为数值位，按权相加可知其十进制值为  $2^{31}+2^{27}+2^{26}+2^{25}+2^{24}+2^{23}+2^{22}+2^{21}+2^{19}+2^{18}+2^{17}+2^{16}+2^{15}+2^{14}$  

3）表示一个IEEE754标准的单精度浮点数：  

符号阶码尾数00011111 11011111100000000000000  

因为阶码为00011111，所以对应的十进制数为31。1EEE754标准中的阶码用移码表示，其偏置值为127，所以阶码的十进制真值为 $31-127\,{=}\,{-}96$  

因为尾数为1.11011111100000000000000。1EEE754标准中的尾数用原码表示，且采用隐藏尾数最高数位“1”的方法，隐藏的“1”是一位整数。所以尾数真值为  

$$
1+2^{-1}+2^{-2}+2^{-4}+2^{-5}+2^{-6}+2^{-7}+2^{-8}+2^{-9}
$$  

因为符号为1，表示这个浮点数是个负数。所以单精度浮点数的真值为  

$$
-(1+2^{-1}+2^{-2}+2^{-4}+2^{-5}+2^{-6}+2^{-7}+2^{-8}+2^{-9})\times2^{-96}
$$  

02.【解答】  

强制类型转换，转换过程有两个，unsigned in t→int→long→double，二是float→double， 从后向前转换会使得数据丢失，进而使等号不成立。  

1）是。因为double型比int型精度高，所以int型变量转换为double型变量时不会有精度损失。 2）不是。因为float型有小数部分，而int型没有小数部分，所以把float型变量转换为int  
型变量时，可能会丢失小数部分。  

3）是。因为double型比float型精度高，所以float型变量转换为double型变量时不会有精 度损失。  

4）不是。因为float型比double型的有效位数少，所以double型变量转换为float型变量时 会有精度损失。  

03.【解答】  

1）float型变量在计算机中都被表示成IEEE754单精度格式。 $\begin{array}{r}{X\!=\!-68=\!-(1000100)_{2}\!=}\end{array}$  $-1.0001{\times}2^{6}$ ，符号位为1，阶码为 $127+6\,{=}\,128+5\,{=}\,(1000\;0101)_{2}$ ，尾数为1.0001，所以小数部分为 $000\ 1000\ 0000\ 0000\ 0000\ 0000$ ，合起来整个浮点数表示为110000101000 $1000\:0000\:0000\:0000\:0000$ ，写成十六进制为 $C2880000\mathrm{H}$  $Y\!=\!-8.25\!=\!-(1000.01)_{2}\!=\!-1.00001\!\times\!2^{3}$ ，符号位为1，阶码为 $127\ +\ 3=128\ +\ 2=(1000$  $0010)_{2}$ ，尾数为1.00001，所以小数部分为 $000\ 0100\ 0000\ 0000\ 0000\ 0000$ ，合起来整个浮点数表示为 $1\ 1000\ 0010\ 000\ 0100\ 0000\ 0000\ 0000\ 0000$ ，写成十六进制为 $\mathrm{C1040000H}$ 因此，寄存器A和B的内容分别为C2880000H、C1040000H。  

2）两个浮点数相加的步骤如下。  

$\textcircled{\scriptsize{1}}$ 对阶： $E_{x}\!=\!10000101$ ， $E_{y}\!=\!10000010$ ，则 $[E_{x}-E_{y}]_{*}=[E_{x}]_{*}+[-E_{y}]_{*}\,\,=10000101+01111110=00000011$   $E_{x}$ 大于 $E_{y}$ ，所以对 $y$ 进行对阶。对阶后， $y\,{=}\,{-}0.00100001{\times}2^{6}$  

$\circledcirc$ 尾数相加： $x$ 的尾数为 $-1.000\ 1000\ 0000\ 0000\ 0000\ 0000,y$ 的尾数为-0.00100001000000000000000，用原码加法运算实现，两数的符号相同，做加法，结果为-1.001100010000000 00000000。即 $x$ 加 $y$ 的结果为 $-1.001\ 1000\ 1{\times}2^{6}$ ，所以符号位为1，尾数为00110001000000000000000，阶码为 $127+6=128+5$ ，即10000101。合起来为11000010100110001000000000000000，转换为十六进制形式为 $\mathrm{C}2988000\mathrm{H}$ 。所以C寄存器中的内容是 $C2988000\mathrm{H}$  

3）两个浮点数相减的步骤同加法，对阶的结果也一样，只是尾数相减。  

尾数相减： $x$ 的尾数为-1.00010000000000000000000， $y$ 的尾数为-0.00100001000000000000000。  

用原码减法运算实现，两数的符号相同，做减法；符号位：取大数的符号，负数，为1；数值部分：大数加小数负数的补码：  

$$
{\begin{array}{l l l l l l l l}{1.}&{000}&{1000}&{0000}&{0000}&{0000}&{0000}\\ {+}&{1.}&{110}&{1111}&{1000}&{0000}&{0000}&{0000}\\ {\;\;\;0.}&{111}&{0111}&{1000}&{0000}&{0000}&{0000}\end{array}}
$$  

$x$ 减 $y$ 的结果为- $-0.11101111\times2^{6}\,{=}\,{-1.1101111\times2^{5}}$ ，所以符号位为1，尾数为 $110\;1111\;0000\;0000$ 00000000，阶码为 $127+5\!=\!128+4$ ，即 $1000\,0100$  

合起来为 $1\ 1000\ 0100\ 110\ 1111\ 0000\ 0000\ 0000\ 0000\,0000\,.$ ，转换为十六进制形式为 $_{\mathrm{C26F0000H.}}$ 所以寄存器D中的内容是 $\mathrm{C26F0000H}$  

# 提示  

若为选择题，则第二问可先将十进制的 $x+y,x-y$ 计算后的结果再转成IEEE754。  
04.【解答】  

1）因为该数的阶码字段内容为0，符号位为0，尾数字段内容也为0，所以它表示1IEEE浮点格式的 $+0$  

2）该数的阶码字段内容为132，尾数字段内容为 $100\,0000\,0000\,0000\,0000\,0000$ ，因为阶码字段的内容既不全部为0，也不全部为1，所以它表示一个规格化数，其实际值为 $(1.1)_{2}{\times}2^{5}\!=\!48$  

3）因为该数的阶码字段内容全部为0，且尾数字段内容不全部为0，所以它表示一个非规格化数，其实际值为 $(-0.1)_{2}{\times}2^{-126}\!=\!-2^{-127}\!=\!-5.877{\times}10^{-39}$ （表示成4位有效数字形式）。  

4）因为该数的阶码字段内容全部为1，且尾数字段内容为0，符号位为1，所以它表示负无究大。  

05.【解答】  

1）由于i和n是unsigned型，因此‘ $\mathrm{\mathrm{"i<=n-l}"}$ 是无符号数比较， $\mathrm{n\,{=}\,0}$ 时， $\mathrm{n-1}$ 的机器数为全1，值是 $2^{32}\mathbf{-1}$ ，为unsigned型可表示的最大数，条件 ${\mathrm{\Delta}}^{\mathrm{..}}\mathrm{_1\,<=\,n-1}$ ”永真，因此出现死循环。若i和 $\boldsymbol{\mathrm{n}}$ 改为int型，则不会出现死循环。  

因为“ $\mathrm{i}<=\mathrm{n}{-}\mathrm{l}$ ”是有符号整数比较，当 $\boldsymbol{\mathrm{n}}=\boldsymbol{\mathrm{0}}$ 时， $\mathrm{n}-1$ 的值是-1，当 $\mathrm{i}=0$ 时，条件“i $<=\mathsf{n}\mathrm{-}\mathsf{l}$ ”不成立，此时退出for循环。  

2）f1(23)与f2(23)的返回值相等。 $\operatorname{f}(23)=2^{23+1}-1=2^{24}-1$ ，其二进制形式是24个1。int型数占32位，没有溢出。float型数有1个符号位，8个指数位，23个底数位，23个底数位可以表示24位的底数，所以两者返回值相等。fI(23)的机器数是00FFFFFFH，f2(23)的机器数是4B7FFFFFH。显而易见，前者是24个1，即0000000011111111111111111111 $1111_{(2)}$ ，后者的符号位是0，指数位为 $23+127_{(10)}\!=\!1001\,0110_{(2)}$ ，底数位是111 1111 111111111111 $1111_{(2)}$  

3）当 $\mathfrak{n}=24$ 时， $\mathrm{f}(24)=1$ 111111111111111111111111B，而float型数只有24位有效位，舍入后数值增大，所以f2(24)比fl(24)大1。  

4）显然31)已超出了int型数的表示范围，用31)实现时得到的机器数为32个1，作为int型解释时其值为-1，即f131)的返回值为-1。因为int型最大可表示的数是0后面加31个1，因此使fl(n)的返回值与fn)相等的最大n值是30。  

5）IEEE754标准使用“阶码全1、尾数全0”表示无穷大。f2的返回值为float型，机器数 $7\mathrm{F}80~0000\mathrm{H}$ 对应的值是 $+\infty$ 。当 $\mathsf{n}=126$ 时， $\mathrm{f}(126)=2^{127}-1=1.1...1\times2^{126}$ ，对应的阶码为 $127+126=253$ ，尾数部分舍入后阶码加1，最终阶码为254，是IEEE754单精度格式表示的最大阶码。因此使f2结果不溢出的最大n值为126。  

当 $\mathfrak{n}=23$ 时，f23)为24位1，float型数有24位有效位，所以不需要舍入，结果精确。因此使f2获得精确结果的最大 $\mathsf{n}$ 值为23。  

# 2.4 本章小结  

本章开头提出的问题的参考答案如下：  

1）在计算机中，为什么要采用二进制来表示数据？答案已在本章开头说明。  
2）计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明  

计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用 $1/(2^{n})$ 的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限接近。例如0.1就无法用二进制精确地表示。  

3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？  

字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。  

4）用移码表示浮点数的阶码有什么好处？  

移码的两个好处：  

$\textcircled{\scriptsize{1}}$ 浮点数进行加减运算时，要比较阶码的大小，移码比较大小更方便。  

$\circledcirc$ 检验移码的特殊值（0和max）时比较容易。阶码以移码编码时的特殊值如下。0：表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近0，在尾数也为0时可用来表示0：尾数不为零表示未规格化的数。max：表示指数正无穷大，若尾数为0，则表示浮点数超出表示范围（正负无穷大）：尾数不为0，则表示浮点数运算错误。  

# 2.5常见问题和易混淆知识点  

1.如何表示一个数值数据？计算机中的数值数据都是二进制数吗？在计算机内部，数值数据的表示方法有以下两大类。  

$\textcircled{\scriptsize{1}}$ 直接用二进制数表示。分为有符号数和无符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）。  

$\circledcirc$ 二进制编码的十进制数，一般采用BCD码表示，用来表示整数。  

所以，计算机中的数值数据虽然都用二进制表示，但不全是二进制，也有用十进制表示的。例如在指令类型中，就分别有二进制加法指令和十进制加法指令。  

# 2.什么称为无符号整数的“溢出”？  

对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低 $n$ 位，舍弃高位。这样，会产生以下两种结果。  

$\textcircled{\scriptsize{1}}$ 保留的低 $n$ 位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第 $n+1$ 位，称此时发生了“溢出”现象。  

$\circledcirc$ 保留的低 $n$ 位数能正确表达计算结果，即高位的舍去并不影响其运算结果，  

3.如何判断一个浮点数是否是规格化数？  

为了使浮点数能尽量多地表示有效位数，一般要求运算结果用规格化数形式表示。规格化浮点数的尾数小数点后的第一位一定是个非零数。因此，对于原码编码的尾数来说，只要看尾数的第一位是否为1就行；对于补码表示的尾数，只要看符号位和尾数最高位是否相反。需要注意的是，IEEE754标准的浮点数尾数是用原码编码的。  

4.对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？  

不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。 $n$ 位编码只能表示 $2^{n}$ 个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多（有时可能因为一个值有两个或多个编码对应，编码个数会有少量差异）。  
5.现代计算机中是否要考虑原码加减运算？如何实现？现代计算机中的浮点数采用IEEE754标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为IEEE754标准的浮点数尾数都采用原码表示。  

原码的加减运算可以有以下两种实现方式  

1）转换为补码后，用补码加减法实现，结果再转换为原码。2）直接用原码进行加减运算，符号位和数值位分开处理（见原码加减运算部分）。  
# 第3章存储系统  

# 【考纲内容】  

（一）存储器的分类  

（二）层次化存储器的基本结构  

（三）半导体随机存储器（RAM）SRAM、DRAM、Flash存储器  

（四）主存储器DRAM芯片和内存条、多模块存储器、主存储器和CPU之间的连接  

（五）外部存储器磁盘存储器、固态硬盘（SSD）  

（六）高速缓冲存储器（Cache）Cache的基本原理：Cache和主存之间的映射方式Cache中主存块的替换算法：Cache写策略  

（七）虚拟存储器  

虚拟存储器的基本概念页式虚拟存储器：基本原理、页表、地址转换、TLB（快表）段式虚拟存储器的基本原理：段页式虚拟存储器的基本原理  

# 【复习提示】  

本章是历年命题重点，特别是有关Cache和虚拟存储器的考点容易出综合题。此外，存储器的特点，存储器的扩展（芯片选择、连接方式、地址范围等），交叉存储器，Cache的相关计算与替换算法，虚拟存储器与TLB也容易出选择题。读者应在掌握基本原理的基础上，多结合习题进行反复训练，以加深巩固。另外，读者需掌握存在Cache和TLB的计算机中的地址翻译与Cache映射问题，也建议结合《操作系统考研复习指导》复习。  

在学习本章时，请读者思考以下问题  

1）存储器系统为何要分这些层次？计算机如何管理这些层次？  

2）影响Cache性能的因素有哪些？  

3）虚拟存储系统的页面是设置得大一些好还是设置得小一些好？请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。  

# 3.1存储器概述  

# 3.1.1存储器的分类  

存储器种类繁多，可从不同角度对存储器进行分类。  
# 1.按在计算机中的作用（层次）分类  

1）主存储器。简称主存，也称内存储器（内存），用来存放计算机运行期间所需的程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位的价格较高。2）辅助存储器。简称辅存，也称外存储器或外存，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息。辅存的内容需要调入主存后才能被CPU访问。其特点是容量大、存取速度较慢、单位成本低。3）高速缓冲存储器。简称Cache，位于主存和CPU之间，用来存放当前CPU经常使用的指令和数据，以便CPU能高速地访问它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。现代计算机通常将它们制作在CPU中。  

# 2.按存储介质分类  

按存储介质，存储器可分为磁表面存储器（磁盘、磁带）、磁芯存储器、半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘）。  

# 3.按存取方式分类  

# 命题追踪采用随机存取的存储器（2011）  

1）随机存储器（RAM)。存储器的任何一个存储单元都可以随机存取，而且存取时间与存储单元的物理位置无关。其优点是读/写方便、使用灵活，主要用作主存或高速缓冲存储器。RAM又分为静态RAM和动态RAM（第2节会详细介绍）。2）只读存储器（ROM）。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。由ROM派生出的存储器也包含可反复重写的类型，ROM和RAM的存取方式均为随机存取。广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。3）串行访问存储器。对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）和直接存取存储器（如磁盘、光盘）。  

顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。直接存取存储器既不像RAM那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻我整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找。  

# 4.按信息的可保存性分类  

断电后，存储信息即消失的存储器，称为易失性存储器，如RAM。断电后信息仍然保持的存储器，称为非易失性存储器，如ROM、磁表面存储器和光存储器。  

若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出：若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。  

# 3.1.2 存储器的性能指标  

存储器有三个主要性能指标，即存储容量、单位成本和存储速度。这三个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。  
1）存储容量 $=$ 存储字数 $\times$ 字长（如 $1\mathrm{M}{\times}8$ 位）。单位换算：1B（Byte，字节） $=8\mathrm{b}$ (bit，位)。存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。  

2）单位成本：每位价格 $=$ 总成本/总容量。  

3）存储速度：数据传输速率（每秒传送信息的位数） $=$ 数据的宽度/存取周期  

$\textcircled{\scriptsize{1}}$ 存取时间（ $T_{\mathrm{a}})$ ：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。 $\circledcirc$ 存取周期（ $T_{\mathrm{m}}$ )：存取周期是指存储器进行一次完整的读/写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。 $\textcircled{3}$ 主存带宽（ $B_{\mathrm{m}}$ )：也称数据传输速率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（ $\mathbf{B}/\mathrm{s}.$ ）或位/秒（b/s)。  

存取时间不等于存取周期，通常存取周期大于存取时间。这是因为对任何一种存储器，在读/写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达 $T_{\mathrm{m}}\,{=}\,2T_{\mathrm{a}}$ ，因为存储器中的信息读出后需要马上进行再生。  

存取时间与存取周期的关系如图3.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21f64fafd194c1ba1c6165c7728968a6e8ae536402c6539569c4d4e7c1719c0f.jpg)  
图3.1存取时间与存取周期的关系  

# 3.1.3多级层次的存储系统  

为了解决存储系统大容量、高速度和低成本这三个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构，如图3.2所示。在图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU访问的频度也越来越低。实际上，存储系统层次结构主要体现在Cache-主存层和主存-辅存层。在存储体系中，Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息：主存与CPU、Cache、辅存都能交换信息，如图3.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ecbfb7431920fae95ef8cac047bea026b1dcf473fe23120161d91a5948c10f1a.jpg)  
图3.2多级存储器结构  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3695ac60caa0ef8aa0adc0813638b48ef2f1586374984cdd5278a8b6809a560d.jpg)  
图3.3三级存储系统的层次结构及其构成  

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。当CPU要从存储器中存取数据时，先访问Cache，若不在Cache中，则访问主存，若不在主存中，则访问磁盘，此时，操作数从磁盘读出送到主存，然后从主存送到Cache。从CPU的角度看，Cache-主存层的速度接近于Cache，容量和位价却接近于主存。从主存-辅存层分析，其速度接近于主存，容量和位价却接近于辅存。这就解决了速度、容量、成本这三者之间的矛盾。  
Cache-主存层主要解决CPU和主存速度不匹配的问题，主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的。主存一辅存层主要解决存储系统的容量问题，主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员是透明的。  

在主存一辅存层的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应，编程时可用的地址空间远大于主存空间。  

# 注意  

在Cache一主存层和主存一辅存层中，上一层中的内容都只是下一层中的内容的副本，也即Cache（或主存）中的内容只是主存（或辅存）中的内容的一部分。  

# 3.1.4 本节习题精选  

单项选择题  

01.磁盘属于（）类型的存储器。  

A.随机存储器（RAM）B.只读存储器（ROM）C.顺序存取存储器（SAM）D.直接存取存储器（DAM）  

02.存储器的存取周期是指（）  

A.存储器的读出时间B.存储器的写入时间C.存储器进行连续读或写操作所允许的最短时间间隔D.存储器进行一次读或写操作所需的平均时间  

03.设机器字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其可寻址的单元数是()。  

A.  $2^{24}$  B.223 C.  $2^{22}$  D.221  

04.相联存储器是按（）进行寻址的存储器。  

A.地址指定方式B.堆栈存储方式C.内容指定方式和堆栈存储方式相结合D.内容指定方式和地址指定方式相结合  

05.在下列几种存储器中，CPU不能直接访问的是（）A.硬盘B.内存C.CacheD.寄存器06.若某存储器存储周期为 $250\mathrm{ns}$ ，每次读出16位，该存储器的数据传输速率是（）A.  $4{\times}10^{6}\mathrm{B}/\mathrm{s}$  B.16MB/s C.  $8{\times}10^{6}\mathrm{B}/\mathrm{s}$  D.  $8{\times}2^{20}\mathrm{B}/\mathrm{s}$  07.设机器字长为64位，存储容量为128MB，若按字编址，它可寻址的单元个数是（）。A.16MB B.16M C.32M D.32MB 08.计算机的存储器采用分级方式是为了（）  

A.方便编程B.解决容量、速度、价格三者之间的矛盾C.保存大量数据方便 D.操作方便  

09.计算机的存储系统是指（）  

A.RAM B.ROM C.主存储器D.寄存器、Cache、主存储器和外存储器  
10.在多级存储体系中，“Cache-主存”结构的作用是解决（）的问题。  

A.主存容量不足B.主存与辅存速度不匹配C.辅存与CPU速度不匹配D.主存与CPU速度不匹配  

11.存储器分层体系结构中，存储器从速度最快到最慢的排列顺序是（）  

A.寄存器-主存-Cache-辅存 B.寄存器-主存-辅存-Cache C.寄存器-Cache-辅存-主存 D.寄存器-Cache-主存-辅存  

12.在Cache和主存构成的两级存储体系中，主存与Cache同时访问，Cache的存取时间是100ns，主存的存取时间是 $1000\mathrm{ns}$ ，设Cache和主存同时访问，若希望有效（平均）存取时间不超过Cache存取时间的 $115\%$ ，则Cache的命中率至少应为（）。  

A.  $90\%$  B.  $98\%$  C.  $95\%$  D.  $99\%$  

13.下列关于多级存储系统的说法中，正确的有（）  

I.多级存储系统是为了降低存储成本IIL.虚拟存储器中主存和辅存之间的数据调动对任何程序员是透明的III.CPU只能与Cache直接交换信息，CPU与主存交换信息也需要经过Cache  

A.仅IB.仅I和IIC.I、II和ⅢID.仅ⅡI14.【2011统考真题】下列各类存储器中，不采用随机存取方式的是（）A.EPROM B.CD-ROM C.DRAM D.SRAM  

# 3.1.5 答案与解析  

单项选择题  

01.D 磁盘属于直接存取存储器，其速度介于随机存储器和顺序存取存储器之间。  

02.C  

存取时间 $T_{\mathrm{a}}$ 是指从存储器读出或写入一次信息所需要的平均时间：存取周期 $T_{\mathrm{m}}$ 是指连续两次访问存储器之间所必需的最短时间间隔。对 $T_{\mathrm{m}}$ 一般有 $T_{\mathrm{m}}=T_{\mathrm{a}}+T_{\mathrm{r}},$ 其中 $T_{\mathrm{r}}$ 为复原时间；对SRAM指存取信息的稳定时间，对DRAM指刷新的文一次存取时间。D指的是存取时间。  

03.B  

16MB $=\!2^{24}\mathrm{B}$ ，字长为32位，现按半字（2B）寻址，可寻址单元数为 $2^{24}\mathrm{B}/2\mathrm{B}\!=\!2^{23}$  

04.D  

相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是按内容或地址进行寻址的，价格较为昂贵。一般用来制作TLB、相联Cache等。  

05.A CPU不能直接访问硬盘，需先将硬盘中的数据调入内存才能被CPU访问。  

06.C 每个存储周期读出16bit $=$ 2B，因此数据传输速率为 $2\mathrm{B}{\cdot}(250{\times}10^{-9})\mathrm{s}$ ，即 $8{\times}10^{6}\mathrm{B/s}$  

07.B 机器字长位64位，即8B，按字编址，因此可寻址的单元个数是 $128\mathrm{{MB}/8{B}=16\mathrm{{M}}}$  

08.B  

存储器有三个主要特性：速度、容量和价格/位（简称位价）。存储器采用分级方式是为了解决这三者之间的矛盾。  
09.D  

计算机的存储系统包括CPU内部寄存器、Cache、主存和外存。  

10.D  

Cache中的内容只是主存内容的部分副本（拷贝），因而“Cache-主存”结构并未增加主存容量，目的是解决主存与CPU速度不匹配的问题。  

11.D  

在存储器分层结构中，寄存器在CPU中，因此速度最快，Cache次之，主存再次之，最慢的是辅存（如磁盘、光盘等）。  

12.D  

假设命中率为 $x$ ，可得 $100x+1000(1-x){\leqslant}100{\times}(1+15\%)$ ，简单计算后得结果为 $x\!\geqslant\!98.33\%$ 因此命中率至少为 $99\%$  

# 注意  

本题采用同时访问Cache和主存的方式，此时不命中的访问时间为 $1000\mathrm{ns}$ ，但若题中没有说明（通常有说明），则默认Cache不命中的时间为访问Cache和主存的时间之和。  

13.A  

主存和辅存之间的数据调动是由硬件和操作系统共同完成的，仅对应用级程序员透明。CPU与主存可直接交换信息。  

14.B  

随机存取是指CPU可对存储器的任意一个存储单元中的内容随机存取，而且存取时间与存储单元的物理位置无关。A、C和D均采用随机存取方式，CD-ROM即光盘，采用串行存取方式

（直接存取）。注意，CD-ROM是只读型光盘存储器，不属于只读存储器ROM。  

# 3.2主存储器  

# 3.2.1SRAM DRAM  

半导体存储器分为随机存储器（RAM）和只读存储器（ROM）。RAM又分为静态随机存储器

（SRAM）和动态随机存储器（DRAM），主存储器主要由DRAM实现，靠近处理器的那一层（Cache）则由SRAM实现，它们都是易失性存储器。ROM是非易失性存储器。  

1.SRAM的工作原理  

通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。  

静态随机存储器（SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，静态是指即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出）。  

SRAM的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于高速缓冲存储器  

2.DRAM的工作原理  

与SRAM的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM的密度要高很多。相对于SRAM来说，DRAM具有集成度高、位价低和功耗低等优点，但DRAM的存取速度比SRAM慢，且必须定时刷新和读后再生，一般用于大容量的主存系统。  
# 命题追踪需要刷新的存储芯片：SDRAM（2015）  

DRAM电容上的电荷一般只能维持 $1\!\sim\!2\mathrm{ms}$ ，因此即使电源不断电，信息也会自动消失。此外，读操作会使其状态发生改变（破坏性读出），需读后再生，这也是称其为动态存储器的原因。刷新可以采用读出的方法进行，根据读出内容对相应单元进行重写，即读后再生。对同一行进行相邻两次刷新的时间间隔称为刷新周期，通常取 $2\mathrm{ms}$ 。常用的刷新方式有以下3种：  

1）集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读/写操作，称为死时间，也称访存死区。优点是读/写操  

作时不受刷新工作的影响：缺点是在集中刷新期间（死区）不能访问存储器。后半部分用于刷新。这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为 $0.5\upmu\mathrm{s}$  $1\upmu\mathrm{s}$ 。优点是没有死区；缺点是加长了系统的存取周期。3）异步刷新：结合了前两种方法，使得在一个刷新周期内每一行仅刷新一次。具体做法是将刷新周期除以行数，得到相邻两行之间刷新的时间间隔1，每隔时间1产生一次刷新请求。这样就使“死时间”的分布更加分散，避免让CPU连续等待过长的时间。  

DRAM的刷新需要注意以下问题： $\textcircled{\scriptsize{1}}$ 刷新对CPU是透明的，即刷新不依赖于外部的访问； $\circledcirc$ DRAM的刷新单位是行，由芯片内部自行生成行地址； $\textcircled{3}$ 刷新操作类似于读操作，但又有所不同。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。  

# 注意  

虽然DRAM的刷新和再生都是恢复数据，但刷新与再生的过程并不完全相同。刷新是以行为单位，逐行恢复数据的，而再生仅需恢复被读出的那些单元的数据。  

# 命题追踪DRAM芯片行缓冲器容量的计算（2022）  

目前更常用的是SDRAM（同步DRAM)芯片，其工作方式与传统DRAM的不同，传统DRAM与CPU采用异步方式交换数据，CPU发出地址和控制信号后，经过一段延迟时间，数据才读出或写入，在读/写完成之前，CPU不能做其他工作。而SDRAM与CPU采用同步方式交换数据，它将CPU发出的地址和控制信号锁存起来，CPU在其读/写完成之前可进行其他操作。SDRAM的每一步操作都在系统时钟的控制下进行，支持突发传输方式?。第一次存取时给出首地址，同一行的所有数据都被送到行缓冲器，因此，以后每个时钟都可以连续地从SDRAM输出一个数据。行缓冲器用来缓存指定行中整行的数据，其大小为“列数 $\cdot\times$ 位平面数”，通常用SRAM实现。  

# 3.DRAM芯片的读/写周期  

DRAM芯片读/写周期的时序图如图3.4所示。为了使芯片能正确接收行、列地址并实现读写操作，各信号的时间关系应符合一定要求。读（写）周期时间 $t_{\mathrm{{RC}}}$  $t_{\mathrm{{wc}}}$ ）表示DRAM芯片进行两次连续读（写）操作时所必须间隔的时间。  

在读周期中，在RAS有效前将行地址送到芯片的地址引I脚，CAS滞后RAS一段时间，在CAS有效前再将列地址送到芯片的地址引脚，RAS、CAS应分别至少保持 $t_{\mathrm{RAS}}$ 和 $t_{\mathrm{CAS}}$ 的时间。在读周期中WE为高电平，并在CAS有效前建立。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ac49c5139324c976bef95c5760eecc986130d9c6997bdc4b888ceda236371d26.jpg)  
图3.4DRAM芯片读/写周期时序图  

在写周期中，行列选通信号的时序关系和读周期相同。在写周期中WE为低电平，同样在CAS有效前建立。为了保证数据可靠地写入，写数据必须在CAS有效前在数据总线上保持稳定。  

# 4.SRAM DRAM  

表3.1详细列出了SRAM和DRAM各自的特点。  

表3.1SRAM DRAM
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/247e4075afae5a6921141e41eb4721eb9e64db737333bbae6ebd4d1ecd2c7aab.jpg)  

# 5.存储器芯片的内部结构  

如图3.5所示，存储器芯片由存储体、1/0读/写电路、地址译码器和控制电路等部分组成。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2516f94b368ccd12877ec553c7401ec98c5b18224a062f7a42b548d1c7b596b4.jpg)  
图3.5存储器芯片结构图  
1）存储体（存储矩阵）。存储体是存储单元的集合，它由行选择线（X）和列选择线（Y）来选择所访问单元，存储体的相同行、列上的多位（位平面数）同时被读出或写入。  

2）地址译码器。用来将地址转换为译码输出线上的高电乎，以便驱动相应的读/写电路。地址译码有单译码法（一维译码）和双译码法（二维译码）两种方式。  

·单译码法。只有一个行译码器，同一行中所有存储单元的字线连在一起，同一行中的各单元构成一个字，被同时读出或写入。缺点是地址译码器的输出线数过多。·双译码法。如图3.5所示，地址译码器分为 $X$ 和Y方向两个译码器，在选中的行和列交叉点上能确定一个存储单元，这是DRAM芯片目前普遍采用的译码结构。  

3）I/O控制电路。用以控制被选中的单元的读出或写入，具有放大信息的作用。  

4）片选控制信号。单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号。  

5）读/写控制信号。根据CPU给出的读命令或写命令，控制被选中单元进行读或写，  

# 3.2.2只读存储器  

# 1.只读存储器（ROM）的特点  

# 命题追踪RAM和ROM的区别（2010）  

ROM和RAM都是支持随机访问的存储器，其中SRAM和DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失。ROM具有两个显著的优点：

 $\textcircled{\scriptsize{1}}$ 结构简单，所以位密度比可读/写存储器的高。 $\circledcirc$ 具有非易失性，所以可靠性高。  

# 2.ROM的类型  

根据制造工艺的不同，ROM可分为掩模式只读存储器（MROM）、一次可编程只读存储器

（PROM）、可擦除可编程只读存储器（EPROM）、Flash存储器和固态硬盘（SSD）。  

（1）掩模式只读存储器  

MROM的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人都无法改变其内容。优点是可靠性高，集成度高，价格便宜；缺点是灵活性差。  

（2）一次可编程只读存储器  

PROM是可以实现一次性编程的只读存储器。允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。  

（3）可擦除可编程只读存储器  

EPROM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。EPROM虽然既可读又可写，但它不能取代RAM，因为EPROM的编程次数有限，且写入时间过长。  

（4）Flash存储器  

# 命题追踪Flash存储器的特点（2012）  

Flash存储器是在EPROM的基础上发展起来的，它兼有ROM和RAM的优点，可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写。Flash存储器既有EPROM价格便宜、集成度高的优点，又有EPROM电可擦除重写的特点，且擦除重写的速度快。  

（5）固态硬盘（Solid State Drive，SSD）基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（Flash芯片）组成。保留了Flash存储器长期保存信息、快速擦除与重写的特性。对比传统硬盘也具有读/写速度快、低功耗的特性，缺点是价格较高。  
# 3.2.3主存储器的基本组成  

图3.6是主存储器（MainMemory，MM）的基本框图，其中由一个个存储0或1的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部件。存储元件是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，必须对存储单元编号（也称编址）。编址单位是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/32d7adac4f2bd43918e63a15cb75067abfdb78b3072fd13466d39b41b1a285a2.jpg)  
图3.6主存储器的基本组成框图  

指令执行过程中需要访问主存时，CPU首先把被访问单元的地址送到MAR中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码，选中相应单元，同时CPU将读/写信号通过控制线送到主存的读/写控制电路。若是写操作，则CPU同时将要写的信息送到MIDR中，在读/写控制电路的控制下，经数据线将信号写入选中的单元；若是读操作，则主存读出选中单元的内容送至数据线，然后被送到MDR中。MDR的位数与数据线的位数相同，MAR的位数与地址线的位数相同。图3.6采用64位数据线，所以在按字节编址方式下，每次最多可以存取8个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例如，36位地址的最大寻址范围为 $0{\sim}2^{36}\!-\!1$ ，即地址从0开始编号。  

# 注意  

数据线的位数通常等于存储字长，因此MIDR的位数通常等于存储字长；若数据线的位数不等于存储字长，则MIDR的位数由数据线的位数决定。  

# 命题追踪DRAM芯片的地址引脚复用技术（2014）  

DRAM芯片容量较大，地址位数较多，为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半。  

# 命题追踪DRAM芯片行、列数的优化原则（2018）  

假定有一个 $2^{n}{\times}b$ 位DRAM芯片的存储阵列，其行数为r，列数为 $c$ ，则 $2^{n}\!=r\!\times\!c_{\circ}$ 存储阵列的地址位数为 $n$ ，其中行地址位数为 $\log_{2}r$ ，列地址位数为 $\log_{2}\!c$ ，则 $n\!=\!\log_{2}\!r\!+\!\log_{2}\!c$ 。由于DRAM芯片采用地址引脚复用技术，为减少地址引脚数，应尽量使行、列位数相同，即满足 $|r–c|$ 最小。又由于DRAM按行刷新，为减少刷新开销，应使行数较少，因此还需满足 $r\!\leqslant c$  
# 3.2.4多模块存储器  

多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器。  

# 注意  

CPU的速度比存储器快得多，若同时从存储器中取出 $n$ 条指令，就可以充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。  

# 1.单体多字存储器  

在单体多字系统中，每个存储单元存储 $m$ 个字，总线宽度也为 $m$ 个字，一次并行读出 $m$ 个字。在一个存取周期内，从同一地址取出 $m$ 条指令，然后将指令逐条送至CPU执行，即每隔 $1/m$ 存取周期，CPU向主存取一条指令。这显然提高了单体存储器的工作速度。  

缺点：只有指令和数据在主存中连续存放时，这种方法才能有效提升存取速度。一旦遇到转移指令，或操作数不能连续存放时，这种方法的提升效果就不明显。  

# 2.多体并行存储器  

多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读/写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。  

多体并行存储器分为高位交叉编址和低位交叉编址两种。  

（1）高位交叉编址（顺序方式）  

高位地址表示模块号（或体号），低位地址为模块内地址（或体内地址）。如图3.7所示，存储器共有4个模块 $\mathbf{M}_{0}{\sim}\mathbf{M}_{3}$ ，每个模块有 $n$ 个单元，各模块的地址范围如图中所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75d2ac2a627c5bcdace95fe592ef3010583976cec7fbd37807fc2eed52d25b78.jpg)  
图3.7高位交叉编址的多体存储器  

在高位交叉方式下，总把低位的体内地址送到由高位体号确定的模块内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，各模块不能被并行访问，因而不能提高存储器的吞吐率。  

# 注意  

模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。  
（2）低位交叉编址（交叉方式）  

命题追踪交叉存储器中数据的存放方式（2017）  

低位地址为模块号，高位地址为模块内地址。如图3.8所示，每个模块按“模 $m$ ”交叉编址，模块号 $=$ 单元地址 $\%\,m$ ，假定有 $m$ 个模块，每个模块有 $k$ 个单元，则单元 $0,m,\cdots,(k-1)m$ 位于 $\mathbf{M}_{0}$ ：单元 $1,m+1,\cdots,(k-1)m+1$ 位于 $\mathbf{M}_{1}$ ；以此类推。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b4f48c1df4011710c3242e64f98016fdf9a431c95108f08cf1745946d0aec796.jpg)  
图3.8低位交叉编址的多体存储器  

低位交义方式下，总是把高位的体内地址送到由低位体号所确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。  

交叉存储器可以采用轮流启动或同时启动两种方式。  

轮流启动方式  

若每个模块一次读/写的位数正好等于数据总线位数，模块的存取周期为T，总线周期为 $r,$ 为实现轮流启动方式，存储器交叉模块数应大于或等于  

$$
m=T/r
$$  

# 命题追踪交叉存储器存取时间和带宽的计算（2012、2013）  

按每隔 $1/m$ 个存取周期轮流启动各模块，则每隔 $1/m$ 个存取周期就可读出或写入一个数据，存取速度提高 $m$ 倍，图3.9展示了4体交叉轮流启动的时间关系。交叉存储器要求其模块数大于或等于 $m$ ，以保证启动某模块后经过 $_{m\times r}$ 的时间后再次启动该模块时，其上次的存取操作已经完成（以保证流水线不间断）。这样，连续存取 $m$ 个字所需的时间为  

$$
t_{1}=T+(m-1)r
$$  

而顺序方式连续读取 $m$ 个字所需的时间为 $t_{2}\!=\!m T$ 。可见交叉存储器的带宽大大提高。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/357a8d6b3c8858f8e0445d4f33ec790e4dc9c97914e01f04c3acc061319ce47a.jpg)  
图3.9低位交叉轮流启动的存取时间示意图  

# 命题追踪交叉存储器中访存冲突的分析（2015）  

在理想情况下， $m$ 体交叉存储器每隔1/m存取周期可读/写一个数据，若相邻的 $m$ 次访问的访存地址出现在同一个模块内，则会发生访存冲突，此时需延迟发生冲突的访问请求。  
同时启动方式  

若所有模块一次并行读/写的总位数正好等于数据总线位数，则可以同时启动所有模块进行读/写。设每个模块一次读/写的位数为16位，模块数 $m=4$ ，数据总线位数为64位，4个模块一共提供64位，正好构成一个存储字，因此应该同时启动4个模块进行并行读/写。  

# 3.2.5本节习题精选  

# 一、单项选择题  

01.某一SRAM芯片，容量为 $1024\!\times\!8$ 位，该芯片的地址引脚和数据引脚总数至少是（）。  

A.8 B.10 C.18 D.13  

02.某存储器容量为 $32K{\times}16$ 位，则（）  

A.地址线为16根，数据线为32根B.地址线为32根，数据线为16根C.地址线为15根，数据线为16根D.地址线为15根，数据线为32根  

03.DRAM的刷新是以（）为单位的。  

A.存储单元B.行C.列D.存储字  

04.DRAM采用下列哪种刷新方式时，不存在死时间（）  

A.集中刷新 B.分散刷新 C.异步刷新 D.都不对  

05.下面是有关DRAM和SRAM存储器芯片的叙述：  

I.DRAM芯片的集成度比SRAM芯片的高IL.DRAM芯片的成本比SRAM芯片的高III.DRAM SRAMIV.DRAM芯片工作时需要刷新，SRAM芯片工作时不需要刷新通常情况下，错误的是（）。  

A.I和II B.ⅡI和IⅢI C.IⅢI和IV D.I和IV 06.下列关于随机存储器的说法中，正确的是（）  

A.半导体RAM信息可读可写，且断电后仍能保持记忆 B.DRAM是易失性RAM，而SRAM中的存储信息是不易失的C.半导体RAM是易失性RAM，但只要电源不断电，所存信息是不丢失的D.半导体RAM是非易失性RAM  

07.下列关于存储器的说法中，不正确的是（）  

A.随机存储器和只读存储器不可以统一编址B.在访问随机存储器时，访问时间与存储单元的物理位置无关C.随机存储器RAM芯片可随机存取信息，掉电后信息会丢失D.只读存储器ROM芯片可随机存取信息，掉电后信息不会丢失  

08.关于半导体存储器的组织，下列选项中（）是不正确的。  

A.在同一个存储器中，每个存储单元的宽度可以不同B.所谓“编址”，是指给每个存储单元一个编号C.存储器的核心部分是存储阵列，由若干存储单元构成D.每个存储单元由若干存储元件构成，每个存储元件存储一个比特位  

09.关于SRAM和DRAM，下列叙述中正确的是（）。A.通常SRAM依靠电容暂存电荷来存储信息，电容上有电荷为1，无电荷为 $0$  
B.DRAM依靠双稳态电路的两个稳定状态来分别存储0和1C.SRAM速度较慢，但集成度稍高；DRAM速度稍快，但集成度低D.SRAM速度较快，但集成度稍低；DRAM速度稍慢，但集成度高  

10.某一DRAM芯片，采用地址复用技术，容量为 $1024{\times}8$ 位，该芯片的地址引脚和数据引脚总数至少是（）。  

A.18 B.13 C.8 D.17  

11.下列几种存储器中，（）是易失性存储器。  

A.Cache B.EPROM C.Flash存储器 D.CD-ROM  

12.U盘属于（）类型的存储器。  

A.高速缓存B.主存C.只读存储器D.随机存储器  

13.某计算机系统，其操作系统保存于硬盘上，其内存储器应该采用（）。  

A.RAM B.ROM C.RAM和ROMD.均不完善  

14.下列说法正确的是（）  

A.EPROIM是可改写的，因此可以作为随机存储器B.EPROM是可改写的，但不能作为随机存储器C.EPROM是不可改写的，因此不能作为随机存储器D.EPROM只能改写一次，因此不能作为随机存储器  

15.下列（）是动态半导体存储器的特点  

I.在工作中存储器内容会产生变化II.每隔一定时间，需要根据原存内容重新写入一遍III.一次完整的刷新过程需要占用两个存储周期IV.一次完整的刷新过程只需要占用一个存储周期  

A.I、IⅢIB.I、IIIC.II.IVD.只有III  

16.采用 $64\mathrm{K}\!\times\!1$ 位的DRAM芯片构成 $256K\times8$ 位的存储器，若采用异步刷新方式，每单元刷新间隔不超过 $2\mathrm{ms}$ ，则生成的刷新信号的间隔时间是（）；若采用集中刷新方式，则存储器刷新一遍最少用（）个读/写周期  

A.  $7.8\upmu\mathrm{s},256$  B.  $1.9\upmu\mathrm{s},256$  C.  $7.8\upmu\mathrm{s},$  128 D.1.9us,256  

17.DRAM具有破坏性读出的特性，需要定时刷新，下列说法中不正确的是（）  

A.刷新是以行为单位的B.刷新是为了给DRAM存储单元中的存储电容重新充电C.刷新是通过对存储单元进行“读但不输出数据”，即“假读”的操作来实现的D.DRAM内部设有专门的刷新电路，不会影响到CPU的正常访存  

18.下列关于DRAM和SDRAM的说法中，不正确的是（）。  

A.传统DRAM芯片与CPU采用异步方式交换数据B.SDRAM芯片与CPU采用同步方式交换数据C.DRAM需要定期刷新，而SDRAM不需要定期刷新D.SDRAM的行缓冲器通常用SRAM实现  

19.每推出新一代DRAM芯片，地址线至少增1根，则容量至少提高到原来的（）倍。A.2B.4C.8D.16  

20.若一个内存条中有16个DRAM芯片，每个芯片中有4个位平面，每个位平面的存储阵列为4096行 $\times4096$ 列，则内存条的总容量为（）MB。A.64 B.128 C.256 D.512  
21.已知单个存储体的存储周期为110ns，总线传输周期为  $10\mathrm{ns}$  ，采用低位交叉编址的多模 块存储器时，存储体数应（）。  

A.小于11B.等于11C.大于11D.大于或等于11  

22.一个四体并行低位交叉存储器，每个模块的容量是 $64\mathrm{K}\!\times\!32$ 位，存取周期为 $200\mathrm{ns}$ ，总线周期为50ns，在下述说法中，（）是正确的。  

A.在 $200\mathrm{ns}$ 内，存储器能向CPU提供256位二进制信息B.在 $200\mathrm{ns}$ 内，存储器能向CPU提供128位二进制信息C.在50ns内，每个模块能向CPU提供32位二进制信息D.以上都不对  

23.某机器采用四体低位交叉存储器，现分别执行下述操作：  $\textcircled{\scriptsize{1}}$  读取6个连续地址单元中存 放的存储字，重复80次；  $\circledcirc$  读取8个连续地址单元中存放的存储字，重复60次。则  $\textcircled{\scriptsize{1}}$   $\circledcirc$ 所花费的时间之比为（）。  

A. 1:1 B.2:1 C.4:3 D.3:4  

24.假定用若干 $16K\!\times\!8$ 位的存储芯片组成一个 $64K\times8$ 位的存储器，芯片各单元采用交叉编址方式，则地址BFFFH所在的芯片的最小地址为（）。  

A.0000H B.  $0001\mathrm{H}$  C.0002H D.0003H  

25.下列关于单体多字存储器的说法中，不正确的是（）。  

A.单体多字存储器主要解决主存容量太小的问题B.单体多字存储器中，每个存储单元存储多个字C.指令与数据的连续存放有利于单体多字存储器提高主存的读/写速度D.过多的跳转指令会严重影响单体多字存储器的工作效率  

26.多模块存储器之所以能提高存储器的访问速度，是因为（）。  

A.采用了高速元器件B.各模块有独立的读/写电路C.采用了信息预读技术D.模块内各单元地址连续  

27.【2010统考真题】下列有关RAM和ROM的叙述中，正确的是（）  

I.RAM是易失性存储器，ROM是非易失性存储器IIRAM和ROM都采用随机存取方式进行信息访问IⅢl.RAM ROM Cache IV.RAM和ROM都需要进行刷新  

A.仅I和ⅡIB.仅ⅡI和IIIC.仅I、I和IⅢID.仅II、III和IV

28.【2012统考真题】下列关于闪存的叙述中，错误的是（）。  

A.信息可读可写，并且读、写速度一样快B.存储元由MOS管组成，是一种半导体存储器C.掉电后信息不丢失，是一种非易失性存储器D.采用随机访问方式，可替代计算机外部存储器  

29.【2014统考真题】某容量为256MB的存储器由若干  $4{\bf{M}}{\times}8$  位的DRAM芯片构成，该 DRAM芯片的地址引脚和数据引脚总数是（））  

A.19 B.22 C.30 D.36  

30.【2015统考真题】下列存储器中，在工作期间需要周期性刷新的是（）。  

A.SRAM B.SDRAM C.ROM D.Flash  
31.【2015统考真题】某计算机使用四体交叉编址存储器，假定在存储器总线上出现的主存地址（十进制）序列为8005.8006,8007.8008,8001,8002,8003，8004，8000，则可能发生访存冲突的地址对是（）。  

A.8004和8008 B.8002和8007 C.8001和8008 D.8000和8004  

32.【2017统考真题】某计算机主存按字节编址，由4个 $64\mathrm{M}{\times}8$ 位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读/写32位数据。若double型变量x的主存地址为 $804\,001\mathrm{AH}$ ，则读取 $_\mathrm{x}$ 需要的存储周期数是（）。  

A.1 B. 2 C.3 D.4  

33.【2018统考真题】假定DRAM芯片中存储阵列的行数为  $r$  、列数为  $c$  ，对于一个  $2K\!\times\!1$  位的DRAM芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则 $r,~c$ 的取值分别是（)。  

A.2048,1 B.64,32 C.32,64 D.1,2048  

34.【2022统考真题】某内存条包含8个 $8192{\times}8192{\times}8$ 位的DRAM芯片，按字节编址，支持突发（burst）传送方式，对应存储器总线宽度为64位，每个DRAM芯片内有一个行缓冲区（rowbuffer）。下列关于该内存条的叙述中，不正确的是（）。  

A.内存条的容量为512MBB.采用多模块交叉编址方式C.芯片的地址引脚为26位D.芯片内行缓冲有 $8192\!\times\!8$ 位  

# 二、综合应用题  

01.在显示适配器中，用于存放显示信息的存储器称为刷新存储器，它的重要性能指标是带宽。具体工作中，显示适配器的多个功能部分要争用刷新存储器的带宽。设总带宽 $50\%$ 用于刷新屏幕，保留 $50\%$ 的带宽用于其他非刷新功能，且采用分辨率为 $1024\!\times\!768$ 像素、颜色深度为3B、刷新频率为 $72\mathrm{Hz}$ 的工作方式。  

1）试计算刷新存储器的总带宽2）为达到这样高的刷新存储器带宽，应采取何种技术措施？  

02.一个四体并行交叉存储器，每个模块的容量是 $64\mathrm{K}\!\times\!32$ 位，存取周期为 $200\mathrm{ns}$ ，问：  

1）在一个存取周期中，存储器能向CPU提供多少位二进制信息？2）若存取周期为 $400\mathrm{ns}$ ，则在 $0.1\upmu\mathrm{s}$ 内存储器可向CPU提供32位二进制信息，该说法正确否？为什么？  

03.设存储器容量为32个字，字长为64位，模块数 $m=4$ ，分别采用顺序方式和交叉方式进行组织。存取周期 $T=200\mathrm{ns}$ ，数据总线宽度为64位，总线传输周期 $r=50\mathrm{ns}_{\circ}$ 在连续读出4个字的情况下，求顺序存储器和交叉存储器各自的带宽。  

04.某计算机字长32位，存储体的存储周期为 $200\mathrm{ns}$  

1）采用四体交叉工作，用低2位的地址作为体地址，存储数据按地址顺序存放。主机最快多长时间可以读出一个数据字？存储器的带宽是多少？2）若4个体分别保存主存中前1/4、次 $1/4$ 、再下个1/4、最后1/4这四段的数据，即选用高2位的地址作为体地址，可以提高存储器顺序读出数据的速度吗？为什么？3）若把存储器改成单体4字宽度，会带来什么好处和问题？4）比较采用四体低位地址交叉的存储器和四端口读出的存储器这两种方案的优缺点。  

05.假定一个存储器系统支持四体交叉存取，某程序执行过程中访问地址序列为3，9,17,2,51，37，13，4，8，41，67，10，哪些地址访问可能会发生体冲突？  
# 3.2.6 答案与解析  

一、单项选择题  

01.C  

芯片容量为 $1024{\times}8$ 位，8位说明数据线要8根，地址线数要10根（ $1024=2^{10}$ ）。故该芯片的地址引脚和数据引脚总数至少需要18根。  

02.C 该芯片16位，所以数据线为16根，寻址空间 $32\mathrm{K}=2^{15}$ ，所以地址线为15根。  

03.B  

DRAM的刷新按行进行。  

04.B  

集中刷新必然存在死时间。采用分散刷新时，机器的存取周期中的一段用来读/写，另一段用来刷新，因此不存在死时间，但存取周期变长。异步刷新虽然缩短了死时间，但死时间依然存在。  

05.B  

DRAM芯片的集成度高于SRAM，I正确；SRAM芯片的速度高于DRAM，III错误；可以推出DRAM芯片的成本低于SRAM，II错误：SRAM芯片工作时不需要刷新，DRAM芯片工作时需要刷新，IV正确。本题要求选择描述错误的表述，故选II和IⅢI。  

06.C  

RAM属于易失性半导体，SRAM和DRAM的区别在于是否需要动态刷新。  

07.A  

主存由RAM和ROM构成，两者统一编址，A错误。B描述的是随机访问特性，正确。RAM芯片具有随机访问特性和易失性，C正确。ROM芯片具有随机访问特性和非易失性，D正确。  

08.A  

同一个存储器中，每个存储单元的宽度必须相同，即每个存储单元存储的比特位数必须相同。  

09.D  

SRAM依靠双稳态电路的两个稳定状态来分别存储0和1：SRAM速度较快，不需要动态刷新，但集成度稍低，功耗大，单位价格高。DRAM依靠电容暂存电荷来存储信息，电容上有电荷为1，无电荷为0；DRAM集成度高，功耗小，单位价格较低，需定时刷新，速度慢。  

10.B  

$1024{\times}8$ 位，寻址范围是 $1024=2^{10}$ 。采用地址复用技术时，分两次传送行、列地址，地址引脚减半为5根，数据引脚仍为8根，因此地址引脚和数据引脚总数至少为13根。  

注意SRAM和DRAM的区别，DRAM采用地址复用技术，而SRAM不采用。  

11.A Cache由SRAM组成，掉电后信息即消失，属于易失性存储器。  

12.C  

U盘采用Flash存储器技术，它是在E²PROM的基础上发展起来的，属于ROM的一种。由于擦写速度和性价比均很可观，因此其常用作辅存。  

# 注意  

随机存取与随机存储器（RAM）不同，只读存储器（ROM）也是随机存取的。因此，支持随机存取的存储器并不一定是RAM。  
13.C  

因计算机的操作系统保存于硬盘上，所以需要BIOS的引导程序将操作系统引导到主存（RAM）中，而引导程序则固化于ROM中。  

14.B  

EPROM可多次改写，但改写较为烦琐，写入时间过长，且改写的次数有限，速度较慢，因此不能作为需要频繁读/写的RAM使用。  

15.C  

动态半导体存储器利用电容存储电荷的特性记录信息，由于电容会放电，因此必须在电荷流失前对电容充电，即刷新。方法是每隔一定的时间，根据原存内容重新写入一遍，因此1错误。这里的读并不是把信息读入CPU，也不是从CPU向主存存入信息，它只是把信息读出，通过一个刷新放大器后又重新存回存储单元，而刷新放大器是集成在RAM上的。因此，这里只进行了一次访存，也就是占用一个存取周期，ⅡI、IV正确，ⅢI错误。  

16.A  

$64\mathrm{K}\!\times\!1$ 位的DRAM芯片由一个 $256{\times}256$ 的位平面组成。构成存储器的所有芯片同时按行刷新，每个芯片有256行，故存储器所有单元刷新一遍至少需要256次刷新操作。若采用异步刷新方式，则相邻两次刷新信息的时间间隔为 $2\mathrm{ms}/256\approx7.8\upmu\mathrm{s}.$ 若采用集中刷新方式，则整个存储器刷新一遍最少需256个读/写周期，在刷新过程中，存储器不能进行读/写操作。  

17.D  

刷新也是一个读取的过程，根据读出内容对相应单元进行重写，因此会和CPU的访存冲突，会有访存“死时间”。刷新是指每隔一定的时间必须向栅极电容补充一次电荷，并以行为单位。  

18.C  

SDRAM（同步DRAM）与SRAM不同，其与CPU采用同步方式交换数据。SDRAM也是DRAM的一种，需要定期刷新。行缓冲器用来缓存指定行中整行的数据，通常用SRAM实现。  

19.B  

DRAM芯片采用地址线复用技术，行地址和列地址分时复用，每增加1根地址线，则行地址和列地址各增加1位，所以行数和列数各增加1倍，因此容量至少提高到原来的4倍。  

20.B  

DRAM芯片的容量 $=$ 位平面数 $\times$ 行数 $\times$ 列数，即由位平面数、存储阵列的行数和列数决定。故一个DRAM芯片的容量为 ${\bf4096{\times}4096{\times}4b}={\bf8M B}$ ，故内存条的总容量为 $8\mathrm{MB}{\times}16=128\mathrm{MB}$  

21.D  

低位交叉编址多模块存储器，采用轮流启动的方式时，类似于流水线的工作方式，为保证某个模块再次启动时，其上次的存取操作已完成（流水线不间断），要求两次启动间隔的时间必须大于或等于一个存储周期，即“模块数 $\cdot\times$ 总线周期≥存储周期”，得出存储体数应大于或等于11。  

22.B  

低位交叉存储器采用流水线技术，可以在一个存取周期内连续访问4个模块，32位 $\times4=128$ 位。本题答案为B。注：本题若作为计算题来考虑，从第一个字的读/写请求发出，到第4个字读/写结束，共需要 $350\mathrm{ns}$ ，但这里考查的是整体工作性能，可从以下角度理解：1）连续取 $m$ 个字耗时 $t_{1}=T+(m-1)r$ ，平均每个字的存取时间是 $t_{1}/m$ ，实际工作时 $m$ 非常大，因此 $t_{1}/m$ 也就非常接近 $r$ ，可认为存储器在每个总线周期 $r$ 都能给CPU提供一个字。2）流水线充分流动起来后，每个总线周期后都能完成一个字的读/写，所以本题中每4个总  
线周期（200ns）都能完成4个字的读/写。  

23.C  

1）在每轮读取存储器的前6个 $T/4$ 时间（共3T/2）内，依次进入各体。下一轮欲读取存储器时，最近访问的 $\mathbf{M}_{1}$ 还在占用审（才过 $T/2$ 的时间），因此必须再等待 $T/2$ 的时间才能开始新的读取（ $\mathbf{M}_{1}$ 连续完成两次读取，也即总共 $2T$ 的时间才可进入下一轮）。  

# 注意  

进入下一轮不需要第6个字读取结束，第5个字读取结束时 $\mathbf{M}_{1}$ 就已空出，即可马上进入下一轮。  

最后一轮读取结束的时间是本轮第6个字读取结束，共 $(6-1){\times}(T/4)+T\,{=}\,2.25\,T.$ 情况1）的总时间为 $(80-1){\times}2T+2.25T{=}160.25T.$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/153b9d5bdf206a094cb694d14323915d7457d1260621994882de465cba4006b8.jpg)  

2）每轮读取8个存储字刚好经过 $2T$ 的时间，每轮结束后，最近访问的 $\mathbf{M}_{1}$ 刚好经过了时间T，此时可以立即开始下一轮的读取。  

最后一轮读取结束的时间是本轮第8个字读取结束，共 $(8-1){\times}(T/4)+T\,{=}\,2.75T.$ 情况2）的总时间为 $(60-1){\times}2T+2.75T{=}120.75T.$ 因此情况1）和2）所花费的总时间比为4:3。  

24.D  

$64\mathrm{K}\!\times\!8$ 位/ $16K{\times}8$ 位 $=4$ ，可知芯片数为4。芯片各单元采用交叉编址，所以每个芯片的片选信号由最低两位地址确定，高14位为片内地址。4个芯片内各存储单元的最低两位地址分别为00、01、10、11，即最小地址分别为0000H、0001H、0002H、0003H。地址BFFFH最低两位为11，因此该存储单元所在芯片的最小地址为 $0003\mathrm{H}$  

25.A  

单体多字存储器主要解决访存速度的问题，并没有解决主存容量太小的问题。在单体多字存储器中，每个存储单元存储多个字，当指令和数据连续存放，且没有过多的跳转指令时，单体多字存储器能有效地提高主存的读/写速度。  

26.B  

多模块存储器各模块有独立的读/写电路，可以实现并行操作，故多模块存储器能进行高速的读/写操作。采用低位交叉编址的多模块存储器各单元地址不连续。  

27.A  

RAM（分DRAM和SRAM）断电后会失去信息，而ROM断电后不会丢失信息，它们都采用随机存取方式。Cache一般采用高速的SRAM制成，而ROM只可读，不能用作Cache，III错误。DRAM需要定期刷新，而ROM不需要刷新，故IV错误。  
28.A  

闪存是 $\mathrm{E^{2}P R O M}$ 的进一步发展，可读可写，用MOS管的浮栅上有无电荷来存储信息。闪存依然是ROM的一种，写入时必须先擦除原有数据，所以写速度要比读速度慢。闪存是一种非易失性存储器，它采用随机访问方式。现在常见的SSD固态硬盘，即由Flash芯片组成。  

29.A  

$4{\bf{M}}{\times}8$ 位的芯片数据线应为8根，地址线应为 $\log_{2}\!4\mathbf{M}=22$ 根，而DRAM采用地址复用技术，地址线是原来的1/2，且地址信号分行、列两次传送。地址线数为 $22/2=11$ 根，所以地址引脚与数据引脚的总数为 $11+8=19$ 根，选A。此题需要注意DRAM采用的是传两次地址的策略，所以地址线为正常的一半，这是很多考生容易忽略的地方。  

30.B  

DRAM使用电容存储，所以必须隔一段时间刷新一次，若存储单元未被刷新，则存储的信息就会丢失。同步动态随机存储器SDRAM是现在最常用的一种DRAM。  

31.D  

每个访存地址对应的存储模块序号（0，1,2，3）如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8e912d9bd3833a3cfe3a2e1adcc07bab81903b2a12a15b4c9f3c74e6a49264e.jpg)  

其中，模块序号 $=$ 访存地址%存储器交叉模块数。  

判断可能发生访存冲突的规则如下：给定的访存地址在相邻的四次访问中出现在同一个存储模块内。据此，根据上表可知8004和8000对应的模块号都为0，即表明这两次的访问出现在同一模块内且在相邻的访问请求中，满足发生冲突的条件。  

32.C  

交叉编址多模块存储器有轮流启动和同时启动两种方式，本题中所有存储模块一次并行读/写的总位数正好等于系统总线中的数据线数，故可以判定采用的是同时启动方式。在同时启动方式下，一个存储周期可以对所有芯片的同一行都读取一个字节。double型变量占64位（8B）。其主存地址 $804\;001\,\mathrm{AH}$ 的最低两位是10，说明它从编号为2的芯片开始存储（编号从0开始），共占3行，因此需要同时启动3轮才能完成对double型变量的读取。从本题也可发现，采用同时启动方式时，一次读行也许会有没用的数据读入。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/316df9934e3d1e7df954feb12767b55b3494d5b22292de4d2e33837230279dc2.jpg)  

33.C  

由题意，首先根据DRAM采用的是行列地址线复用技术，我们尽量选用行列差值不要太大的选项B、C的地址线只需6根（取行或列所需地址线的最大值），轻松排除A和D。其次，为了减小刷新开销，而DRAM一般是按行刷新的，所以应选行数值较少的。  

34.C  

$8{\times}8192{\times}8192{\times}8\mathrm{bit}=512\mathrm{MB}$ ，内存条的容量为512MB，A正确。存储器总线宽度 $64=8{\times}8\mathrm{bit}$ 而每个芯片一次只能传输8bit，需要8体多模块交叉编址采用同时启动方式才能实现，B正确。芯片容量为 $8192{\times}8192{\times}8{\mathrm{bit}}$ ，按字节编址，地址线数应为 $\log_{2}(8192{\times}8192)=26$ ，DRAM采用地址复用技术，地址信号分行、列两次传送，因此地址引脚数为 $26/2=13$ 根，C错误。芯片内行数是8192，一行的大小是 $8192{\times}8\mathrm{bit}$ ，行缓冲长度就是一行的大小，D正确。  
# 二、综合应用题  

01.【解答】  

1）因为刷新带宽  $W_{1}=$  分辨率  $\times$  像素点颜色深度×刷新速率  ${\begin{array}{l}{=1024{\times}768{\times}3\mathrm{B}{\times}72/\mathrm{s}}\\ {=169869\mathrm{KB}/\mathrm{s}}\end{array}}$  

所以刷新总带宽 $W_{0}=W_{1}(W_{0}/W_{1})$  $=169869\mathrm{KB/s}{\times}100/50=339738\mathrm{KB/s}$   $=339.738\mathrm{MB/s}$ （其中 $1\mathrm{K}=1000$ 一  

2）要提高刷新存储器带宽，可采用以下技术： $\textcircled{\scriptsize{1}}$ 采用高速DRAM芯片； $\circledcirc$ 采用多体交叉存储结构； $\textcircled{3}$ 刷新存储器到显示控制器的内部总线宽度加倍； $\textcircled{4}$ 采用双端口存储器将刷新端口和更新端口分开。  

02.【解答】  

1）一个存取周期，四体并行交叉存储器可取32位 $\times4=128$ 位，其中32位为总线宽度，4为交叉存储器内的存储体个数。  

2）该说法不正确。因为在 $0.1\upmu\mathrm{s}$ 内整个存储器可向CPU提供32位二进制信息，但每个存储体必须经过 $400\mathrm{ns}$ 才能向CPU提供32位二进制信息。  

03.【解答】  

顺序存储器和交叉存储器连续读出  $m=4$  个字的信息总量均是  

顺序存储器和交叉存储器连续读出4个字所需的时间分别是  

$t_{1}=m T=4{\times}200\mathrm{ns}=800\mathrm{ns}=8{\times}10^{-7}\mathrm{s}$   $t_{2}=T+(m-1)r=200\mathrm{ns}+3\times50\mathrm{ns}=350\mathrm{ns}=35\times10^{-8}\mathrm{s}$  

顺序存储器和交叉存储器的带宽分别是  

$$
\begin{array}{c}{{W_{1}=q/t_{1}=256^{+}(8\!\times\!10^{-7})=32\!\times\!10^{7}\!\mathrm{b/s}}}\\ {{W_{2}=q/t_{2}=256^{+}(35\!\times\!10^{-8})=73\!\times\!10^{7}\!\mathrm{b/s}}}\end{array}
$$  

04.【解答】  

交叉存储器在统考真题中曾多次考查，希望能引起读者重视，本题是这一类题中较难的。  

1）因为每个体的存取周期是 $200\mathrm{ns}$ 。四体交叉工作，每两个体间读出操作的延时为1/4个存储周期，理想情况是每个存取周期平均可读出4个数据字，读出一个数据字的时间平均为 $200\mathrm{ns}/4=50\mathrm{ns}$ 。数据字长为32位，数据传输速率为32位 $\mathrm{\Delta/50ns=640Mb/s=80MB/s}.$  

2）若对多体结构的存储器选用高位地址交叉，通常起不到提高存储器读/写速度的作用，因为它不符合程序运行的局部性原理，一次连续读出彼此地址相差一个存储体容量的4个字的机会太少。因此，通常只有一个存储模块在不停地忙碌，其他存储模块是空闲的。  

3）若把存储器的字长扩大为原来的4倍，实现的则是一个单体4字结构的存储器，每次读可以同时读出4个字的内容，有利于提高存储器每个字的平均读/写速度，但其灵活性不如多体单字结构的存储器，还会多用到几个缓冲寄存器。  
4）多端口存储器是对同一个存储体使用多套读/写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则充许在同一个存储周期对几个存储体执行写入操作。  

05.【解答】  

对于四体交叉访问的存储系统，每个存储模块的地址分布如下：  

Bank0:0,4,8,12,16,.. Bank1:1,5,9,13,17,.….,37.….,41... Bank2:2,6,10,14,18, Bank3:3,7,11,15,19,.…·,51,·.,67  

若给定的访存地址在相邻的4次访问中出现在同一个Bank内，则可能发生访存冲突。所以17和9、37和17、13和37、8和4可能发生冲突。易错点：虽然41和13号单元也在同一个模块内，并且访问间隔小于4，但是由于访问8号单元发生冲突而使其访问延迟3个间隔，从而使41号单元的访问也延迟3个间隔，因此其访问不会和13号单元的访问发生冲突。  

# 3.3 主存储器与CPU的连接  

# 3.3.1连接原理  

1）主存储器通过数据总线、地址总线和控制总线与CPU连接。  

2）数据总线的位数与工作频率的乘积正比于数据传输速率。  

3）地址总线的位数决定了可寻址的最大内存空间。  

4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。  

主存储器与CPU的连接如图3.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1e1d92cf5473f7cdbefec0c268399f79d298a75bd67083e238876b319130a603.jpg)  
图3.10主存储器与CPU的连接  

单个芯片的容量是有限的，因此通过存储器芯片扩展技术，将多个芯片集成在一个内存条上，然后由多个内存条及主板上的ROM芯片组成计算机所需的主存空间，再通过总线与CPU相连。  

# 3.3.2主存容量的扩展  

由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需要在字和位两方面进行扩充才能满足实际存储器的容量要求。  

1.位扩展法  

位扩展是指对字长进行扩展（增加存储字长）。当CPU的系统数据线数多于存储芯片的数据位数时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。  
位扩展的连接方式：各芯片的地址线、片选线和读/写控制线与系统总线相应并联：各芯片的数据线单独引出，分别连接系统数据线。各芯片同时工作。  

如图3.11所示，用8片 $8K\!\times\!1$ 位的RAM芯片组成 $8K\!\times\!8$ 位的存储器。8片RAM芯片的地址线 $\mathrm{A}_{12}{\sim}\mathrm{A}_{0}$ 、CS、WE都分别连在一起，每片的数据线依次作为CPU数据线的一位。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f2b1e66bdcaafe6c0055bf34f9b6020f9ac3160dbd2ded9961f636deabd2b444.jpg)  
图3.11位扩展连接示意图  

2.字扩展法  

字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。  

字扩展的连接方式：各芯片的地址线与系统地址线的低位对应相连；芯片的数据线和读/写控制线与系统总线相应并联；由系统地址线的高位译码得到各芯片的片选信号。各芯片分时工作。  

# 命题追踪字扩展（或字位扩展）后存储芯片的地址范围（2010、2016）  

如图3.12所示，用4片 $16K{\times}8$ 位的RAM芯片组成 $64\mathrm{K}\!\times\!8$ 位的存储器。4片RAM芯片的数据线 $\mathrm{D}_{0}{\sim}\mathrm{D}_{7}$ 和WE都分别连在一起。将 $\mathrm{A_{15}A_{14}}$ 用作片选信号， $\mathrm{A}_{15}\mathrm{A}_{14}=00$ 时，译码器输出端0有效，选中最左边1号芯片； $\mathrm{A}_{15}\mathrm{A}_{14}=01$ 时，译码器输出端1有效，选中2号芯片，以此类推（同一时刻只能有一个芯片被选中）。各芯片的地址分配如下：  

第一片，最低地址：0000000000000000：最高地址：0011111111111111（16位）第二片，最低地址：0100000000000000：最高地址：0111111111111111  

第三片，最低地址：1000000000000000；最高地址：1011111111111111第四片，最低地址：1100000000000000：最高地址：1111111111111111  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/44f1fe99a9391d96d9aeb0fb8712474bf298dbedaaa36321308e7bb49a6874d2.jpg)  
图3.12字扩展连接示意图  
3.字位同时扩展法  

字位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。  

字位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展的相同；由系统地址线高位译码产生若干片选信号，分别接到各组芯片的片选信号。  

如图3.13所示，用8片 $16K\times4$ 位的RAM芯片组成 $64\mathrm{K}\!\times\!8$ 位的存储器。每两片构成一组 $16K\times8$ 位的存储器（位扩展），4组便构成 $64\mathrm{K}\!\times\!8$ 位的存储器（字扩展）。地址线 $\mathrm{A}_{15}\mathrm{A}_{14}$ 经译码器得到4个片选信号， $\mathrm{A}_{15}\mathrm{A}_{14}=00$ 时，输出端0有效，选中第一组的芯片（ $\textcircled{\scriptsize{1}}$ 和 $\circledcirc$ )； $\mathrm{A}_{15}\mathrm{A}_{14}=01$ 时，输出端1有效，选中第二组的芯片（ $\textcircled{3}$ 和 $\textcircled{4}$ )，以此类推。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bd0ffee871eff245d8c4e998e914cbf1ee53c30a0465b58592027c9ed8d0501.jpg)  
图3.13字位同时扩展及CPU的连接图  

# 3.3.3存储芯片的地址分配和片选  

CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后在选定的芯片中选择具体的存储单元，以进行数据的读/写，即进行字选。芯片内的字选通常是由CPU送出的 $N$ 条低位地址线完成（ $(N$ 由片内存储容量 $2^{N}$ 决定）。片选信号的产生方法分为线选法和译码片选法。  

# 1.线选法  

线选法用除片内寻址外的高位地址线直接连接至各个存储芯片的片选端，当某位地址线信息为“0”时，就选中与之对应的存储芯片。这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组）。假设4片  $2\mathrm{K}\!\times\!8$  位存储芯片采用线选法构成  $8K\!\times\!8$  位存储器，各芯片 的片选信号见表3.2，其中低位地址线 $\mathrm{A_{10}}\mathrm{\sim}\mathrm{A_{0}}$ 作为字选线，用于片内寻址。  

优点：不需要地址译码器，线路简单。缺点：地址空间不连续，选片的地址线必须分时为低电平（否则不能工作），不能充分利用系统的存储器空间，造成地址资源的浪费。  

表3.2线选法的地址分配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d3e8ef9e2d826e33c5a04dddaf3613401040af874224f56e1f181b5f42aec2d2.jpg)  

# 2.译码片选法  

译码片选法用除片内寻址外的高位地址线通过地址译码器产生片选信号。如用8片 $8K\!\times\!8$ 位的存储芯片组成 $64\mathrm{K}\!\times\!8$ 位存储器（地线为16位，数据线为8位），需要8个片选信号；若采用线选法，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用译码片选法，即用一片74LS138作为地址译码器，高3位用于片选，则 $\mathrm{A}_{15}\mathrm{A}_{14}\mathrm{A}_{13}=000$ 时选中第一片， $\mathrm{A}_{15}\mathrm{A}_{14}\mathrm{A}_{13}\,{=}\,001$ 时选中第二片，以此类推。  
# 3.3.4 存储器与CPU的连接  

# 1.合理选择存储芯片  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7794c8d428e0c6881d434e25e174952bfec52ac2823fcd17f03373df192eebd5.jpg)  

# 根据要求合理选择存储芯片（2009、2021）  

要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型（RAM或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便。  

# 2.地址线的连接  

# 命题追踪  

# 地址范围与存储容量的对应关系（2016、2023）  

存储芯片的容量不同，其地址线数也不同，而CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选），这部分的译码是由芯片的片内逻辑完成的。而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成。  

例如，设CPU地址线为16位，即 $\mathrm{A}_{15}{\sim}\mathrm{A}_{0}$  $1K{\times}4$ 位的存储芯片仅有10根地址线，此时可将CPU的低位地址 $\mathrm{A}_{9}{\sim}\mathrm{A}_{0}$ 与存储芯片的地址线 $\mathrm{A}_{9}{\sim}\mathrm{A}_{0}$ 相连。  

# 3.数据线的连接  

CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连：在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。  

# 4.读/写命令线的连接  

CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的（读为RD，写为WE，均为低电平有效），此时CPU的读命令线应与芯片的充许读控制端相连，而CPU的写命令线则应与芯片的充许写控制端相连。  

# 5.片选线的连接  

片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。  

片选有效信号与CPU的访存控制信号MREQ（低电平有效）有关，因为只有当CPU要求访存时，才要求选中存储芯片。若CPU访问I/O，则MREQ为高，表示不要求存储器工作。  

# 3.3.5 本节习题精选  

# 一、单项选择题  

01.用存储容量为 $16K\!\times\!1$ 位的存储器芯片来组成一个 $64\mathrm{K}\!\times\!8$ 位的存储器，则在字方向和位方向分别扩展了（）倍。  

A. 4,2 B.8,4 C. 2,4 D. 4,8  

02.80386DX是32位系统，以4B为编址单位，当在该系统中用8KB（ $8K\!\times\!8$ 位）的存储芯片构造32KB的存储体时，应完成存储器的（）设计。  
A.位扩展B.字扩展C.字位扩展D.字位均不扩展

03.某计算机字长为16位，存储器容量为256KB，CPU按字寻址，其寻址范围是（）A.  $0\sim2^{19}-1$  B.  $0\sim2^{20}-1$  C.  $0\sim2^{18}\mathrm{-}1$  D.  $0\sim2^{17}–1$  04.4个 $16K{\times}8$ 位的存储芯片，可设计为（）容量的存储器。A. $32\mathrm{K}\!\times\!16$ 位B. $16\mathrm{K}\!\times\!16$ 位C. $32K{\times}8$ 位D. $8K{\times}16$ 位

05.16片 $2K{\times}4$ 位的存储器可以设计为（）存储容量的16位存储器。A.16K B.32K C.8K D.2K  

06.设CPU地址总线有24根，数据总线有32根，用 $512K{\times}8$ 位的RAM芯片构成该机的主存储器，则该机主存最多需要（）片这样的存储芯片。  

A.256 B.512 C.64 D.128  

07.地址总线 $\mathrm{A}_{0}$ （高位） $\mathrm{\simA_{15}}$ （低位），用 $4\mathrm{K}\!\times\!4$ 位的存储芯片组成16KB存储器，则产生片选信号的译码器的输入地址线应该是（）。  

A.  $\mathrm{A}_{2}\mathrm{A}_{3}$  B.  $\mathrm{A}_{0}\mathrm{A}_{1}$  C.  $\mathrm{A}_{12}\mathrm{A}_{13}$  D.  $\mathrm{A}_{14}\mathrm{A}_{15}$  

08.若内存地址区间为 $4000\mathrm{H}\sim43\mathrm{F}\mathrm{H},$ 每个存储单元可存储16位二进制数，该内存区域用4片存储器芯片构成，构成该内存所用的存储器芯片的容量是（）。  

A.  $512\times1$  16bit B.  $256{\times}8{\mathrm{bit}}$  C.256x16bit D.  $1024{\times}8\mathrm{bit}$  

09.内存按字节编址，地址从90000H到CFFFFH，若用存储容量为 $16K\times8$ 位芯片构成该内存，至少需要的芯片数是（）。  

A.2B.4C.8D.16  

10.若片选地址为111时，选定某一 $32\mathrm{K}\!\times\!16$ 位的存储芯片工作，则该芯片在存储器中的首地址和末地址分别为（）。  

A. 00000H,01000H B.38000H,3FFFFH C.3800H3FFFHD.0000H,0100H  

11.如下图所示，若低位地址（ $\mathbf{A}_{0}\sim\mathbf{A}_{11}$ ）接在内存芯片地址引脚上，高位地址（ $\mathbf{A}_{12}\sim\mathbf{A}_{19}$ 一进行片选译码（其中 $\mathsf{A}_{14}$ 和 $\mathrm{A}_{16}$ 未参加译码），且片选信号低电平有效，则对图中所示的译码电路，不属于此译码空间的地址是（）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/57827d332e3cff33cfd4e52694ce2393359a717d4c1b92db8e8385ada09e9c7d.jpg)  

A.AB0OOH\~ABFFFH B.BB000H\~BBFFFH C.EF000H\~EFFFFH D.FEO00H\~FEFFFH  

12.【2009统考真题】某计算机主存容量为64KB，其中ROM区为4KB，其余为RAM区，按字节编址。现要用 $2\mathrm{K}\!\times\!8$ 位的ROM芯片和 $4K{\times}4$ 位的RAM芯片来设计该存储器，需要上述规格的ROM芯片数和RAM芯片数分别是（）  

A.1,15 B.2,15 C.1,30 D.2,30  

13.【2010统考真题】假定用若干 $2\mathrm{K}\!\times\!4$ 位的芯片组成一个 $8K\!\times\!8$ 位的存储器，则地址OB1FH所在芯片的最小地址是（）。  

A.0000H B.0600H C.0700H D.0800H  
14.【2011统考真题】某计算机存储器按字节编址，主存地址空间大小为64MB，现用 $4{\bf{M}}{\times}8$ 位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（）。  

A.22位B.23位C.25位D.26位  

15.【2016统考真题】某存储器容量为64KB，按字节编址，地址4000H\~5FFFH为ROM区，其余为RAM区。若采用 $8K\!\times\!4$ 位的SRAM芯片进行设计，则需要该芯片的数量是（）。  

A.7 B.8 C.14 D.16  

16.【2021统考真题】某计算机的存储器总线中有24位地址线和32位数据线，按字编址，字长为 32位。若 $00\ 0000\mathrm{H}\sim3\mathrm{F}$ FFFFH为RAM区，则需要 $512K{\times}8$ 位的RAM芯片数为()。  

A.8 XB.16 C.32 D.64  

17.【2023统考真题】某计算机的CPU有30根地址线，按字节编址，CPU和主存连接时，要求主存芯片占满所有可能的存储地址空间，并且RAM区和ROM区所分配的空间大小比是3:1。若RAM在低地址区，ROM在高地址区，则ROM的地址范围是（）。  

A 00000000H\~OFFFFFFFH B. 10000000H\~2FFFFFFFH 30000000H\~3FFFFFFFH D.40000000H\~4FFFFFFFH  

# 二、综合应用题  

01.主存储器的地址寄存器和数据寄存器各自的作用是什么？设一个IMB容量的存储器，机器字长和存储字长均为32位，问：1）按字节编址，地址寄存器和数据寄存器各几位？编址范围为多大？2）按字编址，地址寄存器和数据寄存器各几位？编址范围为多大？  

02.用一个 $512K{\times}8$ 位的Flash存储芯片组成一个 $4\mathrm{M}{\times}32$ 位的半导体只读存储器，存储器按字编址，试回答以下问题：1）该存储器的数据线数和地址线数分别为多少？2）共需要几片这样的存储芯片？3）说明每根地址线的作用。  

03.有一组 $16K{\times}16$ 位的存储器，由 $1K\times4$ 位的DRAM芯片构成（芯片是 $32\!\times\!32$ 结构）。问：1）共需要多少RAM芯片？2）采用异步刷新方式，如单元刷新间隔不超过 $2\mathrm{ms}$ ，则刷新信号周期是多少？  

# 3.3.6 答案与解析  

一、单项选择题  

01.D 字方向扩展了 $64\mathrm{K}/16\mathrm{K}=4$ 倍，位方向扩展了8bit/1bit $=8$ 倍。  

02.A 因为以4B为编址单位，要扩展到32KB，即扩展到 $8K{\times}32\mathrm{bit}$ ，所以只用进行位扩展。  

03.D  $256\mathrm{KB}=2^{18}\mathrm{B}$ ，按字寻址，且字长为 $16\mathrm{bit}=2\mathrm{B}$ ，可寻址的单元数 $=2^{18}\mathrm{B}/2\mathrm{B}=2^{17}$ ，其寻址范围是 $0{\sim}2^{17}{-}1$ 。  

04.A  

4个 $16K{\times}8$ 位的存储芯片构成的存储器容量 $=4{\times}16\mathrm{K}{\times}8$ 位 $=512\mathrm{K}$ 位或64KB，只有选项A的容量为64KB。注意，若有某项为 $128K\times4$ 位，则此选项不能选，因为芯片为8位，不可能将字长“扩展”成4位。  
05.C  

设存储容量为 $M_{c}$ 则有 $(M\!\times\!16)\!+\!(2\!\times\!4)=16$ ，因此 $M\!=\!8K$  

06.D  

地址线为24根，寻址范围是 $2^{24}$ ：数据线为32根，字长为32位。主存的总容量 $=2^{24}{\times}32$ 位因此所需存储芯片数 $=(2^{24}{\times}32){\div}(512\mathrm{K}{\times}8)=128$  

07.A  

由于 $\mathrm{A}_{15}$ 为地址线的低位，接入各芯片地址端的是地址线的低12位，即 $\mathrm{A}_{4}{\sim}\mathrm{A}_{15}$ ，共有8个芯片 $[16\mathrm{{KB}/4\mathrm{{K}=4\mathrm{{B}}}}$ ，并且位扩展时每组两片分为4组）组成16KB的存储器，因此由高两位地址线 $\mathrm{A}_{2}\mathrm{A}_{3}$ 作为译码器的输入。  

08.C  

$43\mathrm{FF}-4000+1=400\mathrm{H}$ ，即内存区域为1K个单元，总容量为 $1K{\times}16$ 位。现由4片存储芯片构成，则构成该内存的芯片容量为 $1\mathrm{K}\!\times\!16$ 位 $'4=256{\times}16$ 位。  

09.D  

CFFFF $-90000+1=40000\mathrm{H}$ ，即内存区域有256K个单元。若用存储容量为 $16K{\times}8$ 位的芯片，则需要的芯片数 $=(256\mathrm{K}{\times}8){\div}(16\mathrm{K}{\times}8)=16$ 片。  

10.B  

$32\mathrm{K}\!\times\!16$ 的存储芯片有地址线15根（片内地址），片选地址为3位，因此地址总位数为18位现高3位为111，则首地址为 $11100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000$ ，末地址为111111111111111111 $=$ 3FFFFH。  

11.D  

这是一个部分译码的片选信号，高8位地址中有2位 $(\mathbf{A}_{14}$ 和 $\mathrm{{A}_{16}}$ ）未参与译码，根据译码器电路，译码输出的逻辑表达式应为  

$$
\overline{{\mathrm{CS}}}=\overline{{\mathrm{A}_{19}(\mathrm{A}_{18}\!+\mathrm{A}_{17})\,\mathrm{A}_{15}\,\mathrm{A}_{13}\,\mathrm{A}_{12}}}
$$  

因此不属于此译码空间的是这几位不合该逻辑表达式的，A选项为AB，即10101011，去掉14位和16位为101111：B选项为101111：C选项为111111：D选项为 $111\ 110$ 。由逻辑表达式可知A17与A18至少有一个为1， $\mathrm{A_{19}A_{15}A_{13}A_{12}}$ 应全为1，仅D无法满足。  

12.D  

首先确定ROM的个数，ROM区为4KB，选用 $2\mathrm{K}\!\times\!8$ 位的ROM芯片，需要 $(4\mathrm{K}{\times}8){\div}(2\mathrm{K}{\times}8)=2$ 片，采用字扩展方式：RAM区为60KB，选用 $4K{\times}4$ 位的RAM芯片，需要 $(60\mathrm{K}{\times}8)^{\div}(4\mathrm{K}{\times}4)=30$ 片，采用字和位同时扩展的方式。  

13.D  

用 $2K{\times}4$ 位的芯片组成一个 $8K{\times}8$ 位存储器，共需8片 $2\mathrm{K}\!\times\!4$ 位的芯片，分为4组，每组由2片 $2K{\times}4$ 位的芯片并联组成 $2\mathrm{K}\!\times\!8$ 位的芯片，各组芯片的地址分配如下：  

第一组（两个芯片并联）： $0000\mathrm{{H}}{\sim}07\mathrm{{F}}\mathrm{{H}}.$ 第二组（两个芯片并联）： $0800\mathrm{H}{\sim}0\mathrm{FFH}\,.$ 第三组（两个芯片并联）： $1000\mathrm{H}{\sim}17\mathrm{F}\mathrm{H}.$ 第四组（两个芯片并联）：1800H\~1FFFH。地址0B1FH所在的芯片属于第二组，故其所在芯片的最小地址为 $0800\mathrm{H}$  

主存按字节编址，地址空间大小为64MB，MAR的寻址范围为 $64\mathrm{M}=2^{26}$ ，因此是26位。实际的主存容量32MB不能代表MAR的位数，考虑到存储器扩展的需要，MAR应保证能访问到整个主存地址空间，反过来，MAR的位数决定了主存地址空间的大小。  
15.C  

5FFF $-4000+1\,{=}\,2000\mathrm{H}$ ，即ROM区容量为 $2^{13}\mathrm{B}=8\mathrm{KB}\ \ (2000\mathrm{H}=2{\times}16^{3}=2^{13})$ ，RAM区容量为56KB(64KB- $8\mathrm{{KB}}=56\mathrm{{KB}}$ )。需要 $8K\!\times\!4$ 位的SRAM芯片的数量为14（ $56\mathrm{KB}/8\mathrm{K}{\times}4$ 位 $=14)$ 。  

16.C  

000000\~3FFFFF，共有3FFFI  $\mathrm{FWHM}-000000\mathrm{H}+1\mathrm{H}=400000\mathrm{H}=2^{22}$  个地址，按字编址，字长为32 位（4B)，因此RAM区大小为 $2^{22}{\times}4\mathrm{B}=2^{22}{\times}32\mathrm{b}$ it。每个RAM芯片的容量为 $512\mathrm{K}{\times}8\mathrm{bit}=2^{19}{\times}8\mathrm{b}$ it，所以需要RAM芯片的数量为 $(2^{22}{\times}32\mathrm{bit})\div(2^{19}{\times}8\mathrm{bit})=32$  

17. C  

地址空间为 $2^{30}$ ，地址范围 $0000\,0000\mathrm{H}{\sim}3\mathrm{FI}$ FFFFFH。RAM $\mathrm{\cdotROM}=3\cdot1$ ，则ROM可分配的地址空间为 $2^{28}$ ，3 FFFFFF FH $2^{28}$ 个地址，即ROM的地址范围是30000000H～3FFFFFFFH.  

# 二、综合应用题  

01.【解答】  

在主存储器中，地址寄存器MAR用来存放当前CPU访问的内存单元地址，或存放CPU写入内存的内存单元地址。数据寄存器MDR用来存放由内存中读出的信息或写入内存的信息。  

1）按字节编址， $1\mathrm{MB}=2^{20}{\times}8$ 位，地址寄存器为20位，数据寄存器位数由存储字长决定，为32位，编址范围为 $0000\mathrm{H}\!\sim$ FFFFFH（FFFFFH $-\ensuremath{00000}\mathrm{H}+1=\ensuremath{100000}\mathrm{H}=2^{20})$ 。2）按字编址， $1\mathbf{MB}=2^{18}{\times}32$ 位，地址寄存器为18位，数据寄存器为32位，编址范围为0000OH  $\sim$  3FFFFH（3FFFFH  $\mathrm{I}-00000\mathrm{H}+1=40000\mathrm{H}=2^{18})$  

02.【解答】  

1）因为所需的组成存储器的最终容量为 $4\mathrm{M}{\times}32$ 位，所以需要32根数据线。而存储器又是按字编址的，所以此时不需要将存储器的容量先转换成 $16{\bf{M}}{\times}8$ 位，直接是 $4{\bf{M}}{\times}32$ 位中的4M，所以只需要22根地址线 $(2^{22}\,{=}\,4\mathrm{M})$ 。2）采用 $512\mathrm{K}{\times}8$ 位的Flash存储芯片组成 $4\mathrm{M}{\times}32$ 位的存储器时，需要同时进行位扩展和字扩展。位扩展：4片 $512\mathrm{K}{\times}8$ 位的Flash存储芯片位扩展可组成 $512\mathrm{K}{\times}32$ 位的Flash存储芯片。字扩展：8片 $512\mathrm{K}{\times}32$ 位的Flash存储芯片字扩展可组成 $4{\bf{M}}{\times}32$ 位的存储器。综上可知，一共需要 $4\!\times\!8=32$ 片 $512\mathrm{K}{\times}8$ 位的存储芯片。3）在CPU的22根地址线中 $(\mathbf{A}_{0}{\sim}\mathbf{A}_{21})$ ，地址线的作用分配如下：首先，此时不需要指定 $\mathrm{A}_{0},\ \mathrm{A}_{1}$ 来标识每组中的4片存储器，因为此时是按字寻址的，所以4片每次都是一起取的，而不是按字节编址时需要取4片中的某一片。 $\mathrm{A_{0}}{\sim}\mathrm{A_{18}}$ ：每片都是512K，所以需要19位（ $(2^{19}=512\mathrm{K}$ ）来表示。 $\mathrm{A_{19}}$  $\mathrm{A}_{20}$ 、 $\mathrm{A}_{21}$ ：因为在扩展中4片一组，一共有8组 $(=2^{3})$ ，所以需要用3位地址线来决定取哪一组（通过3/8译码器形成片选信号）。  

03.【解答】  

1）存储器总容量为 $16\mathrm{K}\!\times\!16$ 位，RAM芯片为 $1K\times4$ 位，因此所需芯片总数为( $16K\!\times\!16$ 位/ $\mathrm{1K\times4}$ 位 $=64$ 片。2）采用异步刷新方式，在 $2\mathrm{ms}$ 时间内分散地把芯片64行刷新一遍，因此刷新信号的时间间隔为 $2\mathrm{ms}/64=31.25\upmu\mathrm{s}$ ，即可取刷新信号周期为 $31\upmu\mathrm{s}$  
# 注意  

刷新周期也可取 $30\upmu\mathrm{s}$ ，只要小于 $31.25\upmu\mathrm{s}$ 即可，但通常取刷新间隔的整数部分。  

# 3.4外部存储器  

# 3.4.1磁盘存储器  

磁盘存储器是以磁盘为存储介质的存储器，其主要优点： $\textcircled{\scriptsize{1}}$ 存储容量大，位价格低： $\circledcirc$ 记录介质可重复使用： $\textcircled{3}$ 记录信息可长期保存而不丢失，甚至可脱机存档： $\textcircled{4}$ 非破坏性读出，读出时不需要再生。缺点：存取速度慢，机械结构复杂，对工作环境要求较高。  

# 1.磁盘存储器  

# 命题追踪  

# 磁盘存储器的相关概念（2019）  

（1）磁盘设备的组成  

$\textcircled{\scriptsize{1}}$ 磁盘存储器的组成。磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。  

·磁盘驱动器。驱动磁盘转动并在盘面上通过磁头进行读/写操作的装置，如图3.14所示。·磁盘控制器。磁盘驱动器与主机的接口，负责接收并解释CPU发来的命令，向磁盘驱 动器发出各种控制信号，并负责检测磁盘驱动器的状态。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/949e3320f633db83d48f7dfbb5d87ac3e37d71935bede8ce35981b7926da2bb7.jpg)  
图3.14磁盘驱动器示意图  

$\circledcirc$ 存储区域。一个磁盘含有若干记录面，每个记录面划分为若干圆形的磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读/写的最小单位，即磁盘按块存取。  

·磁头数（Heads）：即记录面数，表示磁盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头·柱面数（Cylinders）：表示磁盘每面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。  

·扇区数（Sectors）：表示每条磁道上有多少个扇区。  

相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。由于扇区按固定圆心角度划分，因此位密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。  
$\textcircled{3}$ 磁盘高速缓存（DiskCache）。在内存中开辟一部分区域，用于缓冲将被送到磁盘上的数据。优点：写磁盘时是按“簇”进行的，可以避免频繁地用小块数据写盘；有些中间结果数据在写回磁盘之前可被快速地再次使用。  

（2）磁记录原理  

编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。  

磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。  

（3）磁盘的性能指标  

$\textcircled{\scriptsize{1}}$ 记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。  

$\circledcirc$ 磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，非格式化容量 $=$ 记录面数 $\cdot\times$ 柱面数 $\times$ 每条磁道的磁化单元数。格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化容量  $=$  记录面数  $\times$  柱 面数 $\times$ 每道扇区数x每个扇区的容量。格式化后的容量比非格式化容量要小。  

# 命题追踪磁盘存取时间的计算（2013、2015、2022）  

$\circledast$ 存取时间。存取时间由寻道时间（磁头移动到自的磁道的时间）、旋转延迟时间（磁头定位到要读/写扇区的时间）和传输时间（传输数据所花费的时间）三部分构成。因为寻道和我扇区的距离远近不一，所以寻道时间和旋转延迟时间通常取平均值（平均寻道时间取从最外道移动到最内道时间的一半，平均旋转延迟时间取旋转半周的时间）。  

$\textcircled{4}$ 数据传输速率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输速率。假设磁盘转数为r转/秒，每条磁道容量为 $N$ 字节，则数据传输速率为  

$$
D_{\mathrm{r}}\,{=}\,r N
$$  

# （4）磁盘地址  

# 命题追踪磁盘地址结构的计算（2022）  

主机向磁盘控制器发送寻址信息，磁盘的地址一般如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/63c7621ebd786e99322bc2b3b8f2b7a6108c715c1896f3fefe6388625f9c5d47.jpg)  

若磁盘有16个盘面，每个盘面有256个磁道，每个磁道划分为16个扇区，则每个扇区地址要16位二进制代码，其格式如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a05c8eee3f46040951717583967f67c0aa6f299dd9fed653a49b666bc3e3b2b4.jpg)  

（5）磁盘的工作过程  

磁盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，磁盘工作时，第一步是取控制字，第二步是执行控制字。磁盘属于机械式部件，其读/写操作是事行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。  

# 2.磁盘阵列  

RAID（独立冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交义存储、并行访问，具有更好的存储性能、可靠性和安全性。  
# 命题追踪提高RAID可靠性的措施（2013）  

RAID的分级如下所示。在RAID1～RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。  

RAID0：无冗余和无校验的磁盘阵列，RAID1：镜像磁盘阵列。RAID2：采用纠错的海明码的磁盘阵列。RAID3：位交叉奇偶校验的磁盘阵列。RAID4：块交叉奇偶校验的磁盘阵列。RAID5：无独立校验的奇偶校验磁盘阵列。  

RAIDO把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读/写，即条带化技术，这样不仅扩大了存储容量，还提高了磁盘存取速度，但RAIDO没有容错能力。  

为了提高可靠性，RAID1使两个磁盘同时进行读/写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。  

总之，RAID通过同时使用多个磁盘，提高了传输速率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量：通过镜像功能，提高安全可靠性：通过数据校验，提供容错能力。  

# 3.4.2 固态硬盘  

# 1.固态硬盘的特性  

固态硬盘（SSD）是一种基于闪存技术的存储器。它与U盘并无本质差别，只是容量更大，存取性能更好。一个SSD由一个或多个闪存芯片和闪存翻译层组成，如图3.15所示。闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层将来自CPU的逻辑块读/写请求翻译成对底层 物理设备的读/写控制信号，因此，这个闪存翻译层相当于代替了磁盘控制器的角色。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f4c9b82aff9e75d81635a4e6f89fa583ec0838d5124b1cd07047a821d4691ebd.jpg)  
图3.15固态硬盘（SSD）  

在图3.15中，一个闪存由 $B$ 块组成，每块由 $P$ 页组成。通常，页的大小是 $512\mathrm{B}{\sim}4\mathrm{KB}$ ，每块由 $32\!\sim\!128$ 页组成，块的大小为 $16\mathrm{KB}{\sim}512\mathrm{KB}$ 。数据是以页为单位读/写的。只有在一页所属的块整个被擦除后，才能写这一页。不过，一旦一个块被擦除，块中的每个页就都可以直接再写一次。某个块进行了若干次重复写之后，就会磨损坏，不能再使用。  

随机写很慢，有两个原因。首先，擦除块较慢，通常比访问页高一个数量级。其次，若写操作试图修改一个包含已有数据的页 $P_{i},$ 则这个块中所有含有用数据的页都必须被复制到一个新（擦除过的）块中，然后才能进行对页 $P_{i}$ 的写操作。  

比起传统磁盘，SSD有很多优点，它由半导体存储器构成，没有移动的部件，因而随机访问时间比机械磁盘要快很多，也没有任何机械噪声和振动，能耗更低，抗震性好，安全性高等。  
# 2.磨损均衡（Wear Leveling）  

固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几干次。若直接用普通闪存组装SSD，则实际的寿命表现可能非常令人失望一一读/写数据时会集中在SSD的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块SSD也就损坏了。这种磨损不均衡的情况，可能会导致一块256GB的SSD，只因数兆字节空间的闪存损坏而整块损坏。  

为了弥补SSD的寿命缺陷，引入了磨损均衡。SSD磨损均衡技术大致分为两种1）动态磨损均衡。写入数据时，自动选择较新的闪存块。老的闪存块先歇一歇。  

2）静态磨损均衡。这种技术更为先进，就算没有数据写入，SSD也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读/写操作在较新的闪存块中进行。如此一来，各个闪存块的寿命损耗就都差不多。  

有了这种算法加持，SSD的寿命就比较可观了。例如，对于一个256GB的SSD，若闪存的擦写寿命是500次，则需要写入125TB数据，才寿终正寝。就算每天写入10GB数据，也要三十多年才能将闪存磨损坏，更何况很少有人每天往SSD中写入10GB数据。  

# 3.4.3 本节习题精选  

# 一、单项选择题  

01.下列关于磁盘的说法中，错误的是（）  

A.本质上，U盘（闪存）是一种只读存储器B.RAID技术可以提高磁盘的磁记录密度和磁盘利用率C.未格式化的硬盘容量要大于格式化后的实际容量D.计算磁盘的存取时间时，“寻道时间”和“旋转等待时间”常取其平均值  

02.下列关于磁盘驱动器的叙述中，错误的是（）。  

A.送到磁盘驱动器的地址由磁头号、盘面号和扇区号组成B.能控制磁头移动到指定磁道，并发回“寻道结束”信号C.能控制磁盘片转过指定的扇区，并发回“扇区符合”信号D.能控制对指定盘面的指定扇区进行数据的读或写操作  

03.下列有关磁盘存储器读/写操作的叙述中，错误的是（）。  

A.最小读/写单位可以是一个扇区B.采用直接存储器存取DMA方式进行输入/输出C.按批处理方式进行一个数据块的读/写D.磁盘存储器可与CPU交换盘面上的存储信息  

04.若磁盘的转速提高一倍，则（）  

A.平均寻道时间减少一半B.存取速度也提高一倍C.平均旋转延迟时间减少一半D.不影响磁盘传输速率  

05.下列关于固态硬盘（SSD）的叙述中，不正确的是（）。  

A.固态硬盘的读/写是以页为单位的B.固态硬盘的擦除是以页为单位的C.固态硬盘的写入速度比读取速度慢很多D.固态硬盘的写入次数有限，引入磨损均衡可以延长使用寿命  

06.下列关于固态硬盘（SSD）的说法中，错误的是（）  
A.基于闪存的存储技术B.随机读/写性能明显高于磁盘C.随机写比较慢D.读/写速度快，常用作主存  

07.一个磁盘的转速为7200转/分，每个磁道有160个扇区，每个扇区有512字节，则在理想情况下，磁盘每秒传输的数据量是（）  

A.7200x160KB/sB.7200KB/s C.9600KB/s D.19200KB/s  

08.某磁盘盘面共有200个磁道，盘面总存储容量为60MB，磁盘旋转一周的时间为 $25\mathrm{ms}$ 每个磁道有8个扇区，各扇区之间有一间隙，磁头通过每个间隙需 $1.25\mathrm{ms_{e}}$ 则磁盘接口所需的最大传输速率是（）。  

A.10MB/s B.60MB/s C.83.3MB/s D.20MB/s  

09.【2013统考真题】某磁盘的转速为10000转/分，平均寻道时间是6mS，磁盘传输速率是20MB/S，磁盘控制器延迟为 $_{0.2\mathrm{ms}}$ ，读取一个4KB的扇区所需的平均时间约为（）。  

A.9ms B.  $9.4\mathrm{ms}$  C.12ms D.12.4ms 10.【2013统考真题】下列选项中，用于提高RAID可靠性的措施有（）  

I.磁盘镜像II.条带化III.奇偶校验IV.增加Cache机制A.仅I、ⅡIB.仅I、IIIC.仅I、IⅢI和IVD.仅II、III和IV  

11.【2015统考真题】若磁盘转速为7200转/分，平均寻道时间为8mS，每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是（）。  

A.8.1ms B.  $12.2\mathrm{ms}$  C.16.3ms D.20.5ms 12.【2019统考真题】下列关于磁盘存储器的叙述中，错误的是（）  

A.磁盘的格式化容量比非格式化容量小 B.扇区中包含数据、地址和校验等信息C.磁盘存储器的最小读/写单位为1字节D.磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成  

# 二、综合应用题  

01.某个硬磁盘共有4个记录面，存储区域内半径为  $10\,\mathrm{cm}$  ，外半径为  $15.5\mathrm{cm}$  ，道密度为60 道/cm，外层位密度为  $600\mathrm{bit/cm}$  ，转速为6000转/分。  

1）硬磁盘的磁道总数是多少？2）硬磁盘的容量是多少？3）将长度超过一个磁道容量的文件记录在同一个柱面上是否合理？4）采用定长数据块记录格式，直接寻址的最小单位是什么？寻址命令中磁盘地址如何表示？5）假定每个扇区的容量为512B，每个磁道有12个扇区，寻道的平均等待时间为 $10.5\mathrm{ms}$ ，试计算磁盘平均存取一个扇区的时间。  

# 3.4.4 答案与解析  

# 一、单项选择题  

01.B  

闪存是在EPROM的基础上发展起来的，本质上是只读存储器。RAID将多个物理盘组成像单个逻辑盘，不会影响磁记录密度，也不可能提高磁盘利用率。在磁盘的格式化过程中，要对磁盘划分扇区，每个扇区要写入一些控制信息，扇区尾部还要留有一定的空隙，这些均需占用一些存储空间，因此导致格式化后的实际容量比非格式化的容量要小。  
02.A  

因为每个盘面对应一个磁头，所以盘面号和磁头号是同一个概念，显然A的说法是错误的，磁盘地址应该由磁道号（柱面号）、磁头号（盘面号）和扇区号组成。  

03.D  

磁盘存储器以成批（组）方式进行数据读/写，CPU中没有那么多通用寄存器用于存放交换的数据，且磁盘与通用寄存器的速度相差过大，因此磁盘存储器通常直接和主存交换信息。  

04.C  

磁盘存取的步骤为：启动磁头、寻找磁道（寻道时间）、查找扇区（旋转延迟时间）、传输数据，转速提高对寻道时间无影响；存取速度取决于所有步骤的时间，虽然会提高，但不会提高一倍；平均旋转延迟时间为旋转半圈的时间，因此会减少一半；转速提高则传输速率也提高。  

05.B  

固态硬盘的擦除以块为单位，读/写以页为单位，B错误。固态硬盘的写入速度比读取速度要慢很多，因为在写入时需要擦除，且写入次数有限，否则该块就会因为磨损而无法再次写入。  

06.D  

固态硬盘基于闪存技术，没有机械部件，随机读/写不需要机械操作，因此速度明显高于磁盘，A和B正确。选项C已在考点讲解中解释过。SSD常用作外存而非主存，D错误。  

07.C  

磁盘的转速为7200转/分 $=\,120$ 转/秒，转一圈经过160个扇区，每个扇区为512B，所以磁盘每秒传输的数据量为 $120{\times}160{\times}512/1024=9600\mathrm{KB}$  

08.D  

每个磁道的容量 $=60\mathrm{MB}/200=0.3\mathrm{MB}$ ，读一个磁道数据的时间等于磁盘旋转一周的时间减去通过扇区间隙的总时间（每个磁道有8个间隙），即 $25\mathrm{ms}-1.25\mathrm{ms}{\times}8=15\mathrm{ms},$ ，数据传输速率 $=$  $0.3\mathrm{{MB}/15\mathrm{{ms}=20\mathrm{{MB}/s.}}}$  

09.B  

磁盘转速是10000转/分，转一圈的时间为6ms，因此平均查询扇区的时间为 $3\mathrm{ms}$ ，平均寻道时间为6ms，读取4KB扇区信息的时间为 $4\mathrm{KB}{\div}20\mathrm{MB/s}=0.2\mathrm{ms}$ ，磁盘控制器延迟为 $0.2\mathrm{ms}$ ，总时间为 $3+6+0.2+0.2=9.4\mathrm{ms}$  

10.B  

RAID0方案是无余和无校验的磁盘阵列，而RAID1～RAID5方案均是加入了余（镜像）或校验的磁盘阵列。因此，提高RAID可靠性的措施主要是对磁盘进行镜像和奇偶校验，其余选项不符合条件。条带化是一种将数据分片，分别存储至不同的磁盘，提高读/写速度的技术。条带化的优点是读/写速度快，缺点是没有允余，若其中一块磁盘损坏，则数据就会丢失。因此，条带化通常和其他技术如磁盘镜像或奇偶校验结合使用，形成不同的RAID级别。  

11.B  

存取时间 $=$ 寻道时间 $^+$ 延迟时间 $^+$ 传输时间。存取一个扇区的平均延迟时间为旋转半周的时间，即 $(60/7200)/2=4.17\mathrm{ms}$ ，传输时间为 $(60/7200)/1000=0.01\mathrm{ms}$ ，因此访问一个扇区的平均存取时间为 $4.17+0.01+8=12.18\mathrm{ms}$ ，保留一位小数则为 $12.2\mathrm{ms}$  

12.C 磁盘存储器的最小读/写单位为一个扇区，即磁盘按块存取。磁盘存储数据之前需要进行格式化，将磁盘分成扇区，并写入信息，因此磁盘的格式化容量比非格式化容量小。磁盘扇区中包含数据、地址和校验等信息。磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成。  
# 二、综合应用题  

# 01.【解答】  

1）有效存储区域 $=15.5-10=5.5\mathrm{cm}$ ，道密度 $=60$ 道/cm，因此每个面为 $60\!\times\!5.5=330$ 道，即有330个柱面，因此磁道总数 $=4{\times}330=1320$ 个磁道。  

2）外层磁道的长度为 $2\pi R=2\!\times\!3.14\!\times\!15.5=97.34\mathrm{cm}.$ 每道信息量 $\mathbf{\tau}=600\mathbf{b}\mathrm{i}/\mathbf{cm}\times97.34\mathbf{cm}=58404\mathrm{b}\mathrm{i}=7300\mathbf{B}.$ 利用1）的结果，可得磁盘总容量 $\mathbf{\Pi}=7300\mathbf{B}\mathbf{\times}1320=9636000\mathbf{B}$ （非格式化容量）。  

3）若长度超过一个磁道容量的文件，将它记录在同一个柱面上是比较合理的，因为不需要重新寻找磁道，这样数据读/写速度快。  

4）采用定长数据块格式，直接寻址的最小单位是一个扇区，每个扇区记录固定字节数目的信息，在定长记录的数据块中，活动头磁盘组的编址方式可用如下格式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8cfd8412ea63a0e85eaa0d0e4f85ff011096379c573fc7eb8cb2c1d6fc700b0a.jpg)  

此地址格式表示共有4个记录面，每面有128个磁道，每道最多可有16个扇区。  

5）读一个扇区中数据所用的时间 $=$ 找磁道的时间 $^+$ 找扇区的时间 $^+$ 磁头扫过一个扇区的时间。找磁道的时间是指磁头从当前所处磁道运动到目标磁道的时间，一般选用磁头在磁盘径向方向上移动1/2个半径长度所用的时间为平均值来估算，题中给出的是 $10.5\mathrm{ms}$ 找扇区的时间是指磁头从当前所处扇区运动到目标扇区的时间，一般选用磁盘旋转半周所用的时间作为平均值来估算，题中给出磁盘转速为6000转/分，即100转/秒，所以磁盘转一周用时 $10\mathrm{ms}$ ，转半周用时 $5\mathrm{ms}$ 题中给出每个磁道有12个扇区，磁头扫过一个扇区用时为 $10/12\,=\,0.83\mathrm{ms}$ ，因此磁盘平  

均存取时间为 $10.5+5+0.83=16.33\mathrm{ms}$  

# 3.5高速缓冲存储器  

由于程序的转移概率不会很低，数据分布的离散性较大，因此单纯依靠并行主存系统提高主存系统的效率是有限的。高速缓存Cache拥有比主存更快的速度，因此在CPU和主存之间设置Cache可以显著提高存储系统的效率。Cache由SRAM组成，通常直接集成在CPU中。  

# 3.5.1程序访问的局部性原理  

程序访问的局部性原理包括时间局部性和空间局部性。命题追踪分析给定代码的时空局部性（2017、2023）  

时间局部性是指最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在盾环和需要多次重复执行的子程序段，以及对数组的存储和访问操作。空间局部性是指最近的末来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储的。  
高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而提高程序的执行速度。  

【例3.2】假设数组元素按行优先方式存储，对于下面的两个程序：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b41550f0178bf3620106cb205eed357ec765a9ec70eeda1a5cf5cda98d67dbf0.jpg)  

1）对于数组a的访问，哪个空间局部性更好？哪个时间局部性更好？2）对于指令访问来说，for循环体的空间局部性和时间局部性如何？  

解：假定M、N都为2048，按字节编址，每个数组元素占4字节，则指令和数据在主存中的存放情况如图3.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3beffe3fd561e33f22d27b23b7735f6b3805a9b89288a00b6514d0ad34b06ace.jpg)  
图3.16指令和数据在主存的存放  

命题追踪数组按行或列访问命中率的分析（2010）；数组循环访问的命中率分析（2016、2020）  

1）对于数组a，程序A和程序B的空间局部性相差较大  

程序A对数组a的访问顺序为a[0][0],a[0][1],,a[0][2047];a[1][0],a[1][1],,a[1][2047] 由此可见，访问顺序与存放顺序是一致的，因此空间局部性好。  

程序B对数组a的访问顺序为a[0][0],a[1][0].,a[2047][0];a[0][1],a[1][1],,a[2047][1]；。由此可见，访问顺序与存放顺序不一致，每次访问都要跳过2048个数组元素，即8192字节，若主存与Cache的交换单位小于8KB，则每访问一个数组元素都需要将一个主存块装入Cache，因而没有空间局部性。  

两个程序中，数组a的时间局部性都差，因为每个数组元素都只被访问一次。  
# 命题追踪程序中指令Cache的命中率分析（2014）  

2）对于for循环体，程序A和程序B中的访问局部性是一样的。因为循环体内指令按序连续存放，所以空间局部性好；内循环体被连续重复执行 $2048{\times}2048$ 次，因此时间局部性也好。  

由上述分析可知，虽然程序A和程序B的功能相同，但因内、外两重循环的顺序不同而导致两者对数组a访问的空间局部性相差较大，从而带来执行时间的巨大差异。  

# 3.5.2Cache的基本工作原理  

为便于Cache与主存交换信息，Cache和主存都被划分为大小相等的块，Cache块也称Cache行，每块由若干字节组成，块的长度称为块长（也称行长）。因为Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，Cache中仅保存主存中最活跃的若干块的副本。因此，可按照某种策略预测CPU在未来一段时间内欲访存的数据，将其装入Cache。图3.17所示为Cache的基本结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e95e7ed2b82fea1f024168bab35ac7aaf81ff99ed3bddc2a543be0029e74d2bd.jpg)  
图3.17高速缓冲存储器的工作原理  

# 命题追踪  

Cache命中对CPU执行时间影响的分析（2013、2015）  

当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。整个过程全部由硬件实现。值得注意的是，CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位。  

当CPU发出写请求时，若Cache命中，有可能会遇到Cache与主存中的内容不一致的问题。例如，由于CPU写Cache，把Cache某单元中的内容从 $X$ 修改成 $X$ ，而主存对应单元中的内容仍然是 $X,$ ，没有改变，因此若Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和回写法，详见本节的Cache写策略部分。  

# 注意  

某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则终止访存。  

# 命题追踪Cache命中率的计算（2009）  

CPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache的总命中次数为 $N_{\mathrm{c}}$ ，访问主存的总次数为 $N_{\mathrm{m}}$ ，则命中率 $H$ 为  
$$
H={N_{\mathrm{c}}}\,/({N_{\mathrm{c}}}+{N_{\mathrm{m}}})
$$  

可见为提高访问效率，命中率 $H$ 越接近1越好。设 $t_{c}$ 为命中时的Cache访问时间， $t_{\mathrm{m}}$ 为未命中时的访问时间， $1-H$ 表示未命中率，则Cache-主存系统的平均访问时间 $T_{\mathrm{a}}$ 为  

$$
T_{\mathrm{a}}=H t_{\mathrm{c}}+\left(1-H\right)t_{\mathrm{m}}
$$  

命题追踪Cache缺失率对主存带宽的影响（2012）  

【例3.3】假设Cache的速度是主存的5倍，且Cache的命中率为 $95\%$ ，则采用Cache后，存储器性能提高多少（假设采用先访问Cache，Cache不命中时，才采用访问主存的方式）？  

解：设Cache的存取周期为 $t$ ，主存的存取周期为 $5t$ ，得出系统的平均访问时间 $T$ 为  

$T\!=$ Cache命中时的访问时间 $\times$ 命中率 $^+$ Cache缺失时的访问时间 $\times$ 缺失率 $=0.95\times t+0.05\times(t+5t)=1.25t$  

或  

$T\!=$  Cache命中时的访问时间  $^+$  Cache缺失时的访存开销  $\times$  缺失率  $=t+0.05{\times}5t=1.25t$  可知，采用Cache后的存储器性能为原来的 $5t/1.25t/{\approx}\,4$ 倍。  

根据Cache的读、写流程，可知实现Cache时需解决以下关键问题  

1）数据查找。如何快速判断数据是否在Cache中。2）地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址。3）替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰。4）写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率。  

# 3.5.3Cache和主存的映射方式  

由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache中，因此在Cache中要为每块加一个标记位，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。  

Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cachnie。地址映射的方法有以下3种。  

1.直接映射  

主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。  

# 命题追踪直接映射的地址结构及映射关系的分析（2010、2011、2015）  

直接映射的关系可定义为  

Cache行号 $=$ mod Cache  

假设Cache共有 $2^{c}$ 行，主存有 $2^{m}$ 块，在直接映射方式中，主存的第0块、第 $2^{c}$ 块、第 $2^{c+1}$ 块·………·只能映射到Cache的第0行；而主存的第1块、第 $2^{c}+1$ 块、第 $2^{c+1}+1$ 块·只能映射到Cache的第1行，以此类推。由映射函数可看出，主存块号的低 $^c$ 位正好是它要装入的Cache行号。给每个Cache行设置一个长为 $\scriptstyle t\,=\,m\,-\,c$ 的标记（tag），当主存某块调入Cache后，就将其块号的高 $t$ 位设置在对应Cache行的标记中，如图3.18（a所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0d4d9150e1b74972905e0f2411e001d19ac079c052b685d6319df172fd1f46af.jpg)  
图3.18Cache和主存之间的直接映射方式  

直接映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1a310ec397e1e430790891edc7b4fe7034517d79896535099a72318e362d5cfc.jpg)  

CPU访存过程如图3.18（b）所示。首先根据访存地址中间的c位，找到对应的Cache行，将对 应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或有效位为O，则“不命中”，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高：位，同时将该地址中的内容送CPU。  

# 2.全相联映射  

主存中的每一块可以装入Cache中的任何位置，如图3.19所示，每行的标记用于指出该行来自主存的哪一块，因此CPU访存时需要与所有Cache行的标记进行比较。优点： $\textcircled{\scriptsize{1}}$ Cache块的冲突概率低，只要有空闲Cache行，就不会发生冲突： $\circledcirc$ 空间利用率高： $\textcircled{3}$ 命中率高：缺点： $\textcircled{\scriptsize{1}}$ 标记的比较速度较慢： $\circledcirc$ 实现成本较高，通常需采用按内容寻址的相联存储器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8989ceb071e5ad8c8d6dca134a27f62a4c6286c510cc52ef891f745bf53aba0.jpg)  
图3.19Cache和主存之间的全相联映射方式  

全相联映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d778483358bb5cfaa81acdb4053dea9aacce5ec9ea238257e705ba9e2fca92cd.jpg)  
CPU访存过程如下：首先将主存地址的高位标记（位数 $=\log_{2}$ 主存块数）与Cache各行的标记进行比较，若有一个相等且对应有效位为1，则命中，此时根据块内地址从该Cache行中取出信息；若都不相等，则不命中，此时CPU从主存中读出该地址所在的一块信息送到Cache的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。  

# 命题追踪根据地址结构和比较器数量判断映射方式（2018）  

通常为每个Cache行都设置一个比较器，比较器位数等于标记字段的位数。访存时根据标记字段的内容来访问Cache行中的主存块，因而其查找过程是一种“按内容访问”的存取方式，所以是一种“相联存储器”。这种方式的时间开销和硬件开销都较大，不适合大容量Cache。  

# 3.组相联映射  

# 命题追踪组相联映射方式的原理（2009、2016、2018～2020、2023）  

将Cache分成 $\mathcal{Q}$ 个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式，如图3.20所示。它是对直接映射和全相联映射的一种折中，当 $Q=1$ 时变为全相联映射，当 $\varrho=$ Cache行数时变为直接映射。路数越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。假设每组有 $r$ 个Cache行，则称为 $r$ 路组相联，图3.20中每组有两个Cache行，因此称为二路组相联。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/705d35296eca71ed8eded974c3d677da76008d584c3b528fa5e8971962c6d880.jpg)  
图3.20Cache和主存之间的二路组相联映射方式  

组相联映射的关系可以定义为  

Cache组号 $=$ mod Cache 组数（Q）  

组相联映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16468247b7f68d80ea35bf713452faaeaab1af0cc4620f1f67e90b71bd4d66a4.jpg)  

# 命题追踪组相联映射的访存过程及Cache缺失处理过程（2020）  

CPU访存过程如下：首先根据访存地址中间的组号找到对应的Cache组；将对应Cache组中每个行的标记与主存地址的高位标记进行比较；若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息；若都不相等或虽相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。  
# 命题追踪组相联映射中比较器的个数和位数（2022）  

直接映射因为每块只能映射到唯一的Cache行，因此只需设置1个比较器。而 $r$ 路组相联映射需要在对应分组中与 $r$ 个Cache行进行比较，因此需设置 $r$ 个比较器。  

# 命题追踪直接映射、组相联映射相关标记位及总容量的分析（2010）  

【例3.4】假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B。  

1）若不考虑用于Cache的一致维护性位（脏位）和替换算法控制位，并且采用直接映射方式，则该数据Cache的总容量为多少？2）若该Cache采用直接映射方式，则主存地址为3200（十进制）的主存块对应的Cache行号是多少？采用二路组相联映射时又是多少？3）以直接映射方式为例，简述访存过程（设访存的地址为0123456H）。  

解：  

1）因为Cache包括了可以对Cache中所包含的存储器地址进行跟踪的硬件，即Cache的总容量 $\bar{=}$ 存储容量 $^+$ 标记阵列容量（有效位、标记位），本题不考虑脏位和替换算法位。  

命题追踪直接映射相关标记位的分析（2015、2021）  

# 注意  

每个Cache行对应一个标记项（包括有效位、脏位、替换算法位、标记位），在组相联中，将每组各行的标记项排成一行，将各组从上到下排列，构成一个二维的标记阵列。查找Cache时就是查找标记阵列的标记项是否符合要求。二路组相联的标记阵列如图3.21所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/57f1a99d258e755109902e23acf15b394fc66b1b280f1f9dca674653a358810b.jpg)  
图3.21二路组相联的标记阵列示意图  

因此本题中每行相关的存储器容量如图3.22所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/683ed3f03365e410bb54f631a3aa7975ef5c257a5d5fb4a06bc06596f36764f8.jpg)  
图3.22Cache行的存储容量示意图  

标记字段长度的计算：主存地址有28位 $(256\mathrm{MB}=2^{28}\mathrm{B}$ ），其中6位为块内地址（ $2^{6}\mathrm{B}=$ 64B），3位为行号 $(2^{3}=8)$ ），剩余 $28-6-3=19$ 位为标记字段，故数据Cache的总容量为 $8{\times}(1+19+512)=4256$ 位。  
2）直接映射方式中，主存按照块的大小划分，主存地址3200对应的字块号为 $3200\mathrm{B}/64\mathrm{B}=$ 50。而Cache只有8行，则 $50\;\mathrm{mod}\;8=2$ ，因此对应的Cache行号为2。二路组相联映射方式，实质上就是将两个Cache行合并，内部采用全相联方式，外部采用直接映射方式， $50~\mathrm{mod}\:4=2$ ，对应的组号为2，即对应的Cache行号为4或5。  

3）直接映射方式中，28位主存地址可分为19位的主存标记位，3位的块号，6位的块内地址，即 $0000\:0001\:0010\:0011\:010$ 为主存标记位，001为块号，010110为块内地址。首先根据块号，查Cache（即001号Cache行）中对应的主存标记位，看是否相同。若相同，再看Cache行中的有效位是否为1，若是，称此访问命中，按块内地址010110读出Cache行所对应的单元并送入CPU中，完成访存。若出现标记位不相等或有效位为0的情况，则不命中，访问主存将数据取出并送往CPU和Cache对应块中，把主存地址的高19位写入001行的标记位，并将有效位置1。  

思考： $\textcircled{\scriptsize{1}}$ 若第一问中采用二路组相联，则Cache总容量是多少？ $\textcircled{2}$ 仔细分析主存划分和Cache划分的关系，自行推导二路组相联映射方式的主存地址划分和访存过程。  

三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行： $N$ 路组相联映射可以映射到 $N$ 行。当Cache大小、主存块大小一定时，  

1）直接映射的命中率最低，全相联映射的命中率最高。2）直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长。3）直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大。  

# 3.5.4Cache中主存块的替换算法  

在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应Cache行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。  

常用的替换算法有随机（RAND）算法、先进先出（FIFO）算法、近期最少使用（LRU）算法和最不经常使用（LFU）算法。其中最常考查的是LRU算法。  

1）随机算法：随机地确定替换的Cache行。它的实现比较简单，但未依据程序访问的局部性原理，因此可能命中率较低。2）先进先出算法：选择最早调入的Cache行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，因为最早进入的主存块也可能是目前经常要用的。  

# 命题追踪组相联映射中LRU算法的命中分析（2012、2021）  

3）近期最少使用算法（LRU）：依据程序访问的局部性原理，选择近期内长久未访问过的Cache行进行替换，其平均命中率要比FlFO的高，是堆栈类算法。  

# 命题追踪LRU替换位及其位数的计算（2018、2020）  

LRU算法对每个Cache行设置一个计数器（也称LRU替换位），用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块，计数值的位数与Cache组大小有关，二路时有1位LRU 位，四路时有2位LRU位。假定采用四路组相联，有5个主存块 $\{1,2,3,4,5\}$ 映射到Cache的同一组，对于主存访问序列 $\{1,2,3,4,1,2,5,1,2,3,4,5\},$ 采用LRU算法的替换过程如图3.23所示。图中左边阴影的数字是对应Cache行的计数值，右边的数字是存放在该行中的主存块号。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/172e58f1cfb7469387af458dc7e49c1ea931605bc2c9081f5e57a4932c9604de.jpg)  
图3.23LRU算法的替换过程示意图  

计数器的变化规则： $\textcircled{\scriptsize{1}}$ 命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变： $\circledcirc$ 未命中且还有空闲行时，新装入的行的计数器置0，其余全加1； $\textcircled{3}$ 未命中且无空闲行时，计数值为3的行的信息块被替换，新装入的行的计数器置0，其余全加1。  

当集中访问的存储区超过Cache组的大小时，命中率可能变得很低，如上例的访问序列变为 $1,2,3,4,5,1,2,3,4,5,\cdots,$ ，而Cache每组只有4行，则命中率为0，这种现象称为抖动。  

4）最不经常使用算法：将一段时间内被访问次数最少的Cache行换出。每行也设置一个计数器，新行装入后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。这种算法与LRU类似，但不完全相同。  

# 3.5.5Cache的一致性问题  

因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。此时分两种情况。  

对于Cache写操作命中（writehit），有两种处理方法。  

# 命题追踪直写法的特点（2015）、直写法是否需设修改位（2020）  

1）全写法（直写法、Write-through）。当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，就不必把这一块写回主存了，用新调入的块直接覆盖即可。这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲（WriteBuffer），如下图所示。CPU同时写数据到Cache和写缓冲中，写缓冲再将内容写入主存。写缓冲是一个FO队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f5ab311434521af2d47d204cc146f946fd1d802128ddcf2071dc6828c717e2cc.jpg)  

# 命题追踪回写法的修改位（2018、2020）  

2）回写法（write-back）?。当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有当此块被替换出时才写回主存。这种方法减少了访存次数，但存在数据不一致的隐惠。为了减少写回主存的次数，给每个Cache行设置一个修改位（脏位）。若修改位为1，则说明对应Cache行中的块被修改过，替换时须写回主存；若修改位为0，则 说明对应Cache行中的块未被修改过，替换时无须写回主存。  
全写法和回写法都对应于Cache写命中（要被修改的块在Cache中）时的情况。  

对于Cache写操作不命中，也有两种处理方法。  

1）写分配法（write-allocate）。更新主存单元，然后把这个主存块调入Cache。它试图利用程序的空间局部性，缺点是每次写不命中都要从主存读一个块到Cache中。  

2）非写分配法（not-write-allocate）。只更新主存单元，而不把主存块调入Cache。  

非写分配法通常与全写法合用，写分配法通常和回写法合用。  

# 命题追踪  

# 采用分离的指令Cache和数据Cache的主要目的（2014）  

随着指令流水技术的发展，需要将指令Cache和数据Cache分开设计，这就有了分离的Cache结构。统一Cache的优点是设计和实现相对简单，但由于执行部件存取数据时，指令预取部件要从同一Cache读指令，因此会引发冲突。采用分离的Cache结构可以解决这个问题，而且分离的指令和数据Cache还可以充分利用指令和数据的不同局部性来优化性能。  

现代计算机的Cache通常设立多级Cache，假定设2级Cache，按离CPU的远近可各自命名为L1Cache、L2Cache，离CPU越远，访问速度越慢，容量越大。指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与回写法合用。下图是一个含有两级Cache的系统，L1Cache对L2Cache使用全写法，L2Cache对主存使用回写法，由于L2Cache的存在，其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a36a40284b9aa454bc42de878bcab6fe9160cad5f6b92ce9054bac667f2a2cf5.jpg)  

# 3.5.6 本节习题精选  

# 一、单项选择题  

01.在高速缓存系统中，主存容量为12MB，Cache容量为400KB，则该存储系统的容量为（）  

A.  $12\mathrm{MB}+400\mathrm{KB}$  B.12MB C.  $12\mathrm{MB}-12\mathrm{MB}+400\mathrm{KB}$  D.12MB-400KB  

02.访问Cache系统失效时，通常不仅主存向CPU传送信息，同时还需要将信息写入Cache，在此过程中传送和写入信息的数据宽度各为（）。  

A.块、页B.字、字C.字、块 D.块、块  

03.假定用作Cache的SRAM的存取时间为2ns，用作主存的SDRAM的存取时间为 $40\mathrm{ns}_{\circ}$ 为使存储系统的平均存取时间达到3ns，则Cache命中率应达到（）左右。  

A.  $92.5\%$  B.  $85\%$  C.  $97.5\%$  D.  $99.9\%$  04.关于Cache的更新策略，下列说法中正确的是（）  

A.读操作时，全写法和回写法在命中时应用B.写操作时，回写法和写分配法在命中时应用C.读操作时，全写法和写分配法在失效时应用D.写操作时，写分配法、非写分配法在失效时应用  

05.在不同的情况下，需要采用适合的Cache写策略。对于下面两种情况： $\textcircled{\scriptsize{1}}$ 主要运行访问密集型应用，其中包含写操作； $\textcircled{2}$ 安全性要求很高，不允许有任何数据不一致的情况发生。适合它们的写策略分别是（）  
A.回写法，全写法B.全写法，回写法C.回写法，回写法D.全写法，全写法  

06.局部性通常有两种不同的形式：时间局部性和空间局部性。程序员是否编写出高速缓存友好的代码，就取决于这两方面的问题。对于下面这个函数，说法正确的是（）。  

int sumvec（int v[N]）{int i,sum  $_{1\left(=0\right)}$  for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ·  $_{\mathrm{i<N}}$   $\ \ \mathrm{i++}$  1 sum  $+=\!\mathrm{v}$  [i]; return sum;  

A.对于变量i和sum，循环体具有良好的空间局部性B.对于变量i、sum和vN]，循环体具有良好的空间局部性C.对于变量i和sum，循环体具有良好的时间局部性D.对于变量i、sum和vN]，循环体具有良好的时间局部性  

07.对于下列代码，以下哪种变化将使其具有更好的空间局部性（）  

$\textcircled{\scriptsize{1}}$  int i，j，k,sum  $_{1=0}$   $\circledcirc$  for（  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\dot{\mathbf{1}}}\leqslant\mathbf{n}$   $\ \ \dot{\mathbf{i}}_{++}$   $\textcircled{3}$ for( $\scriptstyle{\dot{\mathbf{j}}}=0$ ;j<n;j++） $\textcircled{4}$ for $\kappa{=}0$ ;k<n;k++） $\circledast$  sum+  $=\mathrm{a}$  [k][j][i];  

A.将第2行与第3行互换B.将第2行与第4行互换C.将第5行改为  $\mathrm{{sum+=}}$  a[ij[k][i]; D.将第5行改为sum  $\scriptstyle{+=}$  aj][i[k]:  

08.下列关于高速缓存Cache的描述中，正确的是（）  

A.Cache的功能全部由硬件实现B.Cache替换时的单位为字C.Cache与主存统一编址，即主存地址空间的某一部分属于CacheD.无论何时，Cache中的信息一定与主存中的信息一致  

09.下列关于Cache的描述中，比较合理的是（））  

I.指令Cache通常比数据Cache具有更好的空间局部性II.由于空间局部性，适当增加Cache块大小通常会提高命中率III.回写法的写主存操作次数少于写直达法  

A.IⅢI B.I和ⅡI C.II和ⅢI D.I和ⅡI和II  

10.某虚拟存储器系统采用页式内存管理，使用LRU页面替换算法，考虑下面的页面访问地址流（每次访问在一个时间单位中完成）：  

18178272183821317137 假定内存容量为4个页面，开始时是空的，则页面失效率是（）A.  $30\%$  B.  $5\%$  C.  $1.5\%$  D.  $15\%$  

11.某个具有两级Cache的存储系统中，访存时依次通过两级Cache，某程序在执行过程中访存1000次，其中访问第一级Cache时有40次不命中，接着访问第二级Cache，仍有10次不命中，则总命中率是（）。  

A.  $99\%$  B.  $96\%$  C.  $95\%$  D.  $97\%$  

12.假设一个Cache中共有 $M$ 块，每 $K$ 块组成一个组，则下列描述中正确的是（）A.若  $K{=}\,1$  ，Cache Cache B.若  $K=1$  ，Cache Cache C.若  $K\!=\!M,$  ，Cache Cache D.若  $K\!>\!1$  且  $K<M,$  ，则该Cache是M/K-Cache  
13．在Cache中，常用的替换策略有随机法（RAND）、先进先出法（FIFO）、近期最少使用法（LRU），其中与局部性原理有关的是（）  

A.随机法（RAND)B.先进先出法（FIFO）C.近期最少使用法（LRU）D.都不是  

14.某存储系统中，主存容量是Cache容量的4096倍，Cache被分为64个块，当主存地址和Cache地址采用直接映像方式时，地址映射表的大小应为（）。（假设不考虑一致维护和替换算法位。）  

A.6x4097bit B.  $64\!\times\!12\mathrm{bit}$  C.6x4096bit D.  $64\times$  13bit  

15.有效容量为128KB的Cache，每块16B，采用8路组相联。字节地址为1234567H的单 元调入该Cache，则其Tag应为（）。  

A.1234H B.2468H C.048DH D.12345H  

16.有一主存-Cache层次的存储器，其主存容量为1MB，Cache容量为16KB，每块有8个字，每字32位，采用直接地址映像方式，Cache起始字块为第0块，若主存地址为 $35301\mathrm{H}$ 且CPU访问Cache命中，则在Cache的第（）（十进制表示）字块中。  

A.152 B.153 C. 154 D.151

 17.对于由高速缓存、主存、硬盘构成的三级存储体系，CPU直接根据（）进行访问。A.高速缓存地址B.虚拟地址C.主存物理地址D.磁盘地址  

18.设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中，则按字节编址逻辑地址的有效位是（），物理地址至少是（）位。  

A.10, 12 B.10,15 C.13,15 D.13,12  

19.对于 $_n$ 路组相联映射Cache，在保持 $n$ 及主存和Cache总容量不变的前提下，将主存块大小和Cache块大小都增加一倍，则下列描述中正确的是（）。  

A.字块内地址的位数增加1位，主存tag字段的位数增加1位B.字块内地址的位数增加1位，主存tag字段的位数不变C.字块内地址的位数减少1位，主存tag字段的位数增加1位D.字块内地址的位数增加1倍，主存tag字段的位数减少一半  

20.某计算机的Cache有16行，块大小为16B，其映射方式可配置为直接映射或2-路组相联映射，主存按字节编址，主存单元从0开始编号。若依次访问下列主存单元，则不论采取上述哪种映射方式都可能引起Cache冲突的是（）。  

A.52号和102号单元B.48号和308号单元C.60号和160号单元D.46号和236号单元  

21.假设主存地址位数为32位，按字节编址，主存和Cache之间采用全相联映射方式，主存块大小为1个字，每字32位，采用回写（writeback）方式和随机替换策略，则能存 放32K字数据的Cache的总容量至少应有（）位。  

A.1536K B.1568K C.2016K D.2048K  

22．假设主存按字节编址，Cache共有64行，采用四路组相联映射方式，主存块大小为32字节，所有编号都从0开始。则第2593号存储单元所在主存块的Cache组号是（）。  
A.1 B.15 C.14 D.4  

23.假定CPU通过存储器总线读取数据的过程为：发送地址和读命令需1个时钟周期，存 储器准备一个数据需8个时钟周期，总线上每传送1个数据需1个时钟周期。若主存和Cache之间交换的主存块大小为64B，存取宽度和总线宽度都为8B，则Cache的一次缺失损失至少为（）个时钟周期。  

A. 64 B.72 C. 80 D.160  

24.假定8个存储器模块采用交叉方式组织，存储器芯片和总线支持突发传送，CPU通过存储器总线读取数据的过程为：发送首地址和读命令需1个时钟周期，存储器准备第一个数据需8个时钟周期，随后每个时钟周期总线上传送1个数据，可连续传送8个数据（即突发长度为8）。若主存和Cache之间交换的主存块大小为64B，存取宽度和总线宽度都为8B，则Cache的一次缺失损失至少为（）个时钟周期。  

A.17 B.20 C.33 D.80

 25.下列关于Cache替换算法的叙述中，错误的是（）。  

A.组相联映射和全相联映射都必须考虑如何进行替换B.先进先出算法无须对每个Cache行记录替换信息C.直接映射是多对一的映射，无须考虑替换问题D.LRU算法需要对每个Cache行记录替换信息  

26．下列关于Cache大小、主存块大小和Cache缺失率之间关系的叙述中，错误的是（）  

A.主存块大小和Cache容量无直接关系B.Cache容量越大，Cache缺失率越低 C.主存块大小通常为几十到上百字节D.主存块越大，Cache缺失率越低  

27.【2009统考真题】假设某计算机的存储系统由Cache和主存组成，某程序执行过程中访存1000次，其中访问Cache缺失（未命中）50次，则Cache的命中率是（）。  

A.  $5\%$  B.  $9.5\%$  C.  $50\%$  D.  $95\%$  

28.【2009统考真题】某计算机的Cache共有16块，采用二路组相联映射方式（即每组2块）。每个主存块大小为32B，按字节编址，主存129号单元所在主存块应装入的Cache组号是()。  

A.0 B.2 C. 4 D.6  

29.【2012统考真题】假设某计算机按字编址，Cache有4行，Cache和主存之间交换的块大小为1个字。若Cache的内容初始为空，采用二路组相联映射方式和LRU替换策略，则访问的主存地址依次为 $0,4,8,2,0,6,8,6,4,8$ 时，命中Cache的次数是（）。【提示，本题的映射方式与本书所讲的映射方式不同，具体见解析部分的“注意”】  

A.1 B.2 C.3 D. 4  

30.【2016统考真题】有如下C语言程序段：for( $\kappa{=}0$ ； $\Bbbk{<}1000$ ； $\kappa++,$  

a[k]  $=$  a[k]+32;  

若数组a和变量 $\mathbf{k}$ 均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为（）。  

A.  $1.25\%$  B.  $2.5\%$  C.  $12.5\%$  D.  $25\%$  
31.【2017统考真题】某C语言程序段如下：  

for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\mathrm{i}}\,<=9$   $\ \ \ \mathrm{i}_{ Ḋ }+\+ Ḍ$  temp  $_{\parallel}=\!1$  for(  $\scriptstyle{\dot{\mathbf{j}}}=0$   $\mid\;<=\mathrm{i}$   $\dot{\mathbf{\xi}}_{j}++)$  temp  $\star\!=\!{\mathrm{a}}$  []; sum  $+=$  temp:  

下列关于数组a的访问局部性的描述中，正确的是（）  

A.时间局部性和空间局部性皆有B.无时间局部性，有空间局部性C.有时间局部性，无空间局部性 D.时间局部性和空间局部性皆无  

32.【2021统考真题】若计算机主存地址为32位，按字节编址，Cache数据区大小为32KB主存块大小为32B，采用直接映射方式和回写（WriteBack）策略，则Cache行的位数至少是()。  

A.275 B.274 C.258 D.257  

33.【2022统考真题】若计算机主存地址为32位，按字节编址，某Cache的数据区容量为32KB，主存块大小为64B，采用8路组相联映射方式，该Cache中比较器的个数和位数分别为（)。  

A.8,20 B.8,23 C.64,20 D.64,23  

# 二、综合应用题  

01.假定某处理器可通过软件对高速缓存设置不同的写策略，则在下列两种情况下，应分别设置成什么写策略？为什么？  

1）处理器主要运行包含大量存储器写操作的数据访问密集型应用。2）处理器运行程序的性质与1）相同，但安全性要求高得多，不允许有任何数据不一致的情况发生。  

02.某计算机的主存地址位数为32位，按字节编址。假定数据Cache中最多存放128个主存块，采用四路组相联方式，块大小为64B，每块设置了1位有效位。采用随机替换算法，写磁盘采用回写策略，为此每块设置了1位“脏”位。要求：1）分别指出主存地址中标记（Tag）、组号（Index）和块内地址（Offset）三部分的位置与位数。2）计算该数据Cache的总位数。  

03.某个Cache的容量大小为64KB，行长为128B，且是四路组相联Cache，主存使用32位地址，按字节编址。  

1）该Cache共有多少行？多少组？2）该Cache的标记阵列中需要有多少标记项？每个标记项中标记位长度是多少？3）该Cache采用LRU替换算法，若当该Cache为写直达式Cache时，标记阵列总共需要多大的存储容量？回写式又该如何？（提示：四路组相联Cache使用LRU算法的替换控制位为2位。）  

04.某计算机有容量为256B的数据Cache，主存块大小为32B。现有如下C语言程序段：inti,j,c,s,a[128];  

for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<10000;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  for(  $\scriptstyle{\dot{\mathbf{j}}}=0$   $^{<128}$   $\scriptstyle{\dot{\boldsymbol{\mathrm{\omega}}}}={\dot{\boldsymbol{\mathrm{\omega}}}}+{\boldsymbol{\mathrm{s}}}$   $\mathsf{c}\mathrm{=}\mathsf{a}\left[\mathsf{j}\right]$  

int型数据用32位补码表示，编译器将变量ij，C，s都分配在通用寄存器中，因此，只需考虑数组元素的访存情况，假定数组起始地址正好在一个主存块的开始。请回答：  
1）若Cache采用直接映射，则当 $s\,{=}\,64$ 和 $s=63$ 时，缺失率分别为多少？2）若Cache采用2-路组相联映射，则当 $s=64$ 和 $s=63$ 时，缺失率分别为多少？  

05.【2010统考真题】某计算机的主存地址空间大小为256MB，按字节编址。指令Cache和数据Cache分离，均有8个Cache行，每个Cache行大小为64B，数据Cache采用直接映射方式。现有两个功能相同的程序A和B，其伪代码如下所示：  

程序A:程序B：int a[256][256]; int a[256][256]; int sum arrayl() int sum array2() int i，j， sun $\scriptstyle{1\equiv0}$ int i，j,sum $_{1=0}$ for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<256;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  一 for(  $\scriptstyle{\dot{\mathbf{\rho}}}=0$  ;j<256;  $\,\,{\dot{\mathsf{j}}}\,^{++}$  for(  $\scriptstyle{\dot{\bar{\boldsymbol{\mathbf{\rho}}}}}=0$   $_{\dot{1}}{<}256$  5；  $\,\,{\dot{\,}}^{-1\,++}$  1 for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<256;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  sum  $+=$  a[i][j]; sum  $+=$  a[i][j]; return sum; return sum;  

假定int型数据用32位补码表示，程序编译时，i、j和sum均分配在寄存器中，数组a按行优先方式存放，其首地址为320（十进制数）。请回答下列问题，要求说明理由或给出计算过程。  

1）不考虑用于Cache一致性维护和替换算法的控制位，数据Cache的总容量为多少？2）数组元素a[0][31]和a[1][1]各自所在的主存块对应的Cache行号是多少（Cache行号从0开始）？3）程序A和B的数据访问命中率各是多少？哪个程序的执行时间更短？  

06.【2013统考真题】某32位计算机，CPU主频为800MHz，Cache命中时的CPI为4，Cache 块大小为32B；主存采用8体交叉存储方式，每个体的存储字长为32位、存储周期为40ns；存储器总线宽度为32位，总线时钟频率为 ${200}\mathrm{MHz}$ ，支持突发传送总线事务。每次读突发传送总线事务的过程包括：传送首地址和命令、存储器准备数据、传送数据。每次突发传送32B，传送地址或32位数据均需要一个总线时钟周期。请回答下列问题，要求给出理由或计算过程。  

1）CPU和总线的时钟周期各为多少？总线的带宽（即最大数据传输速率）为多少？2）Cache缺失时，需要用几个读突发传送总线事务来完成一个主存块的读取？3）存储器总线完成一次读突发传送总线事务所需的时间是多少？4）若程序BP执行过程中共执行了100条指令，平均每条指令需进行1.2次访存，Cache缺失率为 $5\%$ ，不考虑替换等开销，则BP的CPU执行时间是多少？  

07.【2020统考真题】假定主存地址为32位，按字节编址，指令Cache和数据Cache与主存之间均采用8路组相联映射方式，直写（WriteThrough）写策略和LRU替换算法，主存块大小为64B，数据区容量各为32KB。开始时Cache均为空。请回答下列问题。1）Cache每一行中标记（Tag）、LRU位各占几位？是否有修改位？  

2）有如下C语言程序段：  

for $(\texttt{k}=\texttt{0}$ ； $\mathrm{~k~}<\ 1024$  $\kappa++$  $\mathrm{~\sf~S~}[\mathrm{~\boldmath~k~}]\;\;=\;\;2\,\mathrm{~\boldmath~\star~}\,\mathrm{~\sf~S~}[\mathrm{~\boldmath~k~}]$  

若数组s及其变量 $\mathbf{k}$ 均为int型，int型数据占4B，变量k分配在寄存器中，数组s在主存中的起始地址为 $\mathrm{0080~00C0H}$ ，则在该程序段执行过程中，访问数组s的数据Cache缺失次数为多少？  
3）若CPU最先开始的访问操作是读取主存单元 $0001\ \ 0003\mathrm{H}$ 中的指令，简要说明从Cache中访问该指令的过程，包括Cache缺失处理过程。  

# 3.5.7 答案与解析  

# 一、单项选择题  

01.B  

选项A为干扰项。各层次的存储系统不是孤立工作的，三级结构的存储系统是围绕主存储器来组织、管理和调度的存储器系统，它们既是一个整体，又要遵循系统运行的原理，其中包括包含性原则。因为Cache中存放的是主存中某一部分信息的副本，所以不能认为总容量为两个层次容量的简单相加。  

02.C  

一个块通常由若干字组成，CPU与Cache（或主存）间信息交互的单位是字，而Cache与主存间信息交互的单位是块。当CPU访问的某个字不在Cache中时，将该字所在的主存块调入Cache，这样CPU下次要访问的字才有可能在Cache中。  

03.C  

Cache命中时的存取时间为2ns；Cache不命中时先访问Cache，再访问主存，总存取时间为42ns。设Cache命中率为 $x$ ，则平均存取时间为 $2\!\times\!x+42\!\times\!(1-x)=3$ ，解得 $x=97.5\%$  

04.D  

在写不命中时，加载相应的低一层中的块到高速缓存（Cache）中，然后更新这个高速缓存块，称为写分配法；而避开Cache，直接把这个字写到主存中，则称为非写分配法。这两种方法都是在不命中Cache的情况下使用的，而回写法和全写法是在命中Cache的情况下使用的。在写Cache时，写分配法和回写法搭配使用，非写分配法和全写法搭配使用。  

05.A  

写操作比较密集，采用回写法速度快，更适合访问密集型的应用。全写法每次均写入主存和Cache，能够随时保持主存数据的一致性，适合安全性要求很高的应用。  

06.C  

时间局部性是指一个内存位置被重复引用，循环体中的变量i和sum具有良好的时间局部性。空间局部性是指若一个内存位置被引用，则它附近的位置很快也会被引用，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式存储的，v具有良好的空间局部性。  

# 07.B  

空间局部性是指程序在一段时间内所访问的存储空间的集中度。为了提高空间局部性，应尽量按照数组在内存中的存储顺序依次访问数组元素。根据C语言的规定，数组a在内存中是按最右下标变化最快的方式存储的，即a[0][0][0],a[0][0][1]..,a[0][0][n-1],a[0][1][0]..,a[0][n-1][n-1]a1][0][0]..，an-1]n-1][n-1]。因此，若将代码的第2行与第4行互换，则可使得对数组a的访问变成顺序访问，从而提高空间局部性。  

08.A  

Cache的功能完全由硬件实现，A正确。Cache替换时的单位是块，而不是字或字节，因为Cache和主存是以块为单位进行数据交换的。Cache地址空间和主存地址空间相互独立，通过地址映射把主存地址空间映射到Cache地址空间。Cache中的信息不一定与主存中的信息一致，因为Cache可能采用回写策略，只有当被修改的块被换出时才写回主存。  
09.D  

指令Cache通常比数据Cache具有更好的空间局部性，这是因为指令流通常是顺序执行的，而数据流跳转或随机访问的概率较高，1正确。由于空间局部性，同一主存块中的数据的访问概率较高，因此增加Cache块大小会提高命中率，IⅡ正确。写回法只有在被修改的块被换出时才写回主存，而写直达法每次写操作都会同时写回主存，Ⅲ正确。  

10.A  

LRU表如下：
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca95328eda743bf11e48cf9d6cae6c3cd6b2972d0ef00bd22e02aed0822228e.jpg)  
可见页面失效率是 $6/20=30\%$  

11. A  

访存1000次，访问第2级Cache后，仍有10条不命中，故总命中率为 $1-10/1000=99\%.$  

12.A  

$K=1$ 即一块为一组，每个主存块映射到唯一的Cache块，为直接映射，A正确，B错误。 $K\!=\!M$ 即每个主存块可映射到所有Cache块中，为全相联映射，C错误。D应为 $K_{\uparrow}$ 路组相联映射。  

13.C  

LRU算法根据程序访问局部性原理选择近期使用得最少的存储块作为替换的块。  

14.D  

地址映射表即标记阵列，由于Cache被分为64个块，因此Cache有64行，采用直接映射，一行相当于一组。因此标记阵列每行存储一个标记项，其中主存标记项为12位（ $.2^{12}=4096$ ，是Cache容量的4096倍，即地址长度比Cache长12位），加上1位有效位，因此为 $64\!\times\!13$ 位。  

15.C  

块大小为16B，所以块内地址字段为4位；Cache容量为128KB，采用8路组相联，共有  $128\mathrm{{KB}{\div}}(16\mathrm{{B}{\times}}8)=1024$ 组，组号字段为10位；剩下的为标记字段。1234567H转换为二进制数0001 $0010\,0011\,0100\,0101\,0110\,0111$ ，标记字段对应高14位，即 $048\mathrm{DH}$  

16.A  

先写出主存地址的二进制形式，然后分析Cache块内地址、Cache字块地址和主存字块标记。主存地址的二进制数 $0011\;0101\;0011\;0000\;0001$ ，根据直接映射的地址结构，字块内地址为低5位（每个字块32B， $2^{5}=32$ ，因此为5位），主存字块标记为高6位 $(1\mathrm{{MB}/16\mathrm{{KB}=64}}$  $2^{6}=64$ ，因此为6位），其余 $01\ 0011\ 000$ 即为Cache字块地址，转换为十进制数152。  

17.C  

当CPU访存时，先要到Cache中查看该主存地址是否在Cache中，所以发送的是主存物理地址。只有在虚拟存储器中，CPU发出的才是虚拟地址，这里并未指出是虚拟存储系统。磁盘地址是外存地址，外存中的程序由操作系统调入主存中，然后在主存中执行，因此CPU不可能直接访问磁盘。  

18. C  

对于逻辑地址，因为 $\ 8=2^{3}$ 页，所以表示页号的地址有3位，又因为每页有 $1024=2^{10}\mathrm{B}$ ，所以页内地址有10位，因此逻辑地址共13位。  
对于物理地址，块内地址和页内地址一样有10位，内存至少有 $32=2^{5}$ 个物理块，所以表示块号的地址至少有5位，因此物理地址至少有15位。  

19.B  

组相联映射的主存地址结构为：tag标记 $^+$ Cache组号 $^+$ 字块内地址。Cache块大小增加一倍，则字块内地址的位数增加1位。Cache组数 $=$ (Cache总容量/Cache块大小)/n，敌Cache组数减少一半；Cache组号  $=$  主存块号MODCache组数，故Cache组号也减少1位。主存总容量不 变，则主存地址总长度不变，字块内地址和Cache组号一个增1一个减1，因此tag字段的位数不变。  

20.B  

块大小为 $16\mathrm{B}=2^{4}\mathrm{B}$ ，所以块内地址占4位。若采用直接映射，Cache共16行，主存地址中块内地址的前4位为Cache行号，Cache行号 $=$ 主存块号%Cache总行数 $=$ （主存地址 $/16)\%16$ 选项B的地址48和308的Cache行号均为3，产生冲突。若采用2-路组相联映射，共有 $16/2=8$ 组，主存地址中块内地址的前3位为Cache组号，Cache组号 $=$ 主存块号%Cache组数 $=$ （主存地址 $/16)\%8$ ，选项B的地址48和308的Cache组号均为3，可能产生冲突。  

21.D  

主存块大小为1个字，即32位，按字节编址，所以块内地址占2位。在全相联映射方式下，主存地址只有两个字段，所以标志占 $32-2=30$ 位。因采用回写法，故需1位修改位；因为采用随机替换策略，故无须替换控制位。每个Cache行的总位数为32bit（数据位） $+\,30\,\mathrm{bit}$ （tag位） $^+$ Ibit（修改位） $^+$ Ibit（有效位） $=$ 64bit。综上，Cache总容量至少应有 $32\mathrm{K}\!\times\!64\mathrm{bit}=2048\mathrm{K}$ bit。  

22.A  

主存块大小为32字节，按字节编址，所以块内地址占5位。采用四路组相联映射方式，共64行，分 $64/4=16$ 组，故组号占4位。因为 $2593=0\cdots0101\ 0001\ 00001$ ，根据主存地址划分的结果，可以看出第2593号存储单元所在主存块的Cache组号为 $0001$  

23.C  

一次缺失损失需要从主存读出一个主存块（64B），每个总线事务读取8B，因此需要8个总线事务。每个总线事务所用的时间为 $1+8+1=10$ 个时钟周期，共需要80个时钟周期。  

24.A  

一次缺失损失需要从主存读出一个主存块（64B），每个突发传送总线事务可读取 $8\mathrm{B}{\times}8{=}64\mathrm{B}$ 因此只需要一个突发传送总线事务。首先，发送首地址和读命令需要一个时钟周期，然后轮流启动每个存储器模块，每隔一个时钟周期启动一个存储器模块，采用流水线工作方式，所以每个突发传送总线事务所用的时间为 $1+8+8=17$ 个时钟周期，因此共需17个时钟周期。  

25.B  

对于直接映射，主存中的每一块只能装入Cache中的唯一位置，若产生块冲突，原来的块将被无条件换出，因此无须考虑替换问题，而组相联映射和全相联映射都需要考虑替换问题。先进先出算法需要对每个Cache行打一个时间戳，记录何时装入了一个新主存块。  

26.D  

主存块太小，不能很好地利用空间局部性，从而导致缺失率变高；但主存块太大也会使得Cache行数变少，即Cache中可以存放主存块的位置变少，从而也会降低命中率。因此，主存块大小应该适中，既不能太大，又不能太小，通常为几十字节到上百字节。  
27.D  

命中率 $=$ Cache命中次数/总访问次数。注意看清题目，题中说明的是缺失50次，而不是命中50次，仔细审题是做对题的第一步。  

28. C  

由于Cache共有16块，采用二路组相联，共分为8组，组号为 $0,\,1,\,2,\cdots,\,7$ ，组号占3位。主存块大小为32B，按字节编址，块内地址占5位。主存单元地址 $129=0^{\cdots0}\;100\;00001$ ，后5位是块内地址，块内地址的前3位是组号，因此将映射到组号4的任意一个Cache块中。  

# 29.C  

地址映射采用二路组相联，主存字地址为 $0{\sim}1\!\cdot\!4{\sim}5\!\cdot\!8{\sim}9$ 可映射到第0组Cache中，主存地址为 $2{\sim}3{\sim}~6{\sim}7$ 可映射到第1组Cache中。Cache置换过程如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5c6d3488af8e8163b07751cb16ce02d55798381ef41b13fc464e42476c0971b7.jpg)  
注：“”表示当前访问块，“\*”表示本次访问命中。  

# 注意  

在不同的计算机组成原理教材中，关于组相联映射的介绍并不相同。通常是采用上题中的方式，也是本书及唐朔飞所编教材中的方式，但本题中采用的是蒋本珊所编教材中的方式。可以推断两次命题的老师应该不是同一老师，这也给考生答题带来了困扰。  

30.C  

分析语句“ $\mathsf{\tilde{a}[k]}=\mathsf{a[k]}+32^{\circ}$ ”：首先读取ak]需要访问一次ak]，之后将结果赋值给ak]需要访问一次，共访问两次。第一次访问ak未命中，并将该字所在的主存块调入Cache对应的块中，对该主存块中的4个整数的两次访问中，只在访问第一次的第一个元素时发生缺失，其他的7次访问中全部命中，因此该程序段执行过程中访问数组a的Cache缺失率约为1/8。  

31.A  

时间局部性是指最近的未来要用到的信息，很可能是现在正在使用的信息，本题的外层循环每次都会访问一次数组a，体现了时间局部性。空间局部性是指最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，本题在访问数组a的过程中是顺序访问的，体现了空间局部性。  

32.A  

Cache数据区大小为32KB，主存块的大小为32B，于是Cache中共有1K个Cache行，物理地址中偏移量部分的长度为5bit。因为采用直接映射方式，所以1K个Cache行映射到1K个分组，物理地址中组号部分的长度为10bit。32bit的主存地址除去5bit的偏移量和10bit的组号后，还剩17bit的tag部分。又因为Cache采用回写法，所以Cache行的总位数应为32B（数据位） $^+$ 17bit(tag位） $^+$ 1bit（脏位） $^+$ 1bit（有效位） $=$ 275bit。  

33.A  

Cache采用组相联映射，主存地址结构应分为Tag标记、组号、块内地址三部分。主存块大小 $=$ Cache块大小 $=64\mathrm{B}=2^{6}\mathrm{B}$ ，因此块内地址占6位。Cache数据区容量为32KB，每个Cache块大小为64B，则Cache总块数 $=\,32\mathrm{{KB}/64B}\,=\,2^{9}$ ，由于采用8路组相联映射，即每8个Cache块为一个分组，因此总共被分为 $2^{9}/8=2^{6}$ 组，因此，组号占6位。除了块内地址和组号，剩余的位为Tag标记，占 $32-6-6=20$ 位。地址结构如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6367334f9ded4fbae6a7b359ccdaedc1d6194c5bbf1663799c71f6d287334c98.jpg)  

Cache采用8路组相联映射，因此在访问一个物理地址时，要先根据组号定位到某一分组，然后用物理地址的高20位（Tag标记）与分组中8个Cache行的Tag标记做并行比较（用8个20位“比较器”实现），若某个Cache行的Tag标记与物理地址的高20位完全一致，则选中该Cache行。综上所述，在组相联映射的Cache中，“比较器”用于并行地比较分组中所有Cache行的Tag标记位与要访问物理地址的Tag标记位，因此比较器的个数就是分组中的Cache行数8，比较器的位数就是Tag标记位数20。  

# 二、综合应用题  

01.【解答】  

回写法（WriteBack）减少了访存次数，但存在不一致的隐患。因此若题目中出现了“较高的安全要求”，则尽量要使用写直通法（WriteThrough）。  

1）采用WriteBack策略较好，可减少访存次数。2）采用WriteThrough策略较好，能保证数据的一致性  

02.【解答】  

块大小为64B，因此块内地址字段占6位；Cache中有128个主存块，采用四路组相联，故Cache分为32组（ $128/4=321$ ），因此组号字段占5位；标记字段为剩余的 $32-5-6=21$ 位。  

数据Cache的总位数应包括标记项的总位数和数据块的位数。每个Cache块对应一个标记项，标记项中应包括标记字段、有效位和“脏”位（仅适用于回写法）。  

1）主存地址中Tag为21位，位于主存地址前部；组号Index为5位，位于主存地址中部；块内地址Offset为6位，位于主存地址后部。  

2）标记项的总位数 $=128{\times}(21+1+1)=128{\times}23=2944$ 位，数据块位数 $=128\!\times\!64\!\times\!8\!=\!65536$ 位，所以数据Cache的总位数 $=2944+65536=68480$ 位。  

03.【解答】  

1）由于 $64\mathrm{{KB}}/128\mathrm{{B}}=512$ ，因此有512行。而该Cache是四路组相联，所以 $512/4=128$ 组。  

2）每行有一个标记项，因此有512个标记项。主存字块标记长度就是标记位的长度，因为该Cache有128组 $(=2^{7})$ ），所以7位为组地址。而行长128B $(=2^{7})$ ），7位为字块内地址，因此该标记项中的标记位长度为 $32-7-7=18$ 位。  

3）LRU替换策略要记录每个Cache行的生存时间，因此每个标记项有两位替换控制位。而全写法没有“脏”位（一致性控制位），再加一个有效位即可。因此每个标记项位数是 $18+2+1=21$ 位，因此总大小为 $512\!\times\!21=10752$ 位。  

回写式则是每个标记项加一个一致性控制位，因此为 $512\!\times\!22=11264$ 位。  

04.【解答】  

块大小为32B，数组起始地址正好是一个主存块的开始，因此每8个数组元素占一个主存块：Cache共有 $256\mathrm{B}/32\mathrm{B}=8$ 行，采用2-路组相联映射时，Cache有4组。下面分析两种情况。  

1）直接映射。当  $s=64$  时：访存顺序为a[0],a[64];a[0],a[64]"；循环10000次。因为a[0] 所在主存块和a[64]所在主存块正好相差8个主存块，在直接映射方式下，除以8同余，  
这两个主存块会映射到同一个Cache行，每次都会发生冲突，缺失率为 $100\%$ 。当 $s=63$ 时：访存顺序为a[0],a[63],a[126]:a[0],a[63],a[126]；循环10000次。因为a[63]所在主存块和a[1261所在主存块正好相差8个主存块，在直接映射方式下，这两个主存块会映射到同一个Cache行，每次都会发生冲突，而a[0]不会发生冲突，缺失率约为 $67\%$  

2）2-路组相联映射。当  $s\,{=}\,64$  时：访存顺序为a[0],a[64]；a[0],a[64]，；循环10000次。因 为a[0]所在主存块和a[64]所在主存块正好相差8个主存块，在2-路组相联映射方式下，除以4同余，这两个主存块会映射到同一组，可放在同一组的不同Cache行中，不会发生冲突，总缺失次数仅为2次，缺失率近似为0.当  $s=63$  时：访存顺序为a[0],a[63],a[126] a[0],a[63]，a[126]，；循环10000次。因为a[63]所在主存块和a[126]所在主存块正好相差8个主存块，这两个主存块会映射到同一组，可放在同一组的不同Cache行中，而a[0]不会发生冲突，总缺失次数仅为3次，缺失率近似为0。  

05.【解答】  

1）每个Cache行对应一个标记项，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5b8b46f643df17cfaede8b1aa0b4e4b3f0c7a24d95f225e459403c0e5a084b5d.jpg)  

不考虑用于Cache一致性维护和替换算法的控制位。地址总长度为28位 $(2^{28}=256\mathrm{M})$ ，块内地址6位 $2^{6}\!=\!64)$ ，Cache块号3位 $\ 2^{3}=8$ ），因此Tag的位数为 $28-6-3=19$ 位，还需使用一个有效位，因此题中数据Cache行的结构如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb5acc0009f8543760c114f98c5cd228eb0b76b77dd344f3567ea462668afe6e.jpg)  

数据Cache共有8行，因此数据Cache的总容量为 ${\bf8}\!\times\!(64+20/8)\mathrm{{\bfB}}=532\mathrm{{\bfB}}$  

2）数组a在主存的存放位置及其与Cache之间的映射关系如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2bb734350f3df8989ece04f9459fe312b57e24670735ad7b4f962b26e81f7f78.jpg)  

数组按行优先方式存放，首地址为320，数组元素占4B。a[0][31]所在的主存块对应的Cache行号为 $(320+(0{\times}256+31){\times}4)\mathrm{div}2^{6}]\ \mathrm{mod}2^{3}=6;$ a[1][1]所在的主存块对应的Cache行号为 $(320+(1\!\times\!256+1)\!\times\!4)\mathrm{div}2^{6}]\bmod2^{3}=5.$  

【另解】由1）可知主存和Cache的地址格式如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1c6ed13a6f46155b86b2d616d6569c490fbe99a61d5bef41a08d41b179c3c3c7.jpg)  

数组按行优先方式存放，首地址为320，数组元素占4B。a[0][31]的地址为 $320+31{\times}4=$  $1\ 1011\ 1100_{\mathrm{B}}$ ，因此其对应的Cache行号为 $110_{\mathrm{B}}=6$ ；a[1][1]的地址为 $320+256{\times}4+1{\times}4=$  $1348=101\,0100\,0100_{\mathrm{B}}$ ，因此其对应的Cache行号为 $101_{\mathrm{B}}=5$  

3）编译时ijsum均分配在寄存器中，所以数据访问命中率仅考虑数组a的情况。  

数组a的大小为 $256{\times}256{\times}4\mathrm{B}=2^{18}\mathrm{B}$ ，占用 $2^{18}/64=2^{12}$ 个主存块，按行优先存放，程序A逐行访问数组a，共需访问的次数为 $2^{16}$ 次，未命中次数为 $2^{12}$ 次（即每个字块的第一个数未命中)，因此程序A的命中率为 $(2^{16}-2^{12})/2^{16}\times100\%=93.75\%$  

【另解】数组a按行存放，程序A按行存取。每个字块中存放16个int型数据，除访问的第一个不命中外，随后的15个全都命中，访问全部字块都符合这一规律，且数组大小为字块大小的整数倍，因此程序A的命中率为 $15/16=93.75\%$  

程序B逐列访问数组a，Cache总数据容量为 $64\mathrm{B}{\times}8=512\mathrm{B}$ ，数组a一行的大小为1KB，正好是Cache容量的2倍，可知不同行的同一列数组元素使用的是同一个Cache单元，因此逐列访问每个数据时，都会将之前的字块置换出，即每次访问都不会命中，命中率为0。  

因为从Cache读数据比从主存读数据快很多，所以程序A的执行比程序B快得多。  

# 06.【解答】  

1）CPU的时钟周期是主频的倒数，即  $1/800\mathrm{MHz}=1.25\mathrm{ns}$  总线的时钟周期是总线频率的倒数，即 $1/200\mathrm{MHz}=5\mathrm{ns}$ 总线宽度为32位，因此总线带宽为 $4\mathrm{B}{\times}200\mathrm{MHz}=800\mathrm{MB}/\mathrm{s}$ 或 $4\mathrm{B}/5\mathrm{ns}=800\mathrm{MB}/\mathrm{s}.$  

2）Cache块大小是32B，因此Cache缺失时需要一个读突发传送总线事务读取一个主存块。  

3）一次读突发传送总线事务包括一次地址传送、32B数据准备和传送：用一个总线时钟周期传输地址；之后每隔 $40\mathrm{ns}/8=5\mathrm{ns}$ 启动一个存储体（各进行一次读操作），第一个体准备数据花费 $40\mathrm{ns}$ ，之后这个字的传送操作与下一个字的准备操作重叠；用8个总线时钟周期传送数据。读突发传送总线事务时间为 $5\mathrm{ns}+40\mathrm{ns}+8{\times}5\mathrm{ns}=85\mathrm{ns}$  

另解：首先5ns的传送地址和命令，然后把存储体准备数据的时间视为流水线，因为总线周期是5ns，存储体的存储周期是 $40\mathrm{ns}$ ，所以相当于准备数据是一个8段流水线，因此准备8个数据的时间是 $40+5{\times}7,$ ，最后再花5ns传输最后一个数据，因为之前的7个存储体的数据的传输时间和其下一个存储体准备数据的时间是并行的，所以共需要 $5+40+5{\times}7+$  $5=85\mathrm{{ns}}$ 。也可以这样理解，将从数据准备到传输结束视为一个完整的流水线，也就是共视为9个流水段，每个流水段的时间是5ns，这样总共花费的时间就是 $5+45+7{\times}5=85\mathrm{ns}.$ 只要是有关于流水线思想的，最关键的就是分清楚流水段，剩下的就是简单计算，不同的算法不是关键，本质上都是一样的。  

4）CPU执行时间 $=$ Cache命中时的指令执行时间 $^+$ Cache未命中时的额外访存开销 $\times$ 缺失率。一条指令在Cache命中时的执行时间 $=$ Cache C PIx $\mathrm{\Omega}=\mathrm{\Omega}4{\times}1.25\mathrm{ns}\,=$ 5ns。一条指令因Cache缺失而导致的平均访存开销 $=$ 平均访存次数 $\times$ 一次突发传送总线事务时间 $=1.2{\times}85{\mathrm{ns}}\,=\,102{\mathrm{ns}}$ 。因此BP的CPU执行时间 $=(5\mathrm{ns}\ +\ 102\mathrm{ns}\!\times\!5\%)\!\times\!100\ =$  $1010\mathrm{ns}$ 。100条指令中，平均有 $95\%$ 的指令Cache命中，只需要5ns；平均有 $5\%$ 的指令Cache缺失，需要  $5\mathrm{ns}+102\mathrm{ns}=\!107\mathrm{ns}$  。本题说明了408真题采用先访问Cache再访问主 存的方式。  
07.【解答】  

1）主存块大小为  $64\mathrm{B}=2^{6}$  字节，故主存地址低6位为块内地址，Cache组数为  $32\mathrm{KB}{\cdot}(64\mathrm{B}{\times}8)=$   $64=2^{6}$ ，故主存地址中间6位为Cache组号，主存地址中高 $32-6-6\,{=}\,20$ 位为标记，采用8路组相联映射，故每行中的LRU位占3位，采用直写方式，故没有修改位。  

2） $\mathrm{0080\,000C0H}=\mathrm{0000\,0000\,1000\,0000\,0000\,0000\,1100\,0000B}$ ，主存地址的低6位为块内地址，为全0，故s位于一个主存块的开始处，占 $1024\times4\mathrm{B}/64\mathrm{B}=64$ 个主存块；在执行程序段的过程中，每个主存块中的 $64\mathrm{B}/4\mathrm{B}=16$ 个数组元素依次读、写1次，因而对每个主存块，总是第一次访问缺失，此时会将整个主存块调入Cache，之后每次都命中。综上，数组s的数据Cache访问缺失次数为64次。  

3) $\begin{array}{r}{0001\ 0003\mathrm{H}=0000\ 0000\ 0000\ 0001\ 0000\ 00000\ 000011\mathrm{B},}\end{array}$ 根据主存地址划分可知，组索引为O，故该地址所在主存块被映射到指令Cache的第0组；因为Cache初始为空，所有Cache行的有效位均为O，所以Cache访问缺失。此时，将该主存块取出后存入指令Cache的第0组的任意一行，并将主存地址高20位（00010H）填入该行标记字段，设置有效位，修改LRU位，最后根据块内地址000011B从该行中取出相应的内容。  

# 3.6虚拟存储器  

主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。  

# 3.6.1虚拟存储器的基本概念  

虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。  

用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。虚拟存储器的地址空间如图3.24所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3f30148f78a751f6de56c12ee740b690d95cef0f05379cb11a3386b06baf0ec8.jpg)  
图3.24虚拟存储器的三个地址空间  

CPU使用虚地址时，先判断这个虚地址对应的内容是否已装入主存。若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。若主存已满，则采用替换算法置换主存中的交换块（页面）。  

# 命题追踪虚拟存储器只能采用回写法的原因（2016）  

虚拟存储器也采用和Cache类似的技术，将辅存中经常访问的数据副本存放到主存中。但是缺页（或段）而访问辅存的代价很大，提高命中率是关键，因此虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而，在处理一致性问题时，采用回写法。  
# 3.6.2页式虚拟存储器  

页式虚拟存储器以页为基本单位。主存空间和虚拟地址空间都被划分成相同大小的页，主存空间中的页称为物理页、实页、页框，虚拟地址空间中的页称为虚拟页、虚页。页表记录了程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。  

# 1.页表  

图3.25是一个页表示例。有效位也称装入位，用来表示对应页面是否在主存，若为1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号：若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。脏位也称修改位，用来表示页面是否被修改过，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。引用位也称使用位，用来配合替换策略进行设置，例如是否实现最先调入（FIFO位）或最近最少用（LRU位）策略等。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8ab5292e69b51c36468563f144fde40a570b1a370f205fa85c05cc588cbae16.jpg)  
图3.25主存中的页表示例  

# 命题追踪数组的分页存放、缺页异常分析及缺页处理过程（2014、2019、2023）  

以图3.25的页表为例，假设CPU欲访问的数据在第1页，对应的有效位为1，说明该页已存放在主存中，再通过地址转换部件将虚拟地址转换为物理地址，然后到相应的主存实页中存取数据。若该数据在第5页，有效位为0，则发生“缺页”异常，需调用操作系统的缺页异常处理程序。缺页处理程序根据对应表项中的存放位置字段，将所缺页面从磁盘调入一个空闲的物理页框。若主存中没有空闲页框，还需要选择一个页面替换。由于采用回写策略，因此换出页面时根据脏位确定是否要写回磁盘。缺页处理过程中需要对页表进行相应的更新。  

页式虚拟存储器的优点是，页面的长度固定，页表简单，调入方便。缺点是，因为程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。  

# 2.地址转换  

# 命题追踪虚拟地址结构的分析（2011、2019、2021）  

在虚拟存储系统中，指令给出的地址是虚拟地址，因此当CPU执行指令时，要先将虚拟地址转换为主存物理地址，才能到主存中存取指令和数据。虚拟地址分为两个字段：高位为虚页号，低位为页内偏移地址。物理地址也分为两个字段：高位为物理页号，低位为页内偏移地址。由于两者的页面大小相同，因此页内偏移地址是相等的。虚拟地址到物理地址的转换是由页表实现的，页表是一张存放在主存中的虚页号和实页号的对照表。  
# 命题追踪虚拟地址主存物理地址（2011、2013、2018、2022）  

每个进程都有一个页表基址寄存器，存放该进程的页表首地址，据此找到对应的页表首地址（对应 $^\mathrm{\textregistered}$ )，然后根据虚拟地址高位的虚拟页号找到对应的页表项（对应 $\mathcal{Q}$ ），若装入位为1，则取出物理页号（对应 $\textcircled{3}$ ），和虚拟地址低位的页内地址拼接，形成实际物理地址（对应 $^{(4)}$ ）。若装入位为0，说明缺页，需要操作系统进行缺页处理。地址变换过程如图3.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8abbc24dc44951166da271761d02b9beff867be6de5e5dc08cc6e6325bcebf8e.jpg)  
图3.26页式虚拟存储器的地址变换过程  

3.快表（TLB）  

由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。若缺页，则还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。  

# 命题追踪TLB的硬件实现（2018），TLB和Cache的比较（2020）  

依据程序访问的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表（TLB）中，则可以明显提高效率。相应地把放在主存中的页表称为慢表（Page）。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。  

# 命题追踪TLB映射方式、地址划分与标记字段：与Cache相同（2016、2021）  

快表用SRAM实现，其工作原理类似于Cache，通常采用全相联或组相联映射方式。TLB表项由页表表项内容和TLB标记组成。全相联映射下，TLB标记就是对应页表项的虚拟页号；组相联方式下，TLB标记则是对应虚拟页号的高位部分，而虚拟页号的低位部分作为TLB组的组号。  

# 4.具有TLB和Cache的多级存储系统  

图3.27是一个具有TLB和Cache的多级存储系统，其中Cache采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换；若未命中，则TLB缺失，需要访问主存去查页表。图中所示的是两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送给CPU。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/631bb0e61b3bdacef3897c62f9b2563c6e1aa46c348e5f719e87b9db2f47ed57.jpg)  
图3.27TLB和Cache的访问过程  

查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并且使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。  

# 命题追踪TLB、Cache和Page缺失组合的分析（2010）  

在一个具有TLB和Cache的多级存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问，访问过程如图3.28所示。可见，CPU访存过程中存在三种缺失情况： $\textcircled{\scriptsize{1}}$ TLB缺失：要访问的页面的页表项不在TLB中： $\circledcirc$ Cache缺失：要访问的主存块不在Cache中： $\textcircled{3}$ Page缺失：要访问的页面不在主存中。由于TLB只是页表的一部分副本，因此Page缺失时，TLB也必然缺失。同理，Cache也只是主存的一部分副本，页表未命中意味着信息不在主存，因此Page缺失时，Cache也必然缺失。这三种缺失的可能组合情况如表3.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/410f211a8065de602231efcdde6fb31482045afcb7cd24653c854c6b447608e7.jpg)  
图3.28带TLB虚拟存储器的CPU访存过程  
表3.3TLB、Page、Cache三种缺失的可能组合情况
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5449e48e05a1210c3ad8e1dda8ec750f02c257f2e7997847b56ece5d409deea7.jpg)  

最好的情况是第1种组合，此时无须访问主存；第2种和第3种组合都需要访问一次主存；第4种组合需要访问两次主存；第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。Cache缺失处理由硬件完成；缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现：而TLB缺失既可以用硬件，又可以用软件来处理。  

# 注意  

在《操作系统考研复习指导》的第3章中，介绍了在同时具有TLB和Cache的存储系统中虚实地址转换的实例，读者可以结合这些内容进行学习。  

# 3.6.3段式虚拟存储器  

段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。因为段的长度可变，所以段表中要给出各段的起始地址与段的长度。  

CPU根据虚拟地址访存时，首先根据段表基地址与段号拼接成对应的段表项，然后根据该段表项的装入位判断该段是否已调入主存（装入位为“1”，表示该段已调入主存；装入位为“0”表示该段不在主存中）。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。段式虚拟存储器的地址变换过程如图3.29所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1b0fa6804dac3b58468ab24b6f02dbc573bbcb4d48f2326802894513dae0c641.jpg)  
图3.29段式虚拟存储器的地址变换过程  

因为段本身是程序的逻辑结构所决定的一些独立部分，因而分段对程序员来说是不透明的：而分页对程序员来说是透明的，程序员编写程序时不需知道程序将如何分页。  

段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。  
# 3.6.4段页式虚拟存储器  

在段页式虚拟存储器中，把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本交换单位。每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。  

虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。  

段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。  

# 3.6.5 虚拟存储器与Cache的比较  

虚拟存储器与Cache既有很多相同之处，又有很多不同之处。  

# 1.相同之处  

1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。2）都把数据划分为小信息块，并作为基本的交换单位，虚存系统的信息块更大3）都有地址映射、替换算法、更新策略等问题。4）都依据局部性原理应用“快速缓存”的思想，将活跃的数据放在相对高速的部件中。  

# 2.不同之处  

1）Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。  

2）Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。  

# 命题追踪Cache缺失和缺页的处理开销对比（2016）  

3）对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。  

4）CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。  

# 3.6.6 本节习题精选  

# 一、单项选择题  

01.为使虚拟存储系统有效地发挥其预期的作用，所运行程序应具有的特性是（）。  

A.不应含有过多的I/O操作B.大小不应小于实际的内存容量C.应具有较好的局部性D.顺序执行的指令不应过多  

02.虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（）。  

A.在程序的执行过程中，程序对主存的访问是不均匀的B.空间局部性C.时间局部性D.代码的顺序执行  
03.虚拟存储器的常用管理方式有段式、页式、段页式，对于它们在与主存交换信息时的单位，以下表述正确的是（）。  

A.段式采用“页”B.页式采用“块”C.段页式采用“段”和“页” D.页式和段页式均仅采用“页”  

04.下列关于虚存的叙述中，正确的是（）  

A.对应用程序员透明，对系统程序员不透明B.对应用程序员不透明，对系统程序员透明C.对应用程序员、系统程序员都不透明D.对应用程序员、系统程序员都透明  

05.在虚拟存储器中，当程序正在执行时，由（）完成地址映射。  

A.程序员B.编译器C.装入程序D.操作系统  

06.采用虚拟存储器的主要目的是（）  

A.提高主存储器的存取速度B.扩大主存储器的存储空间C.提高外存储器的存取速度D.扩大外存储器的存储空间  

07.下列关于Cache与虚拟存储器的说法中，错误的有（）  

I.一次访存时，页表不命中，则Cache一定也不命中I1.Cache不命中的损失要大于页表不命中的损失III.Cache和TLB缺失后的处理都由硬件完成IV.虚拟存储器的实际容量可以大于主存和辅存的容量之和  

A.I和II B.II和ⅢI C.I和IⅢ和IV D.II和IⅢI和IV

 08.下列有关页式存储管理的叙述中，错误的是（）  

A.进程地址空间被划分成等长的页，内存被划分成同样大小的页框 B.采用全相联映射，每页可以映射到任何一个空闲的页框中C.当从磁盘装入的信息不足一页时会产生页内碎片D.相对于段式存储管理，分页式更利于存储保护  

09.下列有关虚拟存储管理机制中地址转换的叙述，错误的是（）。  

A.地址转换是指把逻辑地址转换为物理地址B.通常逻辑地址的位数比物理地址的位数少C.地址转换过程中会发现是否“缺页D.内存管理单元（MMU）在地址转换过程中要访问页表项  

10.下列有关虚拟存储管理机制的页表的叙述中，错误的是（）  

A.系统中每个进程有一个页表B.页表中每个表项与一个虚页对应C.每个页表项中都包含装入位（有效位）D.所有进程都可以访问页表  

11.下列有关缺页处理的叙述中，错误的是（）  

A.若对应页表项中的有效位为0，则发生缺页B.缺页是一种外部中断，需要调用操作系统提供的中断服务程序来处理C.缺页处理过程中需根据页表中给出的磁盘地址去读磁盘数据D.缺页处理完后要重新执行发生缺页的指令  

12.下列关于段式虚拟存储管理的叙述中，错误的是（）。A.段是逻辑结构上相对独立的程序块，因此段是可变长的B.按程序中实际的段来分配主存，所以分配后的存储块是可变长的C.每个段表项必须记录对应段在主存的起始位置和段的长度D.分段方式对低级语言程序员和编译器来说是透明的  
13.虚拟存储器中的页表有快表和慢表之分，下面关于页表的叙述中正确的是（）。  

A.快表与慢表都存储在主存中，但快表比慢表容量小B.快表采用了优化的搜索算法，因此查找速度快C.快表比慢表的命中率高，因此快表可以得到更多的搜索结果D.快表采用相联存储器件组成，按照查找内容访问，因此比慢表查找速度快  

14.【2010统考真题】下列命令组合的一次访存过程中，不可能发生的是（）。  

A.TLB未命中，Cache未命中，Page未命中B.TLB未命中，Cache命中，Page命中C.TLB命中，Cache未命中，Page命中D.TLB命中，Cache命中，Page未命中  

15.【2013统考真题】某计算机主存地址空间大小为  $256\:\mathrm{MB}$  ，按字节编址。虚拟地址空间大 小为4GB，采用页式存储管理，页面大小为4KB，TLB（快表）采用全相联映射，有4个页表项，内容如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40338a01191962a384c04d698c859a8aa3d9cd14fe4daeb2c62081e89ed7f01d.jpg)  

则对虚拟地址03FFF180H进行虚实地址变换的结果是（）A.0153180HB.003 5180HC.TLB缺失D.缺页  

16.【2015统考真题】假定编译器将赋值语句 $^{\mathrm{u}}\mathrm{x=x}\mathrm{+}\mathrm{3}.$ ”转换为指令“addxaddr, $_{3},$ ，其中xaddr是x对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache使用直写方式，则完成该指令功能需要访问主存的次数至少是（）。  

A.0 B. 1 C. 2 D.3  

17.【2015统考真题】假定主存地址为32位，按字节编址，主存和Cache之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写方式，则能存放4K字数据的Cache的总容量的位数至少是（）。  

A.146K B.147K C.148K D.158K

 18.【2019统考真题】下列关于缺页处理的叙述中，错误的是（）。  

A.缺页是在地址转换时CPU检测到的一种异常B.缺页处理由操作系统提供的缺页处理程序来完成C.缺页处理程序根据页故障地址从外存读入所缺失的页D.缺页处理完成后回到发生缺页的指令的下一条指令执行  

19.【2020统考真题】下列关于TLB和Cache的叙述中，错误的是（）  

A.命中率都与程序局部性有关B.缺失后都需要去访问主存C.缺失处理都可以由硬件实现D.都由DRAM存储器组成  
20.【2022统考真题】某计算机主存地址为24位，采用分页虚拟存储管理方式，虚拟地址空间大小为4GB，页大小为4KB，按字节编址。某个进程的页表部分内容如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db74c64561f3cac5ede5b6a153be651c2c343742d01487e8dbf91b09e09391ee.jpg)  

当CPU访问虚拟地址00082840H时，虚-实地址转换的结果是（）  

A.得到主存地址024840HB.得到主存地址180840HC.得到主存地址018840HD.检测到缺页异常  

# 二、综合应用题  

01.某计算机系统采用虚拟页式存储管理，某个进程的页表见下表，每项的起始编号是0，所有的地址均按字节编址，每页大小为1024B。分别将逻辑地址0793，1197，2099，33204188，5332，转换为物理地址，写出计算过程，对不能计算的说明为什么。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42f72205e1a1cf6c7307f332f6a3efb1d4f5ef3d1f3430ba1ddc83d80fad77fb.jpg)  

02.下图表示使用快表（页表）的虚实地址转换条件，快表存放在相联存储器中，其容量为8个存储单元。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/194de8f74cf08d7e64e68d1b528fa4dee862014095c02d3bd32141f23124d29b.jpg)  

1）当CPU按虚拟地址1去访问主存时，主存的实地址码是多少？2）当CPU按虚拟地址2去访问主存时，主存的实地址码是多少？3）当CPU按虚拟地址3去访问主存时，主存的实地址码是多少？  

03.一个两级存储器系统有8个磁盘上的虚拟页面需要映像到主存中的4个页中。某程序生成以下访存页面序列： $1,0,2,2,1,7,6,7,0,1,2,0,3,0,4,5,1,5,2,4,5,6,7,6,7,2,4,2,7,3,0,2,0,0,2,0,3,0,4,5,1,5,2,4,5,6,7,6,7,2,4,2,7,3,0,2,0,0,2,0,3,0,4,5,1,5,2,4,5,6,7,6,7,2,4,2,7,3,0,2,0,0,2,0,0,3,0,0,4,5,1,5,2,4,5,6,7,6,7,6,7,2,4,2,7,3,0,2,0,0,2,0,0,3,0,0,4,5,1,5,2,4,5,6,7,6,7,2,4,2,7,3,0,2,0,0,2,0,0,3,0,0,0,4,5,1,5,5,2,4,5,6,7,6,7,6,7,2,2,4,2,7,3,0,2,0,0,2,0,0,3,0,0,0,0,2,0,0,0,2,0,0,0,1,1,1,1,5,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0$ 采用LRU替换策略，设初始时主存为空。1）画出每个页号访问请求之后存放在主存中的位置。2）计算主存的命中率。  
04.【2011统考真题】某计算机存储器按字节编址，虚拟（逻辑）地址空间大小为16MB 主存（物理）地址空间大小为1MB，页面大小为4KB；Cache采用直接映射方式，共8行；主存与Cache之间交换的块大小为32B。系统运行到某一时刻时，页表的部分内容和Cache的部分内容分别如下的左图和右图所示，图中页框号及标记字段的内容为十六进制形式。  

回答下列问题：  

1）虚拟地址共有几位，哪几位表示虚页号？物理地址共有几位，哪几位表示页框号（物理页号）？  

2）使用物理地址访问Cache时，物理地址应划分成哪几个字段？要求说明每个字段的位数及在物理地址中的位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a83251329116dd061c4cd041f8a00c1a4f65f03f94dbe7445e55d49d1ffe81c9.jpg)  

3）虚拟地址001C60H所在的页面是否在主存中？若在主存中，则该虚拟地址对应的物理地址是什么？访问该地址时是否Cache命中？要求说明理由。  

4）假定为该机配置一个四路组相联的TLB，共可存放8个页表项，若其当前内容（十六进制）如下图所示，则此时虚拟地址024BACH所在的页面是否存在主存中？要求说明理由。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/39640b3a3488ba9948d3efe47bed443c8606784f33dda3208976292f8f49a506.jpg)  

05.【2016统考真题】某计算机采用页式虚拟存储管理方式，按字节编址，虚拟地址为32位，物理地址为24位，页大小为8KB；TLB采用全相联映射；Cache数据区大小为64KB，按二路组相联方式组织，主存块大小为64B。存储访问过程的示意图如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a5ccae841ba4336d4bf7ebd07f035d4f3ee3c03366776b2baec7225c885b492.jpg)  
回答下列问题：  

1）图中字段A～G的位数各是多少？TLB标记字段B中存放的是什么信息？2）将块号为4099的主存块装入Cache时，所映射的Cache组号是多少？对应的H字段内容是什么？3）是Cache缺失处理的时间开销大还是缺页处理的时间开销大？为什么？4）为什么Cache可以采用直写策略，而修改页面内容时总是采用回写策略？  

06.【2018统考真题】某计算机采用页式虚拟存储管理方式，按字节编址。CPU进行存储访问的过程如下图所示。根据该图回答下列问题。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bf57f0c7b1cf63bf4768a5cfd1834fc0b39f206f3dcdfbe951e8c66520724b32.jpg)  

1）主存物理地址占多少位？2）TLB采用什么映射方式？TLB是用SRAM还是用DRAM实现？  

3）Cache采用什么映射方式？若Cache采用LRU替换算法和回写策略，则Cache每行中除数据（Data）、Tag和有效位外，还应有哪些附加位？Cache总容量是多少？Cache中有效位的作用是什么？  

4）若CPU给出的虚拟地址为0008C040H，则对应的物理地址是多少？是否在Cache中命中？说明理由。若CPU给出的虚拟地址为 $0007\,\mathrm{C}260\mathrm{H}$ ，则该地址所在主存块映射到的Cache组号是多少？  

07.【2021统考真题】假设计算机M的主存地址为24位，按字节编址；采用分页存储管理方式，虚拟地址为30位，页大小为4KB；TLB采用二路组相联方式和LRU替换策略，共8组。请回答下列问题。  

1）虚拟地址中哪几位表示虚页号？哪几位表示页内地址？2）已知访问TLB时虚页号高位部分用作TLB标记，低位部分用作TLB组号，M的虚拟地址中哪几位是TLB标记？哪几位是TLB组号？  

3）假设TLB初始时为空，访问的虚页号依次为10,12,16.7,26,4,12和20，在此过程中，哪一个虚页号对应的TLB表项被替换？说明理由。4）若将M中的虚拟地址位数增加到32位，则TLB表项的位数增加几位？  
08.【2023统考真题】已知计算机M的字长为32位，按字节编址，采用请求调页策略的虚 拟存储管理方式，虚拟地址为32位，页大小为4KB；数据Cache采用4路组相联映射方式，数据区大小为8KB，主存块大小为 $32\mathrm{B}_{c}$ 、现有C语言程序段如下：int a[24][64]; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $_{\mathrm{i}<24}$   $\ \ \ \mathrm{i}_{\ ++}$  for(  $\scriptstyle{\dot{\mathbf{\rho}}}=0$   ${<}64$   $\j++$  )a[i][j]  $\scriptstyle=10$  已知二维数组a按行优先存放，在虚拟地址空间中分配的起始地址为00422000H,sizeof(int) $=4$ 假定在M上执行上述程序段之前数组a不在主存，且在该程序段执行过程中不会发生页面置换。请回答下列问题：1）数组a分布在几个页面中？对于数组a的访问，会发生几次缺页异常？页故障地址各是什么?2）不考虑变量i和j，该程序段的数据访问是否具有时间局部性？为什么？3）计算机M的虚拟地址（A31～A0）中哪几位用作块内地址？哪几位用作Cache组号？a[1][0]的虚拟地址是多少？其所在主存块对应的Cache组号是多少？4)数组a占用多少主存块？假设上述程序段执行过程中数组a的访问不会和其他数据发生Cache访问冲突，则数组a的Cache命中率是多少？若将循环中i和j的次序按如下方式调换：for(  $\mathtt{j}\!=\!0$   $j\!<\!64$   $\j++$  for(  $\scriptstyle{\dot{\mathbf{z}}}=0$   $_{\mathrm{i}<24}$   $\dot{\mathbf{\nabla}}^{\dot{\mathbf{L}}}+\dot{\mathbf{\nabla}}^{\dot{\mathbf{L}}}$  a[i][j]  $^{=10}$  则数组a的Cache命中率又是多少？  

# 3.6.7 答案与解析  

# 一、单项选择题  

01.C  

虚拟存储系统利用的是局部性原理，程序应当具有较好的局部性，C正确。而含有输入、输出操作产生中断，与虚存无关，A错误。大小较小但可以多个程序并发执行，也可以发挥虚存的作用，B错误。。顺序执行的指令应当占较大比重为宜，这样可增强程序的局部性，D错误。  

02.A  

局部性原理的含义是在一个程序的执行过程中，其大部分情况下是顺序执行的，某条指令或数据使用后，在最近一段时间内有较大的可能再次被访问（时间局部性）：某条指令或数据使用后，其邻近的指令或数据可能在近期被使用（空间局部性）。在虚拟存储管理系统中，程序只能访问主存获得指令和数据，A正确。选项B、C、D均是局部性原理的一个方面而已。  

03.D  

页式虚拟存储方式对程序分页，采用页进行交互；段页式则先按照逻辑分段，然后分页，以页为单位和主存交互，D正确。  

04.A  

虚存需要通过对操作系统实现地址映射，因此对操作系统的设计者即系统程序员是不透明的。而应用程序员写的程序所使用的是逻辑地址（虚地址），因此对其是透明的。  

05.D  

虚拟存储器中，地址映射由操作系统来完成，但需要一部分硬件基础的支持，如快表、地址映射系统等。  
06.B  

引入虚拟存储器的目的是为了解决内存容量不够大的问题。  

07.D  

页表不命中，表示该页面没有调入主存，而Cache是页面的副本，因此Cache一定也不命中，I正确。Cache不命中时只需从主存读取数据，页表不命中时需要从辅存读取数据，而辅存的速度比主存慢很多，IⅡI错误。Cache缺失处理由硬件完成，TLB缺失处理既可以由硬件完成，又可以由软件完成，IⅢI错误。虚拟存储器的实际容量小于或等于主存和辅存的容量之和，IV错误。  

08.D  

段的分界与程序的逻辑分界相对应，使得它易于编译、修改、保护和共享。  

09.B  

虚拟存储管理的目的是让程序员可以在一个比主存地址空间大得多的虚拟地址空间中编程，显然逻辑地址空间比主存空间大，因此逻辑地址的位数比物理地址的位数多，B错误。在执行程序时，由CPU中的MIMU进行逻辑地址到物理地址的转换。在转换过程中，MMU需要查找对应的页表项，根据页表项中的装入（有效）位是否为1来确定是否发生缺页。  

10.D  

选项A、B和C都正确。页表中的每个表项反映的是对应虚拟页面的位置和使用等信息，通常只能由操作系统和硬件进行访问，虚拟存储管理机制对用户进程来说是透明的，D错误。  

11.B  

缺页是CPU在执行指令过程中进行取指令或读/写数据时发生的一种故障，属于内部异常。  

12.D  

选项A、B和C都正确。分段方式对低级语言程序员和编译器来说是不透明的，因为低级语信程序员需要使用段号来编程，编译器需要使用段号来链接，D错误。  

13.D  

快表采用高速相联存储器，它的速度快来源于硬件本身，而不是依赖搜索算法来查找的；慢表存储在内存中，通常是依赖于查找算法，故A和B错误。快表与慢表的命中率没有必然联系，快表仅是慢表的一个部分拷贝，不能够得到比慢表更多的结果，C错误。  

14.D  

Cache的内容是主存的一部分副本，TLB的内容是Page（页表）的一部分副本。在同时具有TLB和Cache的虚拟存储系统中，CPU发出访存命令，先查找对应的Cache块。1）若Cache命中，则说明所需内容在Cache内，其所在页面必然已调入主存，因此Page必然命中，但TLB不一定命中。2）若Cache未命中，则并不能说明所需内容未调入主存，和TLB、Page命中与否没有联系。但若TLB命中，Page也必然命中；而当Page命中，TLB则未必命中，因此D不可能发生。  

15.A  

按字节编址，页面大小为4KB，页内地址共12位。地址空间大小为4GB，虚拟地址共32位，前20位为页号。虚拟地址为03FFF180H，因此页号为03FFFH，页内地址为 $180\mathrm{H}$ 。查找页标记03FFFH所对应的页表项，页框号为0153H，页框号与页内地址拼接即为物理地址 $015\,3180\mathrm{H}$  

16.B  

上述指令的执行过程可划分为取数、运算和写回过程，取数时读取xaddr可能不需要访问主存而直接访问Cache，而直写方式需要把数据同时写入Cache和主存，因此至少访问1次。  
17.C  

直接映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/29a5cd848995adbcdc0b0a61ee30283897b0755702526a702eedcbfd9f298149.jpg)  

按字节编址，块大小为  $4{\times}32$  位  ${\it\Omega}=16{\mathrm{B}}=2^{4}{\mathrm{B}}$  ，则“字块内地址”占4位；“能存放4K字数据 的Cache”即Cache 的存储容量为4K字（注意单位），则Cache共有 $1\mathrm{K}=2^{10}$ 个Cache行，Cache字块标记占10位；主存字块标记占  $32-10-\,4=18$  位。  

Cache的总容量包括：存储容量和标记阵列容量（有效位、标记位、一致性维护位和替换算 法控制位）。标记阵列中的有效位和标记位一定存在，而一致性维护位（脏位）和替换算法控制位的取舍标准是看词眼，题目中明确说明了采用回写法，则一定包含一致性维护位，而关于替换算法的词眼题目中未提及，所以不予考虑。因此，每个Cache行标记项包含 $18+1+1=20$ 位，标记阵列容量为  $2^{10}{\times}20$  位  $=20\mathrm{K}$  位，存储容量为  $4K\!\times\!32$  位  $=128\mathrm{K}$  位，总容量为  $128\mathrm{K}+20\mathrm{K}=$  148K位。  

18. D  

在请求分页系统中，每当要访问的页面不在内存中时，CPU检测到异常，便会产生缺页中断，请求操作系统将所缺的页调入内存。缺页处理由缺页中断处理程序完成，根据发生缺页故障的地址从外存读入所缺失的页，缺页处理完成后回到发生缺页的指令继续执行。选项D中描述回到发生缺页的指令的下一条指令执行，明显错误。  

19.D  

Cache由SRAM组成；TLB也由SRAM组成。DRAM需要不断刷新，性能偏低，不适合组成TLB和Cache。选项A、B C T LB Cache。  

20.C  

页大小为  $4\mathrm{KB}=2^{12}\mathrm{B}$  ，按字节编址，故页内地址为12位。虚拟地址空间大小为  $4\mathrm{GB}=2^{32}\mathrm{B}$  故虚拟地址共32位，其中低12位为页内地址，高20位为虚页号。题中给出的虚拟地址为00082840H，虚页号为高20位即00082H（页内地址为低12位即840H），82H对应的十进制数为130（注意题中页表的虚页号部分末尾未写H，所以是十进制数，故查找时要先将虚页号转换为十进制数），查页表命中，并且存在位为1，对应页框号为018H。将查找到的页框号018H和页内地址840H拼接，得到主存地址为 $01\ 8840\mathrm{H}$  

# 二、综合应用题  

01.【解答】  

所有地址均可转换为页号和页内偏移量。地址转换时，先取出逻辑页号，然后查找页表，得到页框号，再将页框号与页内偏移量拼接，即可获得物理地址。根据题意，计算逻辑地址的页号和页内偏移量，拼接的物理地址如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/35e3d360d5c97ebd6263089d17a2af929bf5def7da1edfb5365702b009e69319.jpg)  
注：在本题中，物理地址 $=$ 页框号×1024B $^+$ 页内偏移量，页内偏移量 $=$ 逻辑地址-逻辑页号x1024B，逻辑页号 $=$ 逻辑地址/1024B（结果向下取整）。  
02.【解答】  

1）虚拟地址1的页号为15，页内地址为0324，在左表中页号15对应的主存起始位置为80000，则主存的实地址码为 $0324+80000=80324$  

2）按1）中的方法易知，主存的实地址码为 $0128+96000=96128$  

3）虚拟地址3的页号为48，在左表中无对应项，因此该页面在快表（页表）中无记录。  

03.【解答】  

1）LRU替换策略是换出最近最久未使用的页面，因此每个页号访问请求之后存放在主存中的位置如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5d97e102b608f5c205626050b04deabe246839b152fb0bfb7da24dcff7349ab.jpg)  

2）共30次访存，有13次命中，因此主存的命中率为 $13/30=43\%$  

04.【解答】  

1）存储器按字节编址，虚拟地址空间大小为 $16\mathrm{MB}=2^{24}\mathrm{B}$ ，因此虚拟地址为24位；页面大小为 $4\mathrm{KB}=2^{12}\mathrm{B}$ ，因此高12位为虚页号。主存地址空间大小为 $1\mathrm{MB}=2^{20}\mathrm{B}$ ，因此物理地址为20位；由于页内地址为12位，因此高8位为物理页号。  

2）因为Cache采用直接映射方式，所以物理地址各字段的划分如下  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a7e72355443358451452532f9144a08fa1fe2e9dda183d0e916ebb4a4e3f9f0.jpg)  

由于块大小为32B，因此字块内地址占5位；Cache共8行，因此Cache字块标记占3位；主存字块标记占 $20-5-3=12$ 位。  

3）虚拟地址001C60H的前12位为虚页号，即 $001\mathrm{H}$ ，查看 $001\mathrm{H}$ 处的页表项，其对应的有效位为1，因此虚拟地址 $001\mathrm{C}60\mathrm{H}$ 所在的页面在主存中。页表 $001\mathrm{H}$ 处的页框号为 $\mathrm{04H}$ ，与页内偏移（虚拟地址后12位）拼接成物理地址 $04\mathrm{C}60\mathrm{H}_{\circ}$ 物理地址 $\mathrm{04C60H}=0000\ 0100$  $1100\ 0110\ 0000\mathrm{B}$ ，主存块只能映射到Cache的第3行（即第011B行），由于该行的有效位 $=1$ ，标记（值为105H） $\neq04\mathrm{CH}$ （物理地址高12位），因此未命中。  

4）由于TLB采用四路组相联，因此TLB被分为 $8/4=2$ 个组，因此虚页号中高11位为TLB标记、最低1位为TLB组号。虚拟地址  $\mathrm{024BACH}=0000\ 0010\ 0100\ 1011\ 1010\ 1100B}$  ，虚 页号为 $\mathrm{0000\0010\ 0100B}$ ，TLB标记为 $\mathrm{0000\0010\ 010B}$ （即012H），TLB组号为0B，因此该虚拟地址所对应的物理页面只能映射到TLB的第0组。组O中存在有效位 $=1$ 、标记 $=012\mathrm{H}$ 的项，因此访问TLB命中，即虚拟地址024BACH所在的页面在主存中。  

05.【解答】  

1）页大小为8KB，页内偏移地址为13位，因此 ${\mathrm{A}}={\mathrm{B}}=32-13=19;{\mathrm{~}}{\mathrm{D}}=13;{\mathrm{~}}{\mathrm{C}}=24-13=$ 11；主存块大小为64B，因此 $\mathrm{G}=6$ 。二路组相联，每组数据区容量有 $64\mathrm{B}{\times}2=128\mathrm{B}$ ，共有 $64\mathrm{{KB}}/128\mathrm{{B}}=512$ 组，因此 $\mathrm{F}=9$  $\mathrm{E}=24-\mathrm{G}-\mathrm{F}=24-6-9=9\,.$  

因而 $\mathbf{A}=19$ ， $\mathbf{B}=19$ ， $C=11$ ， $\mathrm{D}=13$ ， $\mathrm{E}=9$ ，F=9，G=6。TLB中标记字段B的内容是虚页号，表示该TLB项对应哪个虚页的页表项。  

2）块号 $4099=00\;0001\;0000\;0000\;0011\mathrm{B}$ ，因此所映射的Cache组号为 $0\ 0000\ 0011\mathbf{B}=3$ ，对  
应的H字段内容为 $0\,\,0000\,\,1000\mathrm{B}$  

3）Cache缺失带来的开销小，而处理缺页的开销大。因为缺页处理需要访问磁盘，而Cache缺失只要访问主存。  

4）因为采用直写策略时需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以在Cache-主存层次，Cache可以采用直写策略，而在主存-外存（磁盘）层次，修改页面内容时总是采用回写策略。  

06.【解答】  

1）物理地址由实页号和页内地址拼接，因此其位数为 $16+12=28$ ；或直接得 $20+3+5\!=\!28$  

2）TLB采用全相联映射，可把页表内容调入任意一块空TLB项中，TLB中的每项都有一个比较器，没有映射规则，只要空闲就行。TLB采用静态存储器（SRAM），读/写速度快，但成本高，多用于容量较小的高速缓冲存储器。  

3）图中可看到，Cache中每组有两行，因此采用二路组相联映射方式。因为是二路组相联并采用LRU替换算法，所以每行需要1位LRU位；因为采用回写策略，所以每行有1位修改位（脏位），根据脏位判断数据是否被更新，若脏位为1，则需要写回内存。28位物理地址中Tag字段占20位，组索引字段占3位，块内偏移地址占5位，因此Cache共有 $2^{3}\!=\!8$ 组，每组2行，每行有 $2^{5}\,{=}\,32\mathrm{B}$ ；Cache的总容量为 $8{\times}2{\times}(20+1+1+1+32{\times}8)=4464{\tt b}=558{\tt B}$ Cache中有效位用来指出所在Cache行中的信息是否有效。  

4）虚拟地址分为两部分：虚页号、页内地址；物理地址分为两部分：实页号、页内地址。利用虚拟地址的虚页号部分去查找TLB表（缺失时从页表调入），将实页号取出后和虚拟地址的页内地址拼接，形成物理地址。虚页号0008CH恰好在TLB表中对应实页号0040H（有效位为1，说明存在），虚拟地址的后3位为页内地址 $040\mathrm{H}$ ，对应的物理地址是0040040H。物理地址为0040040H，其中高20位00400H为标志字段，低5位00000B为块内偏移量，中间3位010B为组号2，因此将00400H与Cache中的第2组两行中的标志字段同时比较，可以看出，虽然有一个Cache行中的标志字段与00400H相等，但对应的有效位为0，而另一Cache行的标志字段与00400H不相等，因此访问Cache不命中。因为物理地址的低12位与虚拟地址的低12位相同，即为 $0010\,0110\,0000\mathrm{B}$ 。根据物理地址的结构，物理地址的后八位01100000B的前三位011B是组号，因此该地址所在的主存映射到Cache组号为3。  

# 07.【解答】  

注意：对于本题的TLB，需要采用处理Cache的方式求解。1）按字节编址，页面大小为 $4\ \mathrm{KB}=2^{12}\mathrm{B}$ ，页内地址为12位。虚拟地址中高 $30-12=18$ 位表示虚页号，虚拟地址中低12位表示页内地址。2）TLB采用二路组相联方式，共 $8\,=\,2^{3}$ 组，用3位来标记组号。虚拟地址（或虚页号）中高 $18-3=15$ 位为TLB标记，虚拟地址中随后3位（或虚页号中低3位）为TLB组号。3）虚页号4对应的TLB表项被替换。因为虚页号与TLB组号的映射关系为TLB组号 $=$ 虚页号modTLB组数 $=$ 虚页号 $\mod8$ ，因此，虚页号10,12，16,7,26,4,12,20映射到的TLB组号依次为 $2,4,0,7,2,4,4,4$ 。TLB采用二路组相联方式，从上述映射到的TLB组号序列可以看出，只有映射到4号组的虚页号数量大于2，相应虚页号依次是12，4，12和20。根据LRU替换策略，当访问第20页时，虚页号4对应的TLB表项被替换出来。4）虚拟地址位数增加到32位时，虚页号增加了 $32\!-\!30\,=\,2$ 位，使得每个TLB表项中的标  
记字段增加2位，因此，每个TLB表项的位数增加2位。  

08.【解答】  

1）数组a的起始地址为 $0042\,2000\mathrm{H}$ ，页大小为4KB，所以页内偏移量占12位，数组a共有 $24{\times}64=1536$ 个元素，每个int型数据占4字节，因此数组a共占 $1536\!\times\!4\mathrm{B}=6\mathrm{KB}$ ，故分布在2个相邻的页面中。页号分别为00422H和00423H，当访问这两个页面的第一个数组元素的地址时，因为页面尚未调入内存，所以会发生2次缺页异常，两个页故障地址分别是00422000H和 $0042\,3000\mathrm{H}$  

2）若不考虑变量i和j，该程序段的数据访问只涉及对数组元素的访问，由于每个数组元素只访问一次，因此该程序段的数据访问没有时间局部性。  

3）在组相联映射方式下，物理地址结构为Tag标记 $^+$ Cache组号 $^+$ 块内地址，主存块大小为32B，故块内地址占5位；Cache数据区共有 $\mathrm{8KB^{\cdot}\!32B=\!256}$ 行，采用4路组相联，共有64组，故Cache组号占6位，因此虚拟地址中低5位（ $\mathrm{A4\!\sim\!A0})$ ）用作块内地址：低11位虚拟地址中高6位 $(\mathrm{A}10{\sim}\mathrm{A}5)$ 用作Cache组号。a[1][o]的虚拟地址为 $0042\ 2000\mathrm{H}+$  $1{\times}64{\times}4\ +\ 0{\times}4\ =0042\ 2100\mathrm{H}$ 。虚拟地址为32位，页框大小为4KB，虚拟地址的低12位表示页内偏移量，因此物理地址的低12位和虚拟地址的低12位相同，因此a[1]I0]所在主存块对应的Cache组号为 $001000\mathbf{B}=8$  

4）数组a占  $24{\times}64{\times}4\mathrm{B}{\div}32\mathrm{B}=192$  个主存块。每个主存块存放  $32\mathrm{B}{\cdot}4\mathrm{B}=8$  个数组元素，访问 数组a的Cache命中率为 $(8-1)/8=87.5\%\,8$ 行数组元素占 $8{\times}64{\times}4\mathrm{B}{\div}32\mathrm{B}=64$ 个主存块，分别映射到64个Cache组的某Cache行，数组a共有24行，因此每个Cache组中只有 $24/8=3$ 个Cache行存放数组a中的数据，而每个Cache组有4行，因而不会发生替换，访问数组a的Cache命中率为 $7/8=87.5\%$  

# 3.7 本章小结  

本章开头提出的问题的参考答案如下。  

1）存储器系统为何要分这些层次？计算机如何管理这些层次？  

Cache-主存层在存储系统中主要对CPU访存起加速作用，即从整体运行的效果看，CPU访存速度加快，接近于Cache的速度，而寻址空间和位价却接近于主存。主存-辅存层在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器的容量和位价接近于辅存，而速度接近于主存。因此从整个存储系统来看，就达到了速度快、容量大、位价低的效果。  

主存与Cache之间的信息调度全部由硬件自动完成。而主存与辅存的信息调度则采用虚拟存储技术实现，即将主存与辅存的一部分通过软/硬结合的技术组成虚拟存储器，程序员可用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软/硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。  

2.影响Cache性能的因素有哪些？  

决定Cache系统访存效率重要因素是命中率，它与很多因素有关。1）命中率与映射方式有关，全相联映射方式的命中率最高，直接映射方式的命中率最低。2）命中率与Cache容量有关，显然Cache容量越大，命中率就越高。3）命中率还与主存块（或Cache行）的大小有关，主存块的大小要适中。  
除上述因素外，系统是采用单级还是采用多级Cache，数据Cache和指令Cache是分离还是合在一起，主存-总线-Cache-CPU之间采用什么架构等，都会影响Cache的总体性能。  

3）虚拟存储系统的页面是设置得大一些好还是设置得小一些好？  

页面大小要适中。页面太小时，平均页内剩余空间较小，可节省存储空间，但会使得页表增大，页面太小时也不能充分利用空间局部性来提高命中率：页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长。  

# 3.8常见问题和易混淆知识点  

1.Cache行的大小和命中率之间有什么关系？  

Cache行的长度较大时，能充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个：  

1）行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块。  

2）行长太大，Cache项数变少，因而命中的可能性变小。  

Cache行的长度较小时，命中率会很低，但好处是存取块的代价较小。  

2.发生取指令Cache缺失的处理过程是什么？  

1）程序计数器恢复当前指令的值。  

2）对主存进行读的操作。  

3）将读入的指令写入Cache中，更改有效位和标记位。  

4）重新执行当前指令。  

3.Cache总容量与映射方式有何种关系？  

Cache总容量 $=$ [每个Cache行标记项的容量（有效位、脏位、LRU替换位、标记位）+Cache行长xCache总行数。其中，有效位和标记位是所有Cache所必需的；脏位只在Cache采用回写法时才需要设置；LRU替换位只在Cache采用LRU替换算法时才需要设置。  

有效位：占1位，用于说明Cache行中的数据是否有效。脏位（修改位）：占1位，回写法才需要设置，用以说明Cache行中的数据是否被修改过。LRU替换位：位数为 $\log_{2}($ 组内块数），用于LRU替换算法中的访问计数。  

标记位Tag：主存地址结构中的标记字段，其位数取决于所用的映射方式，用于匹配Cache行对应主存中的哪个块。  

Cache容量与映射方式的具体关系如图3.30所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/77d74c7bc0a8fc408aa68057edb2cbdd1c424abbf65fd57e9f4d982659723d0b.jpg)  
# 第4章指令系统  

# 【考纲内容】  

（一）指令格式的基本概念（二）指令格式（三）寻址方式（四）数据的对齐和大/小端存放方式（五）CISC和RISC的基本概念（六）高级语言程序与机器级代码之间的对应编译器、汇编器与链接器的基本概念：选择结构语句的机器级表示循环结构语句的机器级表示：过程（函数）调用对应的机器级表示  

# 【复习提示】  

指令系统是表征一台计算机性能的重要因素。应掌握各种寻址方式的特点及有效地址的计算，三种偏移寻址（相对寻址、基址寻址和变寻址）的计算，CISC与RISC的特点与区别。2022年大纲新增机器级表示，机器级代码相关的题型曾在历年统考中多次考查，要能读懂代码。本章知识点既可能出选择题，又可能结合其他章节出有关指令的综合题。指令格式、机器指令和指令寻址方式与CPU指令执行过程部分紧密相关，需引起重视。  

在学习本章时，请读者思考以下问题  

1）什么是指令？什么是指令系统？为什么要引入指令系统？2）一般来说，指令分为哪些部分？每部分有什么用处？3）对于一个指令系统来说，寻址方式多和少有什么影响？请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 4.1指令系统  

# 4.1.1指令集体系结构  

命题追踪指令集体系结构（ISA）规定的内容（2022）  

机器指令（简称指令）是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是指令集体系结构（ISA）中最核心的部分，ISA完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的。  
ISA规定的内容主要包括：  

1）指令格式，指令寻址方式，操作类型，以及每种操作对应的操作数的相应规定。  

2）操作数的类型，操作数寻址方式，以及是按大端方式还是按小端方式存放。  

3）程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。  

4）指令执行过程的控制方式等，包括程序计数器、条件码定义等  

ISA规定了机器级程序的格式，机器语言或汇编语言程序员必须对机器的ISA非常熟悉。不过，大多数程序员不会用汇编语言或机器语言编写程序，通常用高级语言（如 $\mathrm{C}/\mathrm{C++}/\mathrm{Java}$ )广编写程序，这样开发效率更高，也不易出错。但是，高级语言抽象层太高，隐藏了许多机器级程序的细节，使得高级语言程序员不能很好地利用与机器结构相关的一些优化方法来提升程序的性能。若程序员对ISA和底层硬件实现细节有充分的了解，则可以更好地编制高性能程序。  

# 4.1.2指令的基本格式  

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分：  

操作码字段地址码字段  

其中，操作码指出该指令应执行什么操作以及具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。地址码给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。  

指令字长是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度和地址码的个数。指令字长与机器字长没有固定的关系，它既可以等于机器字长，又可以大于或小于机器字长。通常，把指令长度等于机器字长的指令称为单学长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令。  

# 注意  

指令长度的不同会导致取指令时间开销的不同，单字长指令只需访存1次就能将指令完整取出；而双字长指令则需访存2次才能完整取出，耗费2个存取周期。  

在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主存一般是按字节编址的，所以指令字长通常为字节的整数倍。  

根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式。命题追踪根据指令格式及相关编码条件组合成机器代码（2015）  

# 1.零地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6e7552f06b4d8317fc022359d2dcccb811aec4c3314eb4cd1ac1ec714e795bd3.jpg)  

只给出操作码OP，没有显式地址。这种指令有两种可能：1）不需要操作数的指令，如空操作指令、停机指令、关中断指令等。  

2）零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。  
2.一地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f73beb07fd477d00ecf244bb03d345248115ffa6dad3968d55fb69658646a4ca.jpg)  

这种指令也有两种常见的形态，要根据操作码的含义确定究竟是哪一种。  

1）只有目的操作数的单操作数指令，按 $\mathrm{A_{1}}$ 地址读取操作数，进行OP操作后，结果存回原地址。  

指令含义： $\mathrm{OP(A_{1}){\rightarrow}A_{1}}$  

如操作码含义是加1、减1、求反、求补、移位等。  

2）隐含约定目的地址的双操作数指令，按指令地址  $\mathrm{A_{1}}$  可读取源操作数，指令可隐含约定另 一个操作数由ACC（累加器）提供，运算结果也将存放在ACC中。指令含义： $(\mathrm{ACC})\mathrm{OP}(\mathrm{A}_{1}){\rightarrow}\mathrm{ACC}$  

# 命题追踪地址位数与寻址范围的关系（2010、2021）  

若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为 $2^{24}\,=\,16\mathrm{M}$ 。若地址码字段均为主存地址，则完成一条一地址指令需要3次访存（取指令1次，取操作数1次，存结果1次）。  

3.二地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/808143d9dc4a64a19f32b18f99d45ecad816da4b5a2564cee34b907da02c8e67.jpg)  

指令含义： $(\mathrm{A}_{1})\mathrm{OP}(\mathrm{A}_{2}){\rightarrow}\mathrm{A}_{1}$  

对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果。  

若指令字长为32位，操作码占8位，两个地址码字段各占12位，则每个操作数的直接寻址范围为 $2^{12}\,=\,4\mathrm{K}$ 。若地址码字段均为主存地址，则完成一条二地址指令需要4次访存（取指令1次，取两个操作数2次，存结果1次）。  

4.三地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/964f896e4265099daa90e4a7313c3f27dbada8cdcabb04ced0efe9b9d5d4944a.jpg)  

指令含义： $\mathrm{(A_{1})O P(A_{2})}{\rightarrow}\mathrm{A}_{3}\,.$  

若指令字长为32位，操作码占8位，3个地址码字段各占8位，则每个操作数的直接寻址范 围为 $2^{8}\,=\,256$ 。若地址码字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存结果1次）。  

5.四地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56bca1a6922d69a95d02641971447a3f6f573122ef2321a9000c316913151d9c.jpg)  

指令含义： $(\mathrm{A}_{1})\mathrm{OP}(\mathrm{A}_{2}){\rightarrow}\mathrm{A}_{3}$  $\mathrm{A}_{4}\,{=}$ 下一条将要执行指令的地址。  

若指令字长为32位，操作码占8位，4个地址码字段各占6位，则每个操作数的直接寻址范 围为 $2^{6}\!=\!64$ 。若地址码字段均为主存地址，则完成一条四地址指令需要4次访存（取指令1次）取两个操作数2次，存结果1次）。  

# 4.1.3定长操作码指令格式  

命题追踪定长操作码的指令条数（2015）  

定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般 $n$ 位操作码字段的指令系统最大能够表示 $2^{n}$ 条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。当计算机字长为32位或更长时，这是常规用法。  
# 4.1.4扩展操作码指令格式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/071560d5e5eda10464fba863c6dfebfd51fa6d763bb74f898427072c733063e7.jpg)  

扩展操作码的设计与分析（2017、2021、2022）  

为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。图4.1所示即为一种扩展操作码的安排方式。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b10a369778010289fef7ffaa5f77b8dcc6e481322d548dc450d59062bbc00886.jpg)  
操作码的位数随地址数的减少而增加  

在图4.1中，指令字长为16位，其中4位为基本操作码字段0P，另有3个4位长的地址字段 $\mathrm{A_{1}}$  $\mathrm{A}_{2}$ 和 $\mathrm{A}_{3}$ 。4位基本操作码若全部用于三地址指令，则有16条。图4.1中所示的三地址指令为15条，1111留作扩展操作码之用：二地址指令为15条，11111111留作扩展操作码之用；一地址指令为15条，111111111111留作扩展操作码之用；零地址指令为16条。×  

除这种安排外，还有其他多种扩展方法，如形成15条三地址指令、12条二地址指令、63条一地址指令和16条零地址指令，共106条指令，请读者自行分析。  

在设计扩展操作码指令格式时，必须注意以下两点：  

1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同，  

2）各指令的操作码一定不能重复。  

通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。  

# 4.1.5指令的操作类型  

设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。  

1.数据传送  

传送指令通常有寄存器之间的传送（MOV）、从内存单元读取数据到CPU寄存器（LOAD）  
从CPU寄存器写数据到内存单元（STORE）、进栈操作（PUSH）、出栈操作（POP）等。  

# 2.算术和逻辑运算  

这类指令主要有加（ADD）、减（SUB）、乘（MUL）、除（DIV）、加1（INC）、减1（DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）等。  

# 3.移位操作  

移位指令主要有算术移位、逻辑移位、循环移位等。  

# 4.转移操作  

# 命题追踪转跳指令、调用和返回指令、条件转移指令的区分（2019）  

转移指令主要有无条件转移（JMP）、条件转移（BRANCH）、调用（CALL）、返回（RET）、陷阶（TRAP）等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或几个标志位的组合。  

调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行：而转移指令则不返回执行。  

# 5.输入输出操作  

这类指令用于完成CPU与外部设备交换数据或传送控制命令及状态信息。  

# 4.1.6 本节习题精选  

# 一、单项选择题  

01.下列关于指令集体系结构和指令系统的说法中，错误的是（）  

A.指令集体系结构位于计算机软/硬件的交界面上B.指令集体系结构是指低级语言程序员所看到的概念结构和功能特性C.任何程序运行前都要先转换为机器语言程序D.指令系统和机器语言是无关的  

02.下列有关指令集体系结构（ISA）的叙述中，错误的是（）  

A.ISA规定了执行每条指令时所包含的控制信号B.ISA规定了指令获取操作数的方式，即寻址方式C.ISA规定了所有指令的集合，包括指令格式和操作类型D.ISA规定了程序可访问的寄存器个数、存储空间大小、编址方式和大端/小端方式  

03.在CPU执行指令的过程中，指令的地址由（）给出。  

A.程序计数器（PC）B.指令的地址码字段C.操作系统D.程序员  

04.运算型指令的寻址与转移型指令的寻址的不同点在于（）。  

A.前者取操作数，后者决定程序转移地址B.后者取操作数，前者决定程序转移地址C.前者是短指令，后者是长指令D.前者是长指令，后者是短指令  

05.程序控制类指令的功能是（）  

A.进行算术运算和逻辑运算B.进行主存与CPU之间的数据传送  
C.进行CPU和I/O设备之间的数据传送D.改变程序执行的顺序  

06.下列指令中不属于程序控制指令的是（）  

A.无条件转移指令B.条件转移指令C.中断隐指令 D.循环指令  

07.下列指令中应用程序不准使用的指令是（）A.循环指令 B.转换指令 C.特权指令 D.条件转移指令  

08.堆栈计算机中，有些堆栈零地址的运算类指令在指令格式中不给出操作数的地址，参加的两个操作数来自（）  

A.累加器和寄存器B.累加器和暂存器C.堆栈的栈顶和次栈顶单元D.堆栈的栈顶单元和暂存器  

09.以下叙述错误的是（）。  

A.为了便于取指令，指令的长度通常为存储字长的整数倍B.单地址指令是固定长度的指令C.单字长指令可加快取指令的速度D.单地址指令可能有一个操作数，也可能有两个操作数  

10.能够完成两个数的算术运算的单地址指令，地址码指明一个操作数，另一个操作数来自(）方式。  

A.立即寻址 B.隐含寻址 C.间接寻址 D.基址寻址  

11.设机器字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其寻址单元数是CO。  

A.  $2^{24}$  B.  $2^{23}$  C.  $2^{22}$  D.221

 12.某指令系统有200条指令，对操作码采用固定长度二进制编码，最少需要用（）位。A.4 B.8 C.16 D.32

 13.在指令格式中，采用扩展操作码设计方案的目的是（）  

A.减少指令字长度B.增加指令字长度C.保持指令字长度不变而增加指令的数量D.保持指令字长度不变而增加寻址空间  

14.一个计算机系统采用32位单字长指令，地址码为12位，若定义了250条二地址指令，则还可以有（）条单地址指令。  

A.  $2^{12}$  B.  $2^{13}$  C.  $2^{14}$  D.  $3{\times}2^{13}$  

15.【2017统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条、二地址指令107条，每个地址字段为6位，则指令字长至少应该是()。  

A.24位B.26位C.28位D.32位

16.【2022统考真题】下列选项中，属于指令集体系结构（ISA）规定的内容是（）。  

I.指令字格式和指令类型IⅡ.CPU的时钟周期III.通用寄存器个数和位数IV.加法器的进位方式  

A.仅I、IIB.仅I、IⅢIC.仅II、IVD.仅I、III、IV  

17.【2022统考真题】设计某指令系统时，假设采用16位定长指令字格式，操作码使用扩展编码方式，地址码为6位，包含零地址、一地址和二地址3种格式的指令。若二地址指令有12条，一地址指令有254条，则零地址指令的条数最多为（）。  
A.0 B.2 C.64 D.128  

# 二、综合应用题  

01.一个处理器中共有32个寄存器，使用16位立即数，其指令系统结构中共有142条指令。在某个给定的程序中， $20\%$ 的指令带有一个输入寄存器和一个输出寄存器； $30\%$ 的指令带有两个输入寄存器和一个输出寄存器； $25\%$ 的指令带有一个输入寄存器、一个输出寄存器、一个立即数寄存器；其余 $25\%$ 的指令带有一个立即数输入寄存器和一个输出寄存器。  

1）对于以上4种指令类型中的任意一种指令类型来说，共需要多少位？假定指令系统结构要求所有指令长度必须是8的整数倍。2）与使用定长指令集编码相比，当采用变长指令集编码时，该程序能够少占用多少存储器空间？  

02.假设指令字长为16位，操作数的地址码为6位，指令有零地址、一地址、二地址3种格式。1）设操作码固定，若零地址指令有 $M$ 种，一地址指令有 $N$ 种，则二地址指令最多有几种？2）采用扩展操作码技术，二地址指令最多有几种？3）采用扩展操作码技术，若二地址指令有 $P$ 条，零地址指令有 $\boldsymbol{\mathcal{Q}}$ 条，则一地址指令最多有几种？  

03.在一个36位长的指令系统中，设计一个扩展操作码，使之能表示下列指令：  

1）7条具有两个15位地址和一个3位地址的指令。2）500条具有一个15位地址和一个3位地址的指令3）50条无地址指令。  

# 4.1.7 答案与解析  

# 一、单项选择题  

01.D  

指令集体系结构（ISA）完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的。指令系统是计算机硬件的语言系统，这显然和机器语言有关。  

02.A  

指令集体系结构（ISA）是软件和硬件之间接口的一个完整定义，包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断和异常处理及外部I/O。ISA规定了执行每条指令时所需要的操作码、操作数、寻址方式等信息，以及指令的功能和效果。控制信号是由控制单元根据ISA生成的，它属于微架构层面的实现细节，而不是ISA层面的抽象定义。  

03.A PC存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址。  

04.A 运算型指令寻址的是操作数，而转移型指令寻址的是下次欲执行的指令的地址。  

05.D 程序控制类指令用于改变程序执行的顺序，并使程序具有测试、分析、判断和循环执行的能力。  

06.C  
程序控制类指令主要包括无条件转移、有条件转移、子程序调用和返回指令、循环指令等。中断隐指令是由硬件实现的，并不是指令系统中存在的指令，更不可能属于程序控制类指令。  

07. C  

特权指令是指仅用于操作系统或其他系统软件的指令。为确保系统与数据安全起见，这类指令不提供给用户使用。  

08.C 零地址的运算类指令也称堆栈运算指令，参与的两个操作数来自栈顶和次栈顶单元。  

# 注意  

堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。若是软堆栈（堆栈区由内存实现），则对于双目运算需要访问4次内存：取指令、取源数1、取源数2、存结果。若是硬堆栈（堆栈区由寄存器实现），则只需在取指令时访问一次内存。  

09.B  

指令的地址个数与指令的长度是否固定没有必然联系，即使是单地址指令，也可能由于单地址的寻址方式不同而导致指令长度不同。  

10.B  

单地址指令中只有一个地址码，在完成两个操作数的算术运算时，一个操作数由地址码指出，另一个操作数通常存放在累加寄存器（ACC）中，属于隐含寻址。  

11.B  

$16\mathbf{M}=2^{24}$ ，字长为32位，现在按半字（16位）寻址，相当于有8M $(=2^{23}$ ）个存储单元，每个存储单元中存放16位。  

12.B  

因 $128=2^{7}<200<2^{8}=256$ ，因此采用定长操作码时，至少需要8位。  

13.C 扩展操作码并未改变指令的长度，而是使操作码长度随地址码的减少而增加。  

14.D  

地址码为12位，二地址指令的操作码长度为 $32-12-12=8$ 位，已定义了250条二地址指令， $2^{8}\!-250=6$ ，即可以设计出单地址指令 $6{\times}2^{12}=3{\times}2^{13}$ 条。  

15.A  

三地址指令有29条，所以其操作码至少为5位。以5位进行计算，它剩余 $32\mathrm{~-~}29=3$ 种操作码给二地址。而二地址额外多了6位给操作码，因此其数量最大达 $3{\times}64=192$ 。所以指令字长最少为23位，因为计算机按字节编址，需要是8的倍数，所以指令字长至少应该是24位。  

16.B  

指令集体系结构处于软/硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由ISA规定。两个CPU可以有不同的时钟周期，但指令集可以相同；加法器的进位方式涉及电路设计，这两项都属于计算机的硬件部分，不由ISA规定。  

17.D  

地址码为6位，一条二地址指令会占用 $2^{6}$ 条一地址指令的空间，一条一地址指令会占用 $2^{6}$ 条零地址指令的空间。若全都是零地址指令，则最多有 $2^{16}$ 条，减去一地址指令和二地址指令所占用的零地址指令空间，即 $2^{16}{-}254{\times}2^{6}{-}12{\times}2^{6}{\times}2^{6}{=}(2^{10}{-}254{-}12{\times}2^{6}){\times}2^{6}{=}2{\times}2^{6}{=}128{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{$  

另解：二地址指令有12条，则剩余 $16-12=4$ 种操作码给一地址指令，一地址指令有254条，剩余 $4{\times}64-254=2$ 种操作码给0地址指令，所以0地址一共有 $2\!\times\!2^{6}\!=128$ 条。  
# 二、综合应用题  

01.【解答】  

1）因为有142条指令，所以至少需要8位才能确定各条指令的操作码（ $.2^{8}\!=\!256$ ）。由于该处理器有32个寄存器，也就是说要用5位对寄存器ID编码，而每个立即数需要16位。因此，有： $20\%$ 的一个输入寄存器和一个输出寄存器指令需要 $8+5+5=18$ 位，长度对齐到8的倍数，便是24位。  

$30\%$ 的两个输入寄存器和一个输出寄存器指令需要 $8+5+5+5=23$ 位，对齐到24位 $25\%$ 的一个输入寄存器、一个输出寄存器、一个立即数寄存器指令需要 $8+5+5+16=34$ 位，对齐到40位。  

$25\%$ 的一个立即数输入寄存器和一个输出寄存器指令需要 $8+16+5=29$ 位，对齐到32位。  

2）因为变长指令最长的长度为40位，所以定长指令编码每条指令的长度均为40位。而采用变长编码，将各个指令长度和其概率相乘，得出平均长度为30位。所以该程序中，变长编码比定长编码少占用 $25\%$ 的存储空间。  

02.【解答】  

1）根据操作数地址码为6位，得到二地址指令中操作码的位数为 $16-6-6=4$ ，这4位操作码可有16种操作。由于操作码固定，因此除了零地址指令有 $M$ 种，一地址指令有 $N$ 种，剩下的二地址指令最多有 $16-M{-}N$ 种。妆  

2）采用扩展操作码技术，操作码位数可随地址数的减少而增加。对于二地址指令，指令字长16位，减去两个地址码共12位，剩下4位操作码，共16种编码，去掉一种编码（如1111）用于一地址指令扩展，二地址指令最多可有15种操作。  

3）采用扩展操作码技术，操作码位数可变，二地址、一地址和零地址的操作码长度分别为4 位、10位和16位。这样，二地址指令操作码每减少一个，就可以多构成 $2^{6}$ 条一地址指令操作码：一地址指令操作码每减少一个，就可以多构成  $2^{6}$  条零地址指令操作码。设一地址 指令有 $R$ 条，则一地址指令最多有 $(2^{4}\!-\!P)\!\times\!2^{6}$ 条，零地址指令最多有 $[(2^{4}\!-\!P)\!\times\!2^{6}\!-\!R]\!\times\!2^{6}$ 条。根据题中给出零地址指令为 $\mathcal{Q}$ 条，即 $Q\,=\,[(2^{4}-\,P)\!\times\!2^{6}-\,R]\times2^{6}$ ，得 $R\,=\,(2^{4}-\,P){\times}2^{6}\,-$  $\left\lceil Q\times2^{-6}\right\rceil$ 。  

03.【解答】  

1)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/38ef7b4e68e3a7b08474f441f81ab33eeb932a184a4e8eb051d0d03f765b7674.jpg)  

2)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0f3da896c1d01c426c5089e207779cc1657223d154581f5519ec6cd7b1635e45.jpg)  
3)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c690c5f72307ac5a540da94ad269c4415aaf881198bac8f305dbd7ea59543837.jpg)  

# 4.2指令的寻址方式  

寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。  

# 4.2.1指令寻址和数据寻址  

寻找下一条将要执行的指令地址称为指令寻址：寻找本条指令的数据地址称为数据寻址。  

1.指令寻址  

指令寻址方式有两种：一种是顺序导址方式，另一种是跳跃寻址方式。  

（1）顺序寻址  

通过程序计数器PC加1（1条指令的长度），自动形成下一条指令的地址  

命题追踪PC自增大小与编址方式、指令字长的关系（2013、2014、2019、2023）  

# 注意  

PC自增的大小与编址方式、指令字长有关。现代计算机通常是按字节编址的，若指令字长为16位，则PC自增为 $(\mathrm{PC})+2$ ；若指令字长为32位，则PC自增为 $(\mathrm{PC})+4,$  

# （2）跳跃寻址  

通过转移类指令实现。跳跃是指由本条指令给出下条指令地址的计算方式。而是否跳跌可能受到状态寄存器的控制，跳跃的方式分为绝对转移（地址码直接指出转移自标地址）和箱对转移（地址码指出转移目的地址相对于当前PC值的偏移量），由于CPU总是根据PC的内容去主存取指令的，因此转移指令执行的结果是修改PC值，下一条指令仍然通过PC给出。  

# 2.数据寻址  

# 命题追踪指令格式中各字段的位数分析（2020）  

数据寻址是指如何在指令中表示一个操作数的地址，或怎样计算出操作数的地址。数据寻址的方式较多，为区别各种方式，通常在指令字中设置一个寻址特征字段，用来指明属于哪种寻址方式（其位数决定了寻址方式的种类），由此可得指令的格式如下所示：  

命题追踪指令格式中寻址特征字段的作用（2023）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc57f57875406369a446ee41b6e46ac9b01777329de41e632ddfab7ec83264fd.jpg)  

指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址（A）。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址（EA）。  
·若为立即寻址，则形式地址的位数决定了操作数的范围！·若为直接寻址，则形式地址的位数决定了可寻址的范围。·若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。·若为寄存器间接寻址，则寄存器的位数决定了可寻址的范围。  

# 注意  

（A）表示地址为A的数值，A既可以是寄存器编号，又可以是内存地址。  

# 4.2.2常见的数据寻址方式  

# 1.隐含寻址  

这种类型的指令不明显地给出操作数的地址，而是隐含操作数的地址。例如，单地址的指令格式就隐含约定第二个操作数由累加器（ACC）提供，指令中只明显指出第一个操作数的地址。因此，累加器（ACC）对单地址指令格式来说是隐含寻址，如图4.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/eb95a905f61e44cad56b518a1aa375ef438a60ca7ed3fc676e2fa55c6f573d41.jpg)  
图4.2隐含寻址  

优点是有利于缩短指令字长：缺点是需增加存储操作数或隐含地址的硬件。  

# 2.立即（数）寻址  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/110d116c8b8f204cc811f75888fc2be6eb59e94bed8f4be454cefdd61d820bbe.jpg)  

指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表示。图43所亲为立即寻址示意图，图中#表示立即寻址特征，A就是操作数。  

优点是指令在执行阶段不访存，指令执行速度最快；缺点是A的位数限制了立即数的范围。  

# 3.直接寻址  

指令字中的形式地址A就是操作数的真实地址EA，即EA $\mathbf{\tau}=\mathbf{A}$ ，如图4.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/948183c5b772d6544c6bec9a19645480a2b25ccbad62d507552486df04009957.jpg)  

优点是简单，不需要专门计算操作数的地址，指令在执行阶段仅需访存一次；缺点是A的位数限制了该指令操作数的寻址范围，操作数的地址不易修改。  

# 4.间接寻址  

间接寻址是相对于直接寻址而言的，指令的地址字段给出的不是操作数的真正地址，而是操作数有效地址所在主存单元的地址，也就是操作数地址的地址，即 $\mathrm{EA}=(\mathrm{A})$ ，如图4.5所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/297661d0b53d517f5369db6eeea0399b48288d259fb0194ce89d2cff392ca596.jpg)  
图4.5间接寻址  

优点是可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间接寻址可方便地完成子程序返回）：缺点是指令在执行阶段要多次访存（一次间接寻址需2次访存）。由于执行速度较慢，一般为了扩大寻址范围时，通常采用寄存器间接寻址。  

# 5.寄存器寻址  

与直接寻址的原理一样，只是把访问主存改为访问寄存器，指令的地址字段给出的是操作数所在寄存器的编号，即 $\mathrm{EA}=\mathrm{R}_{i}$ ，其操作数在由 $\mathbf{R}_{i}$ 所指的寄存器内，如图4.6所示。  

# 命题追踪寄存器编号位数与寄存器数量的关系（2022）  

优点是指令在执行阶段不用访存，只访问寄存器，执行速度快；寄存器数量远小于内存单元数，所以地址码位数较少，指令字长较短；缺点是寄存器价格昂贵，CPU的寄存器数量有限。  

# 6.寄存器间接寻址  

# 命题追踪寄存器间接寻址的取数操作（2010）  

这种方式综合了间接寻址和寄存器寻址各自的特点，指令字中的 $\mathbf{R}_{i}$ 所指寄存器给出的不是一个操作数，而是操作数所在主存单元的地址，即 $\mathrm{EA}=(\mathrm{R}_{i})$ ，如图4.7所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92cc364b37cca2cace4edc484a7917ca840b456ec8c78df2714108a04df0e6ef.jpg)  
图4.6寄存器寻址  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71cf46d10de7a2353718ca3f208d5dd43920b00188d4ad2d26638c7036ec9415.jpg)  
图4.7寄存器间接寻址  

相比间接寻址，这种方式既扩大了寻址范围，又减少了访存次数，在执行阶段仅需访存1次。相比寄存器寻址，这种方式在执行阶段需要访存（因操作数在主存中）获得操作数。  

# 7.相对寻址  

# 命题追踪相对寻址的偏移量或目标地址的计算（2009、2013、2014、2019、2023）  

相对寻址是把PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA $=$ PC) $\mathbf{\varepsilon}+\mathbf{A}$ ，其中A是相对于当前PC值的偏移量，可正可负，补码表示，如图4.8所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54a79a897f2ebe46f3c3320ba9fc90c8d14eba5a2917c433c88919cf0d1c4e2d.jpg)  
图4.8相对寻址  

在图4.8中，A的位数决定操作数的寻址范围。  

优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定的偏移量，因此便于程序浮动。相对寻址广泛应用于转移指令。  

# 命题追踪相对寻址转跳范围的计算（2010、2013、2014）  

# 注意  

对于转移指令JMPA，若指令的地址为X，且占2B，则在取出该指令后，PC的值会增2，即 $(\mathrm{PC})\,{=}\,\mathrm{X}+2$ ，这样在执行完该指令后，会自动跳转到 $\mathrm{X}+2+\mathrm{A}$ 的地址继续执行。  

8.基址寻址  

命题追踪基址寻址的EA的计算（2019）  

基址寻址是指将基址寄存器（BR）的内容加上指令字中的形式地址A而形成操作数的有效地址，即 $\mathrm{EA}=(\mathrm{BR})+\mathrm{A}_{\circ}$ 其中基址寄存器既可采用专用寄存器，又可指定某个通用寄存器作为基址寄存器，如图4.9所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a34564d3543b6f2ccacb8cfb471b140348d32097e27bbf6b321ab8f9a9a2be06.jpg)  
图4.9基址寻址  

基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。  

基址寻址的优点是可以扩大寻址范围（基址寄存器的位数大于形式地址A的位数）：用户不必考虑自己的程序存于主存的具体位置，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。  

9.变址寻址  

命题追踪变址寻址的EA的计算（2013），先变址后间址方式的EA的计算（2016）  

变址寻址是指将变址寄存器（IX）的内容加上指令字中的形式地址A而形成操作数的有效地址，即 $\mathrm{EA}\,{=}\,(\mathrm{IC})+\mathrm{A}$ ，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。图4.10所示为采用专用寄存器IX的变址寻址示意图。  
变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。  

# 命题追踪变址寻址的适用场景（2017）  

变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任意一个数据的地址，特别适合编制循环程序。偏移量（变址寄存器IX）的位数足以表示整个存储空间。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f0e1bf068edf0a515fc2ed92442f6f857a8030bab1164982e17c514ba92116c.jpg)  
图4.10变址寻址  

# 命题追踪变址寻址访问数组的过程（2018）  

显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的。变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。  

# 命题追踪偏移寻址的范畴（2011）  

相对寻址、基址寻址和变址寻址三种寻址方式非常类似，都将某个寄存器的内容与一个形式地址相加而生成操作数的有效地址，通常把这三种寻址方式称为偏移寻址。  

# 10.堆栈寻址  

堆栈是存储器（或寄存器组）中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为硬堆栈和软堆栈两种。寄存器堆栈也称硬堆栈，硬堆栈的成本较高，不适合做大容量的堆栈。而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。  

在采用堆栈结构的计算机中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。因此在读/写堆栈的前后都伴有自动完成对SP的加减操作。  

下面简单总结寻址方式、有效地址及访存次数（不含取本条指令的访存），见表4.1。  

表4.1寻址方式、有效地址及访存次数
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c51f3e89ddc451b47a9e622c8b801b80139caf0bb46af25e8b2187d5cd2dfd58.jpg)  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1c50194cc3786f302b53c78b63af2b45a119ca8380862b67f5dcabb0710cde4.jpg)  

# 4.2.3 本节习题精选  

# 一、单项选择题  

01.指令系统中采用不同寻址方式的目的是（）。  

A.提供扩展操作码的可能并降低指令译码难度B.可缩短指令字长，扩大寻址空间，提高编程的灵活性C.实现程序控制D.三者都正确  

02.采用直接转移的无条件转移指令的功能是将指令中的地址码送入（）。  

A.程序计数器（PC）B.累加器（ACC）C.指令寄存器（IR）D.地址寄存器（MAR）  

03.为了缩短指令中某个地址段的位数，有效的方法是采取（）A.立即寻址 B.变址寻址 C.间接寻址 D.寄存器寻址

 04.简化地址结构的基本方法是尽量采用（）A.寄存器寻址B.隐含寻址C.直接寻址D.间接寻址

05.在指令寻址的各种方式中，获取操作数最快的方式是（）A.直接寻址B.立即寻址C.寄存器寻址D.间接寻址

06.假定指令中地址码所给出的是操作数的有效地址，则该指令采用（）A.直接寻址B.立即寻址C.寄存器寻址D.间接寻址  

07.设指令中的地址码为A，变址寄存器为X，程序计数器为PC，则变址间址寻址方式的操作数的有效地址EA是（）。  

A.  $((\mathrm{PC})+\mathrm{A})$  B.  $((\mathrm{X})+\mathrm{A})$  C.  $\mathrm{(X)}+\mathrm{(A)}$  D.  $\mathrm{(X)+A}$  

08.（）便于处理数组问题。  

A.间接寻址B.变址寻址C.相对寻址D.基址寻址  

09.堆栈寻址方式中，设A为累加器，SP为堆栈指示器， $\mathbf{M}_{s p}$ 为SP指示的栈顶单元。若进栈操作的动作是 $(\mathrm{A}){\rightarrow}\mathrm{M}_{\mathrm{sp}},(\mathrm{SP})-1{\rightarrow}\mathrm{SP}$ ，则出栈操作的动作应为（）。  

A.  $(\mathbf{M}_{\mathrm{sp}})\,\rightarrow\!\mathrm{A},(\mathrm{SP})+1\!\rightarrow\!\mathrm{SP}$  B.  $(\mathrm{SP})+1{\rightarrow}\mathrm{SP},(\mathrm{M}_{\mathrm{SP}})\rightarrow\mathrm{A}$  C.(SI  $\mathrm{P})-1{\rightarrow}\mathrm{SP},(\mathrm{M}_{\mathrm{SP}})\ {\rightarrow}\mathrm{A}$  D.  $(\mathbf{M}_{\mathrm{SP}}){\rightarrow}\mathbf{A},(\mathrm{SP})-1{\rightarrow}\mathrm{SP}$  

10.相对寻址方式中，指令所提供的相对地址实质上是一种（）  

A.立即数B.内存地址C.以本条指令在内存中首地址为基准位置的偏移量D.以下条指令在内存中首地址为基准位置的偏移量  

11.下列关于堆栈寻址的描述中，错误的是（）  

A.可以用内存来实现堆栈B.堆栈寻址要求计算机中设有堆栈C.可以用硬盘来实现堆栈，称为硬堆栈D.可以用寄存器组来实现堆栈  
12.指令寻址方式有顺序和跳跃两种，采用跳跃寻址方式可以实现（）。  

A.程序浮动B.程序的无条件浮动和条件浮动C.程序的无条件转移和条件转移D.程序的调用  

13.寄存器R1、R2均为16位，指令MOVR1,[R2]的功能是把内存数据传送至寄存器R1，寻址方式为寄存器间接寻址。R2的值为1234H，内存单元1234H存放数据56H，内存单元1235H存放数据78H，采用小端方式存储。则执行指令后R1的值为（）。  

A.5678H B.7856H C.8765H D.6587H  

14.某计算机机的字长为16位，主存按字编址。转移指令由两个字节组成，采用相对寻址，第一个字节为操作码字段，第二个字节为相对偏移量字段。若某转移指令所在的主存地址为4000HI，相对偏移量字段的内容为 $06\mathrm{H}$ ，则该转移指令执行后的PC值为（）。  

A.4002H B.4004H C.4007H D. 4008H  

15.某计算机的指令字长为16位，由低到高第0～7位是形式地址D，第8～9位为寻址特征位X，第10\~15位为操作码。当 $X=00$ 时为直接寻址；当 $X=01$ 时使用X1进行变址寻址；当 $\mathrm{X}=10$ 时使用X2进行变址寻址；当 $\mathrm{X}=11$ 时为相对寻址。设 $(\mathrm{PC})=1234\mathrm{H}$  $\mathrm{(X1)}=0005\mathrm{H}$ ， $(\mathrm{X}2)=1188\mathrm{H}$ ，则指令2222H的有效地址是（）。  

A.1256H B.0027H C.2222H D.11AAH  

16.某机器指令字长为16位，主存按字节编址，取指令时，每取一字节，PC自动加1。当前指令地址为 $2000\mathrm{H}$ ，指令内容为相对寻址的无条件转移指令，指令中的形式地址为 $40\mathrm{H}.$ 。则取指令后及指令执行后PC的内容为（）。  

A.2000H,2042HB.2002H，2040HC.2002H,2042H D.2000H,2040H  

17.某计算机的主存容量为 $4{\bf{M}}{\times}16$ 位，且存储字长等于指令字长，若该机能完成97种操作，操作码位数固定，且有直接、间接、基址、变址、相对、立即六种寻址方式，则相对寻址的偏移量范围为（）。  

A.  $(-32,+31)$  B.(-64,  $+63)$  C.(-128,  $+127)$  D.(-256,  $+255$  

18.对按字寻址的机器，程序计数器和指令寄存器的位数各取决于（）  

A.机器字长，存储器的字数B.存储器的字数，指令字长C.指令字长，机器字长D.地址总线宽度，存储器的字数  

19.假设寄存器R中的数值为200，主存地址为200和300的地址单元中存放的内容分别是300和400，则（）方式下访问到的操作数为200。  

A.直接寻址200B.寄存器间接寻址（R）C.存储器间接寻址（200） D.寄存器寻址R  

20.假设某条指令的第一个操作数采用寄存器间接寻址方式，指令中给出的寄存器编号为8，8号寄存器的内容为 $1200\mathrm{H}$ ，地址为1200H的单元中的内容为12FCH，地址为12FCH的单元中的内容为38D8H，而地址为38D8H的单元中的内容为88F9H，则该操作数的有效地址为（）。  

A.1200H B.12FCH C.38D8H D.88F9H  

21.设相对寻址的转移指令占3B，第一字节为操作码，第二、三字节为相对位移量（补码表示），而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取出一字节时，即自动完成 $(\mathrm{PC})+1{\rightarrow}\mathrm{PC}$ 。若PC的当前值为240（十进制），要求转移到290（十进制），则转移指令的第二、三字节的机器代码是（）；若PC的当前值为240（十进制），要求转移到200（十进制），则转移指令的第二、三字节的机器代码是（）。  
A.2FH、FFH B.D5H、00H C.D5H、FFH D.2FH、00H  

22.某计算机按字节编址，采用大端方式，某指令的一个操作数的机器数为ABCD00FFH，该操作数采用基址寻址方式，指令中形式地址（用补码表示）为FF00H，当前基址寄存器的内容为 $\mathrm{C000\,0000H}$ ，则该操作数的LSB（即FFH）存放的地址是（）。  

A.C000 FF00H B.C000FF03H C.BFFF FFOOH D.BFFFFF03H

 23.关于指令的功能及分类，下列叙述中正确的是（）。  

A.算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据B.移位操作指令，通常用于把指定的两个操作数左移或右移一位C.转移指令、子程序调用与返回指令，用于解决数据调用次序的需求D.特权指令，通常仅用于实现系统软件，这类指令一般不提供给用户  

24.【2009统考真题】某机器字长为16位，主存按字节编址，转移指令采用相对寻址，由2字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一字节PC自动加1。若某转移指令所在主存地址为 $2000\mathrm{H}$ ，相对位移量字段的内容为06H，则该转移指令成功转移后的目标地址是（）。  

A.2006H B.2007H C.2008H D.2009H  

25.【2011统考真题】偏移寻址通过将某个寄存器的内容与一个形式地址相加来生成有效地址。下列寻址方式中，不属于偏移寻址方式的是（）。  

A.间接寻址B.基址寻址C.相对寻址D.变址寻址  

26.【2011统考真题】某机器有一个标志寄存器，其中有进位/借位标志CF、零标志ZF、符号标志SF和溢出标志OF，条件转移指令bgt（无符号整数比较大于时转移）的转移条件是()。  

$$
\mathrm{CF+OF=1}\qquad\mathrm{B.}\quad\overline{{\mathrm{SF}}}+\mathrm{ZF}=1\qquad\mathrm{C.}\quad\overline{{\mathrm{CF+ZF}}}=1\qquad\mathrm{~D.}\quad\overline{{\mathrm{CF+SF}}}=1
$$  

27.【2013统考真题】假设变址寄存器R的内容为 $1000\mathrm{H}$ ，指令中的形式地址为 $2000\mathrm{H}$ ；地址1000H中的内容为 $2000\mathrm{H}$ ，地址 $2000\mathrm{H}$ 中的内容为 $3000\mathrm{H}$ ，地址 $3000\mathrm{H}$ 中的内容为4000H，则变址寻址方式下访问到的操作数是（）  

A.1000H B.2000H C.3000H D.4000H  

28.【2014统考真题】某计算机有16个通用寄存器，采用32位定长指令字，操作码字段（含 寻址方式位）为8位，STORE指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任意一个通用寄存器，且偏移量用补码表示，则STORE指令中偏移量的取值范围是（）  

A.  $-32768\!\sim\!+32767$  B.-32767\~+32768 C.  $-65536{\sim}+65535$  D.-65535\~+65536  

29.【2016统考真题】某指令格式如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/166d38835f2db06c70a799c92705c61cd8b55a080b964360cf86301a51f5b356.jpg)  

其中M为寻址方式，I为变址寄存器编号，D为形式地址。若采用先变址后间址的寻址方式，则操作数的有效地址是（）。  

A.  $\mathrm{I}+\mathrm{D}$  B.  $(\mathrm{I})+\mathrm{D}$  C. (I) + D) D.(I) + D  
30.【2017统考真题】下列寻址方式中，最适合按下标顺序访问一维数组元素的是（）。A.相对寻址B.寄存器寻址C.直接寻址D.变址寻址  

31.【2018统考真题】按字节编址的计算机中，某double型数组A的首地址为 $2000\mathrm{H}$ ，使用变址寻址和循环结构访问数组A，保存数组下标的变址寄存器的初值为0，每次循环取一个数组元素，其偏移地址为变址值乘以sizeof(double)，取完后变址寄存器的内容自动加1。若某次循环所取元素的地址为2100H，则进入该次循环时变址寄存器的内容是（）。  

A. 25 B.32 C.64 D.100  

32.【2019统考真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为1234 FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为FF12H，基址寄存器的内容为 $\mathrm{F}000\,\,0000\mathrm{H}$ ，则该操作数的LSB（最低有效字节）所在的地址是（）  

A.F000FF12H B.F000FF15H C.EFFFFF12H D.EFFFFF15H  

33.【2020统考真题】某计算机采用16位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有48条指令，支持直接、间接、立即、相对4种寻址方式。在单地址指令中，直接寻址方式的可寻址范围是（）。  

A.0\~255 B.0\~1023 C.-128\~127 D.-512\~511  

34.【2023统考真题】某运算类指令中有一个地址码为通用寄存器编号，对应通用寄存器中存放的是操作数或操作数的地址，CPU区分两者的依据是（）。  

A.操作数的寻址方式B.操作数的编码方式C.通用寄存器的编号 D.通用寄存器的内容  

# 二、综合应用题  

01.某机字长为16位，存储器按字编址，访问内存指令格式如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/69085a9ac51c64fe5ffb44c6b9705680feffe1e4b86980317cefe936a1ceedf5.jpg)  

其中，OP为操作码，M为寻址特征，A为形式地址。设PC和Rx分别为程序计数器和变址寄存器，字长为16位，问：  

1）该指令能定义多少种指令？2）下表中各种寻址方式的寻址范围为多少？3）写出下表中各种寻址方式的有效地址EA的计算公式。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/345fa59f371ae7490d9bd35f932c168428ffda82fc702077bb20af965d0f489b.jpg)  

02.一条双字长的LOAD指令存储在地址为200和201的存储位置，该指令将指定的内容装入累加器（ACC）中。指令的第一个字指定操作码和寻址方式，第二个字是地址部分。主存内容示意图如下图所示。PC值为200，R1值为400，XR（变址寄存器）值为100。指令的寻址方式字段可指定任何一种寻址方式。请在下列寻  

址方式中，分析装入ACC的值为多少。  

1）直接寻址。2）立即寻址。3）间接寻址。4）相对寻址。5）变址寻址。 6）寄存器R1寻址。7）寄存器R1间接寻址。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b5e7443bf488a10ed4cedd05ab50d9871641a5be6ed61ce30660d8f8d2e1b753.jpg)  

03.某机的机器字长为16位，主存按字编址，指令格式如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22557510901d1f58bb4b6b88b3a82fabd25e5fb92a05f77c8e6fb176ba98d5c8.jpg)  

其中，D为位移量；X为寻址特征位。 $X\,{=}\,00$ ：直接寻址。 $X=01$ ：用变址寄存器X1进行变址。 $\mathrm{X}=10$ ：用变址寄存器X2进行变址。 $\mathrm{X}=11$ ：相对寻址。  

设( $\mathrm{PC})=1234\mathrm{H}$ ， $(\mathrm{X1})=0037\mathrm{H}$ ， $\mathrm{(X2)}=1122\mathrm{H}$ （H代表十六位进制数），请确定下列指令的有效地址：  

$\textcircled{\scriptsize{1}}$  4420H  $\circledcirc$  2244H  $\textcircled{3}$  1322H  $\textcircled{4}$  3521H  $\textcircled{5}$  6723H  

04.某计算机字长16位，标志寄存器FLAGS中的ZF、SF和OF分别是零标志、符号标志和溢出标志，采用双字节字长指令字。假定bgt（大于零转移）指令的第一个字节指明操作码和寻址方式，第二个字节为偏移地址 $\mathrm{Immm8}$ ，用补码表示。指令功能是：若 $[\mathrm{{ZF}}+(\mathrm{{SF}}\oplus\mathrm{{OF}})=0$ ），则 $\mathrm{PC}=\mathrm{PC}+2+\mathrm{mm}8{\times}2$ ；否则， $\mathrm{PC}=\mathrm{PC}+2$ 请回答下列问题：1）该计算机的编址单位是多少？  

2）bgt指令执行的是有符号整数比较，还是无符号整数比较？3）偏移地址 $\mathrm{Imm98}$ 的含义是什么？转移目标地址的范围是什么？  

05.一条双字长的取数指令（LDA）存于存储器的200和201单元，其中第一个字为操作码OP和寻址特征M，第二个字为形式地址A。假设PC的当前值为200，变址寄存器IX的内容为100，基址寄存器的内容为200，存储器相关单元的内容如下表所示：  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/562395faec3717f33547d0f0302853a43439d98ea75e71f6326ec2281b574128.jpg)  

下表的各列分别为寻址方式、该寻址方式下的有效地址及取数指令执行结束后累加器（AC）的内容，试补全下表：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c9e5a7c8c8d7ea0791d08301756f2c1a62f4545141b2f554405a0cd8bb88ecaa.jpg)  

06.【2010统考真题】某计算机字长为16位，主存地址空间大小为128KB，按字编址，采用单字长指令格式，指令各字段定义如下：  

转移指令采用相对寻址方式，相对偏移量用补码表示，寻址方式定义见下表。
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8263dbd9ea82b564ccdc51d7f4dd85d322a382f5864bcb8da1bb74ceda1f89b5.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/968d3ac1cbb7799fffdc37e47a26a2f9ea3b17fa64f684f594e6ee48a9699910.jpg)  
注：（X）表示存储器地址X或寄存器X的内容。  

回答下列问题：  

1）该指令系统最多可有多少条指令？该计算机最多有多少个通用寄存器？存储器地址寄存器（MAR）和存储器数据寄存器（MDR）至少各需要多少位？  

2）转移指令的目标地址范围是多少？  

3）若操作码0010B表示加法操作（助记符为add），寄存器R4和R5的编号分别为100B和101B，R4的内容为1234H，R5的内容为5678H，地址1234H中的内容为5678H，5678H中的内容为1234H，则汇编语句“add（R4)， $(\mathrm{R}5)^{+"}$ （逗号前为源操作数，逗号后为目的操作数）对应的机器码是什么（用十六进制表示）？该指令执行后，哪些寄存器和存储单元的内容会改变？改变后的内容是什么？  

07.【2013统考真题】某计算机采用16位定长指令字格式，其CPU中有一个标志寄存器，其中包含进位/借位标志CF、零标志ZF和符号标志NF。假定为该机设计了条件转移指令，其格式如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bd090848c3b6d20adec684d6082aa7bf4fc448592c7cff60d8ca94ec38f794ef.jpg)  
其中，00000为操作码OP；C、Z和N分别为CF、ZF和NF的对应检测位，某检测位为1时表示需检测对应标志，需检测的标志位中只要有一个为1就转移，否则不转移。例如，若 $\mathrm{C}=1\,,\;\;\mathrm{Z}=0\,,\;\;\mathrm{N}=1\,,$ 则需检测CF和NF的值，当 $\mathrm{CF}=1$ 或 $\mathrm{NF}=1$ 时发生转移；OFFSET是相对偏移量，用补码表示。转移执行时，转移目标地址为（PC） $^{+}\;^{2}\;^{+}$  $2\times$ OFFSET；顺序执行时，下一条指令地址为 $(\mathrm{PC})+2$ 。请回答下列问题：  

1）该计算机存储器是按字节编址还是按字编址？该条件转移指令向后（反向）最多可跳转多少条指令？  

2）某条件转移指令的地址为200CH，指令内容如下图所示，若该指令执行时 $\mathrm{CF}=0$  $\mathrm{{ZF=0,~NF=1,}}$ 则该指令执行后PC的值是多少？若该指令执行时 $\mathrm{CF}=1$ ， $Z\mathrm{F}=0$  ${\mathrm{NF}}=0$ ，则该指令执行后PC的值又是多少？请给出计算过程。  

3）实现“无符号数比较小于或等于时转移”功能的指令中，C、乙和 $_\mathrm{N}$ 应各是什么？4）以下是该指令对应的数据通路示意图，要求给出图中部件 $\circledast$  $\circledast$ 的名称或功能说明。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c00eb9f5c955eeabd983c94625c30069216dd124eaf07637b8bef94059f4a115.jpg)  

08.【2015统考真题】题中描述的计算机，某部分指令执行过程的控制信号如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cb24dd81822657d2396ca5bcdcdc3739697a39b112fe39cf7c3d7c0ae0a67eee.jpg)  

该机指令格式如下图所示，支持寄存器直接和寄存器间接两种寻址方式，寻址方式位分别为0和1，通用寄存器R0\~R3的编号分别为 $0,1,2$ 和3。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2247beed8defa773350d5fc444bbe870e2b5f37656bb143f8d39042639984a60.jpg)  

回答下列问题：  

1）该机的指令系统最多可定义多少条指令？  

2）假定inc、shl和sub指令的操作码分别为01H、 $\mathrm{02H}$ 和 $03\mathrm{H}$ ，则以下指令对应的机器代码各是什么？  

$\textcircled{\scriptsize{1}}$  inc R1  $(\mathrm{R1})+1{\rightarrow}\mathrm{R1}$   $\circledcirc$  shl R2,R1  $(\mathrm{R1})\!<\!1\!\to\!\mathrm{R2}$   $\textcircled{3}$  sub R3,（R1),R2  $((\mathrm{R}1))-(\mathrm{R}2)\to\mathrm{R}3$  

3）假设寄存器X的输入和输出控制信号分别为Xin和Xout，其值为1表示有效，为0表示无效（如 $\mathrm{PCout}=1$ 表示PC内容送总线）；存储器控制信号为MEMop，用于控制存储器的读（read）和写（write）操作。写出本题第一幅图中标号 $\circledcirc$  $^\mathrm{\textregistered}$ 处的控制信号或控制信号的取值。  

4）指令“subR1，R3，（R2)”和“incR1”的执行阶段至少各需要多少个时钟周期？  

09.【2021统考真题】假定计算机M字长为16位，按字节编址，连接CPU和主存的系统总线中地址线为20位、数据线为8位，采用16位定长指令字，指令格式及说明如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/643b2dc33f1b73efd15a6b6c359e2c92c8f5ce4ab0cfa92e7e42e0841534381f.jpg)  

其中， $\mathrm{op}1\sim\mathrm{op}3$ 为操作码，rs，rt和rd为通用寄存器编号，R[r]表示寄存器r的内容，imm为立即数，target为转移目标的形式地址。请回答下列问题。  

1）ALU的宽度是多少位？可寻址主存空间大小为多少字节？指令寄存器、主存地址寄 存器（MAR）和主存数据寄存器（MDR）分别应有多少位？  

2）R型格式最多可定义多少种操作？I型和J型格式总共最多可定义多少种操作？通用寄存器最多有多少个？  

3）假定0p1为0010和0011时，分别表示有符号整数减法和有符号整数乘法指令，则指令01B2H的功能是什么（参考上述指令功能说明的格式进行描述）？若1，2，3号通用寄存器当前内容分别为B052H，0008H，0020H，则分别执行指令01B2H和01B3H后，3号通用寄存器内容各是什么？各自结果是否溢出？  

4）若采用1型格式的访存指令中imm（偏移量）为有符号整数，则地址计算时应对imm 进行零扩展还是符号扩展？  

5）无条件转移指令可以采用上述哪种指令格式？  
# 4.2.4 答案与解析  

# 一、单项选择题  

01.B  

采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度。程序控制是靠转移指令而非寻址方式实现的。  

02.A  

转移指令有条件/无条件、直接/间接、相对/绝对三种属性。条件转移是指需要先判断条件是否成立，才决定是否转移；无条件转移是指不用判断条件就可以转移，典型的是函数调用和返回。直接转移是指转移目标地址直接放在指令中，执行时直接将地址码送入PC：间接转移是指转移目标地址存放在寄存器或内存单元中。相对转移是指转移目标地址为当前PC值加上偏移量，偏 移量一般在指令中；绝对转移是指转移目标地址直接由指令或寄存器给出。  

03.D  

CPU中寄存器的数量都不会太多，用很短的编码就可以指定寄存器，寄存器寻址需要的地址段位数为log(通用寄存器个数)，因此能有效地缩短地址段的位数。立即寻址，操作数直接保存在指令中，若地址段位数太小，则操作数表示的范围会很小：变址寻址，EA $=$ 变址寄存器IX的内容 $^+$ 形式地址A，A与主存寻址空间有关：间接寻址中存放的仍然是主存地址。  

04.B  

隐含寻址不明显给出操作数地址，而在指令中隐含操作数的地址，因此可以简化地址结构。  

05.B  

立即寻址最快，指令直接给出操作数；寄存器寻址次之，只需访问一次寄存器；直接寻址再次之，访问一次内存；间接寻址最慢，要访问内存两次或以上。  

06.A  

指令字中的形式地址为操作数的有效地址，这种方式为直接寻址。  

07.B  

变址寻址的有效地址是 $\mathrm{(X)+A}$ ，再进行间址，即把 $\mathrm{(X)+A}$ 中取出的内容作为真实地址EA，即  $\mathrm{EA}=((\mathrm{(X)}+\mathrm{A})$  

寄存器中的内容和指令地址码相加得到的是操作数的地址码。  

08.B  

变址寻址便于处理数组问题。基址寻址与变址寻址的区别见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e8049d7cf56958be7a1f660caf7f89e2bc1af43f990c17979558b13f34996147.jpg)  

09.B  

进、出堆栈时对栈顶指针的操作顺序是不同的，进栈时是先压入数据 $(\mathbf{A}){\rightarrow}\mathbf{M}_{\mathrm{SP}}$ ，后修改指针 $(\mathrm{SP})-1{\rightarrow}\mathrm{SP}$ ，说明栈指针是指向栈顶的空单元的，所以出栈时要先修改指针 $(\mathrm{SP})+1{\rightarrow}\mathrm{SP}$ ，然后才能弹出数据 $(\mathbf{M}_{\mathrm{SP}}){\rightarrow}\mathbf{A}$  
10.D  

相对寻址中，有效地址 $\mathrm{EA}\,{=}\,(\mathrm{PC})+\mathrm{A}$ （A为形式地址），执行本条指令时，PC已完成加1操作，PC中保存的是下一条指令的地址，因此以下一条指令的地址为基准位置的偏移量。  

11.C  

堆栈是主存（或寄存器）中一块特定的、按后进先出原则管理的存储区，寄存器堆栈称为硬堆栈，主存中划分出来的区域作为堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。  

12. C  

跳跃寻址通过转移类指令（如相对寻址）来实现，可用来实现程序的条件或无条件转移  

13.B  

寄存器R2中的值是1234H，内存单元1234H中的值是56H，1235H中的值是78H，由于采用小端方式，因此实际存储的数据为7856H，取出后存放到R1，因此R1的值为 $7856\mathrm{H}$  

14.C  

主存按字编址，指令字长为1个字（2字节），因此取出该指令后，PC自动加1，相对偏移量为06H，所以该转移指令执行后的PC值为 $4000\mathrm{H}+06\mathrm{H}+1\mathrm{H}=4007\mathrm{H}.$  

15. D  

将指令2222H展开成二进制为 $0010\ 001{\underline{{0}}}\ 0010\ 0010B$ ，因此寻址特征位 $\mathrm{X}=10$ ，即使用X2进行变址寻址，其有效地址为 $1188\mathrm{H}+22\mathrm{H}=$ 11AAH。  

16.C  

指令字长为16位，2字节，因此取指令后PC的内容为 $(\mathrm{PC})+2=2002\mathrm{H}$ ：无条件转移指令将下一条指令的地址送至PC，形式地址为 $40\mathrm{H}$ ，指令执行后 $\mathrm{PC}=2002\mathrm{H}+0040\mathrm{H}=2042\mathrm{H}.$  

17.A  

操作码位数固定，且能完成97种操作，则操作码位数是 $\scriptstyle{\overline{{\log_{2}\!97}}}\,=\,7$ 位；具有六种寻址方式，则寻址特征位数是 $\left.\overline{{\log_{2}\!6}}\,\right|\!=3$ 位；指令字长为16位，因此地址码位数是 $16-3-7=6$ 位，6位补码的表示范围为- $-32\!\sim\!+31$ ，即为相对寻址的偏移量范围。  

18.B  

机器按字寻址，程序计数器（PC）给出下一条指令字的访存地址（指令在内存中的地址），因此取决于存储器的字数；指令寄存器（IR）用于接收取得的指令，因此取决于指令字长。  

19.D  

直接寻址200访问的操作数是300，A错误。寄存器间接寻址（R）的访问结果与I一样，B错误。存储器间接寻址（200）表示主存地址200中的内容为有效地址，有效地址为300，访问的操作数是400，C错误。寄存器寻址R表示寄存器R的内容为操作数，只有D正确。  

20. A 寄存器间接寻址中操作数的有效地址 $\mathrm{EA}=(\mathrm{R}_{i})$ ，8号寄存器内容为1200H，因此 $\mathrm{EA}=1200\mathrm{H}$  

21. D、C  

首先需要讲解一下补码扩充的问题。补码的扩充只需使用符号位补足即可，也就是说正数补码的扩充只要补0，负数补码的扩充只需补1（这是由补码的性质决定的）。理解了该性质，这道题就变成了十进制转换为十六进制的简单问题。  

1）PC的当前值为240，该指令取出后PC的值为243，要求转移到290，即相对位移量为 $290-243=47$ ，转换成补码为 $2\mathrm{FH}$ 。由于数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为2FH，由于47是正数，因此只需在高位补0，所以第三字节为 $\mathrm{00H}$  
2）PC的当前值为240，该指令取出后PC的值为243，要求转移到200，即相对位移量为 $200-243=-43$ ，转换成补码为D5H。由于数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为D5H，由于-43是负数，因此只需在高位补1，所以第三字节为FFH。  

22.D  

基址寻址的操作数的有效地址为基址寄存器内容加上形式地址，即 $\mathrm{C000~0000H+FF00H=C000}$  $\ensuremath{0000\mathrm{H}}+$ FFFFFI $\mathrm{{F00H}=}$ BFFFFF00H。由于是大端方式，因此LSB的存放地址为BFFFFF03H。  

23.D  

算术与逻辑运算指令用于完成对一个（如自增、取反等）或两个数据的算术运算或逻辑运算，A错误。移位操作用于把一个操作数左移或右移一位或多位，B错误。转移指令、子程序调用与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求，C错误。  

24.C  

相对寻址 $\mathrm{EA}=(\mathrm{PC})+\mathrm{A}$ ，首先计算取指令后的PC值。转移指令由2字节组成，每取一字节PC加1，取指令后的PC值为2002H，因此 $\mathrm{{EA}=(\mathrm{{PC})+A}=2002H+06H=2008H.}$ 本题易误选A或B，选项A未考虑PC值的自动更新，选项B虽然考虑了PC值的自动更新，但未注意到该转移指令是一条2字节指令，PC值应是“ $^{+2}$ ”而不是“ $+1$ ”。  

25.A  

间接寻址不需要寄存器， $\mathrm{EA}=(\mathrm{A})$ 。基址寻址 $\mathrm{EA}=\mathbf{A}+$ 基址寄存器BR的内容：相对寻址 $\mathrm{EA}=\mathrm{A}+$ 程序计数器PC的内容：变址寻址 $\mathrm{EA}=\mathrm{A}+$ 变址寄存器IX的内容。后三者都是将某个寄存器的内容与一个形式地址相加而形成有效地址，所以统称偏移寻址。  

26.C  

假设两个无符号整数 $A$ 和 $B$ ，bgt指令会将 $A$ 和 $B$ 进行比较，也就是将 $A$ 和 $B$ 相减。若 $A>B$ 则 $A-B$ 肯定无进位/借位，也不为0（为 $0$ 时表示两数相等），因此CF和ZF均为O，选C。其余选项中用到了符号标志SF和溢出标志OF，SF表示结果的符号，OF是有符号整数的溢出标志位，对于无符号数运算，SF和OF没有意义，显然应当排除。  

27.D  

根据变址寻址的方法，变址寄存器的内容（1000H）与形式地址的内容（2000H）相加，得到操作数的实际地址（3000H)，根据实际地址访问内存，获取操作数 $4000\mathrm{H}$ ，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c0c2f4c24c538e3a48ebd79d22813dfd68fdf5bf3e8d5b13850ae4e8cabb7579.jpg)  

28.A  

采用32位定长指令字，其中操作码为8位，两个地址码共占用 $32\textrm{--}8\textrm{=}24$ 位，而STORE指令的源操作数和自的操作数分别采用寄存器直接寻址和基址寻址，机器中共有16个通用寄存器，因此寻址一个寄存器需要 $\log_{2}\!16=4$ 位，源操作数中的寄存器直接寻址用掉4位，而目的操作数采用基址寻址也要指定一个寄存器，同样用掉4位，则留给偏移量的位数为 $24-4-4=16$ 位，而偏移量用补码表示，因此16位补码的表示范围为-3 $2768\!\sim\!+32767$  

29.C  

变址寻址中，有效地址（EA）等于指令字中的形式地址D与变址寄存器I的内容之和，即 $\mathrm{EA}=(\mathrm{I})+\mathrm{D}$ 。间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数地址的地址，即 $\mathrm{EA}=(\mathrm{D})$ 。从而该操作数的有效地址是 $\mathrm{((I)+D)}$  
30.D  

在变址操作时，将计算机指令中的地址与变址寄存器中的地址相加，得到有效地址，指令提供数组首地址，由变垃寄存器来定位数据中的各元素。所以它最适合按下标顺序访问一维数组元素，选D。相对寻址以PC为基地址，以指令中的地址为偏移量确定有效地址。寄存器寻址则在指令中指出需要使用的寄存器。直接寻址在指令的地址字段直接指出操作数的有效地址。  

31.B  

根据变址寻址的公式 $\mathrm{EA}\,{=}\,(\mathrm{IC})+\mathrm{A}$ ，有 $\mathrm{\Delta(IV)=2100H-\Delta2000H=100H=256,}$ ，sizeof(double) $=8$ （双精度浮点数用8位字节表示），因此数组的下标为 $256/8=32\$  

32.D  

注意，内存地址是无符号数。  

操作数采用基址寻址方式， $\mathrm{EA}=(\mathrm{BR})+\mathrm{A}$ ，基址寄存器BR的内容为 $\mathrm{F}000\,\,0000\mathrm{H}$ ，形式地址用补码表示为FF12H即 $1111\ 1111\ 0001\ 0010\mathrm{B}$ ，因此有效地址为 $\mathrm{F000\000H+(-00E E H)=E F F}$ FF12H。计算机采用大端方式编址，所以低位字节存放在字的高地址处，机器数一共占4字节，该操作数的LSB所在的地址是EFFFFF12H $+\,3=$ EFFFFF15H。  

33.A  

48条指令需要6位操作码字段 $(2^{5}<48<2^{6}$ )，4种寻址方式需要2位寻址特征位（ $4\!=\!2^{2}$ 还剩 $16-6-2=8$ 位作为地址码，所以直接寻址范围为 $_{0\sim255}$ 。注意，主存地址不能为负。  

34.A  

指令字由操作码、寻址特征和地址码三个字段组成，寻址特征字段用来指明指令属于哪种寻址方式。若寻址方式是寄存器直接寻址，则地址码所指的通用寄存器中存放的是操作数，若寻址方式是寄存器间接寻址，则对应通用寄存器中存放的是操作数的地址。  

# 二、综合应用题  

01.【解答】  

1）因为OP字段长为5位，所以指令能定义 $2^{5}\,{=}\,32$ 种指令。  

2）、3）各种寻址方式的有效地址EA的计算公式、寻址范围见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea424a1fc017761cda43997f3930c83a8dc8761ce95ab6d12e32fe4e4dae0e98.jpg)  

02.【解答】  

1）直接寻址时，有效地址是指令中的地址码部分500，装入ACC的是800。  

2）立即寻址时，指令的地址码部分是操作数而不是地址，所以将500装入ACC。  

3）间接寻址时，操作数的有效地址存储在地址为500的单元中，由此得到有效地址为800，操作数是300。  

4）相对寻址时，有效地址 $\mathrm{EA}=(\mathrm{PC})+\mathrm{A}=202+500=702$ ，所以装入ACC的操作数是325。这是因为指令是双字长，在该指令的执行阶段，PC的内容已经加2，更新为下一条指令的地址202。  
5）变址寻址时，有效地址 $\mathrm{EA}=(\mathrm{NR})+\mathrm{A}=100+500=600$ ，所以装入ACC的操作数是900。6）寄存器寻址时，R1的内容400装入ACC。7）寄存器间接寻址时，有效地址是R1的内容400，装入ACC的操作数是700。  

03.【解答】  

取指令后， $\mathrm{PC}=1235\mathrm{H}$ （注意，不是 $1236\mathrm{H}$ ，因主存按字编址）。 $\textcircled{\scriptsize{1}}$  $\mathrm{X}=00$ ， $\mathrm{D}=20\mathrm{H}$ ，有效地址 $\mathrm{EA}=20\mathrm{H}$  $\circledcirc$  $X=10$ ， $\mathrm{D}=44\mathrm{H}$ ，有效地址 $\mathrm{EA}=1122\mathrm{H}+44\mathrm{H}=1166\mathrm{H}.$  $\textcircled{3}$  $X=11$ ， $\mathrm{D}=22\mathrm{H}$ ，有效地址 $\mathrm{{EA}}=1235\mathrm{{H}}+22\mathrm{{H}}=1257\mathrm{{H}}$  $\textcircled{4}$  $X=01$ ， $\mathrm{D}=21\mathrm{H}$ ，有效地址 $\mathrm{EA}=0037\mathrm{H}+21\mathrm{H}=0058\mathrm{H}$  $\circledast$  $X=11$ ， $\mathrm{D}=23\mathrm{H}$ ，有效地址 $\mathrm{{EA}}=1235\mathrm{{H}}+23\mathrm{{H}}=1258\mathrm{{H}}$  

04.【解答】  

1）因为PC的增量是2，且每条指令占2字节，所以编址单位是字节。  

2）根据“大于”条件判断表达式，可以看出该bg指令实现的是有符号整数比较。因为无符号数比较时，其判断表达式中没有溢出标志OF。继续分析该逻辑表达式，bgt指令的含义是当两数相减的结果大于0时，执行转移操作。因此，要满足bgt指令的条件，必须保 证如下两个条件：一是结果不为0，即零标志位ZF为0：二是结果的符号位与溢出标志位OF相同，即SFOF为O（两数相减结果大于0，有两种情况：第一种情况是结果没有溢出，此时OF位和SF位都为O：第二种情况是结果发生了溢出，此时OF和SF位都为1)。综上所述，逻辑表达式可表示为 $\mathrm{ZF}+(\mathrm{SF}\oplus\mathrm{OF})=0$ 。3）偏移地址 $\mathrm{Imm9}$ 为补码表示，说明转移目标地址可能在bgt指令之后。计算转移目标地址时，偏移量为 $\mathrm{Im}\mathrm{m}8{\times}2$ ，说明 $\mathrm{Immm8}$ 不是相对地址，而是相对指令数。 $\mathrm{Imm9}$ 的范围为 $-128\!\sim$ 127，所以转移目地址的范围是 $\mathrm{PC}+2+(-128{\times}2){\sim}\mathrm{PC}+2+127{\times}2$ ，也即转移目标地址的范围是相对于bgt指令的前127条指令到后128条指令之间。  

05.【解答】  

直接寻址：寄存器的内容是有效地址EA，所以直接寻址的有效地址为300，根据题给出的表格可知，地址300对应的内容为400。间接寻址：根据寄存器的内容寻找到的内容才是真正的有效地址，所以根据寄存器内容300找到的400才是间接寻址的有效地址，因此有效地址为400，地址400对应的内容为700。相对寻址：寄存器的内容加上PC的内容为有效地址，PC的当前值为200，所以当取出一条指令后，变为202，因此有效地址为 $202+300=502$ ，地址502对应的内容为900。变址寻址：变址寻址的有效地址为变址寄存器的内容加上累加器的内容，所以有效地址为 $100\,+$  $300=400$ ，地址400对应的内容为700。基址寻址：基址寻址的有效地址为基址寄存器的内容加上累加器的内容，所以有效地址为 $200+300=500$ ，地址500对应的内容为 $600$ 先变址后间址：先变址，即先让变址寄存器的内容加上累加器的内容，即400：再间址，意思就是根据地址400找到的内容才是有效地址，所以先变址后间址的有效地址为700。地址700对应的内容为401。  

先间址后变址：先间址，即先根据累加器的内容300找到间址的有效地址400；再变址，即400再加上变址寄存器的内容，也就是 $400+100=500$ ，地址500对应的内容为600。  

综上，得到下表：  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c2079d2980d724c722e492928f99eb8be47eca3321f95d3c4077b578c024322.jpg)  

# 06.【解答】  

1）操作码占4位，则该指令系统最多可有 $2^{4}\!=\!16$ 条指令。操作数占6位，其中寻址方式占3位、寄存器编号占3位，因此该机最多有 $2^{3}\,=\,8$ 个通用寄存器。主存地址空间大小为128KB，按字编址，字长为16位，共有 $128\mathrm{{KB}}/2\mathrm{{B}}=2^{16}$ 个存储单元，因此MAR至少为16位；本题已说明了存储字长为16位，因此MDR至少为16位。  

2）寄存器字长为16位，PC可表示的地址范围为 $0{\sim}2^{16}{-}1$ ，Rn可表示的相对偏移量为 $\cdot2^{15}{\sim}2^{15}$ -1，而主存地址空间为 $2^{16}$ ，因此转移指令的目标地址范围为0000H～FFFFH $(0{\sim}2^{16}{-}1)$  

3）汇编语句“add(R4), $({\tt R}5)^{+}$ ”对应的机器码为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2409d3635499b265dd349dd8bd5f98585f11ca964ca8d7908e2b6e732ec6a1c8.jpg)  

将对应的机器码写成十六进制形式为 $0010\,0011\ 0001\ 0101\mathrm{B}=2315\mathrm{H}\,.$  

该指令的功能是将R4的内容所指的存储单元的数据与R5的内容所指的存储单元的数据相加，并将结果送入R5的内容所指的存储单元中。 $(\mathrm{R4})=1234\mathrm{H}$ ， $(1234\mathrm{H})=5678\mathrm{H}$  $(\mathrm{R}5)=5678\mathrm{H}$  $(5678\mathrm{H})=1234\mathrm{H},$ ：执行加法操作 $5678\mathrm{H}+1234\mathrm{H}=68\mathrm{ACH}.$ 。之后R5自增。  

该指令执行后，R5和存储单元5678H的内容会改变，R5的内容从5678H变为5679H，存储单元5678H中的内容变为该指令的计算结果68ACH。  

# 07.【解答】  

1）因为指令长度为16位，且下一条指令地址为 $(\mathrm{PC})+2$ ，因此编址单位是字节。  

相对偏移量OFFSET为8位补码，表示范围为 $-128\!\sim\!127$ ，根据转移目标地址为 $(\mathrm{PC})+2+$  $2\times0$ OFFSET，若要向后跳转，则要求OFFSET必须为负数，OFFSET的最小值为-128，但在执行转移指令之前，PC进行了自增 $^{+2}$ 的操作，所以向后最多可跳转127条指令。  

2）指令中 $C=0$ ， $Z=1$ ， $\Nu=1$ ，因此应根据ZF和NF的值来判断是否转移。 $\mathrm{CF}=0$ ， $Z\mathrm{F}=0$  $\mathrm{NF}=1$ 时，需转移。已知指令中的偏移量为 $1110\ 0011\mathrm{B}=\mathrm{E}3\mathrm{H}$ ，符号扩展后为FFE3H，左移一位（乘以2）后为FFC6H，因此PC的值（即转移目标地址）为 $200\mathrm{CH}+2+\mathrm{FFC6H}=$ 1FD4H。 $\mathrm{CF}=1$ ， $Z\mathrm{F}=0$ ， ${\mathrm{NF}}=0$ 时不转移。PC的值为 $200\mathrm{CH}+2=200\mathrm{EH}.$  

3）指令中的C、Z和 $_\mathrm{N}$ 应分别设置为 $C=Z=1$ ， $\Nu\,{=}\,0$ 。两个数之间的大小比较通常是对两个数做减法运算，即两个数相减当结果为0或为负时转移，若为0，则ZF标志应当是1，若为负，则借位标志应该是1，而无符号数并不涉及符号标志NF。  

4）部件 $\textcircled{\scriptsize{1}}$ 用于存放当前指令，不难得出为指令寄存器；多路选择器根据符号标志C/Z/N来决定下一条指令的地址是PC+2还是 $\mathrm{PC}+2+2\times6$ OFFSET，因此多路选择器左边线  
上的结果应是 $\mathrm{PC}+2+2\times$ OFFSET。根据运算的先后顺序及与 $\mathrm{PC}+2$ 的连接，部件 $\circledcirc$ 用于左移一位实现乘以2，为移位寄存器。部件 $\mathcal{B}$ 用于 $\mathrm{PC}+2$ 和 $2\times$ OFFSET相加，为加法器。  

部件 $\circledcirc$ ：移位寄存器（用于左移一位）；部件 $\mathcal{B}$ ：加法器（地址相加）。  

08.【解答】  

1）指令操作码有7位，因此最多可定义 $2^{7}=128$ 条指令。  

2）各条指令的机器代码如下：  

$\textcircled{\scriptsize{1}}$ “incR1”的机器码为 $0000001\;0\;01\;0\;00\;0\;00$ ，即 $0240\mathrm{H}$  $\circledcirc$ “ $\mathrm{shbar}\,\mathrm{R}2$ ，R1”的机器码为 $0000010\ 0\ 10\ 0\ 01\ 0\ 00$ ，即 $0488\mathrm{H}$  $\textcircled{3}$ “subR3,（R1),R2”的机器码为 $0000011\;0\;11\;1\;01\;0\;10$ ，即06EAH。  

3）各标号处的控制信号或控制信号取值如下： $@00$  $\circledcirc$ mov; $\textcircled{3}$ mova; $\textcircled{4}$ left; $\circledast$ read; $^\mathrm{\textregistered}$ sub; $\textcircled{\scriptsize{2}}$ mov; $\circledast$ SRout。  

4）指令“subR1,R3，（R2)”的执行阶段至少包含4个时钟周期；指令“incR1”的执行阶段至少包含2个时钟周期。  

09.【解答】  

1）ALU的宽度为16位，ALU的宽度即ALU运算对象的宽度，通常与字长相同。地址线为20位，按字节编址，可寻址主存空间大小为 $2^{20}$ 字节（或1MB）。指令寄存器有16位，和单条指令长度相同。MAR有20位，和地址线位数相同。MDR有8位，和数据线宽度相同。  

2）R型格式的操作码有4位，最多有 $2^{4}$ （或16）种操作。I型和J型格式的操作码有6位，因为它们的操作码部分重叠，所以共享这6位的操作码空间，且前6位全为0的编码已被R型格式占用，因此I和J型格式最多有 $2^{6}\!-\!1=63$ 种操作。从R型和I型格式的寄存器编号部分可知，只用2位对寄存器编码，因此通用寄存器最多有4个。  

3）指令 $\mathrm{01B2H=000000\ 01\ 10\ 11\ 0010B}$ 为一条R型指令，操作码0010表示有符号整数减法指令，其功能为 $\mathrm{R}[3]\!\leftarrow\!\mathrm{R}[1]\!-\!\mathrm{R}[2],$ ，执行指令01B2H后， $\mathrm{R}[3]=\mathrm{B}052\mathrm{H}-0008\mathrm{H}=\mathrm{B}04\mathrm{AH},$ 结果未溢出。指令 $\mathrm{01B3H}=\mathrm{000000}\,\mathrm{01}\,\mathrm{10\,11\,0011B}.$ ，操作码0011表示有符号整数乘法指令，执行指令01B3H后， $\mathrm{R}[3]\!=\!\mathrm{R}[1]\!\times\!\mathrm{R}[2]\!=\!\mathrm{B}052\mathrm{H}\!\times\!0008\mathrm{H}\!=\!8290\mathrm{H},\mathrm{B}052\mathrm{H}$ 乘以8相当于将B052H算术左移3位，由于B052H是一个负数，符号位为1，在算术左移的过程中移出了101，不全为1，由此可以判断结果溢出。  

4）在进行指令的跳转时，既可能向前跳转，又可能向后跳转，偏移量是一个有符号整数，因此在地址计算时，应对imm进行符号扩展。  

5）无条件转移指令可以采用J型格式，将target部分写入PC的低10位，完成跳转。  

# 4.3程序的机器级代码表示  

命题追踪涉及过汇编代码的真题的年份（2012、2014、2015、2017、2019、2023）  

本节是2022年才新增的考点，但历年统考真题曾多次以综合题的形式考查过，难度较大，不少跨考生对此无从下手，相信通过本节的学习后，应能从容应对。统考大纲没有指定具体指令集，但历年统考真题主要考查的是x86汇编指令，因此本节主要介绍x86汇编指令。  
# 4.3.1 常用汇编指令介绍  

# 1.相关寄存器  

x86处理器中有8个32位的通用寄存器，各寄存器及说明如图4.11所示。为了向后兼容，EAX、EBX、ECX和EDX的高两位字节和低两位字节可以独立使用，E表示Extended，表示32位的寄存器。例如，EAX的低两位字节称为AX，而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16098179b12ef23c80f73188e819d11bf3ea18af269656a719130684f2a6f922.jpg)  
图4.11x86处理器中的主要寄存器及说明  

除EBP和ESP外，其他几个寄存器的用法是比较灵活的。  

# 2.汇编指令格式  

使用不同的编程工具开发程序时，用到的汇编程序也不同，一般有两种不同的汇编格式：AT&T格式和Intel格式（统考要求掌握的是Intel格式）。它们的区别主要体现如下：  

$\textcircled{\scriptsize{1}}$ AT&T格式的指令只能用小写字母，而Intel格式的指令对大小写不敏感。  

$\circledcirc$ 在AT&T格式中，第一个为源操作数，第二个为目的操作数，方向从左到右，合乎自然：在Intel格式中，第一个为目的操作数，第二个为源操作数，方向从右向左。  

$\textcircled{3}$ 在AT&T格式中，寄存器需要加前缀 $\omega_{0}$ ”，立即数需要加前缀“ $\S$ "；在Intel格式中，寄存器和立即数都不需要加前缀。  

$\textcircled{4}$ 在内存寻址方面，AT&T格式使用“（”和“)"，而Intel格式使用“[”和“]"。  

$\circledast$ 在处理复杂寻址方式时，例如AT&T格式的内存操作数“disp(base,index,scale)”分别表示偏移量、基址寄存器、变址寄存器和比例因子，如“8(%edx,%eax,2)”表示操作数为 $\mathrm{M}[\mathrm{R}[\mathrm{edx}]+\mathrm{R}[\mathrm{eax}]^{*}2+8]$ ，其对应的Intel格式的操作数为‘ $^{*}[\mathrm{edx+ex}^{*}2+8]$  

$\circledcirc$ 在指定数据长度方面，AT&T格式指令操作码的后面紧跟一个字符，表明操作数大小，“b”表示byte（字节）、“w”表示word（字）或“1”表示long（双字）。Intel格式也有类似的语法，byte ptr、word ptr d word ptr。  

# 注意  

由于32或64位体系结构都是由16位扩展而来的，因此用word（字）表示16位。  

表4.2展示了两种格式的几条不同指令。其中，mov指令用于在内存和寄存器之间或者寄存器之间移动数据；lea指令用于将一个内存地址（而不是其所指的内容）加载到目的寄存器。  
表4.2AT&T格式指令和Imtel格式指令的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/49dd1199e96b48c53ff69b24837136b50fa7439742b0d9afe5606d78dc87dc74.jpg)  
注：R[表示寄存器r的内容，M[addr]表示主存单元addr的内容，→或 $\leftarrow$ 表示信息传送方向。  

两种汇编格式的相互转换并不复杂，但历年统考真题采用的均是Intel格式。  

# 3.常用指令  

汇编指令通常可分为数据传送指令、算术和逻辑运算指令和控制流指令，下面以Intel格式为例，介绍一些常用的指令。以下用于操作数的标记分别表示寄存器、内存和常数。  

<reg>：表示任意寄存器，若其后带有数字，则指定其位数，如<reg32>表示32位寄存器（eaxebx,ecx,edx,esi,edi,esp或ebp）;；<reg16>表示16位寄存器（ax,bx，cx或dx）;<reg8>表示8位寄存器（ah,al,bh,bl,ch,cl,dh,dl）。  

<mem>:表示内存地址（如[eax]、[var $^+$ 4]或dwordptr[eax $^+$ ebx])  

<con>：表示8位、16位或32位常数。<con8>表示8位常数；<con16 $>$ 表示16位常数；<con32>表示32位常数。  

# 命题追踪分析汇编指令对应的二进制代码（2010）  

$\mathrm{x86}$ 中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式，比如mov指令就有28种机内编码，用于不同操作数类型或用于特定寄存器，例如，  

movax,<conl6> #机器码为B8H moval,<con8> #机器码为BOH mov <reg16>,<reg16>/<mem16> #机器码为89H mov<reg8>/<mem8>,<reg8> #机器码为8AH mov<reg16>/<mem16>,<reg16> #机器码为8BH  

# 命题追踪模仿写出简单语句的机器级指令（2012）  

（1）数据传送指令  

1）mov指令。将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。  

其语法如下：  

mov<reg>,<reg> mov<reg>,<mem> mov <mem>,<reg> mov<reg>,<con> mov<mem>，<con>  

举例：  

moveax,ebx #eb x ea x mov byteptr[var],5#将5保存到var值指示的内存地址的一字节中  

双操作数指令的两个操作数不能都是内存，即mov指令不能用于直接从内存复制到内存，若需在内存之间复制，可先从内存复制到一个寄存器，再从这个寄存器复制到内存  
2）push指令。将操作数压入内存的栈，常用于函数调用。ESP是栈顶，入栈前先将ESP值减4（栈增长方向与内存地址增长方向相反），然后将操作数压入ESP指示的地址。  

其语法如下：  

push <reg32> push <mem> push <con32>  

举例（注意，栈中元素固定为32位）  

pusheax #将eax值入栈 push[var] #将var值指示的内存地址的4字节值入栈  

3）pop指令。与push指令相反，pop指令执行的是出栈工作，出栈前先将ESP指示的地址中的内容出栈，然后将ESP值加4。  

其语法如下：  

popeax #弹出栈顶元素送到eax pop[ebx]#弹出栈顶元素送到ebx值指示的内存地址的4字节中  

（2）算术和逻辑运算指令  

1）add/sub指令。add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub指令用于两个操作数相减，相减的结果保存到第一个操作数中。  

它们的语法如下：  

add<reg>，<reg>/sub<reg>，<reg> add<reg>,<mem>/sub <reg>,<mem> add<mem>,<reg>/sub<mem>,<reg> add<reg>,<con>/sub <reg>，<con> add<mem>，<con>/sub<mem>，<con>  

举例：  

subeax,10 #eax-eax-10 addbyte ptr [var],10#10与var值指示的内存地址的一字节值相加，并将结果#保存在var值指示的内存地址的字节中  

2）inc/dec指令。inc、dec指令分别表示将操作数自加1、自减1。  

它们的语法如下：  

inc <reg>/dec<reg> inc<mem>/dec <mem> 举例：deceax #eax值自减1 inc dword ptr [var] #var值指示的内存地址的4字节值自加1  

3）imul指令。有符号整数乘法指令，有两种格式： $\textcircled{\scriptsize{1}}$ 两个操作数，将两个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器： $\circledcirc$ 三个操作数，将第二个和第三个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器。  

其语法如下：  

imul <reg32>,<reg32> imul <reg32>,<mem> imul<reg32>,<reg32>,<con> imul <reg32>,<mem>,<con>  

举例：  

imul eax,[var] #eax  $\leftarrow$  eax\*[var] imul esi,edi,25 #esi  $\leftarrow$  edi  $\star~{}^{25}$  

乘法操作结果可能溢出，则编译器置溢出标志 $\mathrm{OF}=1$ ，以使CPU调出溢出异常处理程序。  
4）idiv指令。有符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax中的内容（共64位），操作结果有两部分：商和余数，商送到eax，余数则送到edx。  

其语法如下：  

idiv <reg32> idiv<mem>  

举例：idivebx idiv dword ptr [var]  

5）and/or/xor指令。and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操 作数的位操作，操作结果放在第一个操作数中。  

它们的语法如下：  

and<reg>，<reg>/or<reg>，<reg>/xor<reg>，<reg> and<reg>,<mem>/or<reg>,<mem>/xor<reg>,<mem> and <mem>,<reg>/or <mem>,<reg>/xor<mem>,<reg> and<reg>,<con>/or<reg>，<con>/xor<reg>，<con> and<mem>,<con>/or<mem>,<con>/xor<mem>,<con>  

举例：  

andeax,OfH#将eax中的前28位全部置为0，最后4位保持不变xoredx,edx#置edx中的内容为0  

6）not指令。位翻转指令，将操作数中的每一位翻转，即 $_{0\to1}$ 、1一0  

其语法如下：  

not <reg> not<mem>  

举例：  

notbyteptr[var]#将var值指示的内存地址的一字节的所有位翻转  

7）neg指令。取负指令。  

其语法如下：neg <reg> neg <mem>  

举例：  

8）shil/shr指令。逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。  

它们的语法如下：  

sh1<reg>,<con8>/shr <reg>，<con8> shl<mem>,<con8>/shr <mem>,<con8> shl<reg>，<cl>/shr<reg>，<cl> shl<mem>,<cl>/shr<mem>，<c1>  

举例：  

shleax,1#将eax值左移1位shrebx,cl#将ebx值右移n位（n为cl中的值）  

（3）控制流指令  

$\mathrm{x86}$ 处理器维持着一个指示当前执行指令的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签（label）指示程序中的指令地址，在x86汇编代码中，可在任何指令前加入标签。例如，  

mov esi,[ebp+8] begin: xor ecx,ecx mov eax,[esi]  
这样就用begin指示了第二条指令，控制流指令通过标签就可以实现程序指令的跳转。  

# 命题追踪无条件转移指令的指令格式（2021）  

1）jmp指令。jmp指令控制IP转移到label所指示的地址（从label中取出指令执行）。其语法如下：  

jmp<label>  

举例：jmpbegin#转跳到begin标记的指令执行  

# 命题追踪条件转移指令与标志位的结合（2013）  

2）jcondition指令。条件转移指令，依据CPU状态字中的一系列条件状态转移。CPU状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等。  

其语法如下：  

je<label>(jump whenequal) jz<label>（jump when last result was zero） jne<label>(jump when not equal）jg<label>（jump when greater than) jge<label>(jump when greater than or equal to) jl <label>(jump when less than) ile<label> (iump when less than or equal to)  

举例：  

cmpeax,ebx jledone#若eax值 $<=$ ebx值，则跳转到done执行：否则执行下一条指令  

3）cmp/test指令。cmp指令的功能相当于sub指令，用于比较两个操作数的值。test指令的功能相当于and指令，对两个操作数进行逐位与运算。与sub和and指令不同的是，这两类指令都不保存操作结果，仅根据运算结果设置CPU状态字中的条件码。  

其语法如下：  

cmp<reg>，<reg>/test<reg>,<reg> cmp<reg>,<mem>/test<reg>,<mem> cmp <mem>,<reg>/test<mem>,<reg> cmp<reg>，<con>/test<reg>,<con>  

cmp test j condition，举例：  

c mpd word ptr [var],10#将var指示的主存地址的4字节内容，与10比较jneloop#若相等则继续顺序执行：否则跳转到1oop处执行testeax,eax #测试eax是否为零 jzxxxx#为零则置标志ZF为1，转跳到xxxx处执行  

# 命题追踪call指令的功能（2019）  

4）call/ret指令。分别用于实现子程序（过程、函数等）的调用及返回。其语法如下：  

call <label> ret  

call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其他简单 的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回调用之前的地址）。ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指 令地址执行。call和ret是程序（函数）调用中最关键的两条指令。  
理解上述指令的语法和用途，可以更好地帮助读者解答相关题型。读者在上机调试C程序代码时，也可以尝试用编译器调试，以使更好地帮助理解机器指令的执行。  

# 4.3.2选择语句的机器级表示  

常见的选择结构语句有if-then、if-then-else等。编译器通过条件码（标志位）设置指令和各类转移指令来实现程序中的选择结构语句。条件码描述了最近的算术或逻辑运算操作的属性，可以检测这些寄存器来执行条件分支指令，最常用的条件码有CF、ZF、SF和OF。  

常见的算术逻辑运算指令（add，sub,imul，or,and，shl,inc,dec,not,sal等）会设置条件码，还 有cmp和test指令只设置条件码而不改变任何其他寄存器。  

之前介绍的jcondiion条件转跳指令，就是根据条件码ZF和SF来实现转跳的。  

if-else语句的通用形式如下：  

if(testexpr) then statement else else statement  

这里的test_expr是一个整数表达式，它的取值为0（假），或为非0（真）。两个分支语句（then statement else statement）中只会执行一个。  

这种通用形式可以被翻译成如下所示的goto语句形式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99de2ec0647f045fd562ae8b7c72c2a534fddb8bc8716ce24718f9784d401682.jpg)  

对于下面的C语言函数：  

int get cont（int\*pl,int  $\star_{\mathsf{P}2}$  if(p1>p2) return\*p2; else return\*pl;  

已知p1和p2对应的实参已被压入调用函数的栈帧，它们对应的存储地址分别为 ${\mathrm{R}}[{\mathrm{ebp}}]+8$ R[ebp]+12（EBP指向当前栈帧底部），返回结果存放在EAX中。对应的汇编代码为  

mov eax,dword ptr [ebp+8] mov edx,dword ptr [ebp+12] cmp eax,edx jbe .L1 mov eax,dword ptr [edx] jmp .L2 .L1: mov eax,dword ptr [eax] .L2:  

#R[eax]-M[R[ebp]+8],即R[eax]  $\tt=p1$  #R[edx]M[R[ebp]+12],即R[edx]  $\tt=p2$  #比较p1和p2，即根据p1-p2的结果置标志

#若 $\mathtt{p1<=p2}$ ，则转标记L1处执行

#R[eax]-M[R[edx]],即R[eax]  $\tt=\tt M$  [p2]

 #无条件跳转到标记L2执行  

#R[eax]←M[R[eax]],即R[eax]  $\tt=\tt M$  [p1] p1和p2是指针型参数，所以在32位机中的长度是dwordpt，比较指令cmp的两个操作数都应来自寄存器，因此应先将p1和p2对应的实参从栈中取到通用寄存器，比较指令执行后得到各个条件码，然后根据各条件码值的组合选择执行不同的指令，因此需要用到条件转移指令。  
# 4.3.3循环语句的机器级表示  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e9ce93948244371752a99da718858d0591e96463fdaa6dbe6dd22cbbc3cf37e.jpg)  

循环语句的机器级代码分析（2014、2017、2019、2023）  

常见的循环结构语句有while、for和do-while。汇编中没有相应的指令存在，可以用条件测试和转跳组合起来实现循环的效果，大多数编译器将这三种循环结构都转换为do-while形式来产生机器代码。在循环结构中，通常使用条件转移指令来判断循环条件的结束。  

（1）do-while循环  

do-while语句的通用形式如下：  

body statement while(test expr);  

这种通用形式可以被翻译成如下所示的条件和goto语句  

loop: body statement  $\scriptstyle\mathrm{t}=$  test_expr; if(t) goto loop;  

也就是说，每次循环，程序会执行循环体内的语句，body_statement至少会执行一次，然后执行测试表达式。若测试为真，则继续执行循环。  

（2）while循环  

while语句的通用形式如下：while(test expr)  

body statement  

与do-while，body statement，test expr，循环有可能中止。GCC通常会将其翻译成条件分支加do-while循环的方式。  

用如下模板来表达这种方法，将通用的while循环格式翻译成do-while循环：  

t=test expr; if(!t) gotodone; do body statement while(test expr); done:  

相应地，进一步将它翻译成goto语句  

t=test expr; if(!t) goto done; loop:  

body statement t=test expr; if(t) gotoloop; done:  

（3）for循环  

for循环的通用形式如下：  

for（init expr; test_expr;update expr)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c59e1434ff34a9f2d84130def9419a860a7e3cf1681145df32fe17e1ef02bf32.jpg)  
这个for循环的行为与下面这段while循环代码的行为一样：  

init_expr; while(testexpr){ body statement update expr;  

进一步把它翻译成goto语句：  

init expr; t=test_expr; if(!t) goto done; loop: body statement update expr; t=test_expr; if(t) gotoloop; done:  

下面是一个用for循环写的自然数求和的函数：  

int nsum for（intn）{int i; int result  $\mathbf{\varepsilon}=\mathbf{\varepsilon}_{0}$  for  $\scriptstyle({\dot{\mathrm{i}}}=1;{\dot{\mathrm{i}}}<={\mathrm{n}};{\dot{\mathrm{i}}}++)$  result  $\scriptstyle+=\,\mathrm{i}$  return result;  

这段代码中的for循环的不同组成部分如下：  

initexpr  $_\perp=\!1$  test_expr  $\scriptstyle{\mathrm{i}}<={\mathrm{n}}$  update expr  $\ \ \dot{\mathbf{1}}++$  body statement result  $\scriptstyle+={\dot{\mathbf{x}}}$  

通过替换前面给出的模板中的相应位置，很容易将for循环转换为while或do-while循环。将这个函数翻译为goto语句代码后，不难得出其过程体的汇编代码：  

mov ecx,dword ptr [ebp+8] #R[ecx]-M[R[ebp]  $\mathbf{+8]}$  ，即  $\mathtt{R}\left[\mathtt{e c x}\right]\mathtt{=}\mathtt{n}$  mov eax,0 #R[eax]-0,即 result  $=\!0$  mov edx,1 #R[edx]-1，即  $_\mathrm{i}\!=\!\!1$  cmp edx,ecx #Compare R[edx]：R[ecx]，即比较i:n jgL2#Ifgreater，转跳到L2执行.L1: #loop: add eax,edx #R[eax]-R[eax]+R[edx], 即result  $\scriptstyle+=\mathrm{i}$  addedx,1#R[edx]-R[edx]+1，即 $\ \ \ \mathrm{i}_{\leftarrow}$ cmpedx,ecx#比较R[edx]和R[ecx]，即比较i：njle.L1#If lessor equal，转跳到L1执行.L2:  

已知n对应的实参已被压入调用函数的栈帧，其对应的存储地址为R[ebp]+8，过程nsum_for中的局部变量i和resut被分别分配到寄存器EDX和EAX中，返回参数在EAX中。  

# 4.3.4过程调用的机器级表示  

前面提到的call/ret指令主要用于过程调用，它们都属于一种无条件转移指令。  
假定过程P（调用者）调用过程Q（被调用者），过程调用的执行步骤如下：  

1）P将入口参数（实参）放到Q能访问到的地方。2）P将返回地址存到特定的地方，然后将控制转移到Q。3）Q保存P的现场（通用寄存器的内容），并为自己的非静态局部变量分配空间。  

4）执行过程Q。5）Q恢复P的现场，将返回结果放到P能访问到的地方，并释放局部变量所占空间。  

6）Q取出返回地址，将控制转移到P。  

步骤2）是由call指令实现的，步骤6）通过ret指令返回到过程P。在上述步骤中，需要为入口参数、返回地址、过程P的现场、过程Q的局部变量、返回结果找到存放空间。  

用户可见寄存器数量有限，调用者和被调用者需共享寄存器，若直接覆盖对方的寄存器，则会导致程序出错。因此有如下规范：寄存器EAX、ECX和EDX是调用者保存寄存器，当P调用Q时，若Q需用到这些寄存器，则由P将这些寄存器的内容保存到栈中，并在返回后由P恢复它们的值。寄存器EBX、ESI、EDI是被调用者保存寄存器，当P调用Q时，Q必须先将这些寄存器的内容保存在栈中才能使用它们，并在返回P之前先恢复它们的值。  

每个过程都有自己的栈区，称为栈帧，因此，一个栈由若干栈帧组成，寄存器EBP指示栈帧的起始位置，寄存器ESP指示栈顶，栈从高地址向低地址增长。过程执行时，ESP会随着数据的入栈而动态变化，而EBP固定不变。当前栈帧的范围在EBP和ESP指向的区域之间。  

下面用一个简单的C语言程序来说明过程调用的机器级实现。  

int add（int  $_\mathrm{x}$  ,inty）{ return  $\tt x+y$  int caller(){ int templ  $_{\cdot}=\!125$  int temp2  $_{2=80}$  int sum  $\mathrm{i}=$  add(templ,temp2）; return sum;  

经GCC编译后，caller过程对应的代码如下（#后面的文字是注释）：  

caller: push ebp mov ebp,esp sub esp,24 mov[ebp-12],125#M[R[ebp]-12]-125，即temp1 $_{\cdot}\,=\,\!1\,2\,5$ mov[ebp-8],80#M[R[ebp]-8]←80，即temp2 $\scriptstyle{:=80}$ mov eax,dword ptr [ebp-8] #R[eax]-M[R[ebp]-8]，即R[eax]  $=$  temp2 mov[esp+4],eax#M[R[esp]+4]-R[eax]，即temp2入栈mov eax,dword ptr[ebp-12] #R[eax]←M[R[ebp]-12],即]R[eax]  $=$  temp1 mov[esp],eax#M[R[esp]]←R[eax]，即templ入栈calladd#调用add，将返回值保存在eax中mov[ebp-4],eax#M[R[ebp]-4]-R[eax]，即add返回值送summoveax，dword ptr[ebp-4]#R[eax]←M[R[ebp]-4]，即sum作为返回值leave  

图4.12给出了caller栈帧的状态，假定caller被过程P调用。执行第4行的指令后，ESP所指的位置如图中所示，可以看出GCC为caller的参数分配了24字节的空间。从汇编代码中可以看出，caller中只使用了调用者保存寄存器EAX，没有使用任何被调用者保存寄存器，因此在caller栈帧中无须保存除EBP外的任何寄存器的值；caller有三个局部变量templ、temp2和sum，皆被 分配在栈顿中；在用call指令调用add函数之前，caller先将入口参数从右向左依次将temp2和temp1的值（即80和125）保存到栈中。在执行call指令时再把返回地址压入栈中。此外，在最初进入caller时，还将EBP的值压入了栈，因此caller的栈帧中用到的空间占 $4+12+8+4=28$ 字节。但是，caller的栈帧共有 $4+24+4=32$ 字节，其中浪费了4字节的空间（未使用）。这是因为GCC为保证数据的严格对齐而规定每个函数的栈帧大小必须是16字节的倍数。  
call指令执行后，add函数的返回参数存放在EAX中，因此call指令后面的两条指令中，指令“mov[ebp-4],eax”将 add 的结果存入 sum变量的存储空间，该变量的地址为R[ebp]-4；指令“moveax,dwordptr[ebp-4]”将sum变量的值作为返回值送到寄存器EAX中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d980c64caf10e8c75223e749aaa0890e4e8f054132e40c8f446ccc6806ddab98.jpg)  
图4.12caller add  

在执行ret指令之前，应将当前栈帧释放，并恢复旧EBP的值，上述第14行leave指令实现了这个功能，leave指令功能相当于以下两条指令的功能：  

mov esp，ebp pop ebp  

其中，第一条指令使ESP指向当前EBP的位置，第二条指令执行后，EBP恢复为P中的I旧值，并使ESP指向返回地址。  

执行完leave指令后，ret指令就可从ESP所指处取返回地址，以返回P执行。当然，编译器也可通过pop指令和对ESP的内容做加法来进行退栈操作，而不一定要使用leave指令。  

add过程经GCc编译并进行链接后，对应的代码如下所示：  

8048469:55 push ebp 804846a:89e5 mov ebp,esp 804846c:8b450c mov eax,dwordptr [ebp+12] 804846f:8b5508 mov edx,dword ptr [ebp+8] 8048472:8d0402 lea eax,[edx+eax] 8048475:5d pop ebp 8048476:c3 ret  

通常，一个过程对应的机器级代码都有三个部分：准备阶段、过程体和结束阶段。  

上述第1、2行的指令构成准备阶段的代码段，这是最简单的准备阶段代码段，它通过将当前栈指针ESP传送到EBP来完成将EBP指向当前栈帧底部的任务，如图4.12所示，EBP指向add栈顿底部，从而可以方便地通过EBP获取入口参数。这里add的入口参数x和y对应的值（125和80）分别在地址为 ${\mathrm{R}}[{\mathrm{ebp}}]+8$  $\mathrm{R}[\mathsf{e b p}]+12$ 的存储单元中。  
上述第3、4、5行的指令序列是过程体的代码段，过程体结束时将返回值放在EAX中。这里好像没有加法指令，实际上第5行lea指令执行的是加法运算 $\mathrm{R[edx]+R[eax]=x+y.}$  

上述第6、7行的指令序列是结束阶段的代码段，通过将EBP弹出栈帧来恢复EBP在caller过程中的值，并在栈中退出add过程的栈帧，使得执行到ret指令时栈顶中已经是返回地址。这里的返回地址应该是caller代码中第12行的指令“mov[ebp-4],eax”的地址。  

add过程中没有用到任何被调用者保存寄存器，没有局部变量，此外，add是一个被调用过程，并且不再调用其他过程，因此也没有入口参数和返回地址要保存，因此，在add的栈帧中除了需要保存EBP，无须保留其他任何信息。  

# 4.3.5 本节习题精选  

# 一、单项选择题  

01.假设 $\mathrm{R}[\mathrm{ax}]=\mathrm{FFE}8\mathrm{H}$ ， $\mathrm{R}[\mathrm{bx}]=7\mathrm{FE6H}$ ，执行指令“addax,bx”后，寄存器的内容和各标志的变化为（）。  

A. $\mathrm{R}[\mathrm{ax}]=7\mathrm{FCEH}$ ， $\mathrm{OF}=1\,,\,\,\,\mathrm{SF}=0\,,\,\,\,\mathrm{CF}=0\,,\,\,\,\mathrm{ZF}=0$ B.  $\mathrm{R}[\mathrm{bx}]=7\mathrm{FCEH}$   $\mathrm{~\,~OF=l\,,~\,SF=0,~\,CF=0\,,~\,ZF=0~}$  C.  $\mathrm{R}[\mathrm{ax}]=7\mathrm{FCEH}$   $\mathrm{OF}=0,\;\;\mathrm{SF}=0,\;\;\mathrm{CF}=1,\;\;\mathrm{ZF}=0$  D. $\mathrm{R}[\mathrm{bx}]=7\mathrm{FCEH}$ ， $\mathrm{OF}=0,\;\;\mathrm{SF}=0,\;\;\mathrm{CF}=1,\;\;\mathrm{ZF}=0$  

02.假设 $\mathrm{R}[\mathrm{ax}]=7\mathrm{FE6H}$ ， ${\sf R}[{\sf b x}]=$ FFE8H，执行指令“subbx,ax”后，寄存器的内存和各标志的变化为（）。  

$$
\begin{array}{l l}{\mathrm{R[ax]=8002H,~\OF=0,~\SF=1,~CF=1,~\ZF=0}}\\ {\mathrm{R[bs]=8002H,~\OF=0,~\SF=1,~CF=0,~\ZF=0}}\\ {\mathrm{R[ax]=8002H,~\OF=1,~\SF=1,~CF=0,~\ZF=0}}\\ {\mathrm{R[bs]=8002H,~\OF=1,~\SF=1,~CF=0,~\ZF=0}}\end{array}
$$  

03.某计算机的数据采用小端方式存储，减法指令“subax,imm”的功能为 $\mathrm{(ax)-inmm\rightarrowax}$ imm表示立即数，该指令对应的十六进机器码为2dxxxx（从左到右以字节为单位由低地址到高地址），其中xxxx对应imm的机器码，若 $\mathrm{imm}=-3,\ \mathrm{(ax)}=7$ ，则该指令对应的机器码和执行后OF标志位的值分别为（）。  

A.2DFFFDH，0B.2DFFFDH，1 C.2DFDFFH,0 D.2DFDFFH,1  

04.某C语言程序中对数组变量b的声明为“intb[10][5];”，有一条for语句如下：for(  $\scriptstyle{\dot{\mathbf{1}}}=0$   $\scriptstyle{\dot{\Sigma}}\,<\,\Sigma\,0$   $\ \ \mathrm{i}_{\ ++}$  1 for(  $\scriptstyle{\dot{\mathbf{j}}}=0$   ${<}5$  ;j++) sum+  $\mathrm{\Sigma}_{\mathrm{\Sigma}}=\mathrm{\Sigma}_{0}$  [i] [j ] ;  

假设执行到“sum $\scriptstyle{\mathrm{~\!~+=}}$ b[i][i];”时，sum的值在eax中，b[i][o]所在的地址在edx中，j在esi中，则“sum+=b[i][i];”所对应的指令（Intel格式）可以是（）。  

A.add d word p tre a x,[edx+esi\*4] B.add dword ptreax,[edx+esi\*4] C.add dword ptreax,[edx+esi\*2] D. add dword ptr eax, [esi+edx\*2]  

05.假设  $\mathrm{R}[\mathrm{eax}]=080480\mathrm{B}4\mathrm{H}$   $\mathrm{R}[\mathsf{e b x}]=00000011\mathrm{H}$   $\mathbf{M}[080480\mathrm{F}8\mathrm{H}]=00000\mathbf{B}0\mathrm{H}$  ，执行指 令“imul eax,[eax+ebx\*4],-16”后，寄存器或存储单元的内容变为（）。  

A.R[eax]  $\mathrm{\Lambda=00000B00H}$  B.  $\mathbf{M}[080480\mathrm{F}8\mathrm{H}]=0000\mathbf{B}00\mathrm{H}$  C.R[eax]  $=$  FFFFF500H D.M[08048  $\mathrm{0F8H]=FFFFF5}$  OOH  

06.程序 $\mathrm{P}$ 中有两个变量i和j，被分别分配在寄存器eax和edx 中，P中语句“if(i<j){..}"  
对应的指令序列如下（左边为指令地址，中间为机器代码，右边为汇编指令），其中jle指令的偏移量为0d：  

804846a 39c2 cmp dword ptr edx,eax 804846c 7e0d jle xxxxxxxx  

若执行到804846aH处的cmp指令时， $\mathrm{i}=105$  $\mathrm{j}=100$ ，则jle指令执行后将会转到（）处的指令执行。  

A.8048461H B.804846eH C.8048479H D.804847bH  

07.假定全局数组a的声明为double $^{*}\mathrm{a}[8]$ ，a的首地址为 $80498\mathrm{c0H}$ ，变量i被分配在寄存器ecx中，现要将ai取到eax相应宽度的寄存器中，则所用的汇编指令是（）。  

A. mov eax,  $\mathrm{[exc*4+80498c0H]}$  B.mov eax,  $\mathrm{\exc^{*}4+80498c0H}$  C.moveax,[ecx\*8+80498c0H] D.mov eax,ecx\*8+80498c0H  

08.子程序调用指令的完整功能是（）  

A.改变堆栈指针SP的值 B.改变程序计数器PC的值C.改变程序计数器PC的值和堆栈指针SP的值D.改变地址寄存器的值  

09.下列关于选择结构语句“if（comp_A)then statement B；else statement C”对应的机器级代码表示的叙述中，错误的是（）。  

A.一定包含一条无条件转移指令B.一定包含一条条件转移指令（分支指令）C.计算comp_A的代码段一定在条件转移指令之前D.statement B statement C  

10.下列关于循环结构语句的机器级代码表示的叙述中，错误的是（）  

A.一定至少包含一条条件转移指令B.不一定包含无条件转移指令C.循环结束条件可以用一条比较指令CMP来实现 D.循环体内执行的指令不包含条件转移指令  

11.下列有关调用指令（转子指令）的叙述中，错误的是（）  

A.与高级语言源程序中的过程调用相对应，一次过程调用对应一条调用指令B.指令执行时必须保留返回地址，调用指令随后一条指令的地址是返回地址C.嵌套调用时返回地址通常保存在栈中，非嵌套调用时可保存在特定寄存器中D.指令执行时将无条件转移到目标地址处，转移目标地址无须在指令中明显给出  

12.假设P为调用过程，Q为被调用过程，程序在32位 $\mathrm{x86}$ 处理器上执行，以下是C语言程序中过程调用所涉及的操作：  

$\textcircled{\scriptsize{1}}$ 过程Q保存P的现场，并为非静态局部变量分配空间 $\textcircled{2}$ 过程P将实参存放到Q能访问到的地方 $\textcircled{\scriptsize{3}}$ 过程P将返回地址存放到特定处，并转跳到Q执行 $\circledast$ 过程Q取出返回地址，并转跳回到过程P执行 $\circledast$ 过程Q恢复P的现场，并释放局部变量所占空间 $\circledcirc$ 执行过程Q的函数体  

过程调用的正确执行步骤是（）1  $(\!\!2\!\!){\to}(\!\!3\!\!){\to}(\!\!4\!\!){\to}(\!\!1\!\!){\to}(\!\!5\!\!){\to}(\!\!6\!\!)$  B.  $\textcircled{2}$  一③→  $\textcircled{\scriptsize{1}}$  →  $\textcircled{4}$  →?→5 C.  $(\!\!2\!\!){\to}(\!\!3\!\!){\to}(\!\!1\!\!){\to}(\!\!6\!\!){\to}(\!\!5\!\!){\to}(\!\!4\!\!)$  D.  $\circledcirc$  →③→  $\textcircled{\scriptsize{1}}$  →  $\circledast$  →?→4  
# 二、综合应用题  

01.【2017统考真题】在按字节编址的计算机M上，f1的部分源程序（阴影部分）如下。将f1中的int都改成float，可得到计算fn）的另一个函数f2。  

int fl（unsignedn）(int sum  $_{:=1}$  power  $^{=1}$  for(unsignedi  $_{:=0}$   $\scriptstyle{\dot{\mathbf{1}}}<={\mathfrak{n}}-1$   $\dot{\mathbf{x}}_{++}$  power  $^{\star=2}$  sum  $+=$  power; return sum;  

对应的机器级代码（包括指令的虚拟地址）如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/607fd57b2b9f3a2bb1af57e36776ee9f6ac2b5385b71a2b83d93820161f523b7.jpg)  

其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令。  

1）计算机M是RISC还是CISC？为什么？2）f1的机器指令代码共占多少字节？要求给出计算过程。3）第20条指令cmp通过i减 $\mathrm{n-l}$ 实现对i和 $\mathrm{n-l}$ 的比较。执行f1（0）的过程中，当 $\mathrm{i}=0$ 时，cmp指令执行后，进位/借位标志CF的内容是什么？要求给出计算过程。4）第23条指令shl通过左移操作实现了power $^{*}2$ 运算，在f2中能否用shl指令实现power $^{*}2\,?$ 为什么？  

02.【2019统考真题】已知 $f(n)=n!=n\times(n-1)\times(n-2)\times\cdots\times2\times1$ ，计算 $f(n)$ 的 C语言函数fI的源程序（阴影部分）及其在32位计算机M上的部分机器级代码如下：  

ntf1（int n）{1 00401000 55 pushebp if(n>1) 11 00401018 837D0801 cmp dword ptr [ebp+8],1 120040101C7E17jlef1+35h（00401035）return n\*fl（n-l);13 0040101E 8B4508 mov eax,dword ptr [ebp+8] 14 00401021 83E801 sub eax, 1 15 00401024 50 push eax  
16 00401025 E8D6FFFFFF cal1f1（00401000) 19 00401030 OFAFC1 imul eax,ecx 2000401033EB05jmpf1+3Ah（0040103a）else return 1; 21 00401035 B801000000mov eax,1 26 00401040 3BEC cmp ebp,esp 30 0040104A C3 ret  

其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机M按字节编址，int型数据占32位。请回答下列问题：  

1）计算（10）需要调用函数f1多少次？执行哪条指令会递归调用f1？2）上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？3）根据第16行的call指令，第17行指令的虚拟地址应是多少？已知第16行的call指令采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？已知第16行的call指令的后4字节为偏移量，M是采用大端方式还是采用小端方式？ $\mathrm{~4~})\ f(13)=6227020800$ ，但f1（13）的返回值为1932053504，为什么两者不相等？要使f1（13）能返回正确的结果，应如何修改f1的源程序？5）第19行的imul指令（有符号整数乘）的功能是R[eax]-R[eax]xR[ecx]，当乘法器输出的高、低32位乘积之间满足什么条件时，溢出标志 $\mathrm{OF}=1?$ 要使CPU在发生溢出时转异常处理，编译器应在imul指令后加一条什么指令？  

03.【2019统考真题】对于题2，若计算机M的主存地址为32位，采用分页存储管理方式，页大小为4KB，则第1行的push指令和第30行的ret指令是否在同一页中（说明理由）？若指令Cache有64行，采用4路组相联映射方式，主存块大小为64B，则32位主存地址中，哪几位表示块内地址？哪几位表示Cache组号？哪几位表示标记（tag）信息？读取第16行的call指令时，只可能在指令Cache的哪一组中命中（说明理由）？  

04.【2023统考真题】某C语言程序段在计算机M上的部分机器级代码如下，数组a的定义为“inta[24][64]；”，每个机器级代码行中依次包含指令序号、虚拟地址、机器指令和汇编指令。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21008d381f9ea5a0865fc64418a80fde197442c9e18dcd2a4a8b1298c0ef3edf.jpg)  
请回答下列问题。  

1）第20条指令的虚拟地址是多少？  

2）已知第2条jmp和第7条jge都是跳转指令，其操作码分别是EBH和7DH，跳转目标地址分别为00401084H、004010BCH，这两条指令都采用什么寻址方式？给出第2条指令jmp的跳转目标地址计算过程。3）已知第19条mov指令的功能为“a[i]li] $\leftarrow\!10^{\,\circ}$ ”，其中ecx和edx为寄存器名，00422000H是数组a的首地址，指令中源操作数采用什么寻址方式？已知edx中存放的是变量jecx中存放的是什么？根据该指令的机器码判断M采用的是大端还是小端方式。4）第一次执行第19条指令时，取指令过程中是否会发生缺页异常？为什么？  

# 4.3.6 答案与解析  

# 一、单项选择题  

01.C  

该指令是Intel格式，add指令的目的寄存器为ax。add指令的补码加法过程为111111111110 $1000+0111\;1111\;1110\;0110=\!(1)0111\;1111\;1100\;1110$ （7FCEH），两个操作数的符号不同，必然不会溢出， $\mathrm{OF}\!=\!0$ ：结果的符号位为0， $\mathrm{SF}\!=\!0$ ；有进位， $\mathrm{CF}=\mathrm{C}\oplus\mathrm{Sub}=1\oplus0=1$ ：非0， $\mathrm{{ZF}\,{=}\,0}$  

# 注意  

无论是无符号数还是有符号数，都以二进制代码形式无差别地存放在计算机内。即便两个有符号数相加，也会导致CF的变动，只是CF值对有符号数运算是没有意义的。同理，两个无符号数相加，也会导致OF和SF的变动，只是OF值和SF值仅对有符号数运算有意义。  

02.B  

该指令是Intel格式，sub指令的目的寄存器为bx。sub减法运算用补码加法实现，被减数 $^+$ 减数逐位取反  $+\ 1=1111\ 1111\ 1110\ 1000+1000\ 0000\ 0001\ 1001+1=(1)1000\ 0000\ 0000\ 0010$  （8002H），两个操作数的符号位都是1，结果的符号位也是1，无溢出， $\mathrm{OF}\!=\!0$ ；结果为负数， $\mathrm{SF}=1$ 进位输出  $\mathrm{C_{out}}\mathrm{=}\mathrm{1}$  ，低位进位  ${\mathrm{Sub}}=1$  ，  $\mathrm{CF}=\mathrm{C}_{\mathrm{out}}\oplus\mathrm{Sub}=1\oplus1=0$  ：非  $0$  ，  $Z\mathrm{F}=0$  6  

03.C  

imm的值为-3，转换成二进制为1111111111111101B，即FFFDH，因为该计算机采用小端存储，先存储低位字节，所以该指令对应的机器码为2DFDFFH，OF是有符号数运算的溢出标志位，7-（-3)显然没有溢出，因此0F标志位为0。  

04.A  

b间][O]所在的地址在edx中，j在esi中，一个数组元素占4字节，所以b间的]的地址为R[edx]+R[esij $^{1*4}$ ，指令格式为Intel格式，第一个为目的操作数，第二个为源操作数，于是A正确。  

05. C  

指令的一个源操作数在内存单元中，地址为R[ea $\mathrm{x]+R[e b x]^{*}4=080480B4H+0000011H^{*}4=}$ 080480F8H。指令的功能是 $\mathrm{R}[\mathrm{ex}]\!\leftarrow\!\!\mathrm{M}[080480\mathrm{F}8\mathrm{H}]^{*}(-16)=(\!-\!000000\mathrm{B}0\mathrm{H})<<\!4=$ FFFFFF50H<<4 $=$ FFFFF $500\mathrm{H}$ 。目的操作数保存在eax中，所以主存单元 $080480\mathrm{F}8\mathrm{H}$ 中的内容不会改变。  

06.D  

$\mathrm{i}=105$  $\mathrm{j}=100$ ，即edx的内容为100，eax的内容为105，cmp指令就是对这两个数做减法，显然  $100<105$  ，满足jle指令小于或等于的条件，jle指令长度为2字节，所以jle指令执行后将 转移到当前PC值 $^+$ 偏移量 $=84846{\mathrm{H}}+2+0{\mathrm{d}}{\mathrm{H}}=804847{\mathrm{b}}{\mathrm{H}}$ 处执行。  
07.C  

每个double型的数组元素占8字节，数组a的首地址为  $80498\mathrm{c0H}$  ,i存储在ecx中，所以a[i] 在主存中的地址可表示为[ecx $\mathrm{{}^{*}8+80498c0H]}$ ，因此汇编指令可以是moveax, $\left[\mathrm{exc^{*}8+80498c0H}\right]$  

08.C  

子程序调用指令需要将程序断点保存至堆栈，这个过程会改变SP的值，同时也会改变PC的值以跳转到子程序执行。  

09.D  

在if语句的机器级代码中，comp_A后面紧接着有一个条件跳移指令，条件成立则转跳到statementB，statement B，会转跳到if-else的下一条语句，A、B和C正确。statementB不一定在statementC之前，这取决于条件转移指令的类型和方向，D错误。  

10.D  

循环结构循环体内最后会有一条条件转移指令，判断是否跳出循环，可以用比较指令（CMP）来实现，A和C正确，D错误。循环结构不一定包含无条件转移指令，B正确。  

11.D  

为了能保证从被调用过程返回到调用过程继续执行，必须确定并保存返回地址，这个地址是调用指令随后的指令的地址，返回地址只能由调用指令来计算并保存，因为执行调用指令后就跳转到了被调用过程，因此无法获取返回地址。为了保证嵌套调用时能够返回到调用过程，必须将返回地址压栈，若不压栈而保存在特定寄存器中，则后面执行的调用指令会将前面调用指令保存 的返回地址覆盖掉。调用指令执行时将无条件转移到目标地址处，这个目标地址就是被调用过程第一条指令的地址，它一定在调用指令中明显给出，因此D错误。  

12.C  

过程调用的具体过程已在4.3.4节中介绍  

# 二、综合应用题  

01.【解答】  

1）M为CISC。M的指令长短不一，不符合RISC指令系统的特点。2）fl的机器代码占96B。因为fl的第一条指令“pushebp”所在的虚拟地址为 $0040\ 1020\mathrm{H}$ ，最后一条指令“ret”所在的虚拟地址为0040107FH，所以fl的机器指令代码长度为0040 $107\mathrm{H}-\,0040\,1020\mathrm{H}+1=60\mathrm{H}=96\mathrm{B}.$  3) $\mathrm{CF}=1$ 。cmp指令实现i与 $\mathrm{n-1}$ 的比较功能，进行的是减法运算。在执行f1(0的过程中， $\mathtt{n}\,{=}\,0$ ，当 $\mathrm{i}\!=\!0$ 时， $\mathrm{i}=0000\ 0000\mathrm{H}$ ，并且 $\mathrm{n-1}=$ FFFFFFFFH。因此，执行第20条指令时，在补码加/减运算器中执行“ $0$ 减FFFFFFFFH"操作，即 $0000\ 0000\mathrm{H}+0000000\mathrm{H}+1=0000$  $0001\mathrm{H}$ ，此时进位输出 $C_{\mathrm{out}}\!=\!0$ ，低位进位 $\mathrm{Sub}=1,\;\;\mathrm{CF}=C_{\mathrm{out}}\oplus\mathrm{Sub}=0\oplus1=1.$ 4）f2中不能用shl指令实现power $^{*}2$ 。因为 $\mathrm{shl}$ 指令把一个整数的所有有效数位整体左移，而f2中的变量power是float型，其机器数中不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能实现“乘以2”的功能，因此f2中不能用shi指令实现power  $^{*}2$  。浮点数运算比整型运算要复杂，耗时也较长。  

02.【解答】  

1）计算 $f(10)$ 需要调用函数f1共10次，执行第16行的call指令会递归调用f1。2）第12行的le指令是条件转移指令，其含义为小于或等于时转移，本行代码的意义为：当 $n{\leqslant}1$ 时，跳转至地址 $0040\ 1035\mathrm{H}.$ 第16行的call指令为函数调用指令，第20行的jmp指令为无条件转移指令，第30行的ret指令为子程序的返回指令，这三条指令一定会使  
程序跳转执行。  

3）在计算机M上按字节编址，第16行的call指令的虚拟地址为00401025H，长度为5字节，因此第17行的指令的虚拟地址为 $0040\ 1025\mathrm{H}+5=0040\ 102\mathrm{AH}.$ ，第16行的call指令采用相对寻址方式，即目标地址 $\mathbf{\mu=}\,(\mathbf{PC})+$ 偏移量，call指令的目标地址为 $0040~1000\mathrm{H}$ 所以偏移量 $=$ 目标地址- $\mathrm{{(PC)}=0040\ 1000H\mathrm{{~-~}0040\ 102A H=F F F\ F D6H\mathrm{{.}}}}$ 根据第16行的call指令的偏移量字段为D6FFFFFF，可以确定M采用小端方式。  

4)因为 $\mathcal{f}\!\!\left(13\right)\,=\,6227020800$ ，其结果超出了32位int型数据可表示的最大范围，因此（13)的返回值是一个发生了溢出的错误结果。为使f1(13)能返回正确结果，可将函数f1的返double（或longlong，long double，或float）类型。  

5）若乘积的高33位不全为0或不全为1，则 $\mathrm{OF}=1$ 。编译器应在imul指令后加一条“溢出自陷指令”，使得CPU自动查询溢出标志OF，当 $\mathrm{OF}=1$ 时调出“溢出异常处理程序”。  

# 03.【解答】  

因为页大小为4KB，所以虚拟地址的高20位为虚拟页号。第1行的push指令和第30行的ret指令的虚拟地址的高20位都是 $00401\mathrm{H}$ ，因此两条指令在同一页中。  

指令Cache有64块，采用4路组相联映射方式，因此指令Cache共有 $64/4\,=\!16$ 组，Cache组号共4位。主存块大小为64B，因此块内地址为低6位。综上所述，在32位主存地址中，低6位为块内地址，中间4位为组号，高22位为标记。  

因为页大小为4KB，所以虚拟地址和物理地址的最低12位完全相同，因此call指令虚拟地址 $0040\ 1025\mathrm{H}$ 中的 $025\mathrm{H}=0000\,0010\,0101\mathrm{B}$ 为物理地址的低12位，对应的 $7{\sim}10$ 位为组号，因此对应的Cache组号为0。  

# 04.【解答】  

1）第19条指令的虚拟地址为004010AEH，且第19条指令占11字节，因此第20条指令的虚拟地址为 $004010\mathrm{AED+11}$ （十进制） $\mathrm{\Omega}=0040\ 10B9\mathrm{H}$  

2）第2条指令的虚拟地址为00401079H，占2字节，取该指令后， $\mathrm{PC}+2$ ，变为0040107AH，转移指令的目标地址为00401084H，因此偏移量为 $00401084\mathrm{H}-0040107\mathrm{AH}=09\mathrm{H}$ ，根据第2条指令的机器码可知，09H恰好是第2条指令给出的偏移量。第7条指令的分析同理。因此，第2条jmp和第7条jge指令都采用相对寻址方式。第2条指令jmp的跳转目标地址 $=0040\ 1079\mathrm{H}+2$ （十进制） $\mathrm{~\ensuremath~{~+~}~09H=0040~1084H}$  

3）第19条指令的源操作数为0AH，直接在机器指令中（ $.0\mathrm{A}\;00\;00\;00$ ）给出，因此采用立即（数）寻址方式。数组a的一行有64个元素，每个元素占4字节，因此a回的地址应为 $\mathrm{00422000h+i}{\times}64{\times}4+\mathrm{j}{\times}4=00422000\mathrm{h+i}{\times}256+\mathrm{j}{\times}4$ ，根据汇编指令中给出的计算公式ecx $^+$  $\mathrm{{edx^{*}4+00422000h}}$ 可知，ecx中存放的是 $\mathrm{i}{\times}256$ 。M采用小端方式。  

4）第一次执行第19条指令时，取指令过程中不会发生缺页异常。因为第19条指令所在的该程序段都在页号为 $00401\mathrm{H}$ 的同一个页面中，执行第19条指令时，该页已在主存，因此取指令过程中不会发生缺页异常。  

# 4.4CISC RISC  

指令系统朝两个截然不同的方向的发展：一是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的有采用 $\mathrm{x86}$ 架构的计算机；二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC），典型的有ARM、MIPS架构的计算机。  
# 4.4.1复杂指令系统计算机（CISC）  

随着集成电路技术的发展，软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了复杂指令系统计算机（CISC）。  

# 命题追踪 CISC的特点(2017)  

CISC的主要特点如下：  

1）指令系统复杂庞大，指令数目一般为200条以上。  

2）指令的长度不固定，指令格式多，寻址方式多。  

3）可以访存的指令不受限制。  

4）各种指令使用频度相差很大。  

5）各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。  

6）控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。  

如此庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长。后来人们发现，一味地追求指令系统的复杂和完备程度不是提高性能的唯一途径。对传统CISC指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有 $20\%$ 的简单指令被反复使用，约占整个程序的 $80\%$ 血 $80\%$ 左石的复杂指令则很少使用，约占整个程序的 $20\%$ 。从这一事实出发，人们开始用最常用的 $20\%$ 的简单指令，重组实现不常用的 $80\%$ 的指令功能，RISC随之诞生。  

# 4.4.2精简指令系统计算机（RISC）  

精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下：  

1）选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。2）指令长度固定，指令格式种类少，寻址方式种类少。3）只有LOAD/STORE（取数/存数）指令访存，其余指令的操作都在寄存器之间进行。4）CPU中通用寄存器的数量相当多。5）一定采用指令流水线技术，大部分指令在一个时钟周期内完成。6）以硬布线控制为主，不用或少用微程序控制。7）特别重视编译优化工作，以减少程序执行时间。  

值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于RISC具有更强的实用性，因此应该是未来处理器的发展方向。但事实上，当今时代Intel几乎一统江湖，且早期很多软件都是根据CISC设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。  

# 4.4.3 CISC RISC  

和CISC相比，RISC的优点主要体现在以下几点：1）RISC更能充分利用VLSI（超大规模集成电路）芯片的面积。CISC采用微程序控制，其  
控制存储器占CPU芯片面积的 $50\%$ 以上，而RISC采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的 $10\%$ 左右。  

2）RISC更能提高运算速度。RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。  

3）RISC便于设计，可降低成本，提高可靠性。RISC指令系统简单，因此机器设计周期短：其逻辑简单，出错概率低，有错也易发现，因此可靠性高。  

4）RISC有利于编译程序代码优化。RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。  

CISC和RISC的对比见表4.3。  

表4.3 CISC RISC
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c72ca4df9a8e8d7fdeb190d640247354dcff3e2ee6fb58e6a641d46da41d6b00.jpg)  

# 4.4.4 本节习题精选  

# 单项选择题  

01.下列关于RISC的叙述中，正确的是（）  

A.RISC机一定采用流水技术B.采用流水技术的机器一定是RISC机C.RISC CISCD.CPU配备很少的通用寄存器  

02.下列描述中，不符合RISC指令系统特点的是（）  

A.指令长度固定，指令种类少 B.寻址方式种类尽量减少，指令功能尽可能强C.增加寄存器的数目，以尽量减少访存次数D.选取使用频率最高的一些简单指令，以及很有用但不复杂的指令  

03.以下有关RISC的描述中，正确的是（）  

A.为了实现兼容，新设计的RISC是从原来CISC系统的指令系统中挑选一部分实现的B.采用RISC技术后，计算机的体系结构又恢复到了早期的情况C.RISC的主要目标是减少指令数，因此允许以增加每条指令的功能的方法来减少指令系统所包含的指令数D.以上说法都不对  

04.下列关于RISC和CISC的说法中，不正确的是（）  

A.RISC指令格式种类少，寻址方式少，指令长度固定，更容易用硬布线电路实现B.CISC指令功能强大，寻址方式多，使于汇编程序员编程C.CISC指令格式种类多，所以更有利于编译优化D.RISC多数指令能够在一个时钟周期内完成，特别适合流水线工作  
05.【2009统考真题】下列关于RISC的说法中，错误的是（）。  

A.RISC普遍采用微程序控制器B.RISC大多数指令在一个时钟周期内完成C.RISC的内部通用寄存器数量相对CISC多D.RISC的指令数、寻址方式和指令格式种类相对CISC少  

# 4.4.5 答案与解析  

# 单项选择题  

01.A  

RISC必然采用流水线技术，这也是由其指令的特点决定的。而CISC则无此强制要求，但为了提高指令执行速度，CISC也往往采用流水线技术，因此流水线技术并非RISC的专利。CISC机可以兼容很多不同的高级语言和软件，而RISC机的指令系统简单精简，只包含一些基本的指令，这些指令需要通过组合来实现复杂的功能，从而增加了编译器的设计难度和程序员的编程难度，因此CISC机的兼容性更好。CPU配备很多通用寄存器是RISC机的主要特点。  

02.B  

A、C和D都是RISC的特点。对于B，寻址方式种类尽量减少是RISC的特点，而增强指令的功能则是CISC的特点。RISC指令功能简单，复杂指令的功能由简单指令的组合来实现。  

03.D  

RISC选择一些常用的寄存器型指令，并不是为了兼容CISC，RISC也不可能兼容CISC，A错误。RISC只是CPU的结构发生变化，基本不影响整个计算机的结构，并且即使是采用RISC技术的CPU，其架构也不可能像早期一样简单，B错误。RISC的指令功能简单，通过简单指令的组合来实现复杂指令的功能，C错误，但RISC的主要目标是减少指令数是正确的。  

04.C  

CISC指令格式种类多，增大了编译优化的复杂性，因此不利于编译优化。  

05.A  

相对于CISC，RISC的特点是：指令条数少；指令长度固定，指令格式和寻址种类少；只有取数/存数指令访问存储器，其余指令的操作均在寄存器之间进行：CPU中通用寄存器多；大部分指令在一个时钟周期内完成；以硬布线逻辑为主，不用或少用微程序控制。B、C和D都是RISC的特点。由于RISC的速度快，因此普遍采用硬布线控制器，A错误。  

# 4.5 本章小结  

本章开头提出的问题的参考答案如下。  

1）什么是指令？什么是指令系统？为什么要引入指令系统？  

指令就是要计算机执行某种操作的命令。一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。  
2）一般来说，指令分为哪些部分？每部分有什么用处？  

一条指令通常包括操作码字段和地址码字段两部分。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。  

3）对于一个指令系统来说，寻址方式多和少有什么影响？  

寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成CPU结构的复杂化（详见下章），也不利于指令流水线的运行。而寻址方式太少虽然能够提高CPU的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。  

# 4.6常见问题和易混淆知识点  

1.简述各常见指令寻址方式的特点和适用情况。  

立即寻址操作数获取便捷，通常用于给寄存器赋初值。  

直接寻址相对于立即寻址，缩短了指令长度。  

间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。  

寄存器寻址的指令字较短，指令执行速度较快。  

寄存器间接寻址扩大了寻址范围。  

基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。  

变址寻址主要用于处理数组问题，适合编制循环程序。  

相对寻址用于控制程序的执行顺序、转移等。  

基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。  

# 2.一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？  

现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数（如char、int、float、double）可能是8位、16位、32位或64位等，因此可能占用1个、2个、4个或8个内存单元。也就是说，一个操作数可能有多个内存地址对应。  

有两种不同的地址指定方式：大端方式和小端方式。大端方式：指令中给出的地址是操作数最高有效字节（MSB）所在的地址。小端方式：指令中给出的地址是操作数最低有效字节（LSB）所在的地址。3.装入/存储（LOAD/STORE）型指令有什么特点？  

装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。这种指令风格在RISC指令系统中较为常见。为了规整指令格式，使指令具有相同的长度，规定只有LOAD/STORE指令才能访问内存。而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致。  

这种装入/存储型风格的指令系统的最大特点是，指令格式规整，指令长度一致，一般为32位。由于只有LOAD/STORE指令才能访问内存，因此程序中可能包含许多装入指令和存储指令，与一般通用寄存器型指令风格相比，其程序长度会更长。  
# 第5章中央处理器  

# 【考纲内容】  

（一）CPU的功能和基本结构  

（二）指令执行过程  

（三）数据通路的功能和基本结构  

（四）控制器的功能和工作原理  

五）异常和中断机制异常和中断的基本概念：异常和中断的分类；异常和中断的检测与响应  

（六）指令流水线指令流水线的基本概念：指令流水线的基本实现：结构冒险、数据冒险和控制冒险的处理；超标量和动态流水线的基本概念  

（七）多处理器基本概念  

SISD、SIMD、MIMD、向量处理器的基本概念：硬件多线程的基本概念：多核（multi-core）处理器的基本概念：共享内存多处理器（SMP）的基本概念  

# 【复习提示】  

中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、各种指令执行的周期与特点、控制器的相关概念、流水线的相关概念易出选择题。  

在学习本章时，请读者思考以下问题：  

1）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？  

2）什么是指令周期、机器周期和时钟周期？它们之间有何关系？  

3）什么是微指令？它和第4章谈到的指令有什么关系？  

4）什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？  

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 5.1CPU的功能和基本结构  

# 5.1.1CPU的功能  

中央处理器（CPU）由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列：运算器的功能是对数据进行加工。CPU的具体功能包括：  

1）指令控制。完成取指令（也称取指）、分析指令和执行指令的操作，即程序的顺序控制。  
2）操作控制。产生完成一条指令所需的操作信号，把各种操作信号送到相应的部件，从而控制这些部件按指令的要求正确执行。3）时间控制。严格控制各种操作信号的出现时间、持续时间及出现的时间顺序。4）数据加工。对数据进行算术和逻辑运算。5）中断处理。对运行过程中出现的异常情况和中断请求进行处理。  

# 5.1.2CPU的基本结构  

在计算机系统中，CPU主要由运算器和控制器两大部分组成［也可将CPU分为数据通路（见5.3节）和控制部件两大组成部分]，如图5.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4b9660fe8f486ff3097ffb4d9a7cf8d43ce70d8af78ba631a7eee723b6a34fa0.jpg)  
图5.1中央处理器的组成  

# 1.运算器  

运算器主要由算术逻辑单元（ALU）、暂存寄存器、累加寄存器（ACC）、通用寄存器组（GPRs）程序状态字寄存器（PSW）、移位寄存器、计数器（CT）等组成。其主要功能是根据控制器送来的命令，对数据执行算术运算（加、减、乘、除）、逻辑运算（与、或、非、异或、移位、求补等）或条件测试（用于设置ZF、SF、OF和CF等标志位，作为条件转移的判断条件）。  

# 2.控制器  

控制器主要由程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、时序电路和微操作信号发生器等组成。其主要功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。  

控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。  

# 5.1.3CPU的寄存器  

# 命题追踪汇编程序员可见的寄存器（2010、2015、2021）  

CPU中的寄存器按汇编语言（或机器语言）程序是否可访问，可分为两类：一类是用户可见寄存器，可对这类寄存器编程，以通过使用这类寄存器减少对主存储器的访问次数，如通用寄存器组（含基址/变址寄存器）、程序状态字寄存器、程序计数器、累加寄存器、移位寄存器；另一类是用户不可见寄存器，对用户是透明的，不可对这类寄存器编程，它们被控制部件使用，以控制CPU的操作，如存储器地址寄存器、存储器数据寄存器、指令寄存器、暂存寄存器。  
# 命题追踪CPU中各种寄存器的作用（2013）  

# 1.运算器中的寄存器  

1）通用寄存器组（GPRs）。用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等，如AX、BX、CX、DX、SP等。在指令中要指定寄存器的编号，才能明确是对哪个寄存器进行访问。SP是堆栈指针，用于指示栈顶的地址。2）累加寄存器（ACC）。它是一个通用寄存器，用于暂时存放ALU运算的结果。3）移位寄存器（SR）。不但可用来存放操作数，而且在控制信号的作用下，寄存器中的数据可根据需要向左或向右移位。4）暂存寄存器。用于暂存从数据总线或通用寄存器送来的操作数，以便在取出下一个操作数时将其同时送入ALU。暂存寄存器对应用程序员是透明的（不可见）。5）程序状态字寄存器（PSW）。保留由算术/逻辑运算指令或测试指令的运行结果而建立的各种状态信息，如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。每个标志位通常由一位触发器来保存，这些标志位组合在一起称为程序状态字。  

# 2.控制器中的寄存器  

# 命题追踪PC和IR的位数与主存储器空间和指令字长的关系（2016、2021）  

1）程序计数器（PC）。用于指出欲执行指令在主存储器中的存放地址。若PC和主存储器均按字节编址，则PC的位数等于主存储器地址位数。CPU根据PC的内容从主存储器中取指令，然后送入指令寄存器。指令通常是顺序执行的，因此PC具有自动加1的功能（这里的“1”是指一条指令的字节数）；当遇到转移类指令时，PC的新值由指令计算得到。  

2）指令寄存器（IR）。用于保存当前正在执行的指令，IR的位数等于指令字长。  

3）存储器地址寄存器（MAR）。用于存放要访问的主存储器单元的地址，MAR的位数等于主存储器地址线数，它反映了最多可寻址的存储单元的个数。  

4）存储器数据寄存器（MDR）。用于存放向主存储器写入的信息或从主存储器读出的信息，MDR的位数等于存储字长。当CPU和主存储器交换信息时，都要用到MAR和MDR。  

# 5.1.4 本节习题精选  

# 一、单项选择题  

01.下列部件不属于控制器的是（）  

A.指令寄存器B.程序计数器C.程序状态字寄存器D.时序电路  

02.通用寄存器是（）。  

A.可存放指令的寄存器B.可存放程序状态字的寄存器C.本身具有计数逻辑与移位逻辑的寄存器D.可编程指定多种功能的寄存器  

03.CPU中保存当前正在执行指令的寄存器是（）A.指令寄存器B.指令译码器C.数据寄存器D.地址寄存器04.在CPU中，跟踪后继指令地址的寄存器是（）A.指令寄存器B.程序计数器C.地址寄存器D.状态寄存器  
05.条件转移指令执行时所依据的条件来自（）  

A.指令寄存器B.标志寄存器C.程序计数器D.地址寄存器  

06.在所谓的 $n$ 位CPU中， $n$ 是指（）  

A.地址总线线数B.数据总线线数 C.控制总线线数 D.I/O线数  

07.在CPU的寄存器中，（）对用户是透明的。  

A.程序计数器B.状态寄存器C.指令寄存器D.通用寄存器  

08.指令（）从主存储器中读出。  

A.总是根据程序计数器B.有时根据程序计数器，有时根据转移指令C.根据地址寄存器D.有时根据程序计数器，有时根据地址寄存器  

09.程序计数器（PC）属于（）。  

A.运算器B.控制器C.存储器D.ALU  

10.下面有关程序计数器（PC）的叙述中，错误的是（）  

A.PC中总是存放指令地址B.PC的值由CPU在执行指令过程中进行修改C.执行转移指令时，PC的值总是修改为转移指令的目标地址D.PC的位数一般和存储器地址寄存器（MAR）的位数一样  

11.程序计数器（PC）可以使用字节地址或字地址，其位数取决于（）  

1.存储器的容量II.机器字长I.指令字长A.I B.I和IⅢI C.II和II D.I、和Ⅲ  

12.下列关于程序计数器（PC）的叙述中，错误的是（）  

A.机器指令中不能显式地使用PCB.指令顺序执行时，PC值总是自动加1C.调用指令执行后，PC值一定是被调用过程的入口地址D.无条件转移指令执行后，PC值一定是转移目标地址  

13.指令寄存器（IR）的位数取决于（）  

A.存储器的容量B.机器字长C.指令字长D.存储字长  

14.CPU中通用寄存器的位数取决于（）  

A.存储器的容量B.指令的长度 C.机器字长 D.都不对  

15.CPU中的通用寄存器，（）  

A.只能存放数据，不能存放地址B.可以存放数据和地址C.既不能存放数据，又不能存放地址D.可以存放数据和地址，还可以替代指令寄存器  

16.在计算机系统中表示程序和机器运行状态的部件是（）。  

A.程序计数器B.累加寄存器C.中断寄存器D.程序状态字寄存器  

17.状态寄存器用来存放（）  

A.算术运算结果B.逻辑运算结果C.运算类型 D.算术、逻辑运算及测试指令的结果状态  

18.下列关于标志寄存器（EFLAGS寄存器或PSW寄存器）的叙述中，错误的是（）。A.不需要像通用寄存器那样，对标志寄存器进行编号B.条件转移指令根据其中的一些的标志位来确定PC的值C.可以通过指令直接访问标志寄存器并修改它的值D.可以用它来存放执行指令得到的各种标志信息  
19.控制器的全部功能是（）  

A.产生时序信号B.从主存储器中取出指令并完成指令操作码译码C.从主存储器中取出指令、分析指令并产生有关的操作控制信号D.都不对  

20.指令译码是指对（）进行译码。  

A.整条指令B.指令的操作码字段C.指令的地址码字段D.指令的地址  

21.CPU中不包括（）。  

A.存储器地址寄存器B.指令寄存器C.地址译码器D.程序计数器  

22.以下关于计算机系统的概念中，正确的是（）  

I.CPU不包括地址译码器II1.CPU的程序计数器中存放的是操作数地址III.CPU中决定指令执行顺序的是程序计数器IV.CPU的状态寄存器对用户是完全透明的  

A.I、ⅢIB.III、IVC.ⅡI、I、IVD.I、I、IV

23.间址周期结束后，CPU内寄存器MDR中的内容为（）。A.指令B.操作数地址C.操作数D.无法确定  

24.一台32位计算机的主存储器容量为4GB，按字节编址，存储字长和指令字长都是32位。若指令按字边界对齐存放，则程序计数器（PC）的宽度至少是（）。  

A.32位B.30位C.8位D.34位

25.【2010统考真题】下列寄存器中，汇编语言程序员可见的是（）。  

A.存储器地址寄存器（MAR）B.程序计数器（PC）C.存储器数据寄存器（MDR）D.指令寄存器（IR）  

26.【2016统考真题】某计算机的主存储器空间为4GB，字长为32位，按字节编址，采用32位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是（）。  

A.30,30 B.30,32 C.32,30 D.32,32  

# 二、综合应用题  

01.CPU中有哪些专用寄存器？  

# 5.1.5 答案与解析  

# 一、单项选择题  

01.C  

控制器由程序计数器PC、指令寄存器IR、存储器地址寄存器MAR、存储器数据寄存器MDR、指令译码器、时序电路和微操作信号发生器等组成。程序状态字寄存器（PSW）属于运算器的组成部分，PSW包括两个部分：一是状态标志，如进位标志（CF）、结果为零标志（ZF）等，大多数指令的执行将会影响到这些标志位；二是控制标志，如中断标志、陷阱标志等。  
02.D  

存放指令的寄存器是指令寄存器，A错误。存放程序状态字的寄存器是程序状态字寄存器，B错误。通用寄存器本身并不一定具有计数逻辑和移位逻辑功能，C错误。  

03.A  

指令寄存器用于存放当前正在执行的指令。  

04.B  

程序计数器用于存放下一条指令在主存储器中的地址，具有自增功能。  

05.B  

指令寄存器用于存放当前正在执行的指令：程序计数器用于存放下一条指令的地址；地址寄存器用于暂存指令或数据的地址；程序状态字寄存器用于保存系统的运行状态。条件转移指令执行时，需要对标志寄存器的内容进行测试，判断是否满足转移条件。  

06.B 数据总线的位数与处理器的位数相同，它表示CPU一次能处理的数据的位数，即CPU的位数。  

07. C  

指令寄存器中存放当前正在执行的指令，不需要用户的任何干预，所以对用户是透明的。其他三种寄存器的内容可由程序员指定。  

08.A  

CPU根据程序计数器PC中的内容从主存储器中取指令。读者可能会想到无条件转移指令或中断返回指令，认为不一定总是根据PC读出。实际上，当前指令正在执行时，PC已经是下一条指令的地址。若遇到无条件转移指令，则只需简单地用跳转地址覆盖原PC的内容即可，最终的结果还是根据PC从主存储器中读出。地址寄存器用来指出所取数据在主存储器中的地址。  

09.B  

控制器是计算机中处理指令的部件，包含程序计数器。  

10.C  

PC中存放下一条要执行的指令的地址，A正确。PC的值会根据CPU在执行指令的过程中修改（确切地说是在取指周期），或自增，或转移到程序的某处，B正确。转移指令时，需要判别转移是否成功，若成功则PC修改为转移指令的目标地址，否则下一条指令的地址仍然为PC自增后的地址，C错误。PC的位数通常和MAR的位数一样，D正确。  

11.B  

程序计数器（PC）用于指出下一条指令在主存储器中的地址。可以用字节地址表示指令地址，此时PC的位数与存储器地址的位数相等，而存储器地址的位数取决于存储器的容量；也可以用字地址表示指令地址，这种情况下指令必须采用按边界对齐的方式存放，此时PC的位数 $=$ 存储器地址的位数-log（指令字长的字节数)。可知，PC的位数取决于存储器的容量和指令字长。  

12.B  

机器指令中不能显式地使用PC，PC的值是自增的，或者是由转移类指令设置的。指令顺序执行时，PC自动加1，这里的“1”是指一条指令的长度，PC的值不一定总是自动加1，而是根据指令长度来确定的，具体取决于指令长度占几个编址单位。其余说法均正确。  

13.C  
指令寄存器中保存当前正在执行的指令，所以其位数取决于指令字长。  

14. C 通用寄存器用于存放操作数和各种地址信息等，其位数与机器字长相等，因此便于操作控制。  

15.B  

通用寄存器供用户自由编程，可以存放数据和地址。而指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器代替。  

16.D  

程序状态字寄存器用于存放程序状态字，而程序状态字的各位表征程序和机器的运行状态，如含有进位标志（CF）、结果为零标志（ZF）等。  

17.D 程序状态字寄存器用于保留算术、逻辑运算及测试指令的结果状态。  

18.C  

标志寄存器是专用寄存器，不需要编号，也不能在指令中直接指定编号来访问；标志寄存器中的内容是执行指令的过程中，CPU根据指令执行的结果生成的各种标志信息，用户不能直接修改它的值。标志寄存器中的标志位主要用于条件转移或条件设置类指令的条件判断。  

19.C 控制器的功能是取指令、分析指令和执行指令，执行指令就是发出有关操作控制信号。  

指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能。  

21.C  

地址译码器是主存等存储器的组成部分，其作用是根据输入的地址码唯一选定一个存储单元，它不是CPU的组成部分。而MAR、IR、PC都是CPU的组成部分。  

22.A  

地址译码器位于存储器，I正确；程序计数器中存放的是欲执行指令的地址，ⅡI错误；程序计数器决定程序的执行顺序，IⅢI正确；程序状态字寄存器对用户不透明，IV错误。  

23.B  

间址周期的作用是取操作数的有效地址，因此，间址周期结束后，MDR中的内容为操作数地址。  

24.B  

计算机按字节编址，指令字长为32位，占4字节，指令按字边界对齐方式存放，则指令存放的起始地址必须是4字节的整数倍， $4\mathrm{GB}/4\mathrm{B}=2^{30}$ ，故PC的宽度至少是30位。  

25.B  

汇编语言程序员可见的是程序计数器（PC），即汇编语言程序员通过汇编程序可以对某个寄存器进行访问。汇编程序员可以通过指定待执行指令的地址来设置PC的值，如转移指令、子程序调用指令等。而IR、MAR、MDR是CPU的内部工作寄存器，对程序员不可见。  

26.B  

程序计数器（PC）用于指出下一条指令在内存中的地址，虽然可以用32位的地址来表示指令地址，但实际上内存中最多只能存放4GB/32位 $=2^{30}$ 条指令，故可以用30位的字地址来表示指令地址，这种情况下指令必须采用按边界对齐的方式存放，故PC的位数至少是30位，即PC给出的地址是学地址。题干已说明指令按字边界对齐的方式存放，也就是说，指令地址都是4字节的整数倍，因此为了让PC的位数最少，可以采用字地址，取指令时将PC值左移2位到主存中取指令。指令寄存器（IR）用于存放从内存中取出的指令，它取决于指令字长，敌IR的位数至少是32位。  
# 二、综合应用题  

01.【解答】  

CPU中的专用寄存器有程序计数器（PC）、指令寄存器（IR）、存储器数据寄存器（MDR）、存储器地址寄存器（MAR）和程序状态字寄存器（PSW）。  

# 5.2指令执行过程  

# 5.2.1指令周期  

CPU每取出并执行一条指令所需的全部时间称为指令周期，不同指令的指令周期可能不同。指令周期通常可用若干机器周期来表示，每个指令周期内的机器周期数可以不等。图5.2反映了上述关系。图5.2（a）所示为定长的机器周期，图5.2（b）所示为不定长的机器周期。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4cdf5401a046fb5fe39af366d76c0d8889d1154a1965f8d7673571ffd1641a97.jpg)  
图5.2指令周期和机器周期的关系  

对于无条件转移指令JIMIPX，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。  

对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。  

当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，也称中断周期。这样，一个完整的指令周期可包括取指、间址、执行和中断4个周期，如图5.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7ac4456b5579efe301d3c745f4bafd3791739991e765a528a6dd737b49f8fa6.jpg)  
图5.3带有间址周期、中断周期的指令周期  

# 命题追踪指令执行的过程（2011）  

当CPU执行指令时，首先进入取指周期，从PC指出的主存单元中取出指令，送至指令寄存器，同时PC加“1”以作为下一条指令的地址。当遇到转移指令等改变执行顺序的指令时，  
在PC加“1”后会重新计算并更新PC值。然后判断是否有间接寻址，如果有，那么进入间址周期以获取操作数的有效地址。之后进人执行周期，完成取操作数、执行运算和存操作数的任务。执行周期结束后，如果CPU检测到中断请求，则进入中断周期，此时需要关中断、保存断点、修改PC值为中断服务程序的入口地址，并转向中断服务程序。关于中断的具体内容，见本章的5.5节。  

# 注意  

中断周期中的进栈操作是将SP减“1”，这和传统意义上的进栈操作相反，原因是计算机中的堆栈都是向低地址方向增长，所以进栈操作是减“1”而不是加“”。  

# 5.2.2指令周期的数据流  

数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。  

# 1.取指周期  

取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。  

取指周期的数据流如图5.4所示。PC中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。  

取指周期的数据流向如下：  

1）PC  $\circledast$  MAR②地址总线存储器。 2）CU发出读命令控制总线 $\circeq$ 存储器3）主存 $\circeq$ 数据总线 $\nsupseteq$ MDR $\circledast$ IR（存放指令）4）CU发出控制信号PC内容加1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f75084f25f382c3b663c9acfe77f401b2ea0ef4abcdf6fe2e458bbf2de1010ae.jpg)  
图5.4取指周期的数据流  

# 2.间址周期  

间址周期的任务是取操作数有效地址。以一次间址为例（见图5.5），将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发出读命令，以获取有效地址并存至MDR。  

间址周期的数据流向如下：  

1）Ad（IR）（或MDR） $\circledast$ MAR $\circeq$ 地址总线存储器。2）CU发出读命令控制总线存储器。3）主存数据总线 $\nsupseteq$ MDR（存放有效地址）。  

其中，Ad（IR）表示取出IR中存放的指令字的地址字段。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a85b790d202f2b82ad10656f53199f418770f4c117771fe30b596a329d044671.jpg)  
图5.5一次间址周期的数据流  

# 3.执行周期  

执行周期的任务是取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。  

# 4.中断周期  

中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据，数据流如图5.6所示。  

中断周期的数据流向如下：  

1）CU控制将SP减1，SP $\circeq$ MAR②地址总线存储器。2）CU发出写命令 $\underline{{\boldsymbol{\mathfrak{A}}}}$ 控制总线 $\circeq$ 存储器3）PCMDR $\nsupseteq$ 数据总线 $\circeq$ 主存（程序断点存入存储器）。4）CU（中断服务程序的入口地址）PC。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c5e774da7c287935949863c45b6d8ed1c27c81c7ecb099690202cb499289d6e4.jpg)  
图5.6中断周期的数据流  

# 5.2.3指令执行方案  

一个指令周期通常要包括几个执行步骤，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。不同的处理器采用不同的方案来安排指令的执行步骤。  

命题追踪单周期和多周期CPU的CPI（2020）  

# 1.单周期处理器  

命题追踪单周期CPU的特点（2016）  

单周期处理器对所有指令都选用相同的执行时间来完成。此时每条指令都在一个时钟周期内完成（即 ${\mathrm{CPI}}=1$ ），指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，仍要使用这个较长的周期来完成，会降低整个系统的运行速度。  
# 2.多周期处理器  

多周期处理器对不同类型的指令选用不同的执行步骤。指令需要几个周期就为其分配几个周期，因此可选用不同个数的时钟周期来完成不同指令的执行过程（即 $\mathrm{CPI}>1)$ ，不再要求所有指令占用相同的执行时间。多指令周期方案中指令之间仍是串行执行。  

# 3.流水线处理器  

流水线处理器采用指令之间并行执行的方案，其追求的自标是力争在每个时钟周期完成一条指令的执行过程（只在理想情况下才能达到该效果，此时 ${\mathrm{CPI}}=1$ ）。这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。  

# 5.2.4本节习题精选  

# 单项选择题  

01.计算机工作的最小时间周期是（）  

A.时钟周期 B.指令周期 C.CPU周期 D.总线周期  

02.采用DMA方式传递数据时，每传送一个数据就要占用（）  

A.指令周期B.时钟周期C.机器周期D.存取周期  

03.指令周期是指（）  

A.CPU从主存取出一条指令的时间B.CPU执行一条指令的时间C.CPU从主存取出一条指令加上执行这条指令的时间D.时钟周期时间  

04.在一条无条件跳转指令的指令周期内，程序计数器（PC）的值被修改了（）次。A.1B.2C.3D.不能确定05.取指操作后，程序计数器中存放的是（）  

A.当前指令的地址B.程序中指令的数量C.已执行的指令数量D.下一条指令的地址  

06.下列关于指令执行的叙述中，错误的是（）  

A.指令周期的第一个操作是取指令B.为了进行取指操作，控制器需要得到相应的指令C.取指操作是控制器自动进行的D.指令执行时有些操作是相同或相似的  

07.下列关于指令执行过程的叙述中，错误的是（）  

A.取指操作是控制器固有的功能，不需要在操作码控制下完成B.所有指令的取指操作是相同的C.在指令长度相同的情况下，所有指令的取指操作是相同的D.中断周期是在指令执行完成后出现的  

08.指令周期由一个到几个机器周期组成，第一个机器周期是（）  

A.从主存中取出指令字 B.从主存中取出指令操作码 C.从主存中取出指令地址码 D.从主存中取出指令的地址  
09.由于CPU内部操作的速度较快，而CPU访问一次存储器的时间较长，因此机器周期通常由（）来确定。  

A.指令周期B.存取周期C.间址周期D.中断周期

10.下列有关机器周期的叙述中，错误的是（）  

A.通常把通过一次总线事务访问一次主存或I/O的时间定为一个机器周期B.一个指令周期通常包含多个机器周期C.不同的指令周期所包含的机器周期数可能不同D.每个指令周期都包含一个中断响应机器周期  

11.下列关于多周期CPU的说法中，合理的是（）  

A.执行各条指令的机器周期数相同，各机器周期的长度均匀B.执行各条指令的机器周期数相同，各机器周期的长度可变C.执行各条指令的机器周期数可变，各机器周期的长度均匀D.执行各条指令的机器周期数可变，各机器周期的长度可变  

12.以下关于间址周期的描述中，正确的是（)  

A.所有指令的间址操作都是相同的B.凡是存储器间接寻址的指令，它们的操作都是相同的C.对于存储器间接寻址和寄存器间接寻址，它们的操作是不同的D.都不对  

13.（）可区分存储单元中存放的是指令还是数据。A.控制器B.运算器C.存储器D.数据通路

14.下列关于各种字长的说法中，正确的是（）  

I.指令字长等于机器字长的前提下，取指周期等于机器周期II.指令字长等于存储字长的前提下，取指周期等于机器周期IⅢI.指令字长和机器字长的长度没有任何关系IV.为了硬件设计方便，指令字长都和存储字长一样大  

A.ⅡI、IⅢIB.ⅡI、II、IVC. I、III、IVD.I、IV

15.下列关于单周期CPU和多周期CPU的描述中，错误的是（）  

A.执行任何指令，单周期CPU的时间都要小于多周期CPUB.单周期CPU部件冗余大，时间利用率低，多周期CPU则刚好相反C.单周期CPU在1个时钟周期内执行一条指令， ${\mathrm{CPI}}=1$ D.多周期CPU至少需要2个时钟周期才能执行一条指令， $\mathrm{CPI}>1$  

16.【2009统考真题】冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是（）。  

A.指令操作码的译码结果B.指令和数据的寻址方式C.指令周期的不同阶段D.指令和数据所在的存储单元  

17.【2011统考真题】假定不采用Cache和指令预取技术，且机器处于“开中断”状态，则 在下列有关指令执行的叙述中，错误的是（）。  

A.每个指令周期中CPU都至少访存一次 B.每个指令周期一定大于或等于一个CPU时钟周期C.空操作指令的指令周期中任何寄存器的内容都不会被改变D.当前程序在每条指令执行结束时都可能被外部中断打断  
# 5.2.5 答案与解析  

单项选择题  

01.A  

时钟周期是计算机操作的最小时间单位，为主频的倒数。指令周期则可由多个CPU周期（即机器周期）组成。总线周期是指一次总线操作所需的时间，通常为一个或多个时钟周期。  

02.D  

CPU从主存中每取出并执行一条指令所需的全部时间称为指令周期：时钟周期通常称为节拍或 $T$ 周期，它是CPU操作的最基本单位；指令周期可分为若干机器周期：存取周期是指存储器进行两次独立的存储操作（连续两次读或写操作）所需的最小间隔时间。  

03.C  

指令周期是指CPU从主存取出一条指令加上执行这条指令的时间，间址周期不是必需的。  

04.B  

首先在取指周期结束后，PC值自动加1：在执行周期中，PC值修改为要跳转到的地址。综上，在一条无条件跳转指令的指令周期内，程序计数器（PC）的值被修改了2次。  

05.D 在取指操作后，程序计数器中的内容将被修改为下一条指令的地址，而不是当前指令的地址。  

06.B 取指操作是自动进行的，控制器不需要得到相应的指令。  

07.B  

不同长度的指令，其取指操作可能是不同的。例如，双字指令、三字指令与单字指令的取指操作是不同的。  

08.A 指令周期的第一个机器周期是取指周期，即从主存中取出指令字的时间。  

09.B  

存储器进行一次读或写操作所需的时间称为存储器的读/写时间，而连续启动两次独立的读或写操作（如连续两次读操作）所需的最短时间称为存取周期。机器周期通常由存取周期确定。  

10.D  

在指令的执行周期完成后，处理器会判断是否出现中断请求，只有在出现中断请求时才会进入中断周期。  

11.D  

机器周期是指令执行中每步操作（如取指令、存储器读、存储器写等）所需要的时间，每个机器周期的长度可变。各种指令的功能不同，因此各指令执行所需的机器周期数是可变的。  

12.C  

指令的间址分为一次间址、两次间址和多次间址，因此它们的操作是不同的，A、B错误。存储器间址通过形式地址访存，寄存器间址通过寄存器内容访存，C正确。  

13.A  

存储器本身无法区分存储单元中存放的是指令还是数据。而在控制器的控制下，计算机在不同的阶段对存储器进行读/写操作时，取出的代码也就有不同的用处。而在取指阶段读出的二进制代码为指令，在执行阶段读出的二进制代码则可能为数据；运算器和数据通路显然不能区分。  
14.A  

指令字长一般都取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要两次访存，取指周期等于机器周期的2倍：若指令字长等于存储字长，则取指周期等于机器周期，因此I错。根据1的分析可知，Ⅱ正确。指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，与机器字长没有必然的联系。但为了硬件设计方便，指令字长一般取字节或存储字长的整数倍，因此ⅢI正确。根据IⅢI的分析可知，指令字长一般取字节或存储字长的整数倍，而不一定都和存储字长一样大，因此IV错误。综上所述，IⅡI、IⅢI正确。  

15.A  

单周期CPU执行任何指令的时间不一定都会小于多周期CPU，这取决于单周期CPU和多周期CPU的时钟周期的长短，以及该指令在多周期CPU下所需的时钟周期数，故A错误。  

16.C  

虽然指令和数据都以二进制形式存放在存储器中，但CPU可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据。本题容易误选选项A，需要清楚的是，CPU只有在确定取出的是指令后，才会将其操作码送去译码，因此不可能依据译码的结果来区分指令和数据。  

17. C  

由于不采用指令预取技术，每个指令周期都需要取指令，而不采用Cache技术，因此每次取指令都至少要访存一次（当指令字长与存储字长相等且按边界对齐时），A正确。时钟周期是CPU的最小时间单位，每个指令周期一定大于或等于一个CPU时钟周期，B正确。即使是空操作指令，在取指操作结束后，PC也会自动加1，C错误。由于机器处于“开中断”状态，在每条指令执行结束时都可能被外部中断打断。  

# 5.3数据通路的功能和基本结构  

# 5.3.1数据通路的功能  

随着技术的发展，更多的功能逻辑被集成到CPU芯片中，但不论CPU的内部结构多么复杂，它都可视为由数据通路（DataPath）和控制部件（ControlUnit）两大部分组成。  

# 命题追踪数据通路的组成部件（2017、2021）  

数据在指令执行过程中所经过的路径，包括路径上的部件，称为数据通路，ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等都是指令执行时数据流经的部件，都属于数据通路的一部分。数据通路描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里。数据通路由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。  

# 5.3.2数据通路的组成  

组成数据通路的元件主要分为组合逻辑元件和时序逻辑元件两类。命题追踪数据通路中的组合逻辑元件和时序逻辑元件（2021、2023）  

# 1.组合逻辑元件（操作元件）  

任何时刻产生的输出仅取决于当前的输入。组合电路不含存储信号的记忆单元，也不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的。数据通路中常用的组合逻辑元件有加法器、算术逻辑单元（ALU）、译码器、多路选择器、三态门等，如图5.7所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/96308c858ff5f7964125d669141286fa1586d651484b7c7042c3ce73a05e35c4.jpg)  
图5.7数据通路中的几种常用组合逻辑元件  

图中虚线表示控制信号，译码器可用于操作码或地址码译码， $n$ 位输入对应 $2^{n}$ 种不同组合，因此有 $2^{n}$ 个不同输出。多路选择器（MUX）需要控制信号Select来确定选择哪个输入被输出。三态门可视为一种控制开关，由控制信号EN决定信号线的通断，当 $\mathrm{EN}=1$ 时，三态门被打开，输出信号等于输入信号：当 $\mathrm{EN}\,=\,0$ 时，输出端呈高阻态（隔断态），所连寄存器与总线断开。  

# 2.时序逻辑元件（状态元件）  

任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关，因而时序电路必然包含存储信号的记忆单元。此外，时序电路必须在时钟节拍下工作。各类寄存器和存储器，如通用寄存器组、程序计数器、状态/移位/暂存/锁存寄存器等，都属于时序逻辑元件。  

# 5.3.3数据通路的基本结构  

数据通路的基本结构主要有以下几种。  

# 1.CPU内部单总线方式  

# 命题追踪数据通路中的部件及连接方式（2013、2015、2022）  

将ALU及所有寄存器都连接到一条内部公共总线上，称为单总线结构的数据通路。这种结构比较简单，但数据传输存在较多的冲突现象，性能较低。此总线在CPU内部，注意不要把它与连接CPU、存储器和外设的系统总线相混淆。图5.8所示为单总线的数据通路和控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0161e7b16de00d520d62405d382e730a37430111a550273cdc1cb28934a907c8.jpg)  
图5.8单总线的数据通路和控制信号  

# 命题追踪数据通路中的三态门及其作用（2015）  

在图5.8中，GPRs为通用寄存器组，rs、rd分别为所读、写的通用寄存器的编号；Y和Z为暂存器；FR为标志寄存器，用于存放ALU产生的标志信息。带箭头的虚线表示控制信号，字母加“in”表示该部件充许写入，字母加“out”表示该部件充许输出。MDRin表示内部总线上信息写入MDR，MDRout表示MDR的内容送入内部总线。能输出到总线的部件均通过一个三态门与内部总线相连，用于控制该部件与内部总线之间数据通路的连接与断开。  
# 注意  

单周期处理器（ $\mathrm{CPI}=1$ ）不能采用单总线方式，因为单总线将所有寄存器都连接到一条公共总线上，一个时钟内只允许一次操作，无法完成一条指令的所有操作。  

# 2.CPU内部多总线方式  

CPU内部有两条或更多的总线时，构成双总线结构或多总线结构。将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只充许传送一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。  

# 命题追踪单周期CPU的特点（2016）  

# 3.专用数据通路方式  

根据指令执行过程中的数据和地址的流动方向安排连接电路，避免使用共享的总线，性能较高，但硬件量大。  

# 注意  

内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线。  

# 5.3.4数据通路的操作举例  

总线是一组共享的传输信号线，它不能存储信息，任一时刻也只能有一个部件把信息送到总线上。下面以图5.8所示的单总线数据通路为例，介绍一些常见操作的流程及控制信号。  

命题追踪指令执行的节拍及有效控制信号（2009、2015）：指令在取数和执行阶段所用到的部件（2019）  

# 1.通用寄存器之间传送数据  

在寄存器和总线之间有两个控制信号：Rin和Rout。当Rin有效时，控制将总线上的信息存到寄存器R中；当Rout有效时，控制将寄存器R的内容送至总线。下面以程序计数器PC为例，将PC的内容送至MAR。实现该操作的流程及控制信号为  

(PC)→MARPC out MARin，PC内容→MAR  

# 2.从主存读取数据  

# 命题追踪取指令阶段所需时钟周期分析（2022）  

从主存中读取的信息可能是数据或指令，现以CPU从主存中取指令为例，说明数据在单总线数据通路中的传送过程。实现该操作的流程及控制信号为  

（PC）→MARPC out MARin，现行指令地址→MARMEM（MAR)→MDR，（PC)+1→PCMDRin有效，CU发出读命令，取出指令后PC+1(MDR）→IR MDR out IR in，现行指令→IR  
第一步，将PC的内容通过内部总线送至MAR，需要1个时钟周期。第二步，CU向主存发出读命令，从MAR所指主存单元读取一个字，并送至MDR；同时PC加1为取下一条指令做准备，需要1个主存周期。第三步，将MDR的内容通过内部总线送至IR，需要1个时钟周期。  

# 3.将数据写入主存  

将寄存器R1的内容写入寄存器R2所指的主存单元，完成该操作的流程及控制信号为  

(R1)→MDR Rl out MDR in (R2)→MAR R 2 out MARin MDR→MEM(MAR)MDRout有效，CU发出写命令  

# 4.执行算术或逻辑运算  

# ALU中设置暂存器的原因（2015、2022）  

在单总线数据通路中，每一时刻总线上只有一个数据有效。由于ALU是一个没有存储功能的组合逻辑元件，在其执行运算时必须保持两个输入端同时有效，因此先将一个操作数经内部总线送人暂存器Y保存，Y的内容在ALU的左输入端始终有效，再将另一个操作数经内部总线直接送到ALU的右输入端。此外，ALU的输出端也不能直接与总线相连，否则其输出会通过总线反馈到输入端，影响运算结果，因此将运算结果暂存在暂存器乙中。假设加法指令ADDACC，R1，实现将ACC的内容和R1的内容相加并写回ACC，完成该操作的流程及控制信号为  

(R1)→Y Rl out Yin，操作数→Y (ACC)  $^+$  (Y）→Z ACC out ALU in，CU ALU，结果→Z (Z)→ACC Z out ACC in，结果→ACC  

# 命题追踪分析减法和自增指令执行所需的时钟周期数（2015）  

以上3步不能同时执行，否则会引起总线冲突，因此该操作需要3个时钟周期  

# 5.修改程序计数器的值  

转移指令通过修改程序计数器PC的值来达到转跳的目的。假设转移指令JIMPaddr，addr为目标转移地址，实现将IR中的地址字段写入PC，完成该操作的流程及控制信号为  

Ad(IR)→PCIR out PC in  

数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计。  

# 5.3.5 本节习题精选  

# 一、单项选择题  

01.下列不属于CPU数据通路结构的是（）  

A.单总线结构 B.多总线结构 C.部件内总线结构D.专用数据通路结构  

02.下列有关数据通路的叙述中，错误的是（）。  

A.数据通路由若干组合逻辑元件和时序逻辑元件连接而成B.数据通路的功能由控制部件送出的控制信号决定C.ALU属于操作元件，用于执行各类算术和逻辑运算 D.通用寄存器属于状态元件，但不包含在数据通路中  
03.在单总线的CPU中，（）  

A.ALU的两个输入端及输出端都可与总线相连B.ALU的两个输入端可以与总线相连，但输出端需通过暂存器与总线相连C.ALU的一个输入端可以与总线相连，其输出端也可与总线相连D.ALU只能有一个输入端可以与总线相连，另一输入端需通过暂存器与总线相连  

04.CPU内部如果多个部件共享一条总线，则每个部件与总线之间需设置一个常用的器件，CPU控制该器件的状态，实现某个部件与总线的连接或断开。该器件是（）。  

A.触发器B.多路选择器C.三态门D.与非门  

05.CPU内部电路通常采用总线连接方式，总线上信号流动的原则是（）。  

1.每个时刻只有一个器件发出信息IIL.每个时刻有一个或多个器件发出信息II.每个时刻只有一个器件接收信息IV.每个时刻有一个或多个器件接收信息  

A.I、IⅢIB.I、IVC. II、ⅢID. II、IV

06.下列关于单周期数据通路和多周期数据通路的说法中，正确的是（）  

A.CPU C PI CPU C PIB.单周期CPU的时钟周期通常比多周期CPU的时钟周期短C.在一条指令执行过程中，单周期CPU中的每个控制信号取值一直不变，而多周期CPU中的控制信号可能会发生改变D.在一条指令执行过程中，单周期数据通路和多周期数据通路中的每个部件都可使用多次  

07.采用CPU内部总线的数据通路与不采用CPU内部总线的数据通路相比，（）  

A.前者性能较高B.后者的数据冲突问题较严重C.前者的硬件量大，实现难度高D.以上说法都不对  

08.CPU的读/写控制信号的作用是（）。  

A.决定数据总线上的数据流方向B.控制存储器操作的读/写类型C.控制流入、流出存储器信息的方向D.以上都是  

09.【2016统考真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是（）。  

A.可以采用单总线结构数据通路B.处理器时钟频率较低C.在指令执行过程中控制信号不变 D.每条指令的CPI为1  

10.【2021统考真题】下列关于数据通路的叙述中，错误的是（）。  

A.数据通路包含ALU等组合逻辑（操作）元件B.数据通路包含寄存器等时序逻辑（状态）元件C.数据通路不包含用于异常事件检测及响应的电路D.数据通路中的数据流动路径由控制信号进行控制  

11.【2023统考真题】数据通路由组合逻辑元件（操作元件）和时序逻辑元件（状态元件）组成。下列给出的元件中，属于操作元件的是（）。  

I.算术逻辑单元（ALU）II.程序计数器（PC）IⅢI.通用寄存器组（GPRs）IV.多路选择器（MUX）A.仅I、ⅡIB.仅I、IVC.仅ⅡI、IⅢID.仅I、ⅡI、IV  
# 二、综合应用题  

01.某计算机的数据通路结构如下图所示，写出实现ADDR1，（R2）的微操作序列（取指令及指令执行的过程，包括PC自增的过程）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22951b9d321144a61e33840764cce373f605b8fafc1e7f912014fe3813e32ab0.jpg)  

02.设CPU内部结构如下图所示，此外还设有B、C、D、E、H、L六个寄存器（图中未画出），它们各自的输入端和输出端都与内部总线相通，并分别受控制信号控制（如Bin受寄存器B的输入控制；Bout受寄存器B的输出控制），假设ALU的结果直接送入寄存器Z。要求从取指令开始，写出完成下列指令的微操作序列及所需的控制信号。  

ADDB，C(B) $^+$ （C）→BSUB ACC,H (ACC)-（H)→ACC  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/002c0d498dc156dbfc5373d2f3282941af937422b7c631f4a3ec6c41b5db0e28.jpg)  
03.设有如下图所示的单总线结构，分析指令ADD（R0)，R1【即实现 $\scriptstyle((\mathrm{\mathrm{R}}0))+(\mathrm{\mathrm{R}}1)\rightarrow(\mathrm{\mathrm{R}}0)\;]$ 的指令流程和控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9ed900f6a42401322250681546b0f5c32cd9b29b7b8c7703e0fed436c214bd94.jpg)  

04.下图是一个简化的CPU与主存连接结构示意图（图中省略了所有的多路选择器）。其中有一个累加寄存器（ACC）、一个状态数据寄存器和其他4个寄存器：主存地址寄存器（MAR）、主存数据寄存器（MDR）、程序寄存器（PC）和指令寄存器（IR），各部件及其之间的连线表示数据通路，箭头表示信息传递方向。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75322383bafd6a07679f4b2e347267497ea99a84f8a42cc101bfb53fe0e3de31.jpg)  

要求：  

1）请写出图中a、b、C、d四个寄存器的名称2）简述图中取指令的数据通路。3）简述数据在运算器和主存之间进行存/取访问的数据通路（假设地址已在MAR中）4）简述完成指令LDAX的数据通路（X为主存地址，LDA的功能为 $(\mathrm{X}){\rightarrow}\mathrm{ACC}$ 一。  
5）简述完成指令ADDY的数据通路（Y为主存地址，ADD的功能为（ACC) $^+$ (Y)→ACC)。  

6）简述完成指令STAZ的数据通路（Z为主存地址，STA的功能为 $(\mathrm{ACC}){\rightarrow}\mathrm{Z}$ 一  

05.某机主要功能部件如下图所示，其中M为主存，MDR为主存数据寄存器，MAR为主存地址寄存器，IR为指令寄存器，PC为程序计数器（并假设当前指令地址在PC中）R0\~R3为通用寄存器，C、D为暂存器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a845b59c9a94e79de70bba6914024265dbff0953424ada787b3b02e9f4aacfa1.jpg)  

1）请补充各部件之间的主要连接线（总线自己画），并注明数据流动方向。  

2）画出“ADD（R1)， $(\mathbb{R}2)+"$ 指令周期流程图，该指令的含义是进行求和运算，源操作数地址在R1中，目标操作数寻址方式为自增型寄存器间接寻址方式（先取地址后加1），并将相加结果写回R2寄存器。  

06.已知单总线计算机结构如下图所示，其中M为主存，XR为变址寄存器，EAR为有效地址寄存器，LATCH为暂存器。假设指令地址已存在于PC中，请给出ADDX，D指令周期信息流程和相应的控制信号。说明：  

1）ADDX，D指令字中，X为变址寄存器XR，D为形式地址，指令的功能是将变址寻址得到的操作数和ACC中的操作数相加，结果送回ACC。  

2）寄存器的输入/输出均采用控制信号控制，如PC；表示PC的输入控制信号， $\mathrm{{MDR}_{\mathrm{o}}}$ 表示MDR的输出控制信号。  

3）凡需要经过总线的传送，都需要注明，如（PO）→MAR，相应的控制信号为 $\mathrm{PC}_{\circ}$ 和MARi。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bcceffa9eb6c5201693d8b060562191bdfd204674291f4818262fa52e500f983.jpg)  

07.【2009统考真题】某计算机字长16位，采用16位定长指令字结构，部分数据通路结构如下图所示。图中所有控制信号为1时表示有效，为0时表示无效。例如，控制信号MDRinE为1表示允许数据从DB打入MDR，MDRin为1表示允许数据从总线打入MDR。假设MAR的输出一直处于使能状态。加法指令“ADD（R1)， $\mathrm{R0"}$ 的功能为 $\mathrm{(R0)}+\mathrm{((R1))}\rightarrow$ (R1），即将R0中的数据与R1的内容所指主存单元的数据相加，并将结果送入R1的内容所指主存单元中保存。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bee9966800a4d3d7425e44bef2f0b8373166867d498b90931011ac7bfe8e7148.jpg)  

下表给出了上述指令取指和译码阶段每个节拍（时钟周期）的功能和有效控制信号，请按表中描述方式用表格列出指令执行阶段每个节拍的功能和有效控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c247234308b84d32f1708889d94edb5b9798e49fc8f34ad8010dfaf35e7b7d7b.jpg)  

08.【2015统考真题】某16位计算机的主存按字节编码，存取单位为16位；采用16位定长指令字格式；CPU采用单总线结构，主要部分如下图所示。图中R0\~R3为通用寄存器；T为暂存器；SR为移位寄存器，可实现直送（mov）、左移一位（left）和右移一位（right）三种操作，控制信号为SRop，SR的输出由信号SRout控制；ALU可实现直送A（mova）A加B（add）、A减B（sub）、A与B（and）、A或B（or）、非A（not）、A加1（inc）七种操作，控制信号为ALUop。  

回答下列问题：  

1）图中哪些寄存器是程序员可见的？为何要设置暂存器T？2）控制信号ALUop和SRop的位数至少各是多少？3）控制信号SRout所控制部件的名称或作用是什么？4）端点 $\textcircled{\scriptsize{1}}$ ～ $\textcircled{9}$ 中，哪些端点须连接到控制部件的输出端？5）为完善单总线数据通路，需要在端点 $\textcircled{\scriptsize{1}}$ ～ $\circledcirc$ 中相应的端点之间添加必要的连线。写出连线的起点和终点，以正确表示数据的流动方向。6）为什么二路选择器MUX的一个输入端是2？  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4fff71e9386df0855d05cce86711032c972bd1e49434fa89a25312d07044a308.jpg)  
09.【2022统考真题】某CPU中部分数据通路如下图所示，其中，GPRs为通用寄存器组；FR为标志寄存器，用于存放ALU产生的标志信息；带箭头虚线表示控制信号，如控制信号Read、Write分别表示主存读、主存写，MDRin表示内部总线上的数据写入MDR，MDRout表示MDR的内容送给内部总线。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/29fdce784af50694a91fb81c25f26f938fe7bb82532db088457101b93caeac07.jpg)  

请回答下列问题。  

1）设ALU的输入端A、B及输出端F的最高位分别为 $\mathrm{A}_{15}$  $\mathbf{B}_{15}$ 及 $\mathrm{F}_{15}$ ，FR中的符号标志和溢出标志分别为SF和OF，则SF的逻辑表达式是什么？A加B、A减B时OF的逻辑表达式分别是什么？要求逻辑表达式的输入变量为 $\mathrm{A}_{15}$  $\mathbf{B}_{15}$ 及 $\mathrm{F}_{15}$  

2）为什么要设置暂存器Y和Z？  

3）若GPRs的输入端rS、rd分别为所读、写的通用寄存器的编号，则GPRs中最多有多少个 通用寄存器？rs和rd来自图中的哪个寄存器？已知GPRs内部有一个地址译码器和一个 多路选择器，rd应连接地址译码器还是多路选择器？  

4）取指令阶段（不考虑PC增量操作）的控制信号序列是什么？若从发出主存读指令到主存读出数据并传送到MDR共需5个时钟周期，则取指令阶段至少需要几个时钟周期？  

5）图中控制信号由什么部件产生？图中哪些寄存器的输出信号会连到该部件的输入端？  
# 5.3.6 答案与解析  

# 一、单项选择题  

01.C  

对CPU而言，数据通路的基本结构分为总线结构和专用数据通路结构，其中总线结构又分为单总线结构、双总线结构、多总线结构。  

02.D  

数据通路中的部件包括组合逻辑元件和时序逻辑元件。数据通路的功能由控制部件送出的控制信号决定。数据通路中一个重要的组合逻辑元件为ALU，用于执行各类算术和逻辑运算：另一个重要的元件为通用寄存器，属于时序逻辑元件。  

03.D  

由于ALU是一个组合逻辑电路，因此其运算过程中必须保持两个输入端的内容不变。又由于CPU内部采用单总线结构，因此为了得到两个不同的操作数，ALU的一个输入端与总线相连，另一个输入端需通过一个寄存器与总线相连。此外，ALU的输出端也不能直接与内部总线相连，否则其输出又会通过总线反馈到输入端，影响运算结果，因此输出端需通过一个暂存器（用来暂存结果的寄存器）与总线相连。  

04.C  

三态门可视为一种控制开关，由控制端决定信号线的通断，能输出到内部总线的部件均通过一个三态门与内部总线相连，用于控制该部件与内部总线之间数据通路的连接与断开。  

05.B  

当CPU内部电路采用总线连接方式时，总线上信号流动的原则如下：每个时刻只有一个器件发出信息（否则会导致总线冲突），每个时刻可以有一个或多个器件接收信息。  

06.C  

多周期CPU中的指令通常需要多个时钟周期才能完成， $\mathrm{CPI}>1$ ：单周期CPU的每条指令在一个时钟周期内完成， ${\mathrm{CPI}}=1$ 。单周期CPU的时钟周期取决于最复杂指令的执行时间，通常比多周期CPU的时钟周期长。在一条指令的执行过程中，单周期CPU的每个控制信号保持不变，每个部件只能使用一次；多周期CPU的控制信号可能会发生改变，同一个部件可使用多次。  

07.D  

采用CPU内部总线方式的数据通路的特点：结构简单，实现容易，性能较低，存在较多的冲突现象：不采用CPU内部总线方式的数据通路的特点：结构复杂，硬件量大，不易实现，性能高，基本不存在数据冲突现象。  

08. D  

读/写控制信号线决定了是从存储器读还是向存储器写，显然A、B、C都正确。  

09.A  

单周期处理器中所有指令的指令周期为一个时钟周期，D正确。因为每条指令的CPI为1，要考虑比较慢的指令，所以处理器的时钟频率较低，B正确。单总线数据通路将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只充许一次操作，无法完成指令的所有操作，A错误。控制信号是CUJ根据指令操作码发出的信号，对于单周期处理器来说，每条指令的执行只有一个时钟周期，而在一个时钟周期内控制信号并不会变化；若是多周期处理器，则指令的执行需要多个时钟周期，在每个时钟周期控制器会发出不同信号，C正确。  
10.C  

指令执行过程中数据所经过的路径，包括路径上的部件，称为数据通路。ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等，都是指令执行过程中数据流经的部件，都属于数据通路的一部分。数据通路中的数据流动路径由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。C错误。  

11.B  

组合逻辑元件（操作元件）不含存储信号的记忆单元，任荷时刻产生的输出仅取决于当前的输入，加法器、算术逻辑单元（ALU）、译码器、多路选择器、三态门等都属于操作元件。时序逻辑元件（状态元件）包含存储信号的记忆单元，各类寄存器和存储器，如通用寄存器组、程序计数器、状态/移位/暂存/锁存寄存器等，都属于状态元件。  

# 二、综合应用题  

01.【解答】  

实现ADDR1，（R2）的微操作序列如下：  

微操作(PC）→MAR M→MDR (PC）+1→PC (MDR)→IR (R1)→LA (R2)→MAR M→MDR (MDR)→LB (LA)+(LB)→R1  

02.【解答】  

两条指令的微操作序列和控制信号如下。  

（1）ADDB，C指令。  

微操作控制信号(PC)→→MAR PCout，MARin （PC）+1-PC+1M（MAR)→MDR→IRMDRout,IRin(B）→Y Bout, Yin (Y)+（C）→2 Cout, ALUin,  $^+$  （Z）→B Zout,Bin  

（2）SUBACC，H指令。  

微操作控制信号(PC)→MAR PCout,MARin （PC）+1→PC+1M（MAR)→MDR→IRMDRout,IRin(ACC)→Y ACCout,Yin （Y)-（H）→ZHout,ALUin，(Z)→ACC Zout, Accin  

注：Y是与ALU的一个输入端相连接的暂存器。  

03.【解答】  

指令ADD（R0），R1的功能是把R0的内容作为地址送到主存中取得一个操作数，再与R1中的内容相加，最后将结果送回主存，即实现 $((\mathrm{R0}))+(\mathrm{R1}){\rightarrow}(\mathrm{R0})$ 。其流程和控制信号如下。  
1）取指周期：公共操作。
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f84dcc120dcbcfbb34c20c3c0e2d3b161154967efc1a7f373c7aad2a8b361004.jpg)  

2）取数周期：完成取数操作，被加数在主存中，加数已经放在寄存器R1中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c1689d23e868609146eb52b0b8b1aedad58f47993bdcf50c2c623e9874652d62.jpg)  

3）执行周期：完成加法运算，并将结果返回主存。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2540636a89137a158d85bb6d41d0bf7c59cd9273fdfeb3629886f3ab92ea9388.jpg)  

# 04.【解答】  

1）b单向连接微控制器，由微控制器的作用可以推出b是IR；a和c直接连接主存，只可能是MDR和MAR，c到主存是单向连接，a和主存双向连接，根据指令执行的特点，MAR只单向给主存传送地址，而MIDR既存放从主存中取出的数据，又存放将要写入主存的数据，因此c为MAR，a为MDR。d具有自动加1的功能，且单向连接MAR，为PC。因此，a为MDR，b为IR，c为MAR，d为PC。  

2）将指令地址从PC送入MAR，在相关的控制下从主存中取出指令送至MDR，然后将 MIDR中的指令送至IR，最后流向微控制器。取指令的数据通路为  

3）根据MAR中的地址从主存取数据，将取出的数据送至MDR，然后将MIDR中的数据送至ALU进行运算，运算的结果送至ACC。存储器读的数据通路为  

将ACC中的结果送至MDR，再将MDR中的数据写入主存。存储器写的数据通路为MAR（先置数据地址），ACC一MDR→主存M  

4）指令LDAX的数据通路为  

5）指令ADDY的数据通路为  

Y→MAR→主存→MDR ALU-ACC ACC  
6）指令STAZ的数据通路为（ACC中的数据需放在主存中）  

# 05.【解答】  

1）各功能部件的连接关系及数据通路如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/661f3bd2a04fb0d03925070f3545a20e3ada5d050a8767e107c91dfee82e5fee.jpg)  

2）分析过程如下：  

取指令地址送到IR并译码。  

取源操作数和目的操作数。  

·将源操作数和自的操作数相加送到MAR，随之送到以前目的操作数所在内存的地址  

·将寄存器R2的内容加1。  

取指周期流程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e642dab1517448c221e2f35932a2d3e4cc15b395ee72b510e1bea53e8fd904c.jpg)  

# 06.【解答】  

ADDX，D指令周期信息流程和相应的控制信号见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/00894e01e9f848466f0d413b5b0e69aac60af02ee9f98c3242d2099f24d175cb.jpg)  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/020b8c5c3f3fe53ff8e37feda0fad8fdf539f6981833563b7305a4354a63c1b4.jpg)  
注：题目中的D即为Ad（IR）。  

07.【解答】  

题干已给出取值和译码阶段每个节拍的功能和有效控制信号，我们应以了解取指阶段中数据通路的信息流动为突破口，读懂每个节拍的功能和有效控制信号，然后应用到解题思路中，包括划分执行步骤、确定完成的功能、需要的控制信号。  

先分析题干中提供的示例（本部分解题时不做要求）  

取指令的功能是根据PC的内容所指的主存地址，取出指令代码，经过MIDR，最终送至IR。这部分和后面的指令执行阶段的取操作数、存运算结果的方法是相通的。  

# C1:（PC)→MAR  

在读/写存储器前，必须先将地址（这里为（PC））送至MAR。  

C2:  $\mathrm{M(MAR){\rightarrow}M D R,(PC)+1{\rightarrow}P C}$  

读/写的数据必须经过MDR，指令取出后PC自增1。  

C3:（MDR)→IR  

然后将读到的MDR中的指令代码送至IR进行后续操作。  

指令“ADD（RI），RO”的操作数一个在主存中，一个在寄存器中，运算结果在主存中。根据指令功能，要读出R1的内容所指的主存单元，必须先将RI的内容送至MAR，即（R1）→MAR。而读出的数据必须经过MDR，即 $\mathrm{M(MAR)}{\rightarrow}\mathrm{MDR}.$  

因此，将R1的内容所指的主存单元的数据读出到MDR的节拍安排如下：  

C5:(R1)→MAR  

C6:  $\mathrm{M(MAR){\rightarrow}M D R}$  

ALU一端是寄存器A，MDR或RO中必须有一个先写入A中，如MDR。  

C7:（MDR)→A  

然后执行加法操作，并将结果送入寄存器AC。  

C8:  $(\mathrm{A})+(\mathrm{R0}){\rightarrow}\mathrm{AC}$  

之后将加法结果写回到R1的内容所指的主存单元，注意MAR中的内容没有改变。  

C9:(AC)-→MDR  

C10:(MDR)→M(MAR)  

有效控制信号的安排并不难，只需看数据是流入还是流出，如流入寄存器X就是Xin，流出寄存器X就是Xout。还需注意其他特殊控制信号，如 $\mathrm{PC}+1$ 、Add等。  

于是得到参考答案如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cb4b5ddf9bd5083ae3ddadfec8991f8731b5c91376408050705d1020631f6e88.jpg)  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bcefe925038a14ac746560481899c5f7a468b6b712162df1beece18df4e0e2ce.jpg)  

本题答案不唯一，若在C6执行 $\mathrm{M(MAR){\rightarrow}M D R}$ 的同时，完成 $(\mathrm{R0}){\rightarrow}\mathrm{A}$ （即选择将(R0）写入A），并不会发生总线冲突，这种方案可节省1个节拍，见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0dd137c83beecb2b28a61c379ac984e23d0e38bce599b8df60bfd1bfd409483b.jpg)  

# 08.【解答】  

1）程序员可见寄存器为通用寄存器（ $\mathrm{R}0\!\sim\!\mathrm{R}3$ ）和PC。因为采用了单总线结构，因此若无暂存器T，则ALU的A、B端口会同时获得两个相同的数据，使数据通路不能正常工作。  

2）ALU共有7种操作，其操作控制信号ALUop至少需要3位；移位寄存器有3种操作，其操作控制信号SRop至少需要2位。  

3）信号SRout所控制的部件是一个三态门，用于控制移位器与总线之间数据通路的连接与断开。  

4）端口 $\textcircled{\scriptsize{1}}$ 、 $\circledcirc$ 、 $\textcircled{3}$ 、 $\circledast$ 、 $\circledast$ 须连接到控制部件输出端。  

5）连线1， $(\!(6)\!\!\to\!\!(9)$ ：连线2， $\textcircled{v}{\rightarrow}\textcircled{4}$  

6）因为每条指令的长度为16位，按字节编址，所以每条指令占用2个内存单元，顺序执行时，下条指令地址为 $(\mathrm{PC})+2$ 。MUX的一个输入端为2，可便于执行 $(\mathrm{PC})+2$ 操作。  

# 09.【解析】  

1）符号标志SF表示运算结果的正负性，因此 $\mathrm{SF}=\mathrm{F}_{15}$ 对于加法运算 $\mathrm{A}+\mathrm{B}{\rightarrow}\mathrm{F}$ ，若A、B为负，且F为正，则说明发生溢出：或者，若A、B为正，且F为负，也说明发生溢出。因此，加运算时，溢出标志 $\mathrm{OF}\!=\!\overline{{\mathbf{A}_{15}}}\cdot\overline{{\mathbf{B}_{15}}}\cdot\!\mathrm{F}_{15}\!+\!\mathbf{A}_{15}\!\cdot\!\mathbf{B}_{15}\!\cdot\!\overline{{\mathbf{F}_{15}}}$ 对于减法运算 $\mathrm{A-B\!\to\!F}$ ，若A为负、B为正，且F为正，则说明发生溢出；或者，若A为正、B为负，且F为负，也说明发生溢出。因此，减运算时，溢出标志 $\mathrm{OF}\!=\!\overline{{\mathbf{A}_{15}}}\cdot\!\mathbf{B}_{15}\!\cdot\!\mathrm{F}_{15}+$  $\mathrm{A}_{15}\cdot\overline{{\mathrm{B}_{15}}}\cdot\overline{{\mathrm{F}_{15}}}$ 。  

2）因为在单总线结构中，每一时刻总线上只有一个数据有效，而ALU有两个输入端和一个输出端。因此，当ALU运算时，需要先用暂存器Y缓存其中一个输入端的数据，再通过总线传送另一个输入端的数据。与此同时，ALU的输出端产生运算结果，但由于总线正被占用，因此需要暂存器Z，以缓存ALU的输出端数据。  

3）由图可知，rs和rd都是4bit，因此GPRs中最多有 $2^{4}=16$ 个通用寄存器；rs和rd来自指令寄存器IR；rd表示寄存器编号，应连接地址译码器。  

4）取指阶段需要根据程序计数器PC取出主存中的指令，并将指令写入指令寄存器IR中。控制信号序列如下：  
$\textcircled{\scriptsize{1}}$ PCout,MARin/将指令的地址写入MAR $\circledcirc$ Read//读主存，并将读出的数据写入MDR $\circledast$  MDRout,IRin //将MDR的内容写入指令寄存器IR 步骤 $\circledcirc$ 需要1个时钟周期，步骤 $\circledcirc$ 需要5个时钟周期，步骤 $\textcircled{3}$ 需要1个时钟周期，因此取指  

5）图中控制信号由控制部件（CU）产生。指令寄存器IR和标志寄存器FR的输出信号会连 到控制部件的输入端。  

# 5.4控制器的功能和工作原理  

# 5.4.1控制器的结构和功能  

从图5.9可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。  

现对其主要连接关系简单说明如下：  

1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。  

2）输入设备和输出设备通过接口电路与总线相连接。  

3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。  

4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d13488b4b74cc2530f08d0235bb3404b2df25c7b14a7a83dd5306035c33dd080.jpg)  
图5.9计算机硬件系统和控制器部件的组成  

控制器是计算机系统的指挥中心，控制器的主要功能有：  

1）从主存中取出一条指令，并指出下一条指令在主存中的位置。2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。  

3）指挥并控制CPU、主存、输入设备和输出设备之间的数据流动方向。  

根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法及给出控制各部件运行所需要的控制信号的方案是不同的。  
# 5.4.2硬布线控制器  

硬布线控制器由复杂的组合逻辑门电路和触发器构成，也称组合逻辑控制器，其原理是根据指令的要求、当前的时序及内外部的状态，按时间的顺序发送一系列微操作控制信号。  

指令的操作码是决定控制单元（CU）发出不同控制信号的关键。为了简化CU的逻辑，将存放在 IR的 $n$ 位操作码经过译码电路产生 $2^{n}$ 个输出，每种操作码对应一个输出送至CU。如果将指令译码器和节拍发生器从CU中分离出来，便可得到简化的控制单元框图，如图5.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d2f55e758d9c494275dac108e2cae6bca95b683e62055bdffc92ff9c328afb53.jpg)  
图5.10带指令译码器和节拍输入的控制单元框图  

控制单元（CU）的输入信号来源如下：  

1）经指令译码器译码产生的指令信息。现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，它与时钟配合产生不同的控制信号。2）时序系统产生的机器周期信号和节拍信号。为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制。3）来自执行单元的反馈信息即标志。控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。  

图5.10中，节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令 $C_{i}$ （控制信号）按时间的先后发出。个别指令的操作不仅受操作码控制，而且受到状态标志控制，因此CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上。  

硬布线控制的功能由逻辑门组合实现，其速度主要取决于电路延迟，因此高速计算机中的关键核心部件CPU往往采用硬布线逻辑实现。因此，RISC一般都选用硬布线控制器。硬布线控制器的控制信号先用逻辑式列出，经化简后用电路来实现，因此显得零乱复杂，当需要修改或增加指令时就必须重新设计电路，非常麻烦。而且指令系统功能越全，微操作命令就越多，电路也就越庞杂，调试就更困难。为了克服这些缺点，便产生了微程序设计方法。  

# 5.4.3微程序控制器  

微程序控制器采用存储逻辑实现，也就是将微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。  

# 1.微程序控制的基本概念  

微程序的设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。因此，执行一条指令的过程就是执行一个微程序的过程，这些微程序存储在一个控制存储器中。目前，大多数计算机都采用微程序设计技术。  
微程序设计技术涉及的基本术语如下。  

（1）微命令与微操作  

在微程序控制的计算机中，控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。执行部件收到微命令后所进行的操作称为微操作，微命令和微操作是一一对应的。  

微命令有相容性和互斥性之分。相容性微命令是指那些可以同时出现、共同完成某一些微操作的微命令；而互斥性微命令是指在机器中不允许同时出现的微命令。  

# 注意  

硬布线控制器中也有微命令与微操作的概念，并非微程序控制器的专有概念。  

（2）微指令与微周期  

微指令是若干微命令的集合，一条微指令通常至少包含两大部分信息：  

$\textcircled{\scriptsize{1}}$ 操作控制字段，也称微操作码字段，用于产生某一步操作所需的各种操作控制信号。  

$\circledcirc$ 顺序控制字段，也称微地址码字段，用于控制产生下一条要执行的微指令地址。  

微周期是指从控制存储器中取出并执行一条微指令所需的全部时间，通常为一个时钟周期。  

（3）主存储器与控制存储器  

# 命题追踪主存储器和控制存储器的区别（2017）  

主存储器用于存放程序和数据，在CPU外部，用RAM实现。控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。存放微指令的控制存储器的单元地址称为微地址。  

# （4）程序与微程序  

微程序和程序是两个不同的概念。程序是指令的有序集合，用于完成特定的功能。微程序是微指令的有序集合，用于描述机器指令，一条指令的功能由一段微程序来实现。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，系统中微程序的结构和功能是透明的，无须知道。程序最终由机器指令组成，并且由软件设计人员事先编制好并存放在主存储器或者辅助存储器中。  

读者应注意区分以下寄存器：  

$\textcircled{\scriptsize{1}}$ 地址寄存器（MAR）。用于存放主存的读/写地址。  

$\circledcirc$ 微指令地址寄存器（ $\upmu\mathrm{PC}$ 或CMAR)。用于存放待执行的微指令在控制存储器中的微地址。  

$\textcircled{3}$ 指令寄存器（IR）。用于存放从主存中读出的指令。  

$\textcircled{4}$ 微指令寄存器（ $\upmu\mathrm{{IR}}$ 或CMIDR）。用于存放从控制存储器中读出的微指令。  

# 2.微程序控制器的组成和工作过程  

（1）微程序控制器的基本组成  

图5.11所示为一个微程序控制器的基本结构，其主要部件包括：  

$\textcircled{\scriptsize{1}}$ 起始和转移地址形成部件（或简称微地址形成部件）。用于产生初始和后继微地址，以保证微指令的连续执行。  

$\textcircled{2}$ 微指令地址寄存器。接收微地址形成部件送来的微地址，为读取微指令做准备。  

$\textcircled{3}$ 控制存储器。它是微程序控制器的核心部件，用于存放各指令对应的微程序。  

$\textcircled{4}$ 微指令寄存器。其位数等于微指令字长。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99c89003cac2ee2ef59dde11e4b8aa32720bdbcf83de761ecb39fd778d602223.jpg)  
图5.11微程序控制器的基本结构  

（2）微程序控制器的工作过程  

实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可描述为：  

$\textcircled{\scriptsize{1}}$ 执行取指令公共操作。在机器开始运行时，自动地将取指微程序的入口地址送入 $\upmu\mathrm{PC}$ 并从CM中读出相应的微指令并送入 $\upmu\mathrm{IR}$ 。取指微程序的入口地址一般为CM的O号单元，取指微程序执行完成后，从主存中取出的机器指令就已存入指令寄存器中。 $\circledcirc$ 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 $\upmu\mathrm{PC}$  $\textcircled{3}$ 从CM中逐条取出对应的微指令并执行。 $\textcircled{4}$ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 $^\mathrm{(Q)}$ 步，以完成取下一条机器指令的公共操作。以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。  

# （3）微程序和机器指令  

通常，一条机器指令对应一个微程序。由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。此外，也可编写出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等公共的微程序数。  

# 3.微指令的编码方式  

微指令的编码方式也称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。  

（1）直接编码（直接控制）方式  

微指令的直接编码方式如图5.12所示。直接编码法无须进行译码，微指令的操作控制字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。  

这种编码的优点是简单、直观，执行速度快，操作并行性好；缺点是微指令字长过长， $n$ 个微命令就要求微指令的操作字段有 $n$ 位，造成控制存储器容量极大。  

（2）字段直接编码方式  

# 命题追踪字段直接控制的编码方法（2012）  

将微指令的操作控制字段分成若干小字段，把互斥性微命令放在同一字段中，把相容性微命令放在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图5.13所示。这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c6e197e941e2f1058a37b511cbaa37823f47acc90dd408d7e4f2e9e15c655007.jpg)  
图5.12直接编码方式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8f2b917f211c35fb07f59a18310c4809c207a77d2f9e952f169ab68cecd9625.jpg)  
图5.13字段直接编码方式  

微命令字段分段的原则：  

$\textcircled{\scriptsize{1}}$ 互厅性微命令分在同一段内，相容性微命令分在不同段内。  

$\circledcirc$ 每个小段中包含的信息位不能太多，否则将增加译码电路的复杂性和译码时间。  

$\textcircled{3}$ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。  

（3）字段间接编码方式  

一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，也称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。  

# 4.微指令的地址形成方式  

后继微地址的形成主要有以下几个基本类型：  

1）由微指令的后继地址字段（也称下地址字段）指出。在微指令格式中设置一个后继地址字段，由微指令的后继地址字段直接指出后继微指令的地址，这种方式也称断定方式。  

2）根据机器指令的操作码形成。当机器指令取自指令寄存器后，微指令的地址由操作码经微地址形成部件形成，该部件输出的是对应机器指令微程序的首地址。  

3）增量计数器法，即 $(\upmu\mathrm{PC})+1{\rightarrow}\upmu\mathrm{PC}$ ，适用于后继微指令地址是连续的情况。  

4）根据各种标志决定下一条微指令分支转移的地址  

5）由硬件直接产生微程序入口地址。电源加电后，第一条微指令的地址可由专门的硬件电路产生，并送至 $\upmu\mathrm{PC}$ ，这个地址即为取指周期微程序的入口地址。  

# 5.微指令的格式  

微指令格式与微指令的编码方式有关，通常分为水平型微指令和垂直型微指令两种。  

# 命题追踪 微指令后继地址字段位数与微指令条数的关系（2014）  

（1）水平型微指令  

从编码方式看，直接编码、字段直接编码和字段间接编码都属于水平型微指令。水平型微指令的基本指令格式如图5.14所示，指令字中的一位对应一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行多个并行操作的微命令。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b2aedaa58c557759dbd6b0fe7d9c754a7d34a84fc4317965518d9de55c2fb6a1.jpg)  

水平型微指令的优点是微程序短，并行能力强，执行速度快；缺点是微指令长，编写微程序较麻烦。  

（2）垂直型微指令  

采用类似机器指令操作码的方式，在微指令字中设置微操作码字段，垂直型微指令的基本格式如图5.15所示。一条垂直型微指令通常只能定义并执行一种微命令。  
图5.15垂直型微指令格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7065d0c6793931c03ff4fb46419e81a29e8a05e3dc173555b1f656c5aa397918.jpg)  

垂直型微指令的优点是微指令短、简单、规整，便于编写微程序：缺点是微程序长，执行速 度慢，效率低。  

水平型微指令和垂直型微指令的比较如下：  

$\textcircled{\scriptsize{1}}$ 水平型微指令并行操作能力强、效率高、灵活性强：垂直型微指令则较差。 $\circledcirc$ 水平型微指令执行一条指令的时间短；：垂直型微指令执行的时间长。 $\textcircled{3}$ 用水平型微指令编写的微程序，微指令字较长但微程序短；垂直型微指令正好相反。 $\textcircled{4}$ 水平型微指令难以掌握；而垂直型微指令与机器指令比较相似，相对容易掌握。  

# 6.硬布线和微程序控制器的特点  

# 命题追踪硬布线控制器和微程序控制器的特点（2009）  

（1）硬布线控制器的特点  

硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计自标，一旦设计完成，就不可能通过其他额外修改添加新功能。  

（2）微程序控制器的特点  

相比组合逻辑控制器，微程序控制器的优点是具有规整性、灵活性和可维护性；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度。  

为便于比较，下面以表格的形式对比二者的不同，见表5.1。  

表5.1微程序控制器与硬布线控制器的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5758d88c281f323689f1a57cbe9859540b34d296985c6fd404c91be129bd19f0.jpg)  

# 5.4.4 本节习题精选  

# 一、单项选择题  

01.取指令操作（）。  

A.受到上一条指令的操作码控制B.受到当前指令的操作码控制C.受到下一条指令的操作码控制D.是控制器固有的功能，不需要在操作码控制下进行  

02.在组合逻辑控制器中，微操作控制信号的形成主要与（）信号有关。A.指令操作码和地址码 B.指令译码信号和时钟  
C.操作码和条件码D.状态信息和条件

03.在微程序控制器中，形成微程序入口地址的是（）  

A.机器指令的地址码字段B.微指令的微地址码字段C.机器指令的操作码字段 D.微指令的微操作码字段  

04.下列不属于微指令结构设计所追求目标的是（）。  

A.提高微程序的执行速度B.提供微程序设计的灵活性C.缩短微指令的长度D.增大控制存储器的容量  

05.微程序控制器的速度比硬布线控制器慢，主要是因为（）  

A.增加了从磁盘存储器读取微指令的时间B.增加了从主存读取微指令的时间C.增加了从指令寄存器读取微指令的时间D.增加了从控制存储器读取微指令的时间  

06.下列关于微指令的说法中，错误的是（）  

1.字段直接编码方式可用较少的二进制位数表示较多的微操作命令。如果有两组互厅的微命令，每组微命令的个数分别为4和9，则分别只需要2位和4位即可I1.直接编码方式不用进行译码操作，微命令字段中的每一位都代表一个微命令II.垂直型微指令用较长的微程序结构换取较短的微指令结构，所以在执行效率和灵活 性两方面都高于水平型微指令 IV.在字段间接编码方式中，某个字段的译码输出需要依靠另外某个字段的输入  

A.IIB.I、ⅡIC.I.IID.II、IIV  

07.微程序控制存储器属于（）的一部分。  

A.主存B.外存C.CPUD.缓存  

08.以下说法中，正确的是（）。  

A.采用微程序控制器是为了提高速度B.控制存储器由高速RAM电路组成C.微指令计数器决定指令执行顺序 D.一条微指令存放在控制器的一个控制存储器单元中  

09.硬布线控制器与微程序控制器相比，（）  

A.硬布线控制器的时序系统比较简单B.微程序控制器的时序系统比较简单C.两者的时序系统复杂程度相同D.可能是硬布线控制器的时序系统比较简单，也可能是微程序控制器的时序系统比较简单  

10.在微程序控制器中，控制部件向执行部件发出的某个控制信号称为（）A.微程序 B.微指令 C.微操作 D.微命令

 11.在微程序控制器中，机器指令与微指令的关系是（）  

A.每条机器指令由一条微指令来执行B.每条机器指令由若干微指令组成的微程序来解释执行C.若干机器指令组成的程序可由一个微程序来执行D.每条机器指令由若干微程序执行  

12.水平型微指令与垂直型微指令相比，（） A.前者一次只能完成一个基本操作B.后者一次只能完成一个基本操作C.两者都是一次只能完成一个基本操作D.两者都能一次完成多个基本操作  
13.垂直型微指令的特点是（）  

A.控制信号经过编码产生B.强调并行控制功能C.采用微操作码D.微指令格式垂直表示  

14.下列关于微命令的描述中，正确的是（）  

A.同一CPU周期中，可以同时出现的微命令叫相容性微命令B.同一CPU周期中，可以同时出现的微命令叫互斥性微命令C.在执行过程中可能会引起总线冲突的微命令叫互斥性微命令D.同一CPU周期中，不允许同时出现的微命令叫相容性微命令  

15.在微程序控制方式中，以下说法正确的是（）。  

I.采用微程序控制器的处理器称为微处理器II.每条机器指令由一段微程序来解释执行III.在微指令的编码中，效率最低的是直接编码方式IV.水平型微指令能充分利用数据通路的并行结构  

A.I、ⅡIB.II、IVC.1、IIID.II、IV  

16.下列说法中，正确的是（）。  

1.微程序控制方式和硬布线方式相比较，前者可以使指令的执行速度更快II.若采用微程序控制方式，则可用 $\upmu\mathrm{PC}$ 取代PCIⅢL.控制存储器可以用ROM实现IV.指令周期也称CPU周期  

A.I、IⅢIB.II、IIIC.只有IⅢID.I、II、IV  

17.通常一条指令对应一个微程序，一个微程序的周期对应一个（）  

A.指令周期B.主频周期C.机器周期D.工作周期  

18.下列部件中属于控制部件的是（）  

I.指令寄存器II.操作控制器III.程序计数器IV.状态条件寄存器  

A.I、IⅢ、IVB.I、II、IIC.I、II、IVD.I、II、III、IV  

19.为了确定下一条微指令的地址，通常采用断定方式，其基本思想是（）  

A.用程序计数器（PC）来产生后继微指令地址B.用微程序计数器（ $\upmu\mathrm{PC}$ ）来产生后继微指令地址C.通过微指令后继地址字段由设计者指定或转移控制字段控制产生后继微指令地址D.通过指令中指定一个专门字段来控制产生后继微指令地址  

20.【2009统考真题】相对于微程序控制器，硬布线控制器的特点是（）。  

A.指令执行速度慢，指令功能的修改和扩展容易B.指令执行速度慢，指令功能的修改和扩展难C.指令执行速度快，指令功能的修改和扩展容易D.指令执行速度快，指令功能的修改和扩展难  

21.【2012统考真题】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有（）。  
A.5位B.6位C.15位D.33位  

22.【2014统考真题】某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定法（后继地址字段法）确定下条微指令地址，则微指令中后继地址字段的位数至少是（）。  

A.5 B.6 C.8 D.9

 23.【2017统考真题】下列关于主存储器（MM）和控制存储器（CS）的叙述，错误的是（）  

A.MM在CPU外，CS在CPU内B.MM按地址访问，CS按内容访问C.MM存储指令和数据，CS存储微指令D.MM RAM ROM，CS用ROM实现  

24.【2019统考真题】下列有关处理器时钟脉冲信号的叙述中，错误的是（）  

A.时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成B.时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频 C.时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定D.处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令  

25.【2019统考真题】某指令的功能为 $\mathsf{R}[\mathsf{r}2]\!\leftarrow\!\mathsf{R}[\mathsf{r}1]+\mathbf{M}[\mathsf{R}[\mathsf{r}0]]$ ，其两个源操作数分别采用寄存器、寄存器间接寻址方式。对于下列给定部件，该指令在取数及执行过程中需要用到的是()。  

I.通用寄存器组（GPRs）II.算术逻辑单元（ALU）IⅢl.存储器（Memory）IV.指令译码器（ID）A.仅I、ⅡIB.仅I、Ⅱ、IⅢIC.仅II、IⅢI、IVD.仅I、ⅢI、IV  

26.【2021统考真题】下列寄存器中，汇编语言程序员可见的是（）。  

I.指令寄存器II.微指令寄存器IⅢI.基址寄存器IV.标志/状态寄存器  

A.仅I、ⅡIB.仅I、IVC.仅ⅡI、IVD.仅IⅢI、IV  

# 二、综合应用题  

01.若某机主频为 ${200}\mathrm{MHz}$ ，每个指令周期平均为2.5个CPU周期，每个CPU周期平均包括2个主频周期，问：  

1）该机平均指令执行速度为多少MIPS？2）若主频不变，但每条指令平均包括5个CPU周期，每个CPU周期又包含4个主频周期，平均指令执行速度又为多少MIPS？3）由此可得出什么结论？  

02.某机有80条指令，平均每条指令由4条微指令组成（包含取指微指令），其中有一条取指微指令是所有指令公用的。已知微指令长度为32位，请估算控制存储器CM容量。  

03.某微程序控制器中，采用水平型直接控制（编码）方式的微指令格式，后续微指令地址由微指令的后继地址字段给出。已知机器共有28个微命令，6个互斥的可判定的外部条件，控制存储器的容量为 $512{\times}40$ 位。试设计其微指令的格式，并说明理由。  

04.某机共有52个微操作控制信号，构成5个相斥类的微命令组，各组分别包含5、8、2、15、22个微命令。已知可判定的外部条件有两个，微指令字长28位。  
1）按水平型微指令格式设计微指令，要求微指令的后继地址字段直接给出后继微指 令地址。2）指出控制存储器的容量。  

05.设CPU中各部件及其相互连接关系如下图所示，其中W是写控制标志；R是读控制标志；R1、R2是暂存器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e7b35d85d6f9269f22088aa4900e33d4503d9ca2bb3efaebcb40f883ead374e2.jpg)  

1）写出指令ADD#a（#为立即寻址特征，隐含的操作数在ACC寄存器中）在执行阶段所完成的微操作命令及节拍安排。2）假设要求在取指周期实现（ $\mathrm{PC})+1{\rightarrow}\mathrm{PC}$ ，且由ALU完成此操作（ALU能对它的一个源操作数完成加1运算）。以最少的节拍写出取指周期全部微操作命令及节拍安排。  

# 5.4.5 答案与解析  

# 一、单项选择题  

01.D  

取指令阶段完成的任务是将现行指令从主存中取出并送至指令寄存器，这个操作是公共的操 作，是每条指令都要进行的，与具体的指令无关，所以不需要操作码的控制。  

02.B  

CU的输入信号来源如下： $\textcircled{\scriptsize{1}}$ 经指令译码器译码产生的指令信息： $\circledcirc$ 时序系统产生的机器周期信号和节拍信号： $\textcircled{3}$ 来自执行单元的反馈信息即标志。前两者是主要因素。  

03.C  

执行公用的取指微程序从主存中取出机器指令后，由机器指令的操作码字段指出各个微程序 的入口地址（初始微地址）。  

04.D  

微指令的设计目标和指令结构的设计目标类似，都是基于执行速度、灵活性和指令长度这三个主要方面考虑的。而控制存储器容量的大小与微指令的设计自标无关。  

05.D  

在微程序控制中，控制存储器中存放有微指令，在执行时需要从中读出相应的微指令，从而增加了时间消耗。  

06.C  

字段直接编码方式为了缩短微指令字长而牺牲了速度，当微命令个数为4时需要3位，2位会导致每个编码都输出一个微命令，而不能表示不输出，1错误。Ⅱ正确。垂直型微指令的缺点是微程序长、执行速度慢、工作效率低，Ⅲ错误。在字段间接编码方式中，一个字段的某些微命令要由另一个字段的某些微命令来解释，即依赖另一个字段的译码输出，IV正确。  

07.C  
微程序控制存储器用来存放微程序，是微程序控制器的核心部件，属于CPU的一部分，而不属于主存。  

08.D  

硬布线控制器采用硬件电路，速度较快，但设计难度大、成本高。微程序控制器的速度较慢但灵活性高。通常控制存储器采用ROM组成。微指令计数器决定了微指令执行的顺序。  

09.B  

硬布线控制器需要结合各个微操作的节拍安排，综合分析，写出逻辑表达式，再设计成逻辑电路图，因此时序系统比较复杂；而微程序只需按照节拍的安排，顺序执行微指令，因此比较简单。  

10.D  

在微程序控制器中，控制部件向执行部件发出的控制信号称为微命令，微命令执行的操作称为微操作。微指令则是若干微命令的集合，若干微指令的有序集合称为微程序。  

11.B  

在一个CPU周期中，一组实现一定功能的微命令的组合构成一条微指令，有序的微指令序列构成一段微程序，微程序的作用是实现一条对应的机器指令。  

12. B  

一条水平型微指令能定义并执行几种并行的基本操作；一条垂直型微指令只能定义并执行一种基本操作。  

13. C  

垂直型微指令是一种微指令格式，相比于水平型微指令而言的，并不是指令格式垂直表示，在微指令中设置了微操作码字段，结构类似于机器指令格式。控制信号经过编码产生是一种控制字段的编码方法，属于水平型微指令，强调并行控制功能是一种控制字段的设计目标，适合水平型微指令而不适合垂直型微指令。  

14.A  

在同一个CPU周期中，可以同时出现的微命令叫相容性微命令，不允许同时出现的微命令叫互斥性微命令。不充许同时出现的原因有可能是会引起总线冲突，也有可能是其他原因。  

15.B  

微处理器是相对于一些大型处理器而言的，与微程序控制器没有必然联系。不管是采用微程序控制器，还是采用硬布线控制器，微机的CPU都是微处理器，I错误。微程序的设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令，ⅡI正确。直接编码方式中每位代表一个微命令，不需要译码，因此执行效率最高，只是这种方式会使得微指令的位数大大增加，ⅢI错误。一条水平型微指令能定义并执行几种并行的基本操作，因此能够更充分利用数据通路的并行结构，IV正确。  

16. C  

微程序控制方式采用编程方式来执行指令，而硬布线方式则采用硬件方式来执行指令，因此硬布线方式速度较快，I错误。 $\upmu\mathrm{PC}$ 无法取代PC，因为它只在微程序中指向下一条微指令地址的寄存器。因此它也必然不可能知道这段微程序执行完毕后下一条是什么指令，Ⅱ错误。由于每条微指令执行时所发出的控制信号是事先设计好的，不需要改变，因此存放所有控制信号的存储器应为ROM，ⅢI正确。指令周期是从一条指令启动到下一条指令启动的间隔时间，而CPU周期是 机器周期，是指令执行中每步操作所需的时间，IV错误。  

17.A  

一条指令对应一个微程序，所以一个微程序的周期对应一个指令周期。  
18.B  

CPU控制器主要由三个部件组成：指令寄存器、程序计数器和操作控制器。状态条件寄存器通常属于运算器的部件，保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，如运算结果进位标志（CF）、运算结果溢出标志（VF）等。  

19.C  

断定法是指在微指令（后继地址字段）中直接明确指出下一条微指令的地址，这样相当于每 条都是转移微指令，此外，还有一些其他如条件测试和转移控制字段，也用于控制微指令的寻址。因此，后继微指令地址可由微程序设计者指定，或者根据微指令所规定的转移控制字段控制产生。  

20.D  

微程序控制器采用了“存储程序”的原理，每条机器指令对应一个微程序，因此修改和扩充容易，灵活性好，但每条指令的执行都要访问控制存储器，所以速度慢。硬布线控制器采用专门的逻辑电路实现，其速度主要取决于逻辑电路的延迟，因此速度快，但修改和扩展困难，灵活性差。  

21. C  

字段直接编码法将微命令字段分成若干小字段，互厅性微命令组合在同一字段中，相容性微命令分在不同字段中，每个字段还要留出一个状态，表示本字段不发出任何微命令。5个互斥类，分别包含7、3、12、5和6个微命令，需要3、2、4、3和3位，共15位。  

22.C  

计算机共有32条指令，各个指令对应的微程序平均为4条，则指令对应的微指令为 $32\!\times\!4=128$ 条，而公共微指令还有2条，整个系统中微指令的条数共为  $128+2=130$  条，所以需要  $\lceil\log_{2}\!130\rceil=$  8位才能寻址到130条微指令。  

23.B  

主存储器（MM）在CPU外，用于存储指令和数据，由RAM和ROM实现（主要是RAM）。控制存储器（CS）用来存放构成指令系统的所有微指令，是一种只读型存储器，机器运行时只读不写，在CPU的控制器内。控制存储器按照微指令的地址访问。  

24.D  

时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频。时钟脉冲信号由机器脉冲 源发出的脉冲信号经整形和分频后形成，时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定。对于单周期CPU，一个指令周期就是一个时钟周期，每个时钟周期执行一条新指令；对于多周期CPU，每个指令周期（包含若干时钟周期）执行一条新指令；对于流水线CPU，只有在理想情况下才能实现每个时钟周期执行一条新指令，选项D的描述有误。  

25.B  

该指令的两个源操作数分别采用寄存器、寄存器间接寻址方式，因此在取数阶段需要用到通用寄存器组（GPRs）和存储器（Memory）；在执行阶段，两个源操作数相加需要用到算术逻辑单元（ALU）。而指令译码器（ID）用于对操作码字段进行译码，向控制器提供特定的操作信号，在取数及执行阶段用不到。  

26.D  

汇编程序员可见的寄存器有基址寄存器（用于实现多道程序设计或者编制浮动程序）和状态/标志寄存器、程序计数器PC及通用寄存器组；而MAR、MDR、IR是CPU的内部工作寄存器，对汇编程序员不可见。微指令寄存器属于微程序控制器的组成部分，它是硬件设计者的任务，对汇编程序员是透明的（不可见的）。  
# 二、综合应用题  

01.【解答】  

${200}\mathrm{MHz}$   $=1/200\mathrm{MHz}=0.005\upmu\mathrm{s}.$  每个指令周期平均为2.5个CPU周期，每个CPU周期平均包括2个主频周期，所以一条指令的执行时间 $=2{\times}2.5{\times}0.005{\upmu}{\mathrm{s}}=0.025{\upmu}{\mathrm{s}}.$ 该机平均指令执行速度 $=1/0.025=40\mathrm{MIPS}.$ 2）每条指令平均包括5个CPU周期，每个CPU周期又包含4个主频周期，所以一条指令的执行时间 $=4{\times}5{\times}0.005{\upmu\mathrm{s}}=0.1{\upmu\mathrm{s}}.$ 该机平均指令执行速度 $=1/0.1=10\mathrm{MIPS}$ 3）由此可见，指令的复杂程度会影响平均指令执行速度。  

02.【解答】  

总的微指令条数 $=(4–1){\times}80+1=241$ 条，每条微指令占一个控制存储器单元，控制存储器CM的容量为2的 $n$ 次幂，而241刚好小于256，所以CM的容量 $=256{\times}32$ 位 $=1\mathrm{KB}$  

03.【解答】  

水平型微指令由操作控制字段、判别测试字段和后继地址字段三部分构成。因为微指令采用直接控制（编码）方式，所以其操作控制字段的位数等于微命令数，为28位。又由于后继微指令地址由后继地址字段给出，因此其后继地址字段的位数可根据控制存储器的容量（ $.512{\times}40$ 位）确定为9位 $(512=2^{9}$ )。当微程序出现分支时，后续微指令地址的形成取决于状态条件一一6个互斥的可判定外部条件，因此状态位应编码成3位。非分支时的后续微指令地址由微指令的后继地址字段直接给出。微指令的格式如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/450e1a38e2a3c6592dd4a91dc685a68125be5160303a09ea2bb15b847f6fa540.jpg)  

04.【解答】  

1）根据5个互斥类的微命令组，各组分别包含5、8、2、15、22个微命令，考虑到每组必须增加一种不发送命令的情况，条件测试字段应包含一种不转移的情况，则5个控制字段分别需给出6、9、3、16、23种状态，对应3、4、2、4、5位（共18位），条件测试字段取2位。根据微指令字长为28位，后继地址字段取  $28-18-2=8$  位，则其微指令 格式如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/93db4cd5f499d3cb210536da792fa6d7431dd289ab42c71d7c336a927c763bf3.jpg)  

2）根据后继地址字段为8位，微指令字长为28位，得出控制存储器的容量为 $2^{8}{\times}28$ 位。  

05.【解答】  

1）含有ACC的立即寻址，一个操作数隐藏在ACC中，立即寻址的加法指令执行周期的微操作命令及节拍安排如下：  

$T_{0}$  Ad（IR)→R1  $T_{1}$  (R1)  $^+$  (ACC)→R2  $T_{2}$  (R2)→ACC  

立即数→R1ACC ALU结果→ACC  

2）由于 $(\mathrm{PC})\,+\,1\!\to\!\mathrm{PC}$ 需由ALU完成，因此PC的值可作为ALU的一个源操作数，在ALU  
做加1运算得到 $(\mathrm{PC})+1$ 后，结果送至与ALU输出端相连的R2，然后送至PC。此题的关键是要考虑总线冲突的问题，因此，取指周期的微操作命令及节拍安排如下：  

$T_{0}$ (PC）→MAR，1→RPC通过总线送MAR $T_{1}$ M（MAR)→MDR，（PC) $^+$ 1→R2PC通过总线送ALU完成加1 $T_{2}$  $(\mathrm{{MDR}})\rightarrow\mathrm{{LR}}$ ，OP（IR）→微操作命令形成部件MDR通过总线送IR $T_{3}$ （R2）→PCR2通过总线送PC  

# 5.5异常和中断机制  

现代计算机中都配有完善的异常和中断处理系统，CPU的数据通路中有和应的异常检测和响应逻辑，外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件电路和中断服务程序有机结合，共同完成异常和中断的处理过程。  

# 5.5.1异常和中断的基本概念  

# 异常事件的性质（2015）  

由CPU内部产生的意外事件被称为异常，有些教材中也称内中断。由来自CPU外部的设备向CPU发出的中断请求被称为中断，通常用于信息的输入和输出，有些教材中也称外中断。异常是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件；中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。  

# 命题追踪异常响应的时机（2023）  

异常和中断处理过程的描述如下：若CPU在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或者执行第 $i$ 条指令后发现一个中断请求信号，则CPU打断当前程序，然后转去执行相应的异常或中断处理程序。若异常或中断处理程序能够解决相应的问题，则在异常或中断处理程序的最后，CPU通过执行异常或中断返回指令，回到被打断的用户程序的第 $i$ 条指令或第 $i+1$ 条指令继续执行；若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序。通常情况下，对异常和中断的具体处理过程由操作系统（和驱动程序）完成。  

异常和中断的处理过程基本是相同的，这也是有些教材将两者统称为中断的原因  

# 5.5.2异常和中断的分类  

# 1．异常的分类  

异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常。硬故障中断是由硬连线出现异常引起的，如存储器校验错、总线错误等。程序性异常也称软件中断，是指在CPU内部因执行指令而引起的异常事件。如整除0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页等。按异常发生原因和返回方式的不同，可分为故障、自陷和终止。  

（1）故障（Fault）  

# 命题追踪异常或中断处理后指令重新执行的断点（2021）  

指在引起故障的指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”；取数据时，发生“缺段”或“缺页”执行整数除法指令时，发现“除数为0”等。  
对于“缺段”“缺页”等异常事件，经处理后，可将所需的段或页面从磁盘调入主存，回到发生故障的指令继续执行，断点为当前发生故障的指令；对于“非法操作码”“除数为0”等，因为无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行。  

(2）自陷（Trap）  

# 命题追踪自陷的原理和性质（2020）  

自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是：事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，开不是返回到下一条指令执行，而是返回到转移目标指令执行。  

在x86机器中，用于程序调试“断点设置”和单步跟踪的功能就是通过陷阱机制实现的。此外，系统调用指令、条件自陷指令（如MiPS中的teq、teqi、tne、tnei等）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。  

故障异常和自陷异常属于程序性异常（软件中断）。  

（3）终止（Abort）  

如果在执行指令的过程中发生了使计算机无法继续执行的硬件敌障，如控制器出错、存储器校验错、总线错误等，那么程序将无法继续执行，只能终止，此时，调出异常服务程序来重启系统。这种异常与敌障和自陷不同，不是由特定指令产生的，而是随机发生的。  

终止异常和外中断属于硬件中断。  

# 2.中断的分类  

# 命题追踪对中断和异常事件的判断（2009、2016、2020）  

中断是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括I/O设备发出的I/O中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按Esc键、定时器计数时间到）等。外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。  

中断可分为可屏蔽中断和不可屏蔽中断。  

# （1）可屏蔽中断  

指通过可屏蔽中断请求线INTR向CPU发出的中断请求。CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到CPU。  

# （2）不可屏蔽中断  

指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件。  

中断和异常在本质上是一样的，但它们之间有以下两个重要的不同点：  

1）“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。  

2）异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断。  
此外，根据识别中断服务程序地址的方式，可分为向量中断和非向量中断：根据中断处理过程是否允许被打断，还可分为单重中断和多重中断。  

# 5.5.3异常和中断响应过程  

CPU执行指令时，如果发生了异常或中断请求，必须进行相应的处理。从CPU检测到异常或中断事件，到调出相应的处理程序，整个过程称为异常和中断响应。CPU对异常和中断响应的过程可分为关中断、保存断点和程序状态、识别异常和中断并转到相应的处理程序。  

（1）关中断  

在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断。通常通过设置“中断允许”（IF）触发器来实现，若IF置为1，则为开中断，表示允许响应中断；若F置为0，则表示关中断，表示不充许响应中断。  

（2）保存断点和程序状态  

为了能在异常和中断处理后正确返回到被中断的程序继续执行，必须将程序的断点（返回地址）送到栈或特定寄存器中。通常保存在栈中，这是为了支持异常或中断的嵌套。  

异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的程序状态字寄存器PSW的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到PSW中。  

（3）识别异常和中断并转到相应的处理程序  

异常和中断源的识别有软件识别和硬件识别两种方式。异常和中断源的识别方式不同，异常大多采用软件识别方式，而中断可以采用软件识别方式或硬件识别方式。  

软件识别方式是指CPU设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。  

硬件识别方式也称向量中断，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。  

整个响应过程是不可被打断的。中断响应过程结束后，CPU就从PC中取出对应中断服务程序的第一条指令开始执行，直至中断返回，这部分任务是由CPU通过执行中断服务程序完成的，整个中断处理过程是由软/硬件协同实现的。  

# 5.5.4 本节习题精选  

# 单项选择题  

01.以下关于“自陷”（Trap）异常的叙述中，错误的是（）  

A.“自陷”是人为预先设定的一种特定处理事件B.可由访管指令或自陷指令的执行进入“自陷” C.一定是出现某种异常情况才会发生“自陷” D.“自陷“发生后CPU将进入操作系统内核程序并执行  

02.指令执行结果出现异常而引起的中断是（）  

A.I/O中断 B.机器校验中断 C.故障 D.外部中断  

03.访问主存时发生的校验错误属于（）。  

A.故障 B.自陷 C.终止 D.外中断  

04.下列关于异常和中断响应的叙述中，错误的是（）。  
A.异常事件检测由CPU在执行每一条指令的过程中进行B.中断请求检测由CPU在每条指令执行结束、取下条指令之前进行C.CPU检测到异常事件后所做的处理和检测到中断请求后所做的处理完全相同D.CPU在中断响应时会关中断、保存断点和程序状态并转到相应的中断服务程序  

05.以下给出的事件中，无须异常处理程序进行处理的是（）。  

A.缺页故障 B.Cache缺失 C.地址越界 D.除数为0  

06.CPU响应中断的时间是（）。  

A.一条指令执行结束 B.I/O设备提出中断 C.取指周期结束 D.指令周期结束  

07.下列选项中，不属于外部中断事件的是（）A.采样定时到 B.无效操作码 C.打印机缺纸 D.键盘缓冲满

 08.下列关于异常/中断机制与进程上下文切换机制的叙述中，错误的是（）  

A.进程上下文切换和异常/中断响应两者都会产生异常控制流B.进程上下文切换后，CPU执行的是另一个进程的代码C.响应异常/中断请求后，CPU执行的是内核程序的代码D.进程上下文切换和异常/中断响应处理都通过执行内核程序实现  

09.异常或中断处理结束后，返回到被中断原程序继续执行的指令地址称为“断点”，以下关于“断点”的说法中，错误的是（）。  

A.“陷阱”类异常的断点为陷阱指令下一条指令的地址B.“故障”类异常的断点为当前发生异常的指令的地址C.外部中断的断点总是当前刚执行完的指令的地址D.“终止”类异常的断点可以是当前指令或下一条指令的地址  

10.【2015统考真题】内部异常（内中断）可分为故障（fault）、陷阱（trap）和终止（abort）三类。下列有关内部异常的叙述中，错误的是（）。  

A.内部异常的产生与当前执行指令相关 B.内部异常的检测由CPU内部逻辑实现 C.内部异常的响应发生在指令执行过程中D.内部异常处理后返回到发生异常的指令继续执行  

11.【2016统考真题】异常是指令执行过程中在处理器内部发生的特殊事件，中断是来自处 理器外部的请求事件。下列关于中断或异常情况的叙述中，错误的是（）  

A. “访存时缺页”属于中断 B.“整数除以0”属于异常 C.“DMA传送结束”属于中断 D.“存储保护错”属于异常  

12.【2020统考真题】下列关于“自陷”（Trap，也称陷阱）的叙述中，错误的是（）  

A.自陷是通过陷阱指令预先设定的一类外部中断事件B.自陷可用于实现程序调试时的断点设置和单步跟踪C.自陷发生后CPU将转去执行操作系统内核相应程序 D.自陷处理完成后返回到陷阱指令的下一条指令执行  

13.【2021统考真题】异常事件在当前指令执行过程中进行检测，中断请求则在当前指令执 行后进行检测。下列事件中，相应处理程序执行后，必须回到当前指令重新执行的是（）。  

A.系统调用 B.页缺失 C.DMA传送结束D.打印机缺纸  
# 5.5.5 答案与解析  

# 单项选择题  

01.C  

自陷是人为设定的特殊中断机制，不是出现某些异常情况而产生的，C错误。  

02. C  

异常是CPU执行指令过程中发生的与当前指令执行有关的意外事件，而中断请求则是CPU外部的I/O部件或时钟等向CPU发出的与当前指令执行无关的意外事件。指令执行结果出现异常与当前指令执行有关，如运算溢出等，属于内中断中的故障。  

03.C  

如果在执行指令的过程中发生严重错误，如控制器出错、存储器校验错等，则程序将无法继续执行，只能终止。严重情况下，甚至要调出中断服务程序来重启系统。  

04. C  

CPU对于异常和中断的响应处理大体是一致的，都需要保存断点和程序状态字并转到相应的处理程序去执行，但有些细节并不一样。例如，检测到中断请求后，CPU必须通过“中断回答”信号启动中断控制器进行中断查询，以确定当前发出的优先级最高的中断请求，并通过数据线获取相应的中断类型号；而对于异常，CPU无须进行中断回答。  

05.B  

缺页、地址越界和除数为0都是执行某条指令时可能发生的故障，需要调出操作系统内核中相应的异常处理程序来处理，而Cachne缺失则由CPU硬件实现，无须调出异常处理程序进行处理。  

06.A  

中断周期用于响应中断，若有中断，则在指令的执行周期后进入中断周期。  

07.B  

无效操作码是由CPU在对某条指令译码时发现的，因而是内部异常。采样定时时间到、打印机缺纸、键盘缓冲满都与当前指令的执行无关，是由CPU外部的中断源发出的中断请求。  

08.D  

在硬件层，CPU中有检测异常和中断事件并将控制转移到操作系统内核执行的机制；在操作系统层，内核能通过进程的上下文切换将一个进程的执行转移到另一个进程的执行，它们都会产生异常控制流。响应异常/中断请求后，CPU执行的是异常/中断服务程序，是操作系统的内核程序。进程上下文切换由操作系统的内核程序实现，而异常/中断的响应则由硬件实现。  

补充知识：CPU所执行指令的地址序列称为CPU的控制流。在程序正常执行时，通过顺序执行指令或转移指令得到的控制流称为正常控制流。在正常执行过程中，因遇到异常或中断事件而引起用户程序的正常执行被打断所形成的意外控制流，称为异常控制流，  

09.C  

外部中断请求信号的检测总是在一条指令执行完之后，取下一条指令之前。因此，如果检测到有外部中断请求，那么响应中断请求并转到中断服务程序执行后，应返回到原来被中断的程序中已经执行完成的指令的下一条指令执行，而不返回到刚执行完的指令执行。  

10.D  

内部异常是指来自CPU内部产生的中断，如非法指令、地址非法、校验错、页面失效、运算溢出和除数为零等，以上都是在指令的执行过程中产生的，A正确。内部异常的检测是由CPU自身完成的，不必通过外部的某个信号通知CPU，B正确。内部异常不能被屏蔽，一旦出现应立即处理，C正确。对于非法指令、除数为零等异常，无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行，D错误。  
# 11. A  

中断是指来自CPU执行指令以外的事件，如设备发出的I/O结束中断，表示设备输入/输出已完成，希望处理机能向设备发出下一个输入/输出请求，同时让完成输入/输出后的程序继续运行。异常也称内中断，指源自CPU执行指令内部的事件。  

# 12.A  

自陷是一种内部异常，A错误。在×86中，用于程序调试的“断点设置”功能是通过自陷机制实现的，B正确。执行到自陷指令时，无条件或有条件地自动调出操作系统内核程序进行执行，C正确。CPU执行陷阱指令后，会自动地根据不同陷阶类型进行相应的处理，然后返回到陷阱指令的下一条指令执行，D正确。  

# 13.B  

系统调用属于自陷，“断点”为自陷指令的下一条指令地址。DMA传送结束后，DMA控制器需要向CPU发送中断请求，属于外中断，外中断的“断点”为下一条指令地址。打印机缺纸同样属于外部中断。页缺失属于内部异常中的故障，“断点”为发生敌障的指令地址，执行完缺页异常处理程序之后必须返回发生敌障的指令重新热行。  

# 5.6指令流水线  

前面介绍的指令都是在单周期处理机中采用串行方法执行的，同一时刻CPU中只有一条指令在执行，因此各功能部件的使用率不高。现代计算机普遍采用指令流水线技术，同一时刻有多条指令在CPU的不同功能部件中并发执行，大大提高了功能部件的并行性和程序的执行效率。  

# 5.6.1指令流水线的基本概念  

可从两方面提高处理机的并行性： $\textcircled{\scriptsize{1}}$ 时间上的并行技术，将一个任务分解为几个不同的子阶段，每个子阶段在不同的功能部件上并行执行，以使在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为流水线技术。 $\circledcirc$ 空间上的并行技术，在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为超标量处理机。  

一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。  

假设一条指令的执行过程分为如下5个阶段（也称功能段或流水段）?：  

·取指（IF）：从指令存储器或Cache中取指令。·译码/读寄存器（ID）：操作控制器对指令进行译码，同时从寄存器堆中取操作数。·执行/计算地址（EX）：执行运算操作或计算地址。·访存（MEM）：对存储器进行读/写操作。·写回（WB）：将指令执行结果写回寄存器堆。  
把 $k+1$ 条指令的取指阶段提前到第 $k$ 条指令的译码阶段，从而将第 $k+1$ 条指令的译码阶段与第 $k$ 条指令的执行阶段同时进行，如图5.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e4d3b2fd28bf010d15ebe5c04890299db4e9d522cfa5616dd58c870df156a3c.jpg)  
图5.16一个5段指令流水线  

从图5.16看出，理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即CPI）都为1。  

# 命题追踪流水线对指令集的要求（2011）  

为了利于实现指令流水线，指令集应具有如下特征：  

1）指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花的时间长短不一，使得取指部件极其复杂，并且也不利于指令译码。  

2）指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。  

3）采用LOAD/STORE型指令，其他指令都不能访问存储器，这样可把LOAD/STORE指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。  

4）数据和指令在存储器中“按边界对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。  

# 5.6.2流水线的基本实现  

# 1.流水线设计的原则  

在单周期实现中，虽然不是所有指令都必须经历完整的5个阶段，但只能以执行速度最慢的指令作为设计其时钟周期的依据，单周期CPU的时钟频率取决于数据通路中的最长路径。  

# 命题追踪流水线时钟周期的设计（2009）  

流水线设计的原则： $\textcircled{\scriptsize{1}}$ 指令流水段个数以最复杂指令所用的功能段个数为准： $\circledcirc$ 流水段的长度以最复杂的操作所花的时间为准。假设某条指令的5个阶段所花的时间分别如下。 $\textcircled{\scriptsize{1}}$ 取指： $200\mathrm{ps}$ ； $\circledcirc$ 译码： $100\mathrm{ps}$  $\textcircled{3}$ 执行： $150\mathrm{ps}$  $\textcircled{4}$ 访存： $200\mathrm{ps}$ ； $\textcircled{5}$ 写回： $100\mathrm{ps}$ ，该指令的总执行时间为750ps。按照流水线设计原则，每个流水段的长度为 $200\mathrm{ps}$ ，所以每条指令的执行时间为1ns，反而比串行执行时增加了 $250\mathrm{ps}$ 。假设某程序有 $N$ 条指令，单周期处理机所用的时间为 $N{\times}750\mathrm{ps}$ 而流水线处理机所用的时间为 $(N+4){\times}200\mathrm{ps}$ 。由此可见，流水线方式并不能缩短单条指令的执行时间，但对于整个程序来说，执行效率得到了大幅提高。  

# 2.流水线的逻辑结构  

每个流水段后面都要增加一个流水段寄存器，用于锁存本段处理完的所有数据，以保证本段的执行结果能在下个时钟周期给下一流水段使用，如图5.17所示。各种寄存器和数据存储器均采用统一时钟CLK进行同步，每来一个时钟，各段处理完的数据都将锁存到段尾的流水段寄存器中，作为后段的输入。同时，当前段也会收到前段通过流水段寄存器传递过来的数据。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/15dad3e9b41ca386ed07524528163648ddba3b917ff3c224e8e9b044083935c5.jpg)  
图5.17流水线的逻辑结构图  

一条指令会依次进入IF、ID、EX、MEM、WB五个功能段进行处理，第一条指令进入WB段后，各流水段都包含一条不同的指令，流水线中将同时存在5条不同的指令并行执行。  

命题追踪 存在流水段寄存器时延的时钟周期的设计（2018）  

# 注意  

在考试中，若没有明确说明，则可以不用考虑流水寄存器的时延。  

# 3.流水线的时空图表示  

通常用时空图来直观地描述流水线的执行情况，如图5.18所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8f92b2589c2fe4694603f3c9894919d540ed16f5065d6218d79024a19ab46846.jpg)  
图5.18一个5段指令流水线时空图  

在时空图中，横坐标表示时间，它被分割成长度相等的时间段 $T$ ；纵坐标为空间，表示当前指令所处的功能部件。在图5.18中，第一条指令 $\mathrm{I}_{1}$ 在时刻0进入流水线，在时刻5T流出流水线。第二条指令 $\mathrm{I}_{2}$ 在时刻 $T$ 进入流水线，在时刻6T流出流水线。以此类推，每隔一个时间 $T$ 就有一条指令进入流水线，从时刻5T开始每隔一个时间  $T$  就有一条指令流出流水线。  

# 命题追踪流水线执行4条指令所需的时钟周期数（2012）  

从图5.18中可看出，在时刻 $10T$ 时，流水线上便有6条指令流出。若采用串行方式执行，在时刻10T时，只能执行2条指令，可见使用流水线方式成倍地提高了计算机的速度。  

只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而指令的执行正好是连续不断的，非常适合采用流水线技术。对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，对于单个运算是无法提升性能的。  

# 5.6.3流水线的冒险与处理  

# 命题追踪导致流水线阻塞的各种原因（2010）  

在指令流水线中，可能会遇到一些情况使得后续指令无法正确执行而引起流水线阻塞，这利现象称为流水线冒险。根据导致冒险的原因不同分为结构冒险、数据冒险和控制冒险3种。  

不同类型指令在各流水段的操作是不同的，表5.2中列出了几类指令在各流水段中的操作。  
表5.2不同类型指令在各流水段中的操作
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e6ae322ef1d230d3622eda619a0b7d751d40c5ad99cf6bbc3f88c1bdf5ad624.jpg)  

这几类指令将会在下面介绍流水线冲突时涉及。  

# 1.结构冒险  

# 命题追踪解决结构冒险的办法（2016）  

由不同指令在同一时刻争用同一功能部件而形成的冲突，也称资源冲突，即由硬件资源竞争造成的冲突。例如，指令和数据通常都存放在同一存储器中，在第4个时钟周期，第i条LOAD指令进入MEM段时，第 $i+3$ 条指令的F段也要访存取指令，此时会发生访存冲突，为此可在前一条指令访存时，暂停（一个时钟周期）取后一条指令的操作，如表5.3所示。当然，如果第 $i$ 条指令不是LOAD指令，在IMEM段不访存，也就不会发生访存冲突。  

表5.3用暂停后续指令的方法解决访存冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2db4430898a15d3389f6aa6bbb2b0286feb1c27b0fc3560cab05120628e43091.jpg)  

解决结构冲突有以下两种办法：  

1）前一指令访存时，使后一条相关指令（及其后续指令）暂停一个时钟周期。  

2）设置多个独立的部件。例如，对于寄存器访问冲突，可将寄存器的读口和写口独立开来：对于访存冲突，单独设置数据存储器和指令存储器。在现代Cache机制中，L1级Cache通常采用数据Cache和指令Cache分离的方式，从而也就避免了资源冲突的发生。  

# 2.数据冒险  

命题追踪分析指令之间的数据冒险（2012、2014、2016、2019、2023）  

数据冒险也称数据相关。引起数据冒险的原因是，后面指令用到前面指令的结果时，前面指令的结果还没有产生。在以非乱序执行的流水线中，所有数据冒险都是由于前面指令写结果之前，后面指令就需要读取而造成的，这种数据冒险称为写后读（ReadAfterWrite，RAW）冲突。  

# 注意  

在按序执行?的流水线中（统考中通常采用这种方式），只可能出现RAW冲突。  
例如，考虑下列两条指令：  

I1 addR1,R2,R3 I2 sub R4,R1,R5 #（R2）+（R3）→R1

 #（R1)-（R5）→R4 在写后读（RAW）冲突中，指令I2的源操作数是指令I1的目的操作数。正常的读/写顺序是  

由指令IⅡ1先写入R1，再由指令12来读R1。在非流水线中，这种先写后读的顺序是自然维持的。但在流水线中，由于重叠操作，读/写的先后顺序关系发生了变化，如表5.4所示。  

表5.4add和sub指令发生先写后读（RAW）冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/416a1a3afa37aaf5df2546bab8ffd540b1a22415785989ec06871e8242ff2a92.jpg)  

可以采用以下几种办法解决RAW数据冲突。  

（1）延迟执行相关指令  

把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为软件插入空操作“nop”指令和硬件阻塞（stall）两种方法。  

由表5.4可见，在第5个时钟周期，add指令才将运算结果写入Rl，但后继sub指令在第3个时钟周期就要从R1中读数，使先写后读的顺序改变为先读后写，发生了先写后读（RAW）的数据冲突。如果不采取措施，按表5.4的读/写顺序，就会导致结果出错。为此，可以暂停sub指令3个时钟周期，直至前面add指令的结果生成，如表5.5所示。  

表5.5用延迟相关指令的办法来解决RAW冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83b58f5125520e327f2952f138d8b8e3e1c011a0b53539439425dabca2d3aec6.jpg)  

对于11和12的数据相关问题，还可以通过将寄存器的写口和读口分别控制在前、后半个时钟周期内操作，使前半周期写入R1的值在后半周期马上被读出，在一个周期内读/写寄存器不会产生冲突，这样I1的WB段和I2的ID段就可重叠执行，从而只需延迟2个时钟周期。  

# （2）采用转发（旁路）技术  

设置相关转发通路，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而将数据通路中生成的中间数据直接转发到ALU的输入端。如表5.6所示，指令I1在EX段结束时已得到R1的新值，被存放到EX/MEM流水段寄存器中，因此可以直接从该流水段寄存器中取出数据返送到ALU的输入端，这样，在指令I2执行时ALU中用的就是R1的新值。  

表5.6用转发技术来解决RAW冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6e66822789ad2aac996fbfbdb4f43c39d585688d099743e0d47d9ac80812a914.jpg)  

增加转发通路后，相邻两条运算类指令之间、相隔一条的两个运算类指令之间的数据相关带来的数据冒险问题就都能解决了。  
（3）load-use数据冒险的处理  

如果1oad指令与其后紧邻的运算类指令存在数据相关问题，则无法通过转发技术来解决，通常把这种情况称为load-uise数据冒险。对于下列两条指令，由表5.2可知，load指令只有在MEM段结束时才能得到主存中的结果，然后送MEM/WB流水段寄存器，在WB段的前半周期才能存入R2的新值，但随后的add指令在EX阶段就要取R2的值，因此，得到的是旧值。  

I2 load r2,12(r1) #M[（r1)+12]→（r2) I3 add r4,r3,r2 #  $(\mathfrak{r}3)+(\mathfrak{r}2)\to(\mathfrak{r}4)$  

对于load-use数据冒险，最简单的做法是由编译器在add指令之前插入一条nop指令，这样在add指令的EX段就可以从MEM/WB流水段寄存器中取出load指令的最新结果，如表5.7所示。当然，最好的办法是在程序编译时进行优化，通过调整指令顺序以避免出现load-use现象。  

表5.7用延迟加转发技术来解决load-use冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8f74604a1f7296c5efc84ccc1b539219931dc8dd2633e2e187d4d2cf904438d.jpg)  

# 3.控制冒险  

命题追踪分析指令之间的控制冒险（2014、2023）  

指令通常是顺序执行的，但当遇到改变指令执行顺序的情况，例如执行转移或返回指令、发生中断或异常时，会改变PC值，从而造成断流，也称控制冲突。  

对于由转移指令引起的冲突，最简单的处理方法就是推迟后续指令的执行。通常把因流水线阻塞带来的延迟时钟周期数称为延迟损失时间片 $C$ 。在下列指令中，假设R2存放常数N，R1的初值为1，bne指令在EX段通过计算设置条件码，并在MEM段确定是否将PC值更新为转移目的地址，因此仅当bne指令执行到第5个时钟结束时才能将转移目标地址送PC。为此，在数据通路检测到分支指令后，可以在分支指令后插入 $C$ (此处 $C=3$ ）条nop指令，如表5.8所示。  

I1loop:add Rl,Rl, $\#\left(\mathbb{R}\mathbb{1}\right)+\mathbb{1}\!\rightarrow\!\mathbb{R}\mathbb{1}$ I2 bne R1,R2,loop #if(R1)  $!=(\mathbb{R}^{2}$  ）goto loop  

表5.8用插入空操作的办法解决控制冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5d0c7063bc5e9cb5cf392f3925551cca3ebbfb37ad2e468043801a4c994d2fcf.jpg)  

有以下几种办法解决控制冲突：  

1）对于由转移指令引起的冲突，可采用和解决数据冲突相同的软件插入“nop”指令和硬件阻塞（stall）的方法。比如，延迟损失多少时间片，就插入多少条nop指令。  

2）对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。若静态预测的条件总是不满足，则按序继续执行分支指令的后续指令。动态 预测根据程序转移的历史情况，进行动态预测调整，有较高的预测准确率。  

# 注意  

Cache缺失的处理过程也会引起流水线阻塞。  
# 5.6.4 流水线的性能指标  

1.流水线的吞吐率命题追踪  

流水线吞吐率的计算（2013）  

流水线的吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量。流水线吞吐率（TP）的最基本公式为  

$$
\mathrm{TP}\,{=}\,\frac{n}{T_{k}}
$$  

式中， $n$ 是任务数， $T_{k}$ 是处理完 $n$ 个任务所用的总时间。设 $k$ 为流水段的段数， $\Delta t$ 为时钟周期。在输入流水线中的任务连续的理想情况下，一条 $k$ 段流水线能在 $k+n-1$ 个时钟周期内完成 $n$ 个任务。得出流水线的吞吐率为  

$$
\mathrm{TP}=\frac{n}{(k+n-1)\Delta t}
$$  

连续输入的任务数 $n{\rightarrow}\infty$ 时，得到最大吞吐率为 $\mathrm{TP}_{\mathrm{max}}\,{=}1/\Delta t$  

# 2.流水线的加速比  

完成同样一批任务，不使用流水线与使用流水线所用的时间之比。  

流水线加速比（S）的基本公式为  

$$
S=\frac{T_{0}}{T_{k}}
$$  

式中， $T_{0}$ 表示不使用流水线的总时间： $T_{k}$ 表示使用流水线的总时间。一条 $k$ 段流水线完成 $n$ 个任务所需的时间为 $T_{k}=\left(k+n-1\right)\Delta t$ 。顺序执行 $n$ 个任务时，所需的总时间为 $T_{0}=\left\boldsymbol{k n}\,\Delta t\right.$ 。将 $T_{0}$ 和 $T_{k}$ 值代入上式，得出流水线的加速比为  

$$
S=\frac{k n\Delta t}{(k+n-1)\Delta t}\!=\!\frac{k n}{k+n-1}
$$  

连续输入的任务数 $n{\rightarrow}\infty$ 时，得最大加速比为 $S_{\mathrm{max}}\,{=}\,k,$  

# 5.6.5高级流水线技术  

有两种增加指令级并行的策略：一种是多发射技术，它通过采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理机一次可以发射多条指令进入流水线执行：另一种是超流水线技术，它通过增加流水线级数来使更多的指令同时在流水线中重叠执行。  

# 1.超标量流水线技术  

命题追踪  

也称动态多发射技术，每个时钟周期内可并发多条独立指令，以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件，如图5.19所示。在简单的超标量CPU中，指令是按顺序发射执行的。为了更好地提高并行性能，多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种方式称为乱序执行。  

# 2.超长指令字技术  

也称静态多发射技术，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位），为此需要采用多个处理部件。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3fb915064ad6368ced430ed580e5bb36216c80da07ef16f0bb6a2923dd9be00f.jpg)  
图5.19超标量流水线技术  

# 3.超流水线技术  

如图5.20所示，流水线功能段划分得越多，时钟周期就越短，指令吞吐率也就越高，因此超流水线技术是通过提高流水线主频的方式来提升流水线性能的。但是，流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/742aac8f955fdb4c6ca794363252545db1e5f37ff8e48bc846bf71986d0fa0d6.jpg)  
图5.20超流水线技术  

# 命题追踪基本流水线CPU和超标量流水线CPU的CPI（2020）  

超流水线CPU在流水线充满后，每个时钟周期还是执行一条指令， ${\mathrm{CPI}}=1$ ，但其主频更高：多发射流水线CPU每个时钟周期可以处理多条指令， $\mathrm{CPI}\!<\!1$ ，但其成本更高、控制更复杂。  

# 5.6.6 本节习题精选  

# 一、单项选择题  

01.下列关于流水CPU基本概念的描述中，正确的是（）  

A.流水CPU是以空间并行性为原理构造的处理器B.CPU RISCC.流水CPU一定是多媒体CPU D.流水CPU是一种非常经济而实用的时间并行技术  

02.流水CPU是由一系列称为“段”的处理电路组成的。一个 $m$ 段流水线稳定时的CPU的吞吐能力，与 $m$ 个并行部件的CPU的吞吐能力相比，（）。  

A.具有同等水平的吞吐能力B.不具备同等水平的吞吐能力C.吞吐能力大于前者的吞吐能力D.吞吐能力小于前者的吞吐能力  

03.设指令由取指、分析、执行3个子部件完成，并且每个子部件的时间均为 $\Delta t$ ，若采用常规标量单流水线处理机（即处理机的度为1），连续执行12条指令，共需（）  

A.  $12\,\Delta t$  B.14t C.  $16\,\Delta t$  D.  $18\,\Delta t$  

04.设指令由取指、分析、执行3个子部件完成，并且每个子部件的时间均为 $\Delta t$ ，若采用度为4的超标量流水线处理机，连续执行20条指令，只需（）。  
A.  $3\,\Delta t$  B.  $5\,\Delta t$  C.  $7\,\Delta t$  D.9△t  

05.设指令流水线把一条指令分为取指、分析、执行3部分，3部分执行时间不等长，且3部分的时间分别是 $t_{\scriptscriptstyle{\mathrm{R}}\bar{u}}=2{\mathrm{ns}},~~t_{\scriptscriptstyle{\mathrm{R}}\bar{u}}=2{\mathrm{ns}},~~t_{\scriptscriptstyle{\mathrm{R}}\bar{u}}=1{\mathrm{ns}},$ 则100条指令全部执行完毕需（）。  

A.163ns B.  $183\mathrm{ns}$  C.193ns D. 203ns

 06.下列关于指令流水线设计的叙述中，错误的是（）  

A.指令执行过程中的各个子功能都需要包含在某个流水段中B.所有子功能都必须按一定的顺序经过流水段C.虽然各子功能所用实际时间可能不同，但经过每个流水段的时间都一样D.任何时候各个流水段的功能部件都不可能执行空操作  

07.下列关于流水段寄存器的叙述中，正确的是（）。  

A.指令译码得到的控制信号需通过流水段寄存器传递到下一个流水段B.每个流水段之间的流水段寄存器位数一定相同 C.每个流水段之间的流水段寄存器存放的信息一定相同D.用户程序可以通过指令指定访问哪个流水段寄存器  

08.下列关于流水线数据通路的描述中，错误的是（）  

A.每个流水段由执行指令子功能的功能部件和流水段寄存器组成B.控制信号仅作用在功能部件上，时钟信号仅作用在流水段寄存器上C.在没有阻塞的情况下，PC的值在每个时钟周期都会改变D.取指令阶段和指令译码阶段不需要控制信号的控制  

09.下列关于结构冒险的叙述中，正确的是（）。  

I.结构冒险是指同时有多条指令使用同一个资源II.避免结构冒险的基本做法是使每个指令在相同流水段中使用相同的部件IⅢI.重复设置功能部件可以避免结构冒险IV.数据Cache和指令Cache分离可解决两条指令同时分别取数据和取指令的冒险  

A.I、ⅡI、IVB.I、II、IⅢIC.I、III、IVD.I、ⅡI、ⅢI和IV

10.指令流水线中出现数据相关时流水线将受阻，（）可解决数据相关问题。  

A.增加硬件资源B.采用旁路技术C.采用分支预测技术D.以上都可以  

11.下列关于数据冒险和转发技术的叙述中，正确的是（）  

1.并非所有数据冒险都能通过转发技术解决IL.五段流水线中load-use数据冒险会引起至少一个时钟周期的阻塞III.前面的分支指令和后面的ALU运算指令之间肯定不会发生数据冒险  

A.I、IⅡIB.I、IⅢIC.II、IⅢID.I、II、IⅢI

12.下列关于数据冒险的叙述中，正确的是（）  

1.数据冒险是指后面指令用到的数据还未来得及由前面的指令产生IIL.在发生数据冒险的指令之间插入空操作指令能避免数据冒险IⅢI.采用转发（旁路）技术可以解决一部分数据冒险现象IV.通过编译器调整指令顺序可解决部分数据冒险  

A.I、ⅡI、IVB.I、ⅡI、IⅢIC.I、III、IVD.I、ⅡI、Ⅲ和IV  

13.下列指令序列中，指令11和13、12和13之间发生数据相关。假定采用“取指、译码/取数、执行、访存、写回”五段流水线方式，那么在采用转发技术时，需要在指令I3之前加入（）条空操作指令才能使这段程序不发生数据冒险。  
I1:add rl,r0,1  $\#\left(\mathrm{r}1\right)\gets\left(\mathrm{r}0\right)+1$  12:loadr3,12（r2)  $\#\left(\mathrm{r}3\right)\leftarrow\mathbf{M}[\left(\mathrm{r}2\right)+12]$  13:add r5,r3,r1  $\#\left(\mathrm{r}5\right)\gets\left(\mathrm{r}3\right)+\left(\mathrm{r}1\right)$  

A.3 B.2 C.0 D.1

 14.下面有关控制冒险的描述中，错误的是（）  

1.无条件转移指令不会发生控制冒险II.在分支指令加入若干空操作可以避免控制冒险III.采用转发（旁路）技术，可以解决部分控制冒险IV.流水段的数量与控制冒险引发的开销无关  

A.I、IVB.IIIC.I、IIID.I、I、IV

15.下列关于分支预测的叙述中，正确的是（）  

1.分支预测技术可用于处理控制冒险和数据冒险II1.使用静态预测技术时，每次的预测结果是一样的III.动态预测技术通常比静态预测技术的预测成功率高IV.若预测错误，已被错误放入流水线执行的指令必须被舍弃  

A.I、ⅡI、IIIB.I、II、IVC.II、III、IVD.I、II、III、IV

16.下列关于指令流水线和指令执行效率的叙述中，错误的是（）  

A.加倍增加流水段个数不能成倍提高指令执行效率B.为了提高指令吞吐率，流水段个数应无限制地增加C.增加流水段个数，可以提高处理器的时钟频率D.随着流水段个数的增加，流水段之间缓存开销的比例增大  

17.设指令由取指、分析、执行三个子部件完成，并且每个子部件的时间均为1，若采用常规标量单流水线处理机，连续执行8条指令，则该流水线的加速比为（）  

A.3 B.2 C.3.4 D.2.4

 18.下列关于超标量流水线的描述中，不正确的是（）。  

A.在一个时钟周期内一条流水线可执行一条以上的指令B.一条指令分为多段指令由不同电路单元完成C.超标量通过内置多条流水线来同时执行多个处理器，其实质是以空间换取时间D.超标量流水线仅仅是指运算操作并行  

19.关于流水线技术的说法中，错误的是（）  

A.超标量技术需要配置多个功能部件和指令译码电路等B.与超标量技术和超流水线技术相比，超长指令字技术对优化编译器要求更高，而无其他硬件要求C.在按序流动的流水线中，只可能出现RAW相关D.超流水线技术相当于将流水线再分段，从而提高每个周期内功能部件的使用次数  

20.【2009统考真题】某计算机的指令流水线由4个功能段组成，指令流经各功能段的时间（忽略各功能段之间的缓存时间）分别为90ns、80ns、70ns和60ns，则该计算机的CPU周期至少是（）。  

A.90ns B.80ns C.70ns D.60ns  

21.【2010统考真题】下列不会引起指令流水线阻塞的是（）A.数据旁路B.数据相关C.条件转移D.资源冲突  
22.【2011统考真题】下列指令系统的特点中，有利于实现指令流水线的是（）  

I.指令格式规整且长度一致 11.指令和数据按边界对齐存放 III.只有LOAD/STORE指令才能对操作数进行存储访问  

A.仅I、IIB.仅II、IIIC.仅I、IⅢID.I、II、ⅢI  

23.【2013统考真题】某CPU主频为  $1.03\mathrm{GHz}$  ，采用4级指令流水线，每个流水段的执行需 要1个时钟周期。假定CPU执行了100条指令，在其执行过程中，没有发生任何流水线阻塞，此时流水线的吞吐率为（）。  

A. $0.25\!\times\!10^{9}$ 条指令/秒B. $0.\;97\!\times\!10^{9}$ 条指令/秒C. $1.0\!\times\!10^{9}$ 条指令/秒D. $1.03\!\times\!10^{9}$ 条指令/秒  

24.【2014统考真题】采用指令Cache与数据Cache分离的主要目的是（）  

A.降低Cache的缺失损失B.提高Cache的命中率C.降低CPU平均访存时间D.减少指令流水线资源冲突  

25.【2016统考真题】在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令序列存在数据冒险的指令对是（）。  

I1:addR1,R2,R3； $(\mathrm{R}2)+(\mathrm{R}3){\rightarrow}\mathrm{R}1$ 12:add R5,R2,R4;  $(\mathrm{R}2)+(\mathrm{R}4){\rightarrow}\mathrm{R}5$  13:addR4,R5,R3； $(\mathrm{R}5)+(\mathrm{R}3){\rightarrow}\mathrm{R}4$ 14:add R5,R2,R6;  $(\mathrm{R}2)+(\mathrm{R}6){\rightarrow}\mathrm{R}5$  

A.11和12 B.12和13 C.12和14 D.13和14  

26.【2017统考真题】下列关于超标量流水线特性的叙述中，正确的是（）  

I.能缩短流水线功能段的处理时间IIL.能在一个时钟周期内同时发射多条指令IIl.能结合动态调度技术提高指令执行并行性  

A.仅ⅡIB.仅I、1IIC.仅II、ⅢID.I、II和IⅢI

27.【2017统考真题】下列关于指令流水线数据通路的叙述中，错误的是（）  

A.包含生成控制信号的控制部件B.包含算术逻辑运算部件（ALU）C.包含通用寄存器组和取指部件D.由组合逻辑电路和时序逻辑电路组合而成  

28.【2018统考真题】若某计算机最复杂指令的执行需要完成5个子功能，分别由功能部件A\~E实现，各功能部件所需时间分别为 $80\mathrm{ps}$ 、50ps、50ps、70ps和 $50\mathrm{ps}$ ，采用流水线方式执行指令，流水段寄存器延时为 $20\mathrm{ps}$ ，则CPU时钟周期至少为（）。  

A.60ps B.70ps C.80ps D.100ps  

29.【2019统考真题】在采用“取指、译码/取数、执行、访存、写回”5段流水线的处理器中，执行如下指令序列，其中s0、s1、s2、S3和t2表示寄存器编号。  

11:add s2,sl,s0  $//\mathrm{R}[\mathrm{s}2]\gets\mathrm{R}[\mathrm{s}1]+\mathrm{R}[\mathrm{s}0]$  12:load s3,0（t2)  $//\mathrm{R}[\mathrm{s}3]\gets\mathrm{M}[\mathrm{R}[\mathsf{t}2]+0]$  13:add s2,s2,s3  $//\mathrm{R}[\mathrm{s}2]\gets\mathrm{R}[\mathrm{s}2]+\mathrm{R}[\mathrm{s}3]$  I4:store s2,0（t2)  $//\mathbf{M}[\mathbf{R}[\mathbf{t}2]+0]\leftarrow\mathbf{R}[\mathbf{s}2]$  

下列指令对中，不存在数据冒险的是（）A.11和13 B.12和13 C.12和14 D.I3和I4  
30.【2020统考真题】下列给出的处理器类型中，理想情况下，CPI为1的是（）。I.单周期CPUII.多周期CPUIII.基本流水线CPUIV.超标量流水线CPU A.仅I、IIB.仅I、IIIC.仅II、IVD.仅III、IV  

31.【2023统考真题】在采用“取指、译码/取数、执行、访存、写回”5段流水线的RISC 处理器中，执行如下指令序列（第一列为指令序号），其中s0、s1、s2、s3和t2表示寄存器编号。  

11 add s2,s1,s0 //R[s2]R[s1]+R[s0] 12 load s3,0(s2)  $//\operatorname{R}[\mathrm{s}3]{\leftarrow}\mathbf{M}[\operatorname{R}[\mathrm{s}2]+0]$  13beqt2,s3,L1//ifR[t2] $=$ R[s3]jumptoL114 addi t2,t2,20 //R[t2]←R[t2]+20 15 L1:  

若采用转发（旁路）技术处理数据冒险，采用硬件阻塞方式处理控制冒险，则在指令 $\mathrm{II}$ I4的执行过程中，发生流水线阻塞的指令有（）  

A.仅13B.仅12、14C.仅13、14D.仅12、I3、14  

# 二、综合应用题  

01.现有四级流水线，分别完成取指令、指令译码并取数、运算、回写四步操作，假设完成各部操作的时间依次为 $100\mathrm{ns}$ 100ns、80ns和50ns。试问：  

1）流水线的操作周期应设计为多少？2）若相邻两条指令如下，发生数据相关（假设在硬件上不采取措施），试分析第二条指令要推迟多少时间进行才不会出错。  

ADDR1,R2，R3 #  $\mathtt{R2+R3\ ->\ R1}$  SUBR4,R1,R5 #R1-R5->R4  

3）若在硬件设计上加以改进，至少需要推迟多少时间？  

02.假设指令流水线分为取指（IF）译码（ID）、执行（EX）、回写（WB）4个过程，共有10条指令连续输入此流水线。  

1）画出指令周期流程图。2）画出非流水线时空图。3）画出流水线时空图。4）假设时钟周期为 $100\mathrm{ns}$ ，求流水线的实际吞吐量（单位时间执行完毕的指令数）。  

03.【2012统考真题】某16位计算机中，有符号整数用补码表示，数据Cache和指令Cache分离。下表给出了指令系统中的部分指令格式，其中Rs和Rd表示寄存器，mem表示存储单元地址，（x）表示寄存器x或存储单元 $_\mathrm{x}$ 的内容。  

表指令系统中部分指令格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fcad1d125adab234a88307ed73a19254b671038099c580f47988742f69fb393.jpg)  
该计算机采用5段流水方式执行指令，各流水段分别是取指（IF）、译码/读寄存器（ID）执行/计算有效地址（EX）、访问存储器（M）和结果写回寄存器（WB），流水线采用“按序发射，按序完成”方式，未采用转发技术处理数据相关，且同一寄存器的读和写操作不能在同一个时钟周期内进行。请回答下列问题：  

1）若int型变量x的值为-513，存放在寄存器R1中，则执行“SHRR1”后，R1中的内容是多少（用十六进制表示）？  

2）若在某个时间段中，有连续的4条指令进入流水线，在其执行过程中未发生任何阻塞，则执行这4条指令所需的时钟周期数为多少？  

3）若高级语言程序中某赋值语句为 $\mathbf{\Deltax}=\mathbf{a}+\mathbf{b}$ ，x、a和b均为int型变量，它们的存储单元地址分别表示为[x]、[a和[b]。该语句对应的指令序列及其在指令流中的执行过程如下所示。  

I1 LOAD R1, [a] I2LOADR2,[b]I3 ADD R1,R2 I4 STORE R2,[x]  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/df6e9e54a98c0d8a38e8c7d518026d1613b3bdac376ff5efdd4d2f150c7561cd.jpg)  

则这4条指令执行过程中I3的ID段和I4的IF段被阻塞的原因各是什么？  

4）若高级语言程序中某赋值语句为  $\mathrm{x}=\mathrm{x}^{*}2+\mathrm{a}$  ，x a unsigned in t，它 们的存储单元地址分别表示为[x]、[a]，则执行这条语句至少需要多少个时钟周期？要求模仿上图画出这条语句对应的指令序列及其在流水线中的执行过程示意图。  

04.【2014统考真题】某程序中有循环代码段P：“for(int  $\mathrm{i}=0$   $\mathrm{~i~}\!<\!\mathbf{N}$   $\mathrm{i}{\mathrel{+{+}}}$   $\mathrm{sum+=}$  A[j];”。假 设编译时变量sum和i分别分配在寄存器R1和R2中。常量 $_\mathrm{N}$ 在寄存器R6中，数组A的首地址在寄存器R3中。程序段P的起始地址为 $0804~8100\mathrm{H}$ ，对应的汇编代码和机器代码如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d357049d27b1dc424c355dea800fa3096ae858ad413f0407d90400072213b381.jpg)  

执行上述代码的计算机M采用32位定长指令字，其中分支指令bne采用如下格式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b0da18a7dd0ee480a11f4843f3267e356343a20cc74436def6dc4848b324e1b.jpg)  

OP为操作码；Rs和Rd为寄存器编号；OFFSET为偏移量，用补码表示。请回答下列问题，并说明理由。  
1）M的存储器编址单位是什么？  

2）已知sll指令实现左移功能，数组A中每个元素占多少位？  

3）表中bne指令的OFFSET字段的值是多少？已知bne指令采用相对寻址方式，当前PC内容为bne指令地址，通过分析表中指令地址和bne指令内容，推断bne指令的转移目标地址计算公式。  

4）若M采用如下“按序发射、按序完成”的5级指令流水线：IF（取值）、ID（译码及取数）、EXE（执行）、MEM（访存）、WB（写回寄存器），且硬件不采取任何转发措施，分支指令的执行均引起3个时钟周期的阻塞，则 $\mathrm{P}$ 中哪些指令的执行会由于数据相关而发生流水线阻塞？哪条指令的执行会发生控制冒险？为什么指令1的执行不会因为与指令5的数据相关而发生阻塞？  

05.【2014统考真题】假设对于上题中的计算机M和程序 $\mathrm{P}$ 的机器代码，M采用页式虚拟存储管理；P开始执行时， $(\mathrm{R}1)=(\mathrm{R}2)=0,\;\;(\mathrm{R}6)=1000$ ，其机器代码已调入主存但不在  

Cache中；数组A未调入主存，且所有数组元素在同一页，并存储在磁盘的同一个扇区。请回答下列问题并说明理由。1）P执行结束时，R2的内容是多少？2）M的指令Cache和数据Cache分离。若指令Cache共有16行，Cache和主存交换的块大小为32B，则其数据区的容量是多少？若仅考虑程序段P的执行，则指令Cache的命中率为多少？3)P在执行过程中，哪条指令的执行可能发生溢出异常？哪条指令的执行可能产生缺页异常？对于数组A的访问，需要读磁盘和TLB至少各多少次？  

# 5.6.7 答案与解析  

# 一、单项选择题  

01.D  

空间并行即资源重复，主要指多个功能部件共同执行同一任务的不同部分，典型的如多处理机系统。时间并行即时间重叠，让多个功能部件在时间上相互错开，轮流重叠执行不同任务的相同部分，因此流水CPU利用的是时间并行性，A错误。RISC都采用流水线技术，以提高资源利用率。但反过来并不成立，因为大部分CISC同样采用了流水线技术，B错误。流水CPU和多媒体CPU无必然联系，多媒体CPU是指能够处理多种媒体数据（如图像、音频、视频等）的CPU，它通常具有特殊的指令集和功能部件，与流水CPU的概念不同，C错误。  

02. A  

吞吐能力是指单位时间内完成的指令数。 $m$ 段流水线在第 $m$ 个时钟周期后，每个时钟周期都可以完成一条指令；而 $m$ 个并行部件在 $m$ 个时钟周期后能完成全部的 $m$ 条指令，等价于平均每个时钟周期完成一条指令。因此两者的吞吐能力等同。  

03.B 单流水线处理机执行12条指令的时间为 $3+(12-1))\Delta t=14\Delta t_{\odot}$  

04.C 这个超标量流水线处理机可以发送4条指令，所以执行指令的时间为 $3+(20-4)/4)\Delta t=7\Delta t$  

05.D 每个功能段的时间设定为取指、分析和执行部分的最长时间2ns，第一条指令在第5ns时执行完毕，其余的99条指令每隔2ns执行完一条，所以100条指令全部执行完毕所需的时间为 $(5+99{\times}2)\mathrm{ns}=203\mathrm{ns}$  
06.D  

指令执行过程中的各个子功能都需要包含在某个流水段中，每条指令都会依次进入所有流水段进行处理。不同指令的复杂度不同，所需的功能段不同，但为了保证指令流水线正常运行，流水段个数以最复杂指令所用的功能段个数为准，流水段长度以最复杂的操作所花的时间为准。因此，其他指令可以通过加入“空操作”功能段向最复杂的指令靠齐，  

07.A  

在某个时钟周期内，不同的流水段受不同指令的控制信号控制，执行不同指令的不同功能段，在指令译码阶段由控制器产生指令各流水段的所有控制信号，分别在随后的各个时钟周期内被使用，因此随后各流水段寄存器都要保存相应的控制信号，并通过流水段寄存器传递到下一个流水段，A正确。不同流水段寄存器存放的信息不同，因此流水段寄存器位数不一定相同，流水段寄存器对用户程序是透明的，用户程序不能通过指令指定访问哪个流水段寄存器。  

# 08.B  

在流水线数据通路中，时钟信号不仅作用在流水段寄存器上，还要作用在PC、各类寄存器、存储器等状态元件上。每条指令的取指令阶段和指令译码阶段的功能都相同，是公共流水段，且控制信号是指令译码之后才产生的，因此这两个阶段不需要控制信号。  

# 09.D  

解决结构冒险的策略有两个方面（袁春风老师所撰教材中的结论）： $\textcircled{\scriptsize{1}}$ 一个部件每条指令只能使用一次，且只能在特定阶段使用，可以避免一部分结构冒险； $\circledcirc$ 通过设置多个独立的部件来避免硬件资源冲突，例如可将寄存器的读口和写口分开，以及将指令Cache和数据Cache分离等。因此，四个说法都正确。  

10.B  

处理数据相关问题有两种方法：一种是暂停相关指令的执行，即暂停流水线，直到能够正确读出寄存器操作数为止；另一种是采用专门的数据通路，直接把结果送到ALU的输入端，这种方法称为旁路技术。  

11.A  

部分数据冒险可以通过转发技术解决，但有些数据冒险不行，例如load-uise类型的数据冒险（当下一条指令需要用到本条指令的访存结果时）。load-use类型的数据冒险会引起一个或多个时钟周期的阻塞，需要添加空操作指令解决。若ALU运算指令的某个操作数是分支指令转移后的执行结果，就会发生数据冒险。例如，分支指令“sltrl,r2,r3”，其含义是如果(r2) $\mathrm{<}(\mathrm{r}3)$ ，则 $r1=1$ ；否则 $\mathrm{r}\mathrm{l}=0$ 。如果紧挨着一条ALU运算指令要用到 $_{\mathrm{r1}}$ 的值，就会发生数据冒险。  

12.D  

插入空操作指令，使相关指令延迟执行，可以避免数据冒险。采用转发技术，将数据通路中生成的中间数据直接转发到ALU的输入端，可以解决部分数据冒险，但不能解决load-use类型的数据冒险。通过编译器调整相关指令的顺序，也可以解决部分数据冒险。  

13.D  

转发技术可以解决部分数据冒险，但不能解决load-uise类型的数据冒险。分析上述指令序列，指令I1在EX段结束时已得到r1的新值，采用转发技术后，指令I3在ALU中用到的r1值可以直接从EX/MEM流水段寄存器中取，可以解决指令I1和I3的数据冒险。指令I2和I3是load-use类型的数据冒险，load指令只在MEM段结束时才能取到主存中的数据，然后送MEM/WB流水段寄存器，在WB段的前半个周期才能将新值写入r3，但随后的add指令在EX阶段就要取r3的值，因此会发生数据冒险。需要在add指令之前插入一条空操作指令，这样在add指令的EX段就可从MEM/WB流水段寄存器中取出load指令的最新结果。  
14.D  

直接转移指令的转移目标地址在执行阶段才确定，会发生控制冒险，I错误。插入空操作可使条件转移指令的结果在取下一条有效指令之前确定，从而避免控制冒险，Ⅱ正确。采用转发技术，可以解决的是数据相关，IⅢ错误。流水段的数量越多，意味着在转移结果确定之前，可能取出更多的错误指令，从而需要更多的时间和资源来处理这些错误指令，V错误。  

15. C  

分支预测技术用于处理控制冒险。静态预测技术假定分支总是不发生或者总是发生，每次预测结果是一样的。动态预测技术根据之前条件跳转的比较结果来预测，根据局部性原理，其预测成功率通常比静态预测技术高。预测错误时，已被错误放入流水线执行的指令必须被舍弃。  

16.B  

适当增加流水段的个数，会使得每个流水段内的操作更简单，流水段的延迟更小，缩短了时钟周期，从而可以提高时钟频率。但是，流水段之间的流水段寄存器也随之增多，增加了流水段之间的额外缓存开销，因此加倍增加流水段个数不能成倍提高指令执行效率，且流水段个数也不能无限制地增加。此外，随着流水段个数的增加，也将导致流水段的控制逻辑更复杂。  

17.D  

采用流水线时，第一条指令完成的时间是31，以后每经过7都有一条指令完成，因此共需要的时间为 $3t+(8-1)t=10t$ ：而不采用流水线时，完成8条指令总共需要的时间为 $8{\times}3t=24t$ ，所以流水线的加速比 $=24t\div10t=2.4$  

18.D  

超标量流水线不仅指运算操作并行，还包括取指、译码、访存、写回等其他操作，超标量技术使CPU在同一时间内执行多条指令，从而发挥更大的效率，D错误。  

19.B  

要实现超标量技术，要求CPU中配置多个功能部件和指令译码电路，以及多个寄存器和总线，以便实现同时执行多个操作，A正确。超长指令字技术不仅对优化编译器要求更高，还需要更多的硬件资源，如寄存器、功能部件、指令译码电路等，B错误。流水线按序流动，肯定不会出现先读后写（WAR）相关和写后写（WAW）相关：只可能出现没等到上一条指令写入而当前指令就读寄存器的错误，C正确。由超流水线技术的定义可知D正确。  

20.A  

时钟周期应以各功能段的最长执行时间为准，否则用时长的流水段将不能正确完成。  

21.A  

采用流水线方式，相邻或相近的两条指令可能会因为存在某种关联，后一条指令不能按照原指定的时钟周期运行，从而使流水线断流。有三种相关可能引起指令流水线阻塞： $\textcircled{\scriptsize{1}}$ 结构相关，也称资源相关： $\circledcirc$ 数据相关： $\textcircled{3}$ 控制相关，主要由转移指令引起。  

数据旁路技术的主要思想是，不必等某条指令的执行结果送回到寄存器，再从寄存器中取出该结果，而是直接将执行结果送到其他指令所需的地方，这样可以使流水线不发生停顿。  

22.D  

指令长度一致、按边界对齐存放、仅LOAD/STORE指令访存，这些都是RISC的特征，它 们使取指令、取操作数的操作简化且时间长度固定，能够有效地简化流水线的复杂度。  
23.C  

采用4级流水执行100条指令，在执行过程中共使用 $4+(100-1)=103$ 个时钟周期，如下图所示。CPU的主频是1.03GHz，即每秒有1.03G个时钟周期。流水线的吞吐率为 $1.03\mathrm{G}{\times}100/103\ =$  $1.0\!\times\!10^{9}$ 条指令/秒。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5f7d23fc43f50b4523b95ffba5c416fc29cebea594dfc08c6977dc35b4c88d25.jpg)  

24.D  

把指令Cache与数据Cache分离后，取指和取数分别到不同的Cache中寻找，则指令流水线中取指部分和取数部分就可以很好地避免冲突，即减少了指令流水线的冲突。  

# 25. B  

数据冒险即数据相关，指在一个程序中存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令即为数据相关。当多条指令重叠处理时就会发生冲突。首先这两条指令发生写后读相关，且两条指令在流水线中的执行情况（发生数据冒险）如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a815d58e35bb3ee654053284fc56c112322228f415a7d6aa0399a7bd7acd6b4b.jpg)  

指令I2在时钟5时将结果写入寄存器R5，但指令13在时钟3时读R5。本来指令I2应先写入R5，指令I3后读R5，结果变成指令I3先读R5，指令I2后写入R5，因而发生数据冲突。  

# 26.C  

超标量是指在CPU中有一条以上的流水线，并且每个时钟周期内可以完成一条以上的指令，其实质是以空间换时间。I错误，它不影响流水线功能段的处理时间；ⅡI、ⅢI正确。  

# 27.A  

数据在功能部件之间传送的路径称为数据通路，包括数据通路上流经的部件，如程序计数器、ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号。因此，不包括控制部件。  

# 28.D  

指令流水线中每个流水段的时间单位为一个时钟周期，题中指令流水线的指令需要用到 $\mathbf{A}\!\sim$ E五个部件，所以每个流水段时间应取最大部件时间 $80\mathrm{ps}$ ，此外还有流水段寄存器延时 $20\mathrm{ps}$ ，龙因此CPU时钟周期至少是 $100\mathrm{ps}$  

# 29. C  

画出这四条指令在流水线中执行的过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5038ada6677f2f712eb15c275af65f5d4e8cab52f5ecedfd4e67b4a6433d8318.jpg)  
数据冒险即数据相关，指在程序中存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令即为数据相关。其中11和13、I2和13、13和14均发生了写后读相关，因此必须等相关的前一条指令执行完才能执行后一条指令。只有12和14不存在数据冒险。  

30.B  

CPI表示执行指令所需的时钟周期数。对于一个程序或一台机器来说，其CPI是指执行该程序或机器指令集中的所有指令所需的平均时钟周期数。对于单周期CPU，令指令周期 $=$ 时钟周期， ${\mathrm{CPI}}=1$ ，I正确。对于多周期CPU，CPU的执行过程分成几个阶段，每个阶段用一个时钟完成，每种指令所用的时钟数可以不同， $\mathrm{CPI}>1$ ，ⅡI错误。对于基本流水线CPU，让每个时钟周期流出一条指令，  $\mathrm{CPI}=1$  ，IⅢI正确。超标量流水线CPU在每个时钟周期内并发执行多条独立的指 令，每个时钟周期流出多条指令， $\mathrm{CPI}<1$ ，IV错误。  

31.C  

I2和I1之间存在数据冒险，I1在WB段才将新值写回寄存器R[s2]，但I2的Ex段就要读R[s2]以计算访存的有效地址，I1在EX段结束时就已生成R[s2]的新值，被存放在Ex/Mem流水段寄存器中，采用转发技术后，可直接从该寄存器中取出数据送到ALU的输入端，这样12执行时ALU用的是R[s2]的新值，解决了I2和I1之间的数据冒险。I3和I2之间存在数据冒险，属于load-use数据冒险，用转发电路无法解决I3和12的数据相关问题，原因在于I2的功能是从内存中取数，只有在Mem段结束时才能从主存中得到R[s3]的新值，但I3的EX段就要用到R[s3]，因此无法用转发技术解决，I3仍需阻塞一个时钟周期，等到I2的Mem段结束后，从I12的 $\mathrm{{Mem/Wb}}$ 流水段寄存器中取到R[s3]的新值。I4和I3之间存在控制冒险，beq指令在Ex段设置条件码，在Mem段控制是否将转移地址送到PC，这之后才能开始根据PC内容取指令，因此I4需要进行硬件阻塞。综上所述，13和14的执行需要被阻塞，指令的执行过程如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e3bde2f46c09a966aaa57a60228ed8b12f94ff74d3be9e18c85c15541a7fe7a0.jpg)  

# 二、综合应用题  

# 01.【解答】  

1）流水线操作的时钟周期 $T$ 应按四步操作中的最长时间来考虑，所以 $T\,{=}\,100\,\mathrm{ns}$  

2）分析如下：  

首先该两条指令发生写后读相关，且两条指令在流水线中的执行情况如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ebda786ba7456b49dbba6537db19fff46ef29baecfa0b9d6befa9cfef718cbdb.jpg)  

ADD指令在时钟4时将结果写入寄存器堆（R1），但SUB指令在时钟3时读寄存器堆（R1）。本来ADD指令应先写入R1，SUB指令后读R1，结果变成SUB指令先读R1，ADD指令后写入R1，因而发生数据冲突。若硬件上不采取措施，第二条指令SUB至少应推迟两个时钟周期 $(2\!\times\!100{\mathrm{ns}})$ ，即SUB指令中的指令译码并取数周期应在ADD指令的写回周期之后才能保证不会出错，如下表所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/486ed00cd5ca8749447c319f82cc6ebde5c6a027a32997c18e0548efeb436d4f.jpg)  

3）若在硬件上加以改进，可以不用任何延迟。因为在ADD指令中，运算周期已得到结果。可以通过数据旁路技术得到运算结果后，就将结果送入ALU的一端，而不需要等到写回周期完成。流水线中的执行情况如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0d82b825ad3018858209add2e9e827c4518ac5791176835b562bcde89d5e1070.jpg)  

# 02.【解答】  

1）因为指令周期包括F、ID、EX、WB四个子过程，因此其指令周期流程图如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05fd87316bcf2197dc53408d55c68e6b0c0d4eff0735c18cdecc155298f72df5.jpg)  

2）假设一个时间单位为一个时钟周期，则每隔4个周期才有一个输出结果。非流水线的时空图如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76898bbfd9acf45755451f6d9bd47930edd2285fff20e8298586ef0b8f98368c.jpg)  

3）第一条指令出结果需要4条指令周期。流水线满载时，以后每个时钟周期都可输出一个结果，即执行完一条指令，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4d59c86a7cb620089ab9da623509701244a8247c8d31f76a3120d3d584b5f0ff.jpg)  

4）由上图可知，在13个时钟周期结束时，CPU执行完10条指令，因此实际吞吐率（T）为  

$$
T=\frac{10}{100\mathrm{ns}\times13}\approx7700000
$$  

# 03.【解答】  

1）x的机器码为 $[\mathrm{x}]_{\#}=1111\ 1101\ 1111\ 1111\mathrm{B}$ ，即指令执行前 $\left(\mathrm{R1}\right)=$ FDFFH，右移1位后为1111111011111111B，即指令执行后 $\left(\mathrm{R1}\right)=$ FEFFH。  

2）每个时钟周期只能有一条指令进入流水线，从第5个时钟周期开始，每个时钟周期都会有一条指令执行完毕，因此至少需要 $4+(5-1)=8$ 个时钟周期。  

3) $\mathrm{I}_{3}$ 的ID段被阻塞的原因：因为 $\mathrm{I}_{3}$ 与 $\mathrm{I}_{1}$ 和 $\mathrm{I}_{2}$ 都存在数据相关，需等到 $\mathrm{I}_{1}$ 和 $\mathrm{I}_{2}$ 将结果写回寄  
存器后， $\mathrm{I}_{3}$ 才能读寄存器内容，所以 $\mathrm{I}_{3}$ 的ID段被阻塞。 $\mathrm{I}_{4}$ 的IF段被阻塞的原因：因为 $\mathrm{I}_{4}$ 的前一条指令 $\mathrm{I}_{3}$ 在ID段被阻塞，所以 $\mathrm{I}_{4}$ 的IF段被阻塞。若 $\mathrm{I}_{4}$ 的IF段不被阻塞，则会覆盖指令寄存器的内容，导致 $\mathrm{I}_{3}$ 段的译码结果出错。  

注意：要求“按序发射，按序完成”，因此，第二问中下一条指令的IF可以和上一条指令的ID并行，以免因上一条指令发生冲突而导致下一条指令先执行完。  

4）因 $2^{*}\mathbf{x}$ 操作有左移和加法两种实现方法，因此 $\mathrm{{x}=\mathrm{{x}^{*}2+\mathrm{{a}}}}$ 对应的指令序列为  

I1 LOAD R1，[x] I2 LOAD R2，[a] I3 SHL R1 //或者 ADD R1,R1 I4 ADD R1，R2 I5 STORE R2,[x]  

这5条指令在流水线中执行过程如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/79f6b80cf8403ade469778ee2fbdb49cb53081ee0a6bc6cd74344e0f133c65ba.jpg)  

因此执行 $\mathrm{x}=\mathrm{x}^{*}2+\mathrm{a}$ 语句最少需要17个时钟周期。  

# 04.【解答】  

该题为计算机组成原理的综合题型，涉及指令系统、存储管理和CPU三部分内容，特别是五段式流水线应引起考生的高度重视。整个指令执行过程中各流水段的时间是相同的，由统一的时钟控制。各流水段在5.6.1节中介绍过，这里讨论流水段发生阻塞的情况：  

$\textcircled{\scriptsize{1}}$ 若本条指令的源寄存器是上一条指令的目的寄存器，如果不采取任何措施，本条指令取到的将是寄存器的I旧值，这就是RAW数据冒险。这时有3个时钟周期的阻塞，使本指令ID应在上一条指令WB后。本题中，I1在WB段结束才将结果写回R4，而I2在ID段就需要取R4的值，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e0b6b63c9ba8cbf07cee251a009c49742745fbb9711b3819e75c20dc7e1f2579.jpg)  

第三条指令阻塞了3个时钟周期。  

$\circledcirc$ 跳转指令（JMP）（bra）：由于流水线默认直接取下一条指令，若指令为JMP或JC（条件转移），在没有分支预测的情况下，默认有3个时钟周期的阻塞使下一条指令IF在分支指令M后（分支指令在M段才会确定是否更新PC）。本题中，I6是分支指令，其后一条指令被阻塞3个时钟周期，若跳移条件成立，则转到IⅡ1执行，反之顺序执行17。本题最后一问是分析为什么11的执行不会因为与15的数据相关而阻塞，可以从两个角度来分析：第一，16与15存在数据冒险，从而16的ID段被阻塞3个时钟周期，不论16是不是分支指令，I1的IF段都会被阻塞，从而ID段也会相应地推迟。第二，因为I6是分支指令，后续指令会阻塞3个时钟周期，从而也能消除11和15的数据冒险。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1d7a4a6197a58da7cbd4a0f530fedbc68b1e3e180de8d34f4250a26d029a5696.jpg)  

# 在了解上面的基础知识后，我们再看这道大题。  

1）已知计算机M采用32位定长指令字，即一条指令占4B，观察表中各指令的地址可知，每条指令的地址差为4个地址单位，即4个地址单位代表4B，一个地址单位就代表了1B，所以该计算机是按字节编址的。  

2）在二进制中某数左移两位相当于乘以4，由该条件可知，数组间的数据间隔为4个地址单位，而计算机按字节编址，所以数组A中的每个元素占4B。  

3）由表可知，bne指令的机器代码为1446FFFAH，根据题目给出的指令格式，后2B的内容为OFFSET字段，所以该指令的OFFSET字段为FFFAH，用补码表示，值为-6。系统执行到bne指令时，PC自动加4，PC的内容为08048118H，而跳转的目标是08048100H，两者相差了18H，即24个单位的地址间隔，所以偏移地址的一位即是真实跳转地址的 $-24/{-6}=4$ 位。可知bne指令的转移目标地址计算公式为（PC) $^{+4+}$ OFFSET×4。  

4）由于数据相关而发生阻塞的指令为第2、3、4、6条，因为第2、3、4、6条指令都与各自前一条指令发生数据相关。第6条指令会发生控制冒险。当前循环的第5条指令与下次循环的第1条指令虽然有数据相关，但由于第6条指令后有3个时钟周期的阻塞，因而消除了该数据相关（或者解释如下：第6条指令因为与第5条指令存在数据冒险，导致后续Ⅱ1的执行也相应地推迟，因此消除了该数据冒险）。  

# 05.【解答】  

该题继承了上题中的相关信息，统考中首次引入此种设置，具体考查程序的运行结果、Cache的大小和命中率的计算，以及磁盘和TLB的相关计算，是一道比较综合的题型。2015年同样出现了23分大题的设定，希望读者对其足够重视。  

1）R2中装的是i的值，循环条件是 $\mathrm{i}<\!\mathrm{N}(1000)$ ，即当i自增到不满足这个条件时跳出循环，程序结束，所以此时R2的值为1000。  

2）Cache共有16行，每块32字节，所以Cache数据区的容量为 $16{\times}32\mathrm{B}=512\mathrm{B}$  

P共有6条指令，占24B，小于主存块大小32B，其起始地址为 $0804\ \ 8100\mathrm{H}$ ，对应一块的开始位置，由此可知所有指令都在一个主存块内。读取第一条指令时会发生Cache缺失，因此将P所在的主存块调入Cache的某一行，以后每次读取指令时，都能在指令Cache中命中。因此在1000次循环中，只会发生1次指令访问缺失，所以指令Cache的命中率为 $(1000\times6-1)\div(1000\times6)=99.98\%.$  

3）指令4为加法指令，即对应 $\mathrm{{sum+}=A[i]}$ ，当数组A中元素的值过大时，会导致这条加法指令发生溢出异常；而指令2、5虽然都是加法指令，但它们分别为数组地址的计算指令和存储变量i的寄存器进行自增的指令，而i最大到达1000，所以它们都不会产生溢出异常。  

只有访存指令可能产生缺页异常，即指令3可能产生缺页异常。因为数组A在磁盘的一页上，而一开始数组并不在主存中，第一次访问数组时会导致访盘，把A调入内存，而以后数组A的元素都在内存中，不会导致访盘，所以该程序共访盘一次。  

每访问一次内存数据，就查一次TLB，共访问数组1000次，所以此时又访问1000次TLB还要考虑到第一次访问数组A，即访问A[O]时，会多访问一次TLB（第一次访问A[O]时会先查一次TLB，然后产生缺页，处理完缺页中断后，会重新访问A[O]，此时又查TLB)，所以访问TLB的次数一共是1001次。  
# 5.7多处理器的基本概念  

命题追踪 多处理器的基本概念（2022）  

# 5.7.1SISD、SIMD、MIMID的基本概念  

基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。常规的单处理器属于SISD，而常规的多处理器属于MIMD。  

# 1.单指令流单数据流（SISD）结构  

SISD是传统的事行计算机结构，这种计算机通常仅包含一个处理器和一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干指令。为了提高速度，有些SISD计算机采用流水线的方式，因此，SISD处理器有时会设置多个功能部件，并且采用多模块交叉方式组织存储器。本书前面介绍的内容多属于SISD结构。  

# 2.单指令流多数据流（SIMID）结构  

SIMID是指一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种结构的计算机通常由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器，这样每个单元就都有不同的数据地址，因此，不同处理单元执行的同一条指令所处理的数据是不同的。一个顺序应用程序被编译后，既可能按SISD组织并运行于事行硬件上，又可能按SIMID组织并运行于并行硬件上。  

SIMD在使用for循环处理数组时最有效，比如，一条分别对16对数据进行运算的SIMID指令如果在16个ALU中同时运算，则只需要一次运算时间就能完成运算。SIMD在使用case或switch语句时效率最低，此时每个执行单元必须根据不同的数据执行不同的操作。  

# 3.多指令流单数据流（MISD）结构  

MISD是指同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。  

# 4.多指令流多数据流（MIIMID）结构  

MIMD是指同时执行多条指令分别处理多个不同的数据，MIMID分为多计算机系统和多处理器系统。多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递MIIMID。多处理器系统是共享存储多处理器（SMP）系统的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储MIIMID。  

向量处理器是SIMID的变体，是一种实现了直接操作一维数组（向量）指令集的CPU，而串行处理器只能处理单一数据集。其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中。  

SIMD和MIMD是两种并行计算模式，其中SIIMD是一种数据级并行模式，而MIMD是一种并行程度更高的线程级并行或线程级以上并行计算模式。  
# 5.7.2硬件多线程的基本概念  

在传统CPU中，线程的切换包含一系列开销，频繁地切换会极大影响系统的性能，为了减少线程切换过程中的开销，便诞生了硬件多线程。在支持硬件多线程的CPU中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。  

硬件多线程有3种实现方式：细粒度多线程、粗粒度多线程和同时多线程（SMT）。  

# 1.细粒度多线程  

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。在这种方式下，处理器能在每个时钟周期切换线程。例如，在时钟周期i，将线程A中的多条指令发射执行；在时钟周期 $\mathrm{i}+1$ ，将线程B中的多条指令发射执行。  

# 2.粗粒度多线程  

连续几个时钟周期都执行同一线程的指令序列，仅在当前线程出现了较大开销的阻塞时，才切换线程，如Cache缺失。在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程更大。  

上述两种多线程技术都实现了指令级并行，但线程级不并行。  

# 3.同时多线程  

同时多线程（SMT）是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。  

图5.21分别是三种硬件多线程实现方式的调度示例。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fe12e3816bacd5ce1624427dc34539902f856a1a779a1dfcb27e86ac5ec6d5bd.jpg)  

Intel处理器中的超线程（Hyper-threading）就是同时多线程SMT，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件。  

# 5.7.3多核处理器的基本概念  

多核处理器是指将多个处理单元集成到单个CPU中，每个处理单元称为一个核（core），通常也称片上多处理器。每个核既可以有自己的Cache，又可以共享同一个Cache，所有核通常共享主存储器。图5.22是一个不共享Cache的双核CPU结构。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e190cda79c5d3789bba4003dd4e0cf2eedc2899411a4baf8ced7fc668357302.jpg)  
图5.22不共享Cache的双核CPU结构  

在多核计算机系统中，如要充分发挥硬件的性能，必须采用多线程（或多进程）执行，使得每个核在同一时刻都有线程在执行。与单核上的多线程不同，多核上的多个线程是在物理上并行执行的，是真正意义上的并行执行，在同一时刻有多个线程在并行执行。而单核上的多线程是一种多线程交错执行，实际上在同一时刻只有一个线程在执行。  

下面通过一个例子来理解相关的概念。假设要将四颗圆石头滚到马路对面，滚动每颗石头平均需花费1分钟。串行处理器会逐一滚动每颗石头，花费4分钟。拥有两个核的多核处理器让两个人滚石头，即每人滚两颗，花费2分钟。向量处理器找到一根长木板，放在四颗石头后面，推动木板即可同时滚动四块石头，理论上只要力量够大，就只需要1分钟。多核处理器相当于拥有多名工人，而向量处理器拥有一种方法，可以同时对多件事进行相同的操作。  

# 5.7.4共享内存多处理器的基本概念  

具有共享的单一物理地址空间的多处理器称为共享内存多处理器（SIMIP）。处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指令访问存储器的任何位置。注意，即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。  

单一地址空间的多处理器有两种类型：  

·统一存储访问（UMA）多处理器。每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。·非统一存储访问（NUMA）多处理器。某些存储器的访存速度要比其他的快，具体取决于哪个处理器提出访问请求及访问哪个字，这是由于主存被分割分配给了不同处理器。  

早期的计算机，内存控制器没有整合进CPU，访存操作需要经过北桥芯片（集成了内存控制器，并与内存相连），CPU通过前端总线和北桥芯片相连，这就是统一存储访问（UMA）构架。随着CPU性能提升由提高主频转到增加CPU数量（多核、多CPU），越来越多的CPU对前端总线的争用使得前端总线成为瓶颈。为了消除UMA架构的瓶颈，非统一存储访问（NUMA）构架诞生，内存控制器被集成到CPU内部，每个CPU都有独立的内存控制器。每个CPU都独立连接到一部分内存，CPU直连的这部分内存被称为本地内存。CPU之间通过QPI总线相连。CPU可以通过QPI总线访问其他CPU的远程内存。与UMA架构不同的是，在NUMA架构下，内存的访问出现了本地和远程的区别，访问本地内存明显要快于访问远程内存。  

由于可能会出现多个处理器同时访问同一共享变量的情况，在操作共享变量时需要进行同步，否则，一个处理器可能会在其他处理器尚未完成对共享变量的修改时，就开始使用该变量。常用方法是通过对共享变量加锁的方式来控制对共享变量互斥访问。在一个时刻只能有一个处理器获得锁，其他需要操作该共享变量的处理器必须等待，直到该处理器解锁该变量为止。  
第3章讨论的一致性是指Cache与主存之间的数据一致性。在UMA构架的多处理器中，所有CPU共享同一内存空间，每个CPU的Cache都是共享内存中的一部分副本，因此多核系统的Cache一致性既包括Cache和内存之间的一致性，还包括各CPU的Cache之间的一致性，也就是说，对内存同一位置的数据，不同CPU的Cache不应该有不一致的内容。  

# 5.7.5 本节习题精选  

# 单项选择题  

01.按照Flynn提出的计算机系统分类方法，多处理机属于（）。A. SISD B.SIMD C. MISD D.MIMD 02.从体系结构的角度来看，阵列处理机属于（）结构。A. SISD B.SIMD C. MIMD D.MISD 03.以下机器中，不属于SIMD结构的是（）。A.并行处理机B.阵列处理机C.向量处理机D.标量流水线处理机04.具有一个控制部件和多个处理单元的计算机系统属于（）结构。A. SISD B.SIMD C. MISD D.MIMD 05.下列关于超线程（HT）技术的描述中，正确的是（）  

A.超线程技术可以让四核的IntelCorei7处理器变成八核B.超线程是一项硬件技术，能使系统性能大幅提升，与操作系统和应用软件无关C.含有超线程技术的CPU需要芯片组的支持才能发挥技术优势D.超线程模拟出的每个CPU核都具有独立的资源，各自工作互不干扰  

06.双核CPU和超线程CPU的共同点是（）  

A.都有两个内核B.都能同时执行两个运算C.都包含两个CPUD.都不会出现争抢资源的现象  

07.下列关于双核技术的叙述中，正确的是（）  

A.双核是指主板上有两个CPUB.双核是利用超线程技术实现的C.双核是指在CPU上集成两个运算核心D.双核CPU是时间并行的并行计算  

08.下列有关多核CPU和单核CPU的描述中，错误的是（）。  

A.双核的频率为2.4GHZ，那么其中每个核心的频率也是2.4GHZB.采用双核CPU可以降低计算机系统的功耗和体积C.多核CPU共用一组内存，数据共享D.所有程序在多核CPU上运行速度都快  

09．下列关于多核CPU的描述中，正确的是（）。  

A.各核心完全对称，拥有各自的Cache B.任何程序都可以同时在多个核心上运行C.一颗CPU中集成了多个完整的执行内核，可同时进行多个运算 D.只有使用了多核CPU的计算机，才支持多任务操作系统  
10.下列关于多处理器的说法中，正确的是（）。  

I.通常采用偶数路CPU，如2路、4路、6路等IⅡI.NUMA构架比UMA构架的运算扩展性要强 ImI.UMA构架需要解决的重要问题是Cache一致性  

A. 1B.I和ⅡIC.I和ⅢID.I、ⅡI和IⅢI11.下列关于多核处理器的说法中，不正确的是（）  

A.多核处理器并不能使单线程程序的执行速度加快B.多核处理器在Flynn分类法中属于MIMD系统C.多核处理器实际上就是在一个CPU上集成了多个控制核心D.多核处理器通常比单核处理器的能耗更高  

12.【2022统考真题】下列关于并行处理技术的叙述中，不正确的是（）  

A.多核处理器属于MIMD结构B.向量处理器属于SIMD结构C.硬件多线程技术只可用于多核处理器D.SMP中所有处理器共享单一物理地址空间  

# 5.7.6 答案与解析  

单项选择题  

01.D  

Flynn分类法将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。常规的单处理器属于SISD，常规的多处理机属于MIMD。  

02.B  

阵列处理机包含一个计算阵列，此阵列由多个处理单元组成。它使用单一的控制部件控制多个处理单元，使每个处理单元对各自的数据进行同样的操作，属于SIIMID结构。  

03.D  

A、B和C通常可理解为同一种概念，是SIMD结构。标量流水线处理机是SISD结构。  

04.B  

单指令流多数据流（SIIMID）结构的计算机通常由一个指令控制部件、多个处理单元组成，不同处理单元执行的同一条指令所处理的数据可以不同。  

05.C  

超线程技术是在一个CPU中，提供两套线程处理单元，让单个处理器实现线程级并行。虽然采用超线程技术能够同时执行两个线程，但是当两个线程同时需要某个资源时，其中一个线程必须暂时挂起，直到这些资源空闲后才能继续运行。因此，超线程的性能并不等于两个CPU的性能。而且，超线程技术的CPU需要芯片组、操作系统（如Windows98不支持超线程技术）和应用软件的支持，才能发挥该项技术的优势。双核技术是指将两个一样的CPU集成到一个封装内（或者直接将两个CPU做成一个芯片），而超线程技术在CPU内部仅复制必要的线程资源来让两个线程同时运行，能并行执行两个线程，模拟实体双核。仅C正确。  

06.B  

超线程技术在CPU内部仅复制必要的线程资源，共享CPU的高速缓存和功能部件，让两个线程可以并行执行，模拟双核CPU。当两个线程同时需要某个共享资源时，其中一个线程必须暂时挂起，直到这些资源空闲后才能继续运行。仅B正确。  
07.C  

双核是指将两个CPU核心集成到一个封装中，核心也称内核，是CPU最重要的组成部分，C正确。主板上有两个CPU属于多处理器。超线程技术是模拟实体双核，不能算作真正意义上的双核。时间并行是指流水线技术，空间并行则是指硬件资源的重复，空间并行导致了两类并行机的产生，按Flynn分类法分为SIMD和MIMD。  

08.D  

多核CPU的核心通常都是对称的，因此2.4GHz双核CPU中两个核的主频也是 $2.4\mathrm{GHz}$ 。早期CPU性能提升主要靠提高主频，导致功耗增大，发热量大，而且当主频提高到一定程度后，CPU性能的提升不再明显，后来转到增加CPU核心的方向，将2个核心集成到一个芯片内，提供等同双CPU的性能，这显然也降低了CPU的体积。C显然正确。在多核CPU上运行一个不支持多线程的程序，显然不能发挥多核CPU的优势，D错误。  

09.C  

多核CPU的各核心既可以有独自的Cache，又可以共享同一个Cache。只有支持多线程的并行处理程序才能同时在多个核心上运行，发挥多核的优势。C正确。多任务系统也称多道程序系统，可以运行在单核CPU上，宏观上并行，微观上串行。  

10.D  

SMP也称对称多处理器，一般采用偶数路CPU，I正确。UMA构架由于所有CPU共享相同的内存，增加CPU路数会加大访存冲突，通常2或4路的性能最好，而NUMA理论上支持无限扩展，ⅡI正确。UMA构架中所有CPU共享同一内存空间，每个CPU的Cache中都是共享内存中的一部分副本，因此各CPU的Cache一致性是需要解决的重要问题，IⅢl正确。  

11.C  

单线程程序只有一个执行流，因此多核处理器并不能使其执行速度加快。多核处理器属于Flymn分类法的MIIMD系统。多核处理器是在一颗CPU上集成了多个执行内核而非控制核心的处理器，C错误。多核处理器可在一个时钟周期内处理多个并行任务，因此能耗通常更高。  

12.C  

MIMID结构分为多计算机系统和多处理器系统。向量处理器是SIIMD的变体，属于SIIMID结构。硬件多线程技术在一个核中处理多个线程，可用于单核处理器，C错误。共享内存多处理器（SMIP）具有共享的单一物理地址空间，所有核都可通过存取指令来访问同一片主存地址空间。  

# 5.8 本章小结  

本章开头提出的问题的参考答案如下。  

1）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？  

从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”。从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）  

2）什么是指令周期、机器周期和时钟周期？它们之间有何关系？  

CPU每取出并执行一条指令所需的全部时间称为指令周期；机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排机器周期长度 $=$ 主存周期；时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期 $=$ 计算机主频的倒数。  
3）什么是微指令？它和第4章谈到的指令有什么关系？  

控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为微命令，而一组实现一定操作功能的微命令的组合，构成一条微指令。许多条微指令组成的序列构成微程序， 微程序完成对指令的解释执行。指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。  

4）什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？  

指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高。  

# 5.9常见问题和易混淆知识点  

1.流水线越多，并行度就越高。是否流水段越多，指令执行越快？  

错误，原因如下：  

1）流水段缓冲之间的额外开销增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。  

2）流水段间控制逻辑变多、变复杂。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。  

2.读后写（WAR）相关和写后写（WAW）相关的概念  

1）读后写（WriteAfterRead，WAR）冲突。表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。在下列指令中，寄存器R1可能存在这样的冲突，当指令12试图在指令Ⅱ1读R1之前就写入该寄存器时，指令I1就错误地读出该寄存器新的内容。  

I1 add R3,R1,R2  $\begin{array}{r l}{\#\left(\mathbb{R}{1}\right)+\left(\mathbb{R}{2}\right)\rightarrow\mathbb{R}{3}}&{{}}\\ {\#\left(\mathbb{R}{4}\right)-\left(\mathbb{R}{5}\right)\rightarrow\mathbb{R}{1}}&{{}}\end{array}$  I2 sub R1,R4,R5  

在读后写（WAR）冲突中，指令I2的目的操作数是指令I1的源操作数。  

3）写后写（WriteAfterWrite，WAW）相关。表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。在下列指令中，寄存器RI可能存在这样的冲突，当指令I2试图在指令I1之前就写入R1时，就会错误地使由指令11写入的值成为该寄存器的内容。  

I1 add R1,R2,R3  $\begin{array}{r}{\#\left(\mathbb{R}2\right)+\left(\mathbb{R}3\right)\rightarrow\mathbb{R}1}\\ {\#\left(\mathbb{R}4\right)-\left(\mathbb{R}5\right)\rightarrow\mathbb{R}1}\end{array}$  I2 sub R1,R4,R5  

在写后写（WAW）冲突中，指令I2和指令I1的目的操作数是相同的。  

# 注意  

在非按序执行的流水线中，因为允许后进入流水线的指令超过先进入流水线的指令而先流出流水线，所以既可能发生RAW相关，又可能发生WAR和WAW相关。  
# 第6章总线  

# 【考纲内容】  

总线的基本概念总线的组成及性能指标总线事务和定时  

# 【复习提示】  

本章的知识点较少，通常以选择题的形式出现，特别是总线的特点、猝发传输方式、性能指标、定时方式及常见的总线标准等。总线带宽的计算也可能结合其他章节出综合题。  

在学习本章时，请读者思考以下问题  

1）引入总线结构有什么好处？2）引入总线结构会导致什么问题？如何解决？请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。  

# 6.1总线概述  

早期计算机的各部件之间是通过单独的连线互连的，这种方式称为分散连接。但是，随着1/O设备的种类和数量越来越多，为了更好地解决1/O设备和主机之间连接的灵活性，计算机的结构从分散连接发展为总线连接。为了进一步简化设计，又提出了各类总线标准。  

# 6.1.1总线基本概念  

# 1.总线的定义  

总线是一组能为多个部件分时和共享的公共信息传送线路。分时和共享是总线的两个特点。分时是指同一时刻只充许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地尚总线发送信息。共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，多个部件可同时从总线上接收相同的信息。  

2.总线设备  

总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。  

主设备：指发出总线请求且获得总线控制权的设备。从设备：指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。  

3.总线特性  

总线特性是指机械特性（尺寸、形状）、电气特性（传输方向和有效的电平范围）、功能特性（每根传输线的功能）和时间特性（信号和时序的关系）  
# 6.1.2总线的分类  

# 1.按功能层次分类  

命题追踪 总线相关的概念与特点（2016、2017）  

1）片内总线。芯片内部的总线，用于CPU芯片内部各寄存器之间及寄存器与ALU的连接。  

2）系统总线。计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类：数据总线、地址总线和控制总线。  

# 命题追踪数据总线上传输的内容（2011）  

$\textcircled{\scriptsize{1}}$ 数据总线用来在各部件之间传输数据、指令和中断类型号等，它是双向传输总线，数据总线的位数反映一次能传送的数据的位数。 $\circledcirc$ 地址总线用来指出数据总线上源数据或目的数据所在的主存单元或 $\mathrm{I}/\mathrm{O}$ 端口的地址，它是单向传输总线，地址总线的位数反映最大的寻址空间。 $\textcircled{3}$ 控制总线用来传输各种命令、反馈和定时信号，典型的控制信号包括时钟、复位、总线请求/充许、中断请求/回答、存储器读/写、1/0读、1/O写、传输确认等。  

注意区分数据通路和数据总线：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而数据总线是数据传输的媒介。  

3）1/0总线。主要用于连接中低速的1/0设备，通过1/0接口与系统总线相连接，目的是将低速设备与高速总线分离，以提升总线的系统性能，常见的有USB、PCI总线。  

4）通信总线。计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。  

2.按时序控制方式分类  

1）同步总线。总线上连接的部件或设备通过统一的时钟进行同步，在规定的时钟节拍内进行规定的总线操作，来完成部件或设备之间的信息传输。  

2）异步总线。总线上连接的部件或设备没有统一的时钟，而以信号握手的方式来协调各部件或设备之间的信息传输，总线操作时序不是固定的。  

3.按数据传输方式分类  

1）串行总线。只有一条双向传输或两条单向传输的数据线，数据按比特位串行顺序传输，其效率低于并行总线。串行传输对数据线的要求不太高，因此适合长距离通信。  

2）并行总线。有多条双向传输的数据线，可以实现多比特位的同时传输，其效率比串行总线更高。缺点是各条数据线的传输特点可能存在一些差异，比如有的信息位可能会延迟，并且数据线之间相互干扰还会造成传输错误，因此并行总线适合近距离通信。  

# 注意  

并行总线并不一定总比串行总线快，它们适合不同的场景。并行总线由于是多个数据位同时传输，需要考虑数据的协同性，以及线路之间的相互干扰，导致工作频率无法持续提高。而串行总线可通过不断提高工作频率来提高传输速度，使其速度最终超越并行总线的速度。  
# 6.1.3系统总线的结构  

# 1.单总线结构  

单总线结构将CPU、主存、I/O设备（通过1/O接口）都挂在一组总线上，充许I/O设备之间、I/O设备与主存之间直接交换信息，如图6.1所示。CPU与主存、CPU与外设之间都可以通过总线直接进行信息交换，而无须经过中间设备的干预。需要注意的是，单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8b75e0bcbcbe7c1e22d71e2fa26222c4fe36d1dfe9f77fe38f2dbbcd9c3075a.jpg)  
图6.1单总线结构  

优点：结构简单，成本低，易于接入新的设备。缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作  

# 2.双总线结构  

双总线结构有两条总线：一条是主存总线，用于在CPU、主存和通道之间传送数据；另一条是1/0总线，用于在多个外部设备与通道之间传送数据，如图6.2所示。  

优点：将低速I/O设备从原单总线上分离出来，实现了存储器总线和1/O总线分离。  

缺点：需要增加通道等硬件设备。  

# 3.三总线结构  

三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I/O总线和直接内存访问（DMA）总线，如图6.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7065d4dc41e8445bd893d3f0057b7a4fbb7dfb06e816e4830f2970c62d12561.jpg)  
图6.2双总线结构  

主存总线用于在CPU和内存之间传送地址、数据和控制信息。I/O总线用于在CPU和各类外设之间通信。DMA总线用于在内存和高速外设之间直接传送数据。  

优点：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。缺点：任意时刻只能使用一种总线，系统工作效率较低。  

#  $^{*}6.1.4$ 常见的总线标准  

总线标准是国际上公布的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。IS A、EISA、VESA、PCI、AGP、PCI-ExpresS、USB 等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。  
命题追踪总线标准的英文缩写（2010）  

1）ISA，Industry Standard Architecture，工业标准体系结构。最早出现的系统总线，缺点是传输速率低、CPU占用率高、占用硬件中断资源。它属于系统总线、并行总线。  

2）EISA，Extended Industry Standard Architecture，扩展的ISA。E IS A和突发传送，EISA对ISA完全兼容。它属于系统总线、并行总线。  

# 命题追踪区分设备总线和局部总线（2013）  

3）VESA，Video Electronics Standards Association，视频电子标准协会。是一个32位的局部总线，是针对多媒体PC要求高速传送活动图像的大量数据而推出的。它属于局部总线、并行总线。局部总线是在ISA总线和CPU总线之间增加的一级总线或管理层，这样就可将一些高速外设（如图形卡、硬盘控制器、网卡等）从ISA总线上卸下，而通过局部总线直接挂接到CPU总线上，使之能与高速CPU总线相匹配。4）PCI，Peripheral Component Interconnect，外部设备互连。32 64，目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线是一个与处理器时钟频率无关的高速外围总线，支持即插即用。它属于局部总线、并行总线。5）AGP，AcceleratedGraphicsPort，加速图形接口。是一种视频接口标准，专用于连接主存和图形卡，用于传输视频和三维图形数据。它属于局部总线、并行总线。  

# 命题追踪PCI-E总线的特点（2017）  

6）PCI-E，PCI-ExpreSS。高速串行双通道传输，其传输速率远高于PCI和AGP，且支持双向传输模式，还可以支持全双工模式。它属于局部总线、事行总线。7）RS-232C。应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口。它属于设备总线、串行总线。  

# 命题追踪USB总线的特点（2012）  

8）USB，UniversalSerialBus，通用串行总线。一种连接外部设备的I/O总线，具有即插即用、热插拔等优点，有很强的连接能力。它属于设备总线、串行总线。9）PCMCIA，Personal Computer Memory Card International Association。应用于笔记本电脑的接口标准，通常用于扩展功能，具有即插即用功能。它属于设备总线、并行总线。10）IDE，Integrated Drive Electronics，集成设备电路。更准确地称为ATA，硬盘和光驱通过IDE接口与主板连接。它属于设备总线、并行总线。11）SCSI，Small Computer System Interface，小型计算机系统接口。一种用于计算机和周边设备之间（硬盘等）系统级接口的独立处理器标准。它属于设备总线、并行总线。12）SATA，Serial Advanced Technology Attachment，串行高级技术附件。一种基于行业标准的串行硬件驱动器接口。它属于设备总线、串行总线。  

6.1.5 总线的性能指标  

1）总线时钟周期。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。2）总线时钟频率。即机器的时钟频率，它为时钟周期的倒数。  
3）总线传输周期。指一次总线操作所需的时间，包括申请阶段、寻址阶段、传输阶段和结束阶段。总线传输周期通常由若干总线时钟周期构成。4）总线工作频率。总线上各种操作的频率，为总线周期的倒数。实际上指1秒内传送几次数据。若总线周期 $=N$ 个时钟周期，则总线的工作频率 $=$ 时钟频率/N：此外，若一个时钟周期可以传送 $K$ 次数据，则总线工作频率是总线时钟频率的 $K$ 倍。5）总线宽度。总线宽度也称总线位宽，是总线上能够同时传输的数据位数，通常指数据总线的根数，如32根称为32位总线。  

# 命题追踪总线带宽的相关计算（2009、2013、2014、2019、2020）  

6）总线带宽。单位时间内总线上最多可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。总线带宽 $=$ 总线工作频率 $\times($ (总线宽度/8）。7）总线复用。总线复用是指一种信号线在不同的时间传输不同的信息。例如，有些总线没有单独的地址线，地址信息通过数据线来传送，这种情况称为地址/数据线复用。因此可以使用较少的线传输更多的信息，从而节省空间和成本。8）信号线数。地址总线、数据总线和控制总线3种总线数的总和称为信号线数。  

# 命题追踪提高总线带宽的办法（2018）  

其中，总线最主要的性能指标为总线宽度、总线工作频率、总线带宽。总线带宽是指总线的最大数据传输速率，它是衡量总线性能的重要指标。三者的关系：总线带宽 $=$ 总线宽度 $\times$ 总线工作频率。例如，总线工作频率为22MHz，总线宽度为16位，则总线带宽 $\scriptstyle=22\mathbf{M}\times(16/8)=44\mathbf{M}\mathrm{B/s}$  

# 6.1.6 本节习题精选  

# 一、单项选择题  

01.挂接在总线上的多个部件（）  

A.只能分时向总线发送数据，并只能分时从总线接收数据B.只能分时向总线发送数据，但可同时从总线接收数据C.可同时向总线发送数据，并同时从总线接收数据D.可同时向总线发送数据，但只能分时从总线接收数据  

02.在总线上，同一时刻（）。  

A.只能有一个主设备控制总线传输操作B.只能有一个从设备控制总线传输操作C.只能有一个主设备和一个从设备控制总线传输操作D.可以有多个主设备控制总线传输操作  

03.在计算机系统中，多个系统部件之间信息传送的公共通路称为总线，就其所传送的信息的性质而言，下列（）不是在公共通路上传送的信息。  

A.数据信息B.地址信息C.系统信息D.控制信息  

04.系统总线用来连接（）。  

A.寄存器和运算器部件B.运算器和控制器部件C.CPU、主存和外设部件 D.接口和外部设备  

05.计算机使用总线结构便于增减外设，同时（）A.减少信息传输量B.提高信息的传输速度  
C.减少信息传输线的条数D.提高信息传输的并行性  

06.间址寻址第一次访问内存所得到的信息经系统总线的（）传送到CPU。  

A.数据总线B.地址总线C.控制总线D.总线控制器  

07.系统总线中地址线的功能是（）  

A.选择主存单元地址B.选择进行信息传输的设备C.选择外存地址D.指定主存和IO设备接口电路的地址  

08.系统总线中控制线的主要功能是（）  

A.提供时序信号B.提供主存和1/O模块的回答信号C.提供定时信号、操作命令和各种请求/回答信号等D.提供数据信息  

09.在单机系统中，三总线结构计算机的总线系统组成是（）  

A.片内总线、系统总线和通信总线B.数据总线、地址总线和控制总线C.DMA总线、主存总线和I/O总线 D.ISA总线、VES A PCI  

10.不同信号在同一条信号线上分时传输的方式称为（）。  

A.总线复用方式B.并串行传输方式C.并行传输方式D.串行传输方式  

11.主存通过（）来识别信息是地址还是数据。  

A.总线的类型B.存储器数据寄存器（MDR）C.存储器地址寄存器（MAR）D.控制单元（CU）  

12.在32位总线系统中，若时钟频率为 $500\mathrm{MHz}$ ，传送一个32位字需要5个时钟周期，则该总线的数据传输速率是（）。  

A.200MB/s B.400MB/s C.600MB/s D.800MB/s  

13.传输一幅分辨率为 $640\!\times\!480$ 像素、颜色数量为65536的照片（采用无压缩方式），假设有效数据的传输速率为56kb/s，则大约需要的时间是（）。  

A.34.82s B.43.86s C.85.71s D.87.77s  

14.某总线有104根信号线，其中数据线（DB）为32根，若总线工作频率为 $33\mathrm{MHz};$ 则其理论最大传输速率为（）。  

A.33MB/s B.64MB/s C.132MB/s D.164MB/s  

15.在一个16位的总线系统中，若时钟频率为 $100\mathrm{MHz}$ ，总线周期为5个时钟周期传输一个字，则总线带宽是（）。  

A.4MB/s B.40MB/s C.16MB/s D.64MB/s

 16.微机中控制总线上完整传输的信号有（）  

1.存储器和I/O设备的地址码II.所有存储器和I/O设备的时序信号与控制信号III.来自I/O设备和存储器的响应信号  

A.仅IB.II和IⅢIC.仅ⅡID.I、II、III

17.下列信号中，可在系统总线中的控制总线上传输的有（）。  

1.存储器和I/O设备的地址信息I1.存储器和I/O设备的时序信号、控制信号III.存储器和I/O设备的响应信号IV.存储器中存放的数据A.I和IVB.II和IⅢIC.I、II和ⅢID.II、IⅢI和IV  
18.总线中，有些信息是单向传输的，有些信息是双向传输的，下列说法中正确的是（）。  

A.数据信息是单向传输的，由内存或外设传送至CPUB.地址信息是单向传输的，由CPU发送至内存或外设C.控制信息是双向传输的，由CPU发送至内存或外设，也可反向D.状态信息是双向传输的，由CPU发送至内存或外设，也可反向  

19.按连接部件不同，总线通常可以分为以下哪几种？（）。  

I.系统总线II.片内总线IⅢI.地址线IV.通信总线A.I、ⅡI和IⅢIB.I、ⅢI和IVC.I、IⅡI和IVD.IⅡI、IⅢ和IV  

20.【2009统考真题】假设某系统总线在一个总线周期中并行传输4字节信息，一个总线周期占用2个时钟周期，总线时钟频率为10MHz，则总线带宽是（）。  

A.10MB/s B.20MB/s C.40MB/s D. 80MB/s

 21.【2010统考真题】\*下列选项中的英文缩写均为总线标准的是（）。  

A.PCI、CRT、USB、EISAB.ISA、CPI、VESA、EISAC.ISA、SCSI、RAM、MIPSD.ISA、EISA、PCI、PCI-Express  

22.【2011统考真题】在系统总线的数据线上，不可能传输的是（）。A.指令B.操作数C.握手（应答）信号D.中断类型号

23.【2012统考真题】\*下列关于USB总线特性的描述中，错误的是（）  

A.可实现外设的即插即用和热拔插B.可通过级联方式连接多台外设C.是一种通信总线，连接不同外设D.同时可传输2位数据，数据传输速率高  

24.【2013统考真题】\*下列选项中，用于设备和设备控制器之间互连的接口标准是（）。A.PCI B.USB C. AGP D. PCI-Express  

25.【2014统考真题】某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据（上升沿和下降沿各传送一次数据），该总线的最大数据传输速率（总线带宽）是（）  

A.132MB/s B.264MB/s C.528MB/s D.1056MB/s  

26.【2019统考真题】某计算机采用3通道存储器总线，配套的内存条型号为DDR3-1333，即内存条所接插的存储器总线的工作频率为 $1333\mathrm{MHz}$ ，总线宽度为64位，则存储器总线的总带宽大约是（）。  

A.10.66GB/s B.32GB/s C.64GB/s D. 96GB/s  

27.【2020统考真题】QPI总线是一种点对点全双工同步串行总线，总线上的设备可同时接收和发送信息，每个方向可同时传输20位信息（16位数据 $^{+\ 4}$ 位校验位），每个QPI数据包有80位信息，分2个时钟周期传送，每个时钟周期传递2次。因此，QPI总线带宽为：每秒传送次数 $.{\times}2\mathrm{B}{\times}2$ 。若QPI时钟频率为2.4GHz，则总线带宽为（）。  

A.4.8GB/s B.9.6GB/s C.19.2GB/s D.38.4GB/s  

# 二、综合应用题  

01.某总线的时钟频率为66MHz，在一个64位总线中，总线数据传输的周期是7个时钟周期传输6个字的数据块。1）总线的数据传输速率是多少？2）若不改变数据块的大小，而将时钟频率减半，这时总线的数据传输速率是多少？  

02.某总线支持二级Cache块传输方式，若每块6个字，每个字长4字节，时钟频率为 $100\mathrm{MHz}_{\circ}$  
1）读操作时，第一个时钟周期接收地址，第二、三个为延时周期，另用4个周期传送一个块。读操作的总线传输速率为多少？2）写操作时，第一个时钟周期接收地址，第二个为延时周期，另用4个周期传送一个块，写操作的总线传输速率是多少？ 3）设在全部的传输中， $70\%$ 的时间用于读， $30\%$ 的时间用于写，该总线在本次传输中的平均传输速率是多少？  

# 6.1.7 答案与解析  

# 一、单项选择题  

01.B  

为了使总线上的数据不发生“冲突”，挂在总线上的多个设备只能分时地向总线发送数据，即某个时刻只能有一个设备向总线传送数据，而从总线接收数据的设备可以有多个，因为接收数据的设备不会对总线产生“干扰”。  

02.A  

只有主设备才能获得总线控制权，总线上的信息传输由主设备启动，一条总线上可以有多个设备作为主设备，但在同一时刻只能有一个主设备控制总线的传输操作。  

03.C 总线包括数据线、地址线和控制线，传送的信息分别为数据信息、地址信息和控制信息。  

04.C 系统总线用于连接计算机中的各个功能部件（如CPU、主存和I/O设备）。  

05.C  

计算机使用总线结构便于增减外设，同时减少信息传输线的条数。但相对于专线结构，其实际上也降低了信息传输的并行性及信息的传输速度。  

06.A  

间址寻址首次访问内存所得到的信息是操作数的有效地址，该地址作为数据通过数据总线传送至CPU，地址总线是用于CPU选择主存单元地址和I/O端口地址的单向总线，不能回传。地址总线由单向的多根信号线组成，可用于CPU向主存、外设传送地址信息：数据总线由双向的多根信号线组成，CPU既可以沿着这些线从主存或外设读入数据，又可以发送数据；控制总线上传输控制信息，包括控制命令和反馈信号等。  

07.D 地址总线上的代码用来指明CPU要访问的存储单元或I/O端口的地址。  

08.C 系统总线中控制线的主要功能是提供定时信号、操作命令和各种请求/回答信号等。  

09.C  

选项A是总线按功能层次的划分，单机系统可不需要通信总线。选项B都属于系统总线。选项D则是三种不同的总线标准。只有选项C组成了三总线结构系统。  

10.A  

事行传输是指数据的传输在一条线路上按位进行，并行传输是指每个数据位有一条单独的传输线，所有数据位同时传输。不同信号在同一条信号线上分时传输的方式，称为总线复用。  

11.A  
地址和数据在不同的总线上传输，根据总线传输信息的内容进行区分，地址在地址总线上传输，数据在数据总线上传输。  

12.B  

总线带宽 $=$ 总线宽度 $\times_{c}$ 总线频率，本题中的总线宽度为32位，即4B，总线频率为 $500\mathrm{MHz}/5=$ 100MHz，因此总线的数据传输速率为 $\mathrm{4B\!\times\!(500MHz/5)}=\mathrm{400MHz/s}.$  

13.D  

$65536=2^{16}$ 色，因此颜色深度为16位，占据的存储空间为 $640{\times}480{\times}16=4915200$ 位。有效传输时间 $=4915200^{\div}(56{\times}10^{3})\mathrm{s}{\approx}87.77\mathrm{s}$  

14.C  

数据总线32根，因此每次传输32位，即4B数据，总线工作频率为 $33\mathrm{MHz}$ ，因此理论最大传输速率为 $33{\times}4=132\mathrm{MB}/\mathrm{s}$  

15.B  

时钟频率为 $100\mathrm{MHz}$ ，因此时钟周期 $=\,1/100\mathrm{{MHz}\,=\,0.01\upmu s}$ ，总线周期 $\l=\,5$ 个时钟周期 $=$  $5{\times}0.01\upmu\mathrm{s}=0.05\upmu\mathrm{s}$ ，总线工作频率 $=1/0.05=20\mathrm{MHz},$ ，因总线是16位的，即2B，因此总线带宽 $=$  $20\!\times\!(16/8)=40\mathrm{MB/s}$  

16.B CPU的控制总线提供的控制信号包括时序信号、I/O设备和存储器的响应信号等。  

17.B  

控制总线主要用来传输计算机内各种控制信号，控制信号包括存储器和I/O设备的时序信号和响应信号，IⅡI、ⅢI正确。存储器和I/O设备的地址信息通过地址总线传输，I错误。存储器中存放的数据通过数据总线传输，IV错误。  

18.B  

总线中，数据总线是双向传输的，数据信息既可由CPU传送至内存或外设，又可由内存、外设传送至CPU，A错误。地址总线是单向传输的，地址信息只能由CPU发送至内存或外设，B正确。控制信息和状态信息也是单向传输的，它们的传输方向正好相反，控制信息通过控制总线由CPU发送至内存或外设，而状态信息则通过状态总线由内存或外设发送至CPU。  

19.C  

按连接部件不同，总线通常可分为片内总线、系统总线和通信总线，计算机系统的三总线结构通常是指I/O总线、主存总线和DMA总线。  

20.B  

总线带宽是指单位时间内总线上传输数据的位数，通常用每秒传送信息的字节数来衡量，单位为B/s。由题意可知，在1个总线周期 $(=2$ 个时钟周期）内传输了4字节信息，时钟周期 $=$  $1/10\mathrm{MHz}=0.1\upmu\mathrm{s}$ ，因此总线带宽为 $4{\bf B}{\bf\cdot}(2\times0.1\upmu s)=4{\bf B}{\bf\cdot}(0.2\times10^{-6}{\bf s})=20{\bf M}{\bf B}/{\bf s}\,.$  

21.D  

IS A、EISA、VESA、PCI、PCI-ExpreSS、AGP、USB、RS-232C等。选项A中的CRT是纯平显示器；选项B中的CPI是每条指令的时钟周期数；选项C中的RAM是半导体随机存储器、MIPS是每秒执行多少百万条指令数。  

22.C  

取指令时，指令便是在数据线上传输的。操作数显然在数据线上传输。中断类型号用于指出中断向量（中断服务程序的入口地址）的地址，CPU响应某一外部中断后，就会从数据总线上获取该中断源的中断类型号，然后据此计算对应中断向量在中断向量表（存放在内存中）的位置。而握手（应答）信号属于总线定时的控制信号，应在控制总线上传输。  
23.D  

USB（通用串行总线）的特点有： $\textcircled{\scriptsize{1}}$ 即插即用； $\textcircled{2}$ 热插拔； $\textcircled{3}$ 有很强的连接能力，采用菊花链形式将众多外设连接起来； $\textcircled{4}$ 有很好的可扩充性，一个USB控制器可扩充高达127个外部USB设备； $\circledast$ 高速传输，速率可达 $480\mathrm{M}\mathrm{b}/\mathrm{s}$ 。对于D，USB是串行总线，不能同时传输2位数据。  

24.B  

USB是一种连接外部设备的I/O总线标准，属于设备总线，是设备和设备控制器之间的接口。而PCI、AGP、PCI-E作为计算机系统的局部总线标准，通常用来连接主存、网卡、视频卡等。  

25. C  

数据线有32根，也就是一次可以传送 $32\mathrm{b}/8=4\mathrm{B}$ 的数据，66MHz意味着有66M个时钟周期，而每个时钟周期传送两次数据，可知总线每秒传送的最大数据量为 $66\mathbf{M}\times2\times4\mathrm{B}=528\mathrm{MB}$ ，所以总线的最大数据传输速率为 $528\mathrm{MB/s}$  

26.B  

由题目可知，计算机采用3通道存储器总线，存储器总线的工作频率为 $1333\mathrm{MHz}$ ，即1秒内传送1333M次数据，总线宽度为64位即单条总线工作一次可传输8字节（Byte），因此存储器总线的总带宽为 $3{\times}8{\times}1333\mathrm{MB/s}$ ，约为32GB/s。  

27. C  

每个时钟周期传送2次，所以每秒传送的次数  $=$  时钟频率  $\times2=2.4\mathrm{G}{\times}2/\mathrm{s}$  

总线带宽 $=$ 每秒传送次数 $\times2\mathrm{B}{\times}2=2.4\mathrm{G}{\times}2{\times}2\mathrm{B}{\times}2/\mathrm{s}=19.2\mathrm{GB}/\mathrm{s}\,.$ 题中已给出总线带宽公式，降低了难度。公式中的“ $\times2\mathrm{B}$ ”是因为每次传输16位数据。  

# 二、综合应用题  

01.【解答】  

1）总线周期为7个时钟周期，总线频率为 $66/7\mathrm{MHz}$ 总线在一个完整的操作周期中传输了一个数据块，总线在一个周期内传输的数据量为 $64\mathrm{bit}/8{\times}6=48\mathrm{B}$ ，所以总线的宽度为48B，传输速率为 $48\mathrm{B}{\times}66/7\mathrm{MHz}=452.6\mathrm{MB}/\mathrm{s}.$ 2）时钟频率减半时的总线频率为(66/7)/2MHz，因数据块大小不变，因此总线宽度仍为48B，传输速率为 $\begin{array}{r}{48\mathrm{B}{\times}33/7\mathrm{MHz}=226.3\mathrm{MB/s}.}\end{array}$ 注意总线周期和时钟周期的联系与区别，总线周期通常由多个时钟周期组成。  

02.【解答】  

1）读操作的时钟周期数： $1+2+4=7$ 对应的频率：100MHz/7总线宽度： $6{\times}4\mathrm{B}=24\mathrm{B}$ 所以数据传输速率 $=$ 总线宽度/读取时间 $=\!24\!\times\!(100\mathrm{MHz}/7)=343\mathrm{MB}/\mathrm{s}\,.$  

2）写操作的时钟周期数： $1+1+4=6$ 对应的频率： $100\mathrm{MHz}/6$ 总线宽度： $6{\times}4\mathrm{B}=24\mathrm{B}$ 所以数据传输速率 $=$ 总线宽度/写操作时间 $=24{\times}(100{\mathrm{MHz}}/6)=400{\mathrm{MB}}/{\mathrm{s}}$  

3）平均传输速率 $=343{\times}70\%+400{\times}30\%=360.1\mathrm{MB/s}.$  
# 6.2 总线事务和定时  

# 6.2.1总线事务  

从请求总线到完成总线使用的操作序列称为总线事务，它是在一个总线周期中发生的一系列活动。典型的总线事务包括请求操作、仲裁操作、地址传输、数据传输和总线释放。  

1）请求阶段。主设备（CPU或DMA）发出总线传输请求，并且获得总线控制权。2）仲裁阶段。总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者。3）寻址阶段。主设备通过总线给出要访问的从设备地址及有关命令，启动从模块。4）传输阶段。主模块和从模块进行数据交换，可单向或双向进行数据传送，5）释放阶段。主模块的有关信息均从系统总线上撤除，让出总线使用权。  

# 命题追踪非突发传送的时间分析（2023）  

总线上的数据传送方式分为非突发方式和突发方式两种。非突发传送方式在每个传送周期内都先传送地址，再传送数据，主、从设备之间通常每次只能传输一个字长的数据。  

# 命题追踪突发传送的概念（2014），突发传送的时间分析（2012、2013）  

突发（发）传送方式能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线。  

# 6.2.2总线定时  

总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步、异步、半同步和分离式四种定时方式。  

# 命题追踪各种总线定时方式的特点（2015、2021）  

# 1.同步定时方式  

所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。  

优点：传送速度快，具有较高的传输速率：总线控制逻辑简单。缺点：主从设备属于强制性同步：不能及时进行数据通信的有效性检验，可靠性较差同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。  

同步串行通信方式是发送方时钟直接控制接收方时钟，使双方完全同步的一种逐位传输的通信方式。使用同步串行通信时，由于收发双方的时钟严格一致，因此仅在数据块的头尾处添加了开始和结束标记，传输效率较高，但实现的硬件设备也更复杂，所以较少采用。  

# 2.异步定时方式  

在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。  
优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。  

缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下3种类型。  

1）不互锁方式。主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。双方不存在互锁关系，如图6.4(a)所示。  

2）半互锁方式。主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图6.4(b)所示。  

3）全互锁方式。主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号；从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系，如图6.4（c)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e30f9589c45b2a57c15931e592518bb215f20b47d5abf20d0fd0e062b8376d2f.jpg)  
图6.4请求和回答信号的互锁  

# 命题追踪异步串行通信方式的特点（2016）  

现在越来越多的总线采用异步串行通信方式，使用异步串行通信时，由于收发双方时钟不严格一致，因此每个字符都要用开始位和停止位作为字符开始和结束的标志，从而保证数据传输的准确性。异步事行通信的第一位是开始位，表示字符传送的开始。当通信线上没有数据传送时处于逻辑“1”状态，当发送方要发送一个字符时，首先发出一个逻辑“0”信号，即开始位。接收方检测到这个逻辑低电乎后，就开始准备接收数据位。在字符传送过程中，数据位从最低位开始，一位一位地传输。当字符发送完后，就可以发送奇偶校验位（可选），以用于有限的差错检测。在奇偶位或数据位之后发送的是停止位，表示一个字符数据的结束。  

# 3.半同步定时方式  

半同步定时方式保留了同步定时的特点，如所有地址、命令、数据信号的发出时间都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别：同时，又像异步定时那样，允许不同速度的设备和谐地工作。为此增设一条Wait响应信号线。例如，某个半同步总线总是从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效，再去数据线上取数据。半同步定时适用于系统工作速度不高，但又包含了由许多速度差异较大的各类设备组成的简单系统。  

优点：控制方式比异步定时简单，各模块在系统时钟的控制下同步工作，可靠性较高。缺点：系统时钟频率不能要求太高，所以从整体上来看，系统工作的速度不是很高。  

以上三种定时方式都从主设备发出地址和读/写命令开始，直到数据传输结束，在整个传输周期中，总线的使用权完全由主设备及由其选中的从设备占据。其实，从设备在准备数据的阶段，总线纯属空闲等待，为进一步挖掘总线的潜力，又提出了分离式定时方式。  
# 4.分离式定时方式  

分离式定时方式将总线事务分解为请求和应答两个子过程。在第一个子过程中，主设备A获得总线使用权后，将命令、地址等信息发到总线上，经总线传输后由从设备B接收。此过程占用总线的时间很短，主设备一且发送完，立即释放总线，以便其他设备使用。在第二个子过程中，设备B收到设备A发来的有关命令后，将设备A所需的数据准备好后，便由设备B申请总线使用权，一旦获准，设备B便将相应的数据送到总线上，由设备A接收。上述两个子过程都只有单方向的信息流，每个设备都变为主设备。  

优点：在不传送数据时释放总线，使总线可接受其他设备的请求，不存在空闲等待时间  

缺点：控制复杂，开销也大。  

# 6.2.3 本节习题精选  

# 一、单项选择题  

01.在不同速度的设备之间传送数据，（）  

A.必须采用同步控制方式B.必须采用异步控制方式C.可以选用同步控制方式，也可选用异步控制方式D.必须采用应答方式  

02.某机器1/0设备采用异步串行传送方式传送字符信息，字符信息格式为1位起始位、7位数据位、1位校验位和1位停止位。若要求每秒传送480个字符，则该设备的数据传输速率为（)。  

A.  $380\mathsf{b}/\mathrm{s}$  B.4800B/s C.480B/s D.4800b/s  

03.假设某存储器总线采用同步通信方式，时钟频率为 $50\,\mathrm{MHz}$ ，总线以突发方式传输8个字，以支持块长为8字（每字4B）的Cache行的读/写。若全部访问都为读操作，访问顺序是1个时钟周期接收地址，3个时钟周期等待存储器读数，8个时钟周期用于传输8个字。则该存储器的数据传输速率为（）。  

A.114.3MB/s B.126MB/s C.133.3MB/s D.144.3MB/s  

04.同步控制方式是（）  

A.只适用于CPU控制的方式B.只适用于外部设备控制的方式C.由统一的时序信号控制的方式D.所有指令执行时间都相同的方式  

05.同步通信之所以比异步通信具有较高的传输速率，是因为（）。  

A.同步通信不需要应答信号且总线长度较短B.同步通信用一个公共的时钟信号进行同步C.同步通信中，各部件的存取时间较接近D.以上各项因素的综合结果  

06.以下各项中，（）是同步传输的特点。  

A.需要应答信号B.各部件的存取时间比较接近C.总线长度较长 D.总线周期长度可变  

07.在异步总线中，传送操作（）  

A.由设备控制器控制B.由CPU控制C.由统一时序信号控制D.按需分配时间  
08.总线的异步通信方式是（）  

A.既不采用时钟信号，又不采用“握手”信号B.只采用时钟信号，不采用“握手”信号C.不采用时钟信号，只采用“握手”信号D.既采用时钟信号，又采用“握手”信号  

09.在各种异步通信方式中，（）的速度最快。A.全互锁 B.半互锁 C.不互锁 D.速度均相等

 10.在下列各种情况下，最应采用异步传输方式的是（）  

A.I/O接口与打印机交换信息B.CPU与主存交换信息C.CPU和PCI总线交换信息D.由统一时序信号控制方式下的设备  

11.在手术过程中，医生将手伸出，等护士将手术刀递上，待医生握紧后，护士才松手。若把医生和护士视为两个通信模块，上述动作相当于（）。  

A.同步通信B.异步通信的全互锁方式C.异步通信的半互锁方式D.异步通信的不互锁方式  

12.一个总线传输周期依次包括以下几个阶段（）  

$\textcircled{\scriptsize{1}}$ ．握手阶段 $\circledcirc$ ．寻址阶段 $\textcircled{3}$ ，申请分配阶段 $\textcircled{4}$ ，传输阶段A.  ${\mathfrak{Q}}{\mathfrak{Q}}{\mathfrak{Q}}{\mathfrak{Q}}{\mathfrak{Q}}{\mathfrak{Q}}$  B.  ${\mathcal{Q}}(3)\!{\mathrm{(4)}}$  C.   ${\mathfrak{Q}}{\mathfrak{Q}}{\mathfrak{Q}}$  D.  $\textcircled{\textcircled{2}}\textcircled{\textcircled{3}}$  

13.【2012统考真题】某同步总线的时钟频率为 $100\mathrm{MHz}$ ，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（）。  

A. 20ns B.40ns C. 50ns D.80ns  

14.【2014统考真题】一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据。这种总线事务方式称为（）。  

A．并行传输 B．串行传输 C.突发传输 D.同步传输

 15.【2015统考真题】下列有关总线定时的叙述中，错误的是（）。  

A.异步通信方式中，全互锁协议最慢B.异步通信方式中，非互锁协议的可靠性最差C.同步通信方式中，同步时钟信号可由各设备提供D.半同步通信方式中，握手信号的采样由同步时钟控制  

16.【2016统考真题】下列关于总线设计的叙述中，错误的是（）  

A.并行总线传输比串行总线传输速度快B.采用信号线复用技术可减少信号线数量C.采用突发传输方式可提高总线数据传输速率D.采用分离事务通信方式可提高总线利用率  

17.【2017统考真题】下列关于多总线结构的叙述中，错误的是（）  

A.靠近CPU的总线速度较快B.存储器总线可支持突发传送方式C.总线之间须通过桥接器相连D.PCI-Express $\times16$ 采用并行传输方式  

18.【2018统考真题】下列选项中，可提高同步总线数据传输速率的是（）。  

1.增加总线宽度II.提高总线工作频率III.支持突发传输IV.采用地址/数据线复用A.仅I、IⅡIB.仅I、ⅡI、IⅢIC.仅IⅢI、IVD.I、ⅡI、ⅢI和IV  

19.【2021统考真题】下列关于总线的叙述中，错误的是（）A.总线是在两个或多个部件之间进行数据交换的传输介质B.同步总线由时钟信号定时，时钟频率不一定等于工作频率C.异步总线由握手信号定时，一次握手过程完成一位数据交换D.突发（Burst）传送总线事务可以在总线上连续传送多个数据  
20.【2023统考真题】某存储器总线宽度为64位，总线时钟频率为1GHz，在总线上传输一个数据或地址需要一个时钟周期，不支持突发传送方式。若通过该总线连接CPU和主存，主存每次准备一个64位数据需要6ns，主存块大小为32B，则读取一个主存块所需的时间是（）。  

A. 8ns B.1lns C. 26ns D.32ns  

# 二、综合应用题  

01.在异步串行传输方式下，起始位为1位，数据位为7位，偶校验位为1位，停止位为1位，假设每秒传输1200比特，试问有效数据传输速率为多少？  

# 6.2.4 答案与解析  

# 一、单项选择题  

01. C  

在不同速度的设备之间传送数据时，既可采用同步方式，又可采用异步方式。异步方式主要用于在不同的设备间进行通信，两种速度不同的设备使用同一时钟进行控制时，采用同步控制方式同样可以进行数据的传送，但不能发挥快速设备的高速性能。  

02.D 一个字符占用 $1+7+1+1=10$ 位，因此数据传输速率为 $10{\times}480=4800$ 位/秒。  

03.C  

一次总线事务传输的数据量为 ${\bf8}{\times}4{\bf B}=32{\bf B}$ ，所需时钟周期数为 $1+3+8=12$ ，每个时钟周期为1/50MHz，总时间为 $12\!\times\!(1/50\mathrm{MHz})\!=\!0.24\mathrm{s},$ 。数据传输速率为 $32\mathrm{B}{\cdot}[(12{\times}(1/50\mathrm{MHz}))\mathrm{s}]=133.3\mathrm{MB/s}{\cdot}$  

04.C  

同步控制是指由统一时序控制的通信方式，同步通信采用公共时钟，有统一的时钟周期。同步控制既可用于CPU控制，又可用于高速的外部设备控制。  

05.D  

同步通信采用统一的时钟，每个部件发送或接收信息都在固定的总线传送周期中，一个总线传送周期结束，开始下一个总线传送周期。它适用于总线长度较短且各部件的存取时间较接近的情况，因此具有较高的传输速率。选项A、B、C都是正确原因。  

06. B 各部件的存取时间比较接近时，最适合采用同步传输，以发挥其优势。  

07.D  

异步总线即采用异步通信方式的总线。在异步方式下，没有公用的时钟，完全依靠传送双方相互制约的“握手”信号来实现定时控制。传送操作是由双方按需求分配时间的。  

08.C 异步通信方式也称应答方式，没有公用的时钟信号，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。  

09.C 在全互锁、半互锁和不互锁三种“握手”方式中，只有不互锁方式的请求信号和回答信号没有相互的制约关系，主设备发出请求信号后，不必等待回答信号的到来，便自己撤销了请求信号，所以速度最快。  
10.A  

异步通信方式依靠“握手”信号来实现定时控制，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换。1/O接口与打印机的速度差异较大，应采用异步传输方式。  

11.B  

由题意可知，医生是主模块，护士是从模块。医生伸出手后（即主模块发出请求信号），等待护士将手术刀递上（主模块等待来自从模块的回答信号），护士也必须等待医生握紧后才松开手（从模块等待主模块的回答信号），以上整个流程就是异步通信的全互锁方式。  

12.B  

总线的传输周期分为寻址阶段、申请分配阶段、传输阶段。  

13.C  

由于总线频率为 $100\mathrm{MHz}$ ，因此时钟周期为 $10\mathrm{ns}$ 。总线位宽与存储字长都是32位，因此每个时钟周期可传送一个32位存储字。发式发送可以连续传送地址连续的数据，因此总传送时间为：传送地址 $10\mathrm{ns}$ ，传送128位数据 $40\mathrm{ns}$ ，共需50nS。  

14.C  

猝发（突发）传输是在一个总线周期中，可以传输多个存储地址连续的数据，即一次传输一个地址和一批地址连续的数据，并行传输是在传输中有多个数据位同时在设备之间进行的传输，串行传输是指数据的二进制代码在一条物理信道上以位为单位按时间顺序逐位传输的方式，同步传输是指传输过程由统一的时钟控制。  

15.C  

在同步通信方式中，系统采用一个统一的时钟信号，而不由各设备提供，否则无法实现统一的时钟。  

16.A  

初看起来会觉得A正确，并行总线通常比串行总线传输速率快，但这不是绝对的。在时钟频率较低的情况下，并行总线因为可以同时传输若干比特，速率确实比串行总线快。但是，随着技术的发展，时钟频率越来越高，并行总线之间的相互干扰越来越严重，当时钟频率提高到一定程度时，传输的数据已无法恢复。而事行总线因为导线少，线间干扰容易控制，反而可通过不断提高时钟频率来提高传输速率，A错误。总线复用是指一种信号线在不同的时间传输不同的信息，它可使用较少的线路传输更多的信息，从而节省空间和成本，B正确。突发传输是指在一个总线周期中，可以传输多个存储地址连续的数据，即一次传输一个地址和一批地址连续的数据，C正确。分离事务通信是总线复用的一种，相比单一的传输线路可以提高总线的利用率，D正确。  

17.D  

多总线结构用速率高的总线连接高速设备，用速率低的总线连接低速设备。一般来说，CPU是计算机的核心，是计算机中速度最快的设备之一，A正确。突发传送方式把多个数据单元作为一个独立传输处理，从而最大化设备的吞吐量。现实中一般用支持突发传送方式的总线来提高存储器的读/写效率，B正确。各总线通过桥接器相连，后者起流量交换作用。PCI-Express总线都采用串行数据包传输数据。  

18.B  

总线数据传输速率 $=$ 总线工作频率 $\times($ 总线宽度/8），所以工和ⅡI会影响总线数据传输速率。采用突发（猝发）传输方式，可在一个总线周期内传输存储地址连续的多个数据字，因此能提高传输效率。采用地址/数据线复用只是减少了线的数量，节省了成本，并不能提高传输速率。  
19.C  

总线是在两个或多个设备之间进行通信的传输介质，A正确。同步总线是指总线通信的双方采用同一个时钟信号，但是一次总线事务不一定在一个时钟周期内完成，即时钟频率不一定等于工作频率，B正确。异步总线采用握手的方式进行通信，每次握手的过程完成一次通信，但是一次通信往往会交换多位而非一位数据，C错误。突发传送总线事务是指发送方在传输完地址后，连续进行若干次数据的发送，D正确。  

20.D  

每次传输需经过传输地址、准备数据和传输数据三个过程，分别需要1ns（时钟频率为1GHz，因此时钟周期为1ns）、6ns和1ns，共8ns。总线宽度为64位，所以每次传输的数据为64位，主存块大小为32B，所以读取一个主存块需要传输4次，即 ${\tt8n s}{\times}4=32{\tt n s}$  

# 二、综合应用题  

01.【解答】  

在这样的一个数据帧中，有效数据位是7位，传输过程中发送的代码位共有 $1+7+1+1=10$ 位，所以有效数据传输速率为 $1200\!\times\!7\!\div\!(1+7+1+1)=840{\tt b}/{\tt s}\,\circ$  

# 6.3 本章小结  

本章开头提出的问题的参考答案如下。  

1）引入总线结构有什么好处？  

引入总线结构主要有以下优点： $\textcircled{\scriptsize{1}}$ 简化了系统结构，便于系统设计制造。 $\circledcirc$   $\textcircled{3}$ 便于接口设计，所有与总线连接的设备均采用类似的接口。 $\textcircled{4}$ 便于系统的扩充、更新与灵活配置，易于实现系统的模块化。 $\circledast$ 便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。 $^\mathrm{\textregistered}$ 便于故障诊断和维修，同时也能降低成本。  

2）引入总线会导致什么问题？如何解决？  

引入总线后，总线上的各个设备分时共享同一总线，当总线上多个设备同时请求使用总线时就会导致冲突。为解决多个设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备获得总线控制权，只有获得了总线控制权的设备才能开始数据传送。  

# 6.4常见问题和易混淆知识点  

1.一个总线在某一时刻可以有多对主从设备进行通信吗？  

不可以。在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信（即一对一的关系），或对所有设备进行广播通信（即一对多的关系）。所以一个总线在某一时刻不能有多对主从设备进行通信，否则会发生数据冲突。  
# 第7章输入/输出系统  

# 【考纲内容】  

（一）I/O接口（I/O控制器）I/O接口的功能和基本结构；1/O端口及其编址  

（二）10方式  

程序查询方式程序中断方式：中断的基本概念；中断响应过程；中断处理过程：多重中断和中断屏蔽的概念 DMA方式：DMA控制器的组成：DMA传送过程  

# 【复习提示】  

1/O方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考查，特别是各种17O方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA方式的特点、传输过程、与中断方式的区别等。  

在学习本章时，请读者思考以下问题：1）I/O设备有哪些编址方式？各有何特点？2）CPU响应中断应具备哪些条件？请读者在学习本章的过程中寻找答案，本章末尾将给出参考答案。  

#  $\mathbf{\lambda}^{*7.1}$ I/O系统基本概念  

#  $^{*7.1.1}$ 输入/输出系统  

输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。  

I/O系统中的几个基本概念如下：  

1）外部设备。包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。2）接口。在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件。协调包括传输过程中速度的匹配、电平和格式转换等。3）输入设备。用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。  
4）输出设备。用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。  

5）外存设备。指除计算机内存及CPU缓存等外的存储器，如硬磁盘、光盘等。一般来说，1/O系统由1/O软件和I/O硬件两部分构成：  

$\mathrm{I}/\mathrm{O}$  指令实现CPU与I/O设备的信息交换。2）I/O硬件。包括外部设备、设备控制器和接口、I/0总线等。通过设备控制器来控制I/O设备的具体动作；通过1/0接口与主机（总线）相连。  

#  $^{*7.1.2}$ 1/0控制方式  

在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的1/O控制方式，基本的控制方式主要有以下四种：  

1）程序查询方式。由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息。2）程序中断方式。只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。3）DMA方式。主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无须调用中断服务程序。4）通道方式。在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/0命令时，只需启动有关通道，通道将执行通道程序，从而完成I/O操作。其中，方式1和方式2主要用于数据传输速率较低的外部设备，方式3和方式4主要用于数居传输速率较高的设备。  

#  $\mathbf{\ast7.1}\mathbf{.3}$ 外部设备  

最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。  

# 1.输入设备  

（1）键盘 键盘是最常用的输入设备，通过它可发出命令或输入数据。  

(2）鼠标 鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。  

# 2.输出设备  

（1）显示器  

（LED）显示器等。显示器属于用点阵方式运行的设备，有以下主要参数。1）屏幕大小：以对角线长度表示，单位为英寸，常用的有 $12\!\sim\!32$ 英寸等。2）分辨率：能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示，如 $800{\times}600$ 、 $1024\!\times\!768$ 和 $1280\!\times\!1024$ 等。3）灰度级：指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真，典型的有8位（256级）、16位等。4）刷新：光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。5）刷新频率：指单位时间内扫描整个屏幕内容的次数。按照人的视觉生理，刷新频率大于 $30\mathrm{Hz}$ 时才不会感到闪烁，通常显示器的刷新频率为 $60{\sim}120\mathrm{Hz}$  
6）显示存储器（VRAM）：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。  

VRAM容量 $=$ 分辨率×灰度级位数VRAM带宽  $=$  分辨率×灰度级位数×帧频  

（2）打印机  

用于将计算机的处理结果打印在相关介质上。按工作方式，打印机可分为点阵打印机、针式  

打印机、喷墨式打印机、激光打印机等。1）针式打印机。针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。2）喷墨式打印机。彩色喷墨打印机基于三基色原理，即分别喷射三种颜色的墨滴，按一定的比例混合出所要求的颜色。喷墨式打印机可实现高质量彩色打印。3）激光打印机。计算机输出的二进制信息，经过调制后转换为激光束，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。激光打印机打印质量高、速度快、处理能力强，它是将激光技术和电子显像技术相结合的产物。  

3.外部存储器（辅存）  

（1）磁表面存储器  

所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。  

（2）固态硬盘（SSD）  

微小型高档笔记本电脑采用高性能Flash存储器作为硬盘来记录数据，这种“硬盘”称为固态硬盘（SSD）。固态硬盘除需要Flash存储器外，还需要其他硬件和软件的支持。  

（3）光盘存储器  

光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触方式记录信息。完整的光盘存储系统由光盘片、光盘驱动器、光盘控制器等组成。  

#  $\mathbf{\ast7.1.4}$ 本节习题精选  

单项选择题  

01.在微型机系统中，I/0设备通过（）与主板的系统总线相连接。  

A.DMA控制器B.设备控制器C.中断控制器D.I/O端口  

02.显示汉字采用点阵字库，若每个汉字用 $16\!\times\!16$ 的点阵表示，7500个汉字的字库容量是（）。  

A.16KB B.240KB C.320KB D.1MB  

03.CRT的分辨率为 $1024\!\times\!1024$ 像素，像素的颜色数为256，则刷新存储器的每单元字长为（），总容量为（）。  

A.8B，256MBB.8bit,1MBC.8bit,256KBD.8B，32MB  

04.【2010统考真题】假定一台计算机的显示存储器用DRAM芯片实现，若要求显示分辨率 为 $1600\!\times\!1200$ ，颜色深度为24位，帧频为 $85\mathrm{Hz}$ ，显存总带宽的 $50\%$ 用来刷新屏幕，则需要的显存总带宽至少约为（）。  

A.245Mb/s B.979Mb/s C.1958Mb/s D.7834Mb/s  
#  $\mathbf{\ast7.1.5}$  答案与解析  

# 单项选择题  

01.B  

I/O设备不可能直接与主板总线相连，它总是通过设备控制器来相连的。  

02.B 每个汉字占用 $16\!\times\!16/8=32\mathrm{B}$ ，则汉字库容量 $\mathbf{\Sigma}=7500{\times}32\mathbf{B}=240000\mathbf{B}\approx240\mathbf{K}\mathbf{B}.$  

03.B  

刷新存储器中存储单元的字长取决于显示的颜色数，颜色数为 $m$ ，字长为 $n$ ，二者的关系为 $2^{n}\!=\!m$ 。本题中的颜色数为 $256=2^{8}$ ，因此刷新存储器单元字长为8位。刷新存储器的容量是每个像素点的位数和像素点个数的乘积，因此刷新存储器的容量为 $1024{\times}1024{\times}8\mathrm{bit}=1\mathrm{MB}$  

04.D  

刷新所需带宽 $=$ 分辨率 $\times$ 色深 $\times$ 顺频 $=1600{\times}1200{\times}24{\mathrm{bit}}{\times}85{\mathrm{Hz}}=3916.8{\mathrm{M}}{\mathrm{b}}/{\mathrm{s}}$ ，显存总带宽的 $50\%$ 用来刷新屏幕，于是需要的显存总带宽至少为 $3916.8/0.5=7833.6\mathrm{M}\mathrm{b}/\mathrm{s}\approx7834\mathrm{M}\mathrm{b}/\mathrm{s}.$  

# 7.2I/O 接口  

1/0接口（也称1/O控制器）是主机和外设之间的交接界面，通过接口可以实现主机和外设之向的信息交换。外设种类繁多，且具有不同的工作特性，它们在工作方式、数据格式和工作速度等方面有着很大的差异，接口正是为了解决这些差异而设置的。  

# 7.2.1I/O接口的功能  

# 命题追踪I/O接口的定义与特性（2021）  

I/O接口的主要功能如下：  

1）进行地址译码和设备选择。CPU送来选择外设的地址码后，接口必须对地址进行译码以2）实现主机和外设的通信联络控制。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。3）实现数据缓冲。CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。4）信号格式的转换。外设与主机两者的电平、数据格式都可能存在差异，接口应提供主机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。  

5）传送控制命令和状态信息。CPU要启动某外设时，通过接口中的命令寄存器向外设发出启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给CPU。外设向CPU提出中断请求时，CPU也应有相应的响应信号反馈给外设。  

# 7.2.2I/O接口的基本结构  

命题追踪I/O端口与CPU交换的内容（2015）图7.1所示是一个I/O接口的通用结构，I/O接口在主机侧通过 $\mathrm{I}/\mathrm{O}$ 总线与内存、CPU相连。  
数据缓冲寄存器用来暂存与CPU或内存之间传送的数据信息，状态寄存器用来记录接口和设备的状态信息，控制寄存器用来保存CPU对外设的控制信息。状态寄存器和控制寄存器在传送方向上是相反的，在访问时间上也是错开的，因此可将它们合二为一。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75e5c6546b9bbbf454e784b0b1efb00c038b494907e65ad7039f2432158a0fc4.jpg)  
图7.1I/0接口的通用结构  

# 命题追踪I/O接口的数据线上传输的内容（2012）  

I/O接口中的数据线传送的是读/写数据、状态信息、控制信息和中断类型号。地址线传送的是要访问I/O接口中的寄存器的地址。控制线传送的是读/写控制信号，以确认是读寄存器还是写寄存器，此外控制线还会传送中断请求和响应信号、仲裁信号和握手信号。  

1/0接口中的1/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。  

对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令，1/O指令只能在操作系统内核的底层1/O软件中使用，它们是一种特权指令。  

# 7.2.3I/O接口的类型  

从不同的角度看，1/0接口可以分为不同的类型。  

1）按数据传送方式（外设和接口一侧），可分为并行接口（一字节或一个字的所有位同时传送）和串行接口（一位一位地有序传送），接口要完成数据格式的转换。2）按主机访问I/O设备的控制方式，可分为程序查询接口、中断接口和DMA接口等。3）按功能选择的灵活性，可分为可编程接口（通过编程改变接口功能）和不可编程接口。  

# 7.2.41/O端口及其编址  

# 命题追踪I/O端口的定义及相关特性（2014）  

I/O端口是指I/O接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口。通常，CPU能够对数据端口中的数据进行读/写操作；但对状态端口中的外设状态只能进行读操作，对控制端口中的各种控制命令只能进行写操作。  

# 注意  

端口和接口是两个不同的概念，端口是指接口电路中可以进行读/写的寄存器。  
I/O端口要想能够被CPU访问，就必须要对各个端口进行编址，每个端口对应一个端口地址。而对I/O端口的编址方式有与存储器独立编址和统一编址两种。  

（1）独立编址  

# 命题追踪I/O指令的作用（2017）  

独立编址也称1/O映射方式，是指对所有的1/0端口单独进行编址。1/0端口的地址空间与主存地址空间是两个独立的地址空间，它们的范围可以重叠，相同地址可能属于不同的地址空间。因此需设置专门的1/O指令来表明访向的是1/0地址空间，1/0指令的地址码给出1/O端口号。  

优点：1/0端口数比主存单元数少得多，只需少量地址线，使得1/O端口译码简单，寻址速度更快。使用专用1/O指令，可使得程序更加清晰，便于理解和检查。  

缺点：I/O指令少，只提供简单的传输操作，所以程序设计的灵活性较差。此外，CPU需要提供存储器读/写、I/O设备读/写两组控制信号，增大了控制的复杂性。  

(2）统一编址  

统一编址也称存储器映射方式，是指把主存地址空间分出一部分给I/O端口进行编址，I/O端口和主存单元在同一地址空间的不同分段中，根据地址范围就能区分访问的是1/O端口还是主存单元，因此无须设置专门的1/O指令，用统一的访存指令就可访问1/0端口。  

优点：不需要专门的IO指令，使得CPU访问I/O的操作更加灵活和方便，还使端口有较大的编址空间。1/O访问的保护机制可由虚拟存储管理系统来实现，无须专门设置。  

缺点：端口地址占用了部分主存地址空间，使主存可用容量变小。此外，由于在识别1/O端口时全部地址线都需要参加译码，使得译码电路变得更复杂，降低了译码速度。  

# 7.2.5本节习题精选  

# 单项选择题  

01.在统一编址的方式下，区分存储单元和1/0设备是靠（）  

A.不同的地址码B.不同的地址线C.不同的控制线D.不同的数据线  

02.下列功能中，属于I/O接口的功能的是（）  

I.数据格式的转换IL.I/O过程中错误与状态检测IⅢI.I/O操作的控制与定时IV.与主机和外设通信A.I和IVB.I、IⅢ和IVC.I、ⅡI和IVD.I、ⅡI、Ⅲ和IV  

03.下列关于I/O端口和接口的说法中，正确的是（）  

A.按照不同的数据传送格式，可将接口分为同步传送接口和异步传送接口B.在统一编址方式下，存储单元和I/O设备是靠不同的地址线来区分的C.在独立编址方式下，存储单元和I/O设备是靠不同的地址线来区分的D.在独立编址方式下，CPU需要设置专门的输入/输出指令访问端口  

04.下列属于1/0接口中寄存器的有（）  

I.指令寄存器II.控制寄存器III.状态寄存器V.数据缓冲寄存器IV.地址寄存器A.I、IⅡI、IⅢI和VB.ⅡI、IⅢI和IVC.ⅡI、IⅢI和VD.IⅡI、IⅢI、IV和V  

05.I/0的编址方式采用统一编址方式时，进行输入/输出的操作的指令是（）。A.控制指令 B.访存指令 C.输入/输出指令D.都不对  
06.下列关于1/0指令的说法中，错误的是（）。  

A.I/O指令是CPU系统指令的一部分B.I/O指令是机器指令的一类C.I/O指令反映CPU和I/O设备交换信息的特点D.I/O指令的格式和通用指令的格式相同  

07.下列叙述中，正确的是（）  

A.只有I/O指令可以访问1/O设备B.在统一编址下，不能直接访问1/O设备C.访问存储器的指令一定不能访问I/O设备D.只有在具有专门I/O指令的计算机中，I/O设备才可以单独编址  

08.在内存地址空间与接口地址空间统一编址的计算机中，不需要的指令是（）  

A.数据传送类（如MOV指令）B：算术、逻辑运算类（如ADD、SUB、AND和OR指令）C.输入/输出类（如IN和OUT指令）D.程序控制类（如条件转移指令和子程序调用指令）  

09.在统一编址的情况下，就I/O设备而言，其对应的I/O地址不可取的是（）  

A.要求固定在地址高端B.要求固定在地址低端C.要求相对固定在地址的某部分D.可以随意在地址的任何地方  

10.磁盘驱动器向盘片磁道记录数据时采用（）方式写入。A.并行B.串行C.并行-串行D.串行-并行

11.程序员进行系统调用访问设备使用的是（）A.逻辑地址B.物理地址C.主设备地址D.从设备地址

12.采用中断方式进行打印控制时，在打印控制接口和打印机之间交换的信息不包括（）  

A.打印字符点阵信息B.打印控制信息C.打印机状态信息D.中断请求信号  

13.主机和外设之间的正确连接通路是（）  

A.CPU和主存一I/O总线一通信总线（电缆）一I/O接口一外设 B.CPU和主存一I/O总线一I/O接口一通信总线（电缆）一外设 C.CPU和主存一I/O接口一I/O总线一通信总线（电缆）一外设 D.CPU和主存一I/O接口一通信总线（电缆）一I/O总线一外设  

14.下列有关I/0接口功能和结构的叙述中，错误的是（）  

A.I/O接口中主机侧数据宽度与设备侧数据宽度总是一样的B.I/O接口是像显卡或网卡之类的一种外设控制逻辑C.CPU可以从I/O接口读取状态信息，以了解接口和外设的状态D.CPU可以向I/O接口传送用来对设备进行控制的命令  

15.【2012统考真题】下列选项中，在1/0总线的数据线上传输的信息包括（）I.IO接口中的命令字II.I/O接口中的状态字IⅢI.中断类型号A.仅I、ⅡIB.仅I、IIIC.仅II、IIID.I、Ⅱ、IⅢI

16.【2014统考真题】下列有关1/0接口的叙述中，错误的是（）  

A.状态端口和控制端口可以合用同一个寄存器B.I/O接口中CPU可访问的寄存器称为I/O端口C.采用独立编址方式时，I/O端口地址和主存地址可能相同D.采用统一编址方式时，CPU不能用访存指令访问I/O端口  
17.【2017统考真题】1/0指令实现的数据传送通常发生在（）  

A.I/O设备和I/O端口之间B.通用寄存器和I/O设备之间C.I/O端口和I/O端口之间 D.通用寄存器和I/O端口之间  

18.【2021统考真题】下列选项中，不属于1/0接口的是（）。A.磁盘驱动器B.打印机适配器C.网络控制器D.可编程中断控制器  

# 7.2.6 答案与解析  

单项选择题  

01.A  

在统一编址的情况下，没有专门的I/O指令，因此用访存指令来实现I/O操作，区分存储单元和/0设备是靠它们各自不同的地址码。  

02.D  

I/O接口的功能有： $\textcircled{\scriptsize{1}}$ 选址功能、 $\circledcirc$ 传送命令功能、 $\textcircled{3}$ 传送数据功能、 $\textcircled{4}$ 反映I/O设备工作状态的功能。选项工可参考唐朔飞老师的《计算机组成原理》教材，为设置接口的原因之一，也是接口应具有的功能；选项Ⅱ属于 $^{(4)}$ ：选项IⅢ属于 $\mathcal{Q}$ ：选项IV属于 $\circledast$  

03.D  

D显然正确。按照不同的数据传送格式，可将接口分为并行接口和串行接口，A错误；在统一编址方式下，存储单元和I/O设备是靠不同的地址码而非地址线来区分的，B错误；在独立编址方式下，存储单元和IO设备是靠不同的指令来区分的，C错误。  

04.C IO接口中的寄存器主要有数据缓冲寄存器、控制寄存器和状态寄存器。  

05.B 统一编址时，直接使用指令系统中的访存指令来完成输入/输出操作；独立编址时，则需要使用专门的输入/输出指令来完成输入/输出操作。  

06.D  

I/O指令是指令系统的一部分，是机器指令的一类，但其为了反映与I/O设备交互的特点格式和其他通用指令相比有所不同。  

07.D  

在统一编址的情况下，访存指令也可访问I/O设备，A、B、C错误。在独立编址的方式下，访问I/O地址空间必须通过专门的I/O指令，D正确。  

08.C  

统一编址方式把I/O端口当作存储器的单元进行地址分配，CPU不需要设置专门的I/O指令（即输入/输出类指令），用统一的访存指令就可以访问1/O端口。  

09.D  

在统一编址方式下，指令靠地址码区分内存和I/O设备，若随意在地址的任何地方编址，将给编程造成极大的混乱，D错误。选项A、B、C的做法都是可取的。  

10.B 磁盘驱动器向盘片磁道记录数据时采用串行方式写入。  

11.A 物理地址是外部连接使用的，且是唯一的，它与“地址总线相对应”；而逻辑地址是内部和编程使用的，并不唯一。在内存中的实际地址就是所谓的“物理地址”，而逻辑地址就是用于逻辑段管理内存的，因此程序员使用逻辑地址访问设备。  
12.D  

对打印机的中断控制过程通常是：CPU先将需要打印的字符编码送到打印控制接口（也称打印适配器）中，打印控制接口再将字符编码转换为点阵信息，然后通过电缆传送到打印机，以控制打印针头在何处进行打印。同时，打印控制接口需要将“初始化”“选通”“自动走纸”等控制信息通过电缆传送到打印机，并通过电缆把打印机的“联机”“忙”“缺纸”等状态信号取到打印控制接口，以供CPU读取。中断请求信号是打印控制接口通过中断控制器发送给CPU的，因此不在打印控制接口和打印机之间进行交换，D错误。  

13.B  

CPU和主存通过I/O总线和I/O接口连接，I/O接口通过通信总线和外设相连。  

14.A  

I/O接口中主机侧通过1/O总线与主机相连，设备侧通过通信总线（电缆）与外设相连。显然，1/O总线中的数据线宽度和连接设备的电缆中的数据线宽度不一定相同。  

15. D  

1/O总线分为三类：数据线、控制线和地址线。数据缓冲寄存器和命令/状态寄存器的内容都是通过数据线来传送的：地址线用以传送与CPU交换数据的端口地址；而控制线用于给I/O端口发送读/写信号，仅用于对端口进行读/写控制。中断类型号用于指出中断向量的地址，CPU响应某一外部中断后，就从数据总线上获取该中断源的中断类型号，然后据此计算对应中断向量在中断向量表（存放在内存中）的位置。因此1、Ⅱ和Ⅲ均正确。  

16.D  

采用统一编址时，CPU访存和访问I/O端口用的是一样的指令，所以访存指令可访问I/O端口，D错误。其他三个选项均为正确陈述。  

17.D  

I/O端口是指I/O接口中用于缓冲信息的寄存器，由于主机和I/O设备的工作方式和工作速度有很大差异，I/O端口应运而生。在执行一条指令时，CPU使用地址总线选择所请求的I/O端口，使用数据总线在CPU寄存器和端口之间传输数据。  

18.A  

1/O接口即1/O控制器，其功能是接收主机发送的1/O控制信号，并实现主机和外部设备之间的信息交换。磁盘驱动器是由磁头、磁盘和读/写电路等组成的，也就是我们平常所说的磁盘本身，A错误。选项B、C和D均为I/O控制器。  

# 7.31/O 方式  

输入/输出系统实现主机与I/O设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的I/O方式有程序查询、程序中断和DMA等，其中前两种方式更依赖于CPU中程序指令的执行。  

# 7.3.1程序查询方式  

信息交换的控制直接由CPU执行程序实现。程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行1/O操作时，先读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。  
# 命题追踪程序查询方式的特点（2023）  

程序查询方式的工作流程如下（见图7.2）：  

$\textcircled{\scriptsize{1}}$ CPU执行初始化程序，并预置传送参数。 $\circledcirc$ 向1/O接口发出命令字，启动I/O设备。 $\textcircled{3}$ 从外设接口读取其状态信息。 $\textcircled{4}$  CPU周期或持续的查询设备状态，直到外设准备就绪。  $\circledast$ 传送一次数据。 $\circledcirc$ 修改地址和计数器参数。 $\circleddash$ 判断传送是否结束，若未结束转第 $\textcircled{3}$ 步，直到计数器为0。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fca58357301e2be2277f2fb06008bb5333a1276e5841ec4934610c16e8d988f0.jpg)  
图7.2程序查询方式流程图  

根据上述流程 $^{(4)}$ 中查询方式的不同，程序查询方式可分为如下两类。  

1）独占查询。一旦设备被启动，CPU就一直持续查询接口状态，CPU花费 $100\%$ 的时间用于I/O操作，此时外设和CPU完全事行工作。  

2）定时查询。CPU周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。定时查询的时间间隔与设备的数据传输速率有关。  

# 命题追踪定时查询的特点、效率分析及计算（2011、2018）  

【例7.1】假设计算机的主频为 ${500}\mathrm{MHz}$ ，CPI为4，某外设的数据率为2MB/s，I/O接口中有一个32位数据缓冲寄存器，采用定时查询方式，每次1/0都执行10条指令。外设最多间隔多长时间查询一次才能不丢失数据？CPU用于外设I/O的时间占CPU总时间的百分比至少是多少？  

解：  

由于端口大小有限，必须在外设传输完端口大小的数据时访问端口，以防止数据未被及时读取而丢失。外设准备32位数据所用的时间为 $4\mathrm{B}{\cdot}2\mathrm{MB/s}=2\upmu\mathrm{s}$ ，所以最多每隔 $2\upmu\mathrm{s}$ 就必须查询一次，即每秒的查询次数至少是 $1\mathrm{s}{\cdot}2\upmu\mathrm{s}=5{\times}10^{5}$ ，每秒CPU用于外设I/O的时间至少为 $5{\times}10^{5}{\times}10{\times}4$  $=2{\times}10^{7}$ 个时钟周期，占整个CPU时间的百分比至少是 $2{\times}10^{7}/500\mathbf{M}=4\%$  
程序查询方式的优点是设计简单、硬件量少。缺点是CPU要花费很多时间来查询和等待，且在一段时间内只能和一台外设交换信息，CPU与设备串行工作，效率很低。  

# 7.3.2程序中断方式  

# 1.程序中断的基本概念  

程序中断是指在计算机执行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，处理完毕后再返回到原程序的断点处，继续执行原程序。早期的中断技术是为了处理数据传送。  

# 命题追踪程序中断方式的特点（2022、2023）  

随着计算机的发展，中断技术不断被赋予新的功能，主要功能有：  

$\textcircled{\scriptsize{1}}$ 实现CPU与I/O设备的并行工作。 $\circledcirc$ 处理硬件故障和软件错误。 $\textcircled{3}$ 实现人机交互，用户干预机器需要用到中断系统。 $\textcircled{4}$ 实现多道程序、分时操作，多道程序的切换需借助于中断系统。 $\circledast$ 实时处理需要借助中断系统来实现快速响应。 $\textcircled{6}$ 实现应用程序和操作系统（管态程序）的切换，称为软中断。 $\circleddash$ 多处理器系统中各处理器之间的信息交流和任务切换。  

程序中断方式的思想：CPU在程序中安排好在某个时机启动某台外设，然后CPU继续执行当前的程序，不需要像查询方式那样一直等待外设准备就绪。一且外设完成数据传送的准备工作就主动向CPU发出中断请求。在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序。此时，外设和CPU又开始并行工作，如图7.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d801b68aeb041a5302c1291f1270babd69f5c5840e4f2e2e4063c194152b2d83.jpg)  
图7.3程序中断方式示意图  

# 命题追踪程序中断的效率分析及相关计算（2009、2014、2016、2018、2019）  

【例7.2】假定计算机的主频为 $500\mathrm{MHz}$ ，CPI为4，某外设的数据率为 $40\mathrm{MB/s}$ ，I/0接口中有一个32位数据缓冲寄存器。在中断I/O方式下，若每次中断响应和中断处理的总时钟周期数至少为400，则该外设能否采用中断1/0方式？为什么？  

解：  

中断响应和中断处理的时间为 $400{\times}1/500\mathbf{M}=0.8\upmu\mathrm{s}$ ，只需计算外设准备32位数据的时间，若准备数据的时间小于中断响应和中断处理的时间，则数据被刷新，造成丢失。外设准备32位数据所用的时间为 $4\mathrm{B}{\cdot}40\mathrm{MB}/\mathrm{s}=0.1\upmu\mathrm{s}$ ，因此该外设不适合采用中断I/O方式。  
# 2.程序中断的工作流程  

# 命题追踪  

# 中断工作流程中的相关细节（2017、2018、2021）  

（1）中断请求  

中断源是请求CPU中断的设备或事件，一台计算机允许有多个中断源。每个中断源向CPU发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器，当其状态为“1”时，表示该中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。  

# 命题追踪可屏蔽中断和不可屏蔽中断的特点（2020）  

通过INTR线发出的是可屏蔽中断，通过NMI线发出的是不可屏蔽中断。可屏蔽中断的优先级最低，在关中断模式下不被响应。不可屏蔽中断用于处理紧急和重要的事件，如时钟中断、电源掉电等，其优先级最高，其次是内部异常，即使在关中断模式下也被响应。  

（2）中断响应判优  

中断响应优先级是指CPU响应中断请求的先后顺序。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑来确定响应哪个中断源的请求，中断响应的判优通常是通过硬件排队器（或中断查询程序）实现的。  

一般来说， $\textcircled{\scriptsize{1}}$ 不可屏蔽中断 $>$ 内部异常 $>$ 可屏蔽中断； $\circledcirc$ 在内部异常中，硬件故障 $>$ 软件中断： $\textcircled{3}$ DMA中断请求 $>\,\mathrm{I/O}$ 设备的中断请求； $\textcircled{4}$ 在1/O传送类中断请求中，高速设备 $>$ 低速设备；输入设备 $>$ 输出设备；实时设备 $>$ 普通设备。  

# 注意  

中断优先级包括响应优先级和处理优先级，响应优先级由硬件线路或查询程序的查询顺序决定，不可动态改变。处理优先级可利用中断屏蔽技术动态调整，以实现多重中断。  

（3）CPU响应中断的条件  

CPU在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。CPU响应中断必须满足以下3个条件：  

$\textcircled{\scriptsize{1}}$ 中断源有中断请求。  

$\circledcirc$ CPU允许中断及开中断（异常和不可屏蔽中断不受此限制）。 $\textcircled{3}$ 一条指令执行完毕（异常不受此限制），且没有更紧道的任务。  

# 注意  

I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行结束时，采样中断请求信号（开中断的情况下），以获取I/O的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指1/0中断，异常不属于此类情况。  

# （4）中断响应过程  

CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，只是一种虚拟的说法，本质上是硬件的一系列自动操作。它所完成的操作如下：  

1）关中断。CPU响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过  
程中，CPU不能响应更高级中断源的中断请求。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。  

2）保存断点。为保证在中断服务程序执行完后能正确地返回到原来的程序，必须将原程序的断点（指令无法直接读取的PC和PSW的内容）保存在栈或特定寄存器中?。注意异常和中断的差异：异常指令通常并没有执行成功，异常处理后要重新执行，所以其断点通常是当前指令的地址。中断的断点则是下一条指令的地址。  

3）引出中断服务程序。识别中断源，将对应的服务程序入口地址送入程序计数器PC。有两种方法识别中断源：硬件向量法和软件查询法。本节主要讨论比较常用的向量中断。  

（5）中断向量  

中断识别分为向量中断和非向量中断两种。非向量中断即软件查询法，第5章已介绍。  

每个中断源都有一个唯一的类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，即中断向量，CPU必须找到入口地址。把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断尚量的存储区就称为中断向量表。  

# 命题追踪中断向量表的数据结构（2023）  

CPU响应中断后，通过识别中断源获得中断类型号，然后据此计算出对应中断向量的地址：再根据该地址从中断向量表中取出中断服务程序的入口地址，并送入程序计数器PC，以转去执行中断服务程序，这种方法被称为中断向量法，采用中断向量法的中断被称为向量中断。  

# 注意  

中断请求和响应信号是在IO总线的控制线上传送的。CPU响应某一中断后，就从数据线上获取该中断源的中断类型号，并据此计算对应中断向量在中断向量表中的位置。  

（6）中断处理过程  

不同计算机的中断处理过程各具特色，图7.4所示为一个可嵌套中断的典型处理流程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ab84db701920d4fe3e864b31bb3c16635e25ae9907717b89a42118448e2e3e09.jpg)  
图7.4可嵌套中断的处理流程  
中断处理流程如下：  

$\textcircled{\scriptsize{1}}$ 关中断。 $\circledcirc$ 保存断点。 $\textcircled{3}$ 中断服务程序寻址。  

$\textcircled{4}$ 保存现场和屏蔽字。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放程序执行到断点处的现行值。  

# 注意  

现场和断点，这两类信息都不能被中断服务程序破坏。由于现场信息用指令可直接访问，因此通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现。而断点信息由CPU在中断响应时自动保存到栈或指定的寄存器中，即由硬件实现。  

$\circledast$ 开T卧。儿计史向级中断请小付划响应，以关现中断联县。  

$^\mathrm{\textregistered}$ 执行中断服务程序。这是中断请求的目的。 $\circleddash$ 关中断。保证在恢复现场和屏蔽字时不被中断。 $\circledast$ 恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。 $\circledcirc$ 开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返到原程序的断点处，以便继续执行原程序。  

其中， $\textcircled{\scriptsize{1}}\!\sim\!\textcircled{\scriptsize{3}}$ 由中断隐指令（硬件自动）完成： $\textcircled{4}\!\sim\!\textcircled{9}$ 由中断服务程序完成。  

# 命题追踪单级中断的处理流程（2010）  

# 注意  

若是单重中断（或称单级中断），则在上述流程中去掉 $\circledast$ 和 $\circledast$ 即可。  

# 3.多重中断和中断屏蔽技术  

命题追踪多重中断的中断屏蔽字相关的性质（2017、2020、2021）  

在CPU执行中断服务程序的过程中，若又出现了新的优先级更高的中断请求，而CPU对新的中断请求不予响应，则称这种中断为单重中断，如图7.5（a）所示。若CPU暂停现行的中断服务程序，转去处理新的中断请求，则称这种中断为多重中断，也称中断嵌套，如图7.5b所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1d3d8beb712bf54344e3605d581c5a8d10e4944f258311c805ffa316f694c414.jpg)  
图7.5单重中断和多重中断示意图  

在图7.5（b）中，CPU在执行主程序时发生中断请求1，主程序未屏蔽任何中断，因此响应中断请求1，将主程序的断点压栈保存，然后转去执行中断服务程序1。在执行中断服务程序1时，又发生中断请求2，而其处理优先级比中断请求1的更高，此时须中止中断请求1的处理，响应中断请求2，将中断服务程序1的断点压栈保存，然后转去执行中断服务程序2。同样，拥有更高处理优先级的中断请求3可以打断中断请求2的处理。当中断请求3处理完后，CPU从栈顶取出断点信息，回到中断服务程序2的断点（ $\mathrm{K}3+1)$ ）处继续执行。以此类推，直到所有中断服务程序执行完毕，最终回到原程序的断点（ $.\mathrm{K}1+1)$ ）处继续执行主程序。  
CPU要具备多重中断的功能，必须满足下列条件：  

$\textcircled{\scriptsize{1}}$ 在中断服务程序中提前设置开中断指令。 $\circledcirc$ 优先级别高的中断源有权中断优先级别低的中断源。  

中断处理优先级是指多重中断的实际优先级处理次序，可以利用中断屏蔽技术动态调整，从而可以灵活地调整中断服务程序的优先级，使中断处理更加灵活。若不使用中断屏蔽技术，则处理优先级和响应优先级相同。现代计算机一般使用中断屏蔽技术，每个中断源都有一个屏蔽触发器（MASK），1表示屏蔽该中断源的请求，0表示可以正常请求，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。  

关于中断屏蔽字的设置及多重中断程序执行的轨迹，下面通过实例说明。  

【例7.3】设某机有4个中断源A、B、C、D，其硬件排队优先次序为 $\mathrm{A}\,{>}\,\mathrm{B}\,{>}\,\mathrm{C}\,{>}\,\mathrm{D}$ ，现要求将中断处理次序改为  $\mathrm{D}\,{>}\,\mathrm{A}\,{>}\,\mathrm{C}\,{>}\,\mathrm{B}$  ，写出每个中断源对应的屏蔽字。  

解：  

在中断处理次序改为 $\mathrm{D}\,{>}\,\mathrm{A}\,{>}\,\mathrm{C}\,{>}\,\mathrm{B}$ 后，D具有最高优先级，可以屏蔽其他所有中断，且不能中断自身，因此D对应的屏蔽字为1111；A具有次高优先级，只能被D中断，因此A对应的屏蔽字为1110，以此类推，得到4个中断源的屏蔽字，见表7.1。  

表7.1中断源对应的中断屏蔽字
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c51e363202806c9ac2a1ac35db7cc75e6bd5d697fae775c075ea07369b546fcc.jpg)  

从宏观上看，虽然程序中断方式克服了程序查询方式中CPU的等待现象，提高了CPU的利用率。但从微观操作分析，CPU在处理中断时，仍需暂停原程序的运行，尤其是当高速设备频繁成批地与主存交换信息时，需要不断打断CPU执行现行程序而去执行中断服务程序。  

# 7.3.3DMA方式  

DMA方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。DMA方式在外设与内存之间开辟了一条“直接数据通路”，信息传送不再经过CPU，降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。由于数据传送不经过CPU，因此不需要保护、恢复CPU现场等烦琐操作。  

这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。  

# 1.DMA方式的特点  

主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。  
DMA方式具有下列特点：  

1）它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。2）在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。3）主存中要开辟专用缓冲区，以及时提供和接收外设的数据。4）DMA传送速度快，CPU和外设并行工作，提高了系统效率。5）DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。  

# 2.DMA控制器的组成  

在DMA方式中，对数据传送过程进行控制的硬件称为DMA控制器（DMA接口）。当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。其主要功能如下：  

1）接受外设发出的DMA请求，并向CPU发出总线请求。2）CPU响应并发出总线响应信号，DMA接管总线控制权，进入DMA操作周期。3）确定传送数据的主存起始地址及长度，并自动修改主存地址计数和传送长度计数。4）规定数据在主存和外设间的传送方向，发出读/写等控制信号，执行数据传送操作。5）向CPU报告DMA操作结束。  

图7.6给出了一个简单的DMA控制器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8522cd40675adcad448679876eac85a3951fa26a1116a5b156080131b7de7bcf.jpg)  
图7.6简单的DMA控制器  

·主存地址计数器：存放要交换数据的主存地址。在传送前，其保存的是传送数据的主存起始地址；每传送一个字，地址寄存器的内容就加1，直至该批数据传送完毕。  

·传送长度计数器：记录传送数据的总长度。在传送前，其记录的是该批数据的总字数；每传送一个字，计数器就减1，直至计数器为0，表示该批数据传送完毕。  

·数据缓冲寄存器：暂存每次传送的数据。通常，DMA接口与主存之间的传送单位为字，而DMA与设备之间的传送单位可能为字节或位。  

·DMA请求触发器：每当I/O设备准备好数据后，发出一个控制信号，使DMA请求触发器置位。  

）“控制/状态”逻辑：用于指定传送方向，修改传送参数，并对DMA请求信号、CPU响应信号进行协调和同步。  

·中断机构：当一批数据传送完毕后触发中断机构，向CPU提出中断请求。  
在DMA传送过程中，DMA控制器接管系统总线。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。由此可见，DMA控制器必须具有控制系统总线的能力。  

# 3.DMA的传送方式  

主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA与CPU通常采用以下3种方式使用主存。  

# （1）停止CPU访存  

当I/O设备有DMA请求时，由DMA接口向CPU发送一个停止信号，使CPU放弃总线控制权，停止访问主存，直到DMA传送一块数据结束，如图7.7所示。数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ec983e624318edc13175044b2d5cebc2b11509fa61e7d5aa190149951d0aa44.jpg)  
图7.7停止CPU访存  

优点：控制简单，适用于数据传输速率很高的I/O设备实现成组数据的传送。  

缺点：DMA在访问主存时，CPU基本上处于不工作状态。  

（2）周期挪用  

# 命题追踪周期挪用的特点及挪用次数分析（2012、2020、2022）  

由于I/O访存的优先级高于CPU访存（I/O不立即访存就可能丢失数据），因此由I/O设备挪用一个存取周期，传送完一个数据字后立即释放总线，如图7.8所示。它是一种单字传送方式。当I/O设备有DMA请求时，会遇到3种情况： $\textcircled{\scriptsize{1}}$ 此时CPU不在访存，因此I/O的访存请求与CPU未发生冲突； $\circledcirc$ CPU正在访存，此时必须待存取周期结束后，CPU再将总线占有权让出； $\textcircled{3}$ I/O和CPU同时请求访存，出现访存冲突，此时CPU要暂时放弃总线占有权。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f1cb1aeae481f0ba9014acc77c9a136f81250ae56fe2f1afdbaaae40727dad9f.jpg)  
图7.8周期挪用  

优点：既实现了I/O传送，又较好地发挥了主存与CPU的效率。  

缺点：每挪用一个主存周期，DMA接口都要申请、建立和归还总线控制权。  

（3）DMA与CPU交替访存  

将CPU的工作周期分成两个时间片，一个给CPU访存，另一个给DMA访存，这样在每个CPU周期内，CPU和DMA就都可以轮流访存，如图7.9所示。这种方式适用于CPU的工作周期比主存存取周期长的情况。例如，若CPU的工作周期是 $1.2\upmu\mathrm{s}$ ，主存的存取周期小于 $0.6\upmu\mathrm{s}$ ，则可将一个CPU周期分为 $\mathbf{C}_{1}$ 和 $\mathbf{C}_{2}$ 两个周期，其中 $\mathbf{C}_{1}$ 专供DMA访存， $C_{2}$ 专供CPU访存。这种方式不需要申请、建立和归还总线使用权，总线使用权是通过 $C_{1}$ 和 $\mathrm{C}_{2}$ 分时控制的。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ffcf3f4a552e1dfafa466c4a36585fb69c056f358e0b653e960ca62e1a3344ba.jpg)  
图7.9DMA与CPU交替访存  

优点：不需要总线控制权的申请、建立和归还过程，具有很高的传送速率。  

缺点：相应的硬件逻辑变得更复杂。  

DMA方式的效率分析及相关计算（2011、2018）  

【例7.4】假定计算机的主频为 $500\mathrm{MHz}$ ，CPI为4，某外设的数据率为 $40\mathrm{MB/s}$ ，I/IO接口中的数据端口为32位，采用DMA方式，每次DMA传送块大小为1000B，且DMA预处理和后处理的总时钟周期数为500，则CPU用于该外设I/O的时间占CPU总时间的百分比是多少？  

解：  

外设每秒的DMA次数为 $\mathrm{40MB/s^{\pm}1000B=40000}$ ，在DMA方式中，只有预处理和后处理需要CPU处理，数据传送全程由DMA控制。CPU用于外设I/O的总时间为 $40000{\times}500=2{\times}10^{7}$ 个时钟周期，占CPU总时间的百分比为 $2\!\times\!10^{7}\!\div\!500\mathbf{M}=4\%.$  

# 4.DMA的传送过程  

# 命题追踪DMA方式的传送过程（2019）  

图7.10所示为DMA的数据传送流程，分为预处理、数据传送和后处理3个阶段。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a3b3e6b4a23a187f89eda625719dd33923705cfd841a0f99f9153f246e978d6b.jpg)  
图7.10DMA的传送流程  

（1）预处理  

由CPU完成一些必要的准备工作。首先，初始化DMA控制器中的有关寄存器、设置传送方尚、测试并启动设备等。然后，CPU继续执行原程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发出总线请求（这两个过程也可统称DMA请求），用以传输数据。  
（2）数据传送  

DMA以数据块为基本传送单位。DMA占用总线后的数据输入/输出操作都是通过循环来实现的，这一循环也是由DMA控制器实现的，即数据传送阶段完全由DMA（硬件）控制。  

（3）后处理  

DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验数据（出错则转诊断程序）等后处理工作。在DMA方式下，整个数据块的传送过程都不需要CPU参与，CPU只在最初的DMA控制器初始化和最后的DMA结束处理时才介入，因此CPU用于I/O的开销非常小。  

# 5.DMA方式和中断方式的区别  

命题追踪中断方式与DMA方式的区别（2013、2023）  

DMA万式和中断万式的重要区别如下：  

$\textcircled{\scriptsize{1}}$ 中断方式是程序的切换，需要保护和恢复现场；而DMA方式不中断现行程序，无需保护现场，除了预处理和后处理，其他时候不占用任何CPU资源。 $\circledcirc$ 对中断请求的响应只能发生在每条指令执行结束时（执行周期后）：而对DMA请求的响应可以发生在任意一个机器周期结束时（取指、间址、执行周期后均可）。 $\textcircled{3}$ 中断传送过程需要CPU的干预：而DMA传送过程不需要CPU的干预，因此数据传输速率非常高，适合于高速外设的成组数据传送。  

命题追踪DMA与CPU请求总线的优先级对比（2012、2022）  

$\textcircled{4}$ DMA请求的优先级高于中断请求。 $\circledast$ 中断方式具有处理异常事件的能力，而DMA方式仅局限于大批数据的传送。 $\circledcirc$ 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。  

# 7.3.4 本节习题精选  

# 一、单项选择题  

01.设置中断排队判优逻辑的目的是（）  

A.产生中断源编码B.使同时提出的请求中的优先级别最高者得到及时响应C.使CPU能方便地转入中断服务子程序D.提高中断响应速度  

02.以下说法中，错误的是（）。  

A.中断服务程序一般是操作系统模块B.中断向量方法可提高中断源的识别速度C.中断向量地址是中断服务程序的入口地址D.重叠处理中断的现象称为中断嵌套  

03.当有中断源发出请求时，CPU可执行相应的中断服务程序，可以提出中断（包括内中断和外中断）的有（）。  

I.外部事件 Il.Cache III.虚拟存储器失效 IV.浮点数运算下溢 V.浮点数运算上溢  
A.I、ⅢI和IV B.I和V C.I、II和V D.I、III和V

 04.关于程序中断方式和DMA方式的叙述，错误的是（）  

I.DMA的优先级比程序中断的优先级要高II.程序中断方式需要保护现场，DMA方式在传输过程中不需要保护现场III.程序中断方式的中断请求是为了报告CPU数据的传输结束，而DMA方式的中断请求完全是为了传送数据  

A.仅ⅡIB.II、ⅢIC.仅IID.I、III  

05.下列说法中，错误的是（）。  

1.程序中断过程是由硬件和中断服务程序共同完成的II.在每条指令的执行过程中，每个总线周期要检查一次有无中断请求III.检测有无DMA请求，一般安排在一条指令执行过程的末尾IV.中断服务程序的最后指令是无条件转移指令  

A.III、IVB.II、III、IVC.II、IVD.I、I、II、IV  

06.能产生DMA请求的总线部件是（））  

1.高速外设II.需要与主机批量交换数据的外设IⅢI.具有DMA接口的设备  

A.仅IB.仅IIC.I、IIID.II、IⅢI

07.在具有中断向量表的计算机中，中断向量地址是（）。  

A.子程序入口地址B.中断服务程序的入口地址C.中断服务程序入口地址的地址D.中断程序断点  

08.中断响应是在（）。  

A.一条指令执行开始B.一条指令执行中间C.一条指令执行之末D.一条指令执行的任何时刻  

09.在下列情况下，可能不发生中断请求的是（）  

A.DMA操作结束 B.一条指令执行完毕 C.机器出现故障D.执行“软中断”指令  

10.在配有通道的计算机系统中，用户程序需要输入/输出时，引起的中断是（）。A.访管中断 B.I/O中断 C.故障 D.外中断  

11.某计算机有4级中断，优先级从高到低为 $1{\rightarrow}2{\rightarrow}3{\rightarrow}4.$ 若将优先级顺序修改，改后1级中断的屏蔽字为1101，2级中断的屏蔽字为0100，3级中断的屏蔽字为1111，4级中断的屏蔽字为0101，则修改后的优先顺序从高到低为（）。  

A. $1{\rightarrow}2{\rightarrow}3{\rightarrow}4$ B. $3{\rightarrow}1{\rightarrow}4{\rightarrow}2$ C. $1{\rightarrow}3{\rightarrow}4{\rightarrow}2$ D.2→1→3→4  

12.下列不属于程序控制指令的是（）  

A.无条件转移指令 B.有条件转移指令 C.中断隐指令 D.循环指令  

13.在中断响应周期中，CPU主要完成的工作是（）  

A.关中断，保护断点，发中断响应信号并形成向量地址B.开中断，保护断点，发中断响应信号并形成向量地址C.关中断，执行中断服务程序D.开中断，执行中断服务程序  

14.下列关于中断I/0方式的叙述中，错误的是（）A.CPU对外部中断的响应不可能发生在一条指令的执行过程中B.在中断I/O方式下，外设接口中的寄存器和CPU中的寄存器直接交换数据C.中断请求的是CPU时间，要求CPU执行程序来处理发生的相关事件D.只要有中断请求发生，一条指令执行结束后CPU就进入中断响应周期  
15.当CPU响应中断时，进入“中断响应周期”，采用硬件方法保护并更新程序计数器（PC）内容，而不是由软件完成的，主要是为了（）。  

A.能进入中断处理程序，并能正确返回源程序B.节省主存空间C.提高处理机速度D.易于编制中断处理程序  

16.在I/0接口中设置中断触发器保存外设发出的中断请求，是因为（）。  

A.中断不需要立即处理B.中断设备的处理速度比CPU快C.CPU无法对发生的中断请求立即进行处理D.可能有多个中断同时发生  

17.在中断响应周期中，由（）将允许中断触发器置 $0.$  

A.关中断指令B.中断隐指令C.开中断指令D.中断服务程序  

18.CPU响应中断时最先完成的步骤是（）。  

A.开中断B.保存断点C.关中断D.转入中断服务程序  

19.设置中断屏蔽标志可以改变（）  

A.多个中断源的中断请求优先级B.CPU对多个中断请求响应的优先次序C.多个中断服务程序开始执行的顺序D.多个中断服务程序执行完的次序  

20.在CPU响应中断时，保护两个关键的硬件状态是（）A.PC和IR B.PC和PSW C.AR和IR D.AR和PSW

 21.在各种I/O方式中，中断方式的特点是（），DMA方式的特点是（）。  

A.CPU与外设串行工作，传送与主程序串行工作B.CPU与外设并行工作，传送与主程序串行工作C.CPU与外设串行工作，传送与主程序并行工作D.CPU与外设并行工作，传送与主程序并行工作  

22.下列关于程序查询方式及其工作过程的叙述中，正确的是（）  

A.按启动查询方式的不同，可分为软件查询方式和硬件查询方式B.CPU主要负责启动外设和查询其状态，不参与数据传送C.每完成一次数据传送后，会修改主存地址和计数值D.CPU需一直查询外设的状态，直到外设准备就绪时才可去执行其他程序  

23．在DMA传送方式中，由（）发出DMA请求，在传送期间总线控制权由（）掌握。  

A.外部设备、CPUB.DMA控制器、DMA控制器C.外部设备、DMA控制器D.DMA控制器、内存  

24．下列叙述中，（）是正确的。  

A.程序中断方式和DMA方式中实现数据传送都需要中断请求B.程序中断方式中有中断请求，DMA方式中没有中断请求C.程序中断方式和DMA方式中都有中断请求，但目的不同  
D.DMA要等指令周期结束时才可以进行周期窃取

25.以下关于DMA方式进行I/O的描述中，正确的是（）  

A.一个完整的DMA过程，部分由DMA控制器控制，部分由CPU控制B.一个完整的DMA过程，完全由CPU控制C.一个完整的DMA过程，完全由DMA控制器控制，CPU不介入任何控制D.一个完整的DMA过程，完全由CPU采用周期挪用法控制  

26.CPU响应DMA请求的条件是当前（）执行完。  

A.机器周期 B.总线周期 C.机器周期和总线周期D.指令周期  

27.当某五级流水线CPU正在执行某条指令的第二级流水段时，外部设备产生了一个DMA请求，则CPU对该DMA请求响应的时机是（）。  

A.立即响应B.在该指令的第二级流水段执行完毕后响应C.在该指令的第三级流水段执行完毕后响应D.在该指令执行结束后响应  

28.关于外中断（故障除外）和DMA，下列说法中正确的是（）。  

A.DMA请求和中断请求同时发生时，响应DMA请求B.DMA请求、非屏蔽中断、可屏蔽中断都要在当前指令结束之后才能被响应C.非屏蔽中断请求优先级最高，可屏蔽中断请求优先级最低D.若不开中断，所有中断请求就不能响应  

29.以下有关DMA方式的叙述中，错误的是（）  

A.在DMA方式下，DMA控制器向CPU请求的是总线使用权B.DMA方式可用于键盘和鼠标的数据输入C.在数据传输阶段，不需要CPU介入，完全由DMA控制器控制D.DMA方式要用到中断处理  

30.在主机和外设的信息传送中，（）不是一种程序控制方式。  

A.直接程序传送B.程序中断C.直接存储器存取（DMA）D.通道控制  

31.中断发生时，程序计数器内容的保护和更新是由（）完成的。  

A.硬件自动B.进栈指令和转移指令C.访存指令D.中断服务程序  

32.在DMA方式传送数据的过程中，因为没有破坏（）的内容，所以CPU可以正常工作（访存除外）。  

A.程序计数器B.程序计数器和寄存器C.指令寄存器D.堆栈寄存器  

33.在DMA方式下，数据从内存传送到外设经过的路径是（）。  

A.内存→数据总线→数据通路→外设B.内存→数据总线 $\rightarrow$ DMAC→外设C.内存→数据通路→数据总线→外设D.内存 $\rightarrow$ CPU→外设  

34.采用周期挪用进行DMA数据传送时，每传送一个数据要占用一个（）的时间A.指令周期B.机器周期C.时钟周期D.存取周期  

35.启动一次DMA传送，外设和主机之间将完成一个（）的数据传送。A.字节B.字C.总线宽度D.数据块  
36.在磁盘存储器进行读/写操作之前，CPU需要对磁盘控制器或DMA控制器进行初始化。在下列选项中，不包含在初始化信息中的是（）。  

A.传送信息所在的主存起始地址B.传送方向（是读磁盘还是写磁盘）C.传送信息所在的通用寄存器编号D.传送数据的字数或字节数  

37.【2009统考真题】下列选项中，能引起外部中断的事件是（）A.键盘输入B.除数为0C.浮点运算下溢D.访存缺页

38.【2010统考真题】单级中断系统中，中断服务程序内的执行顺序是（）  

I.保护现场IL.开中断III.关中断IV.保存断点V.中断事件处理VI.恢复现场VII.中断返回  

A.  $\scriptstyle\mathrm{I}\rightarrow\mathrm{V}\rightarrow\mathrm{VI}\rightarrow\mathrm{II}\rightarrow\mathrm{VII}$  B.III→I→V→VII C.III→IV-V→VI→VII D.IV→I-V→VI-→VII  

39.【2011统考真题】某计算机有五级中断  $\mathrm{L}_{4}\sim\mathrm{L}_{0}$  ，中断屏蔽字为  $\mathbf{M}_{4}\mathbf{M}_{3}\mathbf{M}_{2}\mathbf{M}_{1}\mathbf{M}_{0}$   $\mathbf{M}_{i}=1$  C  $0\leqslant$   $i\leqslant\!4$ ）表示对 $\mathrm{L}_{i}$ 级中断进行屏蔽。若中断响应优先级从高到低的顺序是 $\mathrm{L}_{0}{\rightarrow}\mathrm{L}_{1}{\rightarrow}\mathrm{L}_{2}{\rightarrow}$  $\mathrm{L}_{3}{\rightarrow}\mathrm{L}_{4}$ ，且要求中断处理优先级从高到低的顺序为 $\mathrm{L}_{4}{\rightarrow}\mathrm{L}_{0}{\rightarrow}\mathrm{L}_{2}{\rightarrow}\mathrm{L}_{1}{\rightarrow}\mathrm{L}_{3}$ ，则 $\mathrm{L}_{1}$ 的中断处理程序中设置的中断屏蔽字是（）。  

A.11110 B.01101 C.00011 D.01010  

40.【2011统考真题】某计算机处理器主频为 $50\mathrm{MHz}$ ，采用定时查询方式控制设备A的I/O，查询程序运行一次所用的时钟周期数至少为 $500.$ 在设备A工作期间，为保证数据不丢失，每秒需对其查询至少200次，则CPU用于设备A的I/O的时间占整个CPU时间的百分比至少是（）。  

A.  $0.02\%$  B.  $0.05\%$  C.  $0.20\%$  D.  $0.50\%$  

41.【2012统考真题】响应外部中断的过程中，中断隐指令完成的操作，除保护断点外，还包括()。  

I.关中断II.保存通用寄存器的内容ml.形成中断服务程序入口地址并送PC  

A.仅I、ⅡIB.仅I、ⅢIC.仅II、ⅢD.I、II、ⅢI

42.【2013统考真题】下列关于中断I/O方式和DMA方式比较的叙述中，错误的是（）。  

A.中断I/O方式请求的是CPU处理时间，DMA方式请求的是总线使用权B.中断响应发生在一条指令执行结束后，DMA响应发生在一个总线事务完成后C.中断I/O方式下数据传送通过软件完成，DMA方式下数据传送由硬件完成D.中断I/O方式适用于所有外部设备，DMA方式仅适用于快速外部设备  

43.【2014统考真题】若某设备中断请求的响应和处理时间为 $100\mathrm{ns}$ ，每 $400\mathrm{ns}$ 发出一次中断请求，中断响应所允许的最长延迟时间为 $50\mathrm{ns}$ ，则在该设备持续工作过程中，CPU用于该设备的I/O时间占整个CPU时间的百分比至少是（）。  

A.  $12.5\%$  B.  $25\%$  C.  $37.5\%$  D.  $50\%$  

44.【2015统考真题】在采用中断I/O方式控制打印输出的情况下，CPU和打印控制接口中的I/0端口之间交换的信息不可能是（）。  

A.打印字符B.主存地址C.设备状态D.控制命令  

45.【2017统考真题】下列关于多重中断系统的叙述中，错误的是（）。A.在一条指令执行结束时响应中断B.中断处理期间CPU处于关中断状态C.中断请求的产生与当前指令的执行无关 D.CPU通过采样中断请求信号检测中断请求  
46.【2018统考真题】下列关于外部I/0中断的叙述中，正确的是（）。  

A.中断控制器按所接收中断请求的先后次序进行中断优先级排队B.CPU响应中断时，通过执行中断隐指令完成通用寄存器的保护C.CPU只有在处于中断允许状态时，才能响应外部设备的中断请求D.有中断请求时，CPU立即暂停当前指令执行，转去执行中断服务程序  

47.【2019统考真题】某设备以中断方式与CPU进行数据交换，CPU主频为1GHZ，设备接口中的数据缓冲寄存器为32位，设备的数据传输速率为 $50\mathrm{kB/s}.$ 若每次中断开销（包括中断响应和中断处理）为1000个时钟周期，则CPU用于该设备输入/输出的时间占整个CPU时间的百分比最多是（）。  

A.  $1.25\%$  B.  $2.5\%$  C.  $5\%$  D.  $12.5\%$  

48.【2019统考真题】下列关于DMA方式的叙述中，正确的是（）  

I.DMA传送前由设备驱动程序设置传送参数II.数据传送前由DMA控制器请求总线使用权III.数据传送由DMA控制器直接控制总线完成IV.DMA传送结束后的处理由中断服务程序完成  

A.仅I、ⅡIB.仅I、ⅢI、IVC.仅II、IⅢI、IVD.I、ⅡI、IⅢI、IV

49.【2020统考真题】下列事件中，属于外部中断事件的是（）  

I.访存时缺页II.定时器到时III.网络数据包到达A.仅I、ⅡIB.仅I、ⅢIC.仅ⅡI、ⅢID.I、ⅡI和IⅢI  

50.【2020统考真题】外部中断包括不可屏蔽中断（NMI）和可屏蔽中断，下列关于外部中断的叙述中，错误的是（）。  

A.CPU处于关中断状态时，也能响应NMI请求 B.一旦可屏蔽中断请求信号有效，CPU就立即响应C.不可屏蔽中断的优先级比可屏蔽中断的优先级高D.可通过中断屏蔽字改变可屏蔽中断的处理优先级  

51.【2020统考真题】若设备采用周期挪用DMA方式进行输入和输出，每次DMA传送的数据块大小为512字节，相应的I/O接口中有一个32位数据缓冲寄存器。对于数据输入过程，下列叙述中，错误的是（）。  

A.每准备好32位数据，DMA控制器就发出一次总线请求B.相对于CPU，DMA控制器的总线使用权的优先级更高C.在整个数据块的传送过程中，CPU不可以访问主存储器D.数据块传送结束时，会产生“DMA传送结束”中断请求  

52.【2021统考真题】下列是关于多重中断系统中CPU响应中断的叙述，错误的是（）。  

A.仅在用户态（执行用户程序）下，CPU才能检测和响应中断B.CPU只有在检测到中断请求信号后，才会进入中断响应周期C.进入中断响应周期时，CPU一定处于中断允许（开中断）状态 D.若CPU检测到中断请求信号，则一定存在未被屏蔽的中断源请求信号  

53.【2022统考真题】下列关于中断1/0方式的叙述中，不正确的是（）A.适用于键盘、针式打印机等字符型设备B.外设和主机之间的数据传送通过软件完成C.外设准备数据的时间应小于中断处理时间D.外设为某进程准备数据时CPU可运行其他进程  
54.【2023统考真题】下列关于硬件和异常/中断关系的叙述中，错误的是（）  

A.CPU在执行一条指令的过程中检测异常事件B.CPU在执行完一条指令时检测中断请求信号C.开中断时CPU检测到中断请求后就进行中断响应D.外部设备通过中断控制器向CPU发中断结束信号  

55.【2023统考真题】下列关于1/0控制方式的叙述中，错误的是（）  

A.查询方式下，通过CPU执行查询程序进行I/O操作B.中断方式下，通过CPU执行中断服务程序进行I/O操作C.DMA方式下，通过CPU执行DMA传送程序进行I/O操作D.对于SSD、网络适配器等高速设备，采用DMA方式输入/输出  

# 二、综合应用题  

01.在DMA方式下，主存和I/O设备之间有一条物理通路相连吗？  

02.假定某I/O设备向CPU传送信息的最高频率为4万次/秒，而相应中断处理程序的执行时间为 $40\upmu\mathrm{s}$ ，则该I/O设备是否可采用中断方式工作？为什么？  

03．在程序查询方式的输入/输出系统中，假设不考虑处理时间，每个查询操作需要100个时钟周期，CPU的时钟频率为 $50\mathrm{MHz}$ 。现有鼠标和硬盘两个设备，而且CPU必须每秒对鼠标进行30次查询，硬盘以32位字长为单位传输数据，即每32位被CPU查询一次，传输速率为 $2{\times}2^{20}\,\mathrm{B}/\mathrm{s}.$ 求CPU对这两个设备查询所花费的时间比率，由此可得出什么结论？  

04.设某计算机有4个中断源1、2、3、4，其硬件排队优先次序按 $1{\rightarrow}2{\rightarrow}3{\rightarrow}4$ 降序排列，各中断源的服务程序中所对应的屏蔽字如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c89aad610e6d99ea415bb59853289e1def4f91fd522787a4f9de509d439afaa.jpg)  

1）给出上述4个中断源的中断处理次序。2）若4个中断源同时有中断请求，画出CPU执行程序的轨迹。  

05.一个DMA接口可采用周期窃取方式把字符（字节）传送到存储器，它支持的最大批量为400B。若存取周期为 $0.2\upmu\mathrm{s},$ 每处理一次中断需 $5\upmu\mathrm{s}.$ 现有的字符设备的传输速率为 $9600\mathrm{b/s}.$ 假设字符之间的传输是无间隙的，试问DMA方式每秒因数据传输占用处理器多少时间？若完全采用中断方式，又需占处理器多少时间（忽略预处理所需时间）？  

06.假设磁盘传输数据以32位的字为单位，传输速率为 $1\mathbf{M}\mathbf{B}/\mathrm{s}$ ，CPU的时钟频率为 $50\mathrm{MHz}_{\circ}$ 回答以下问题：  

1）采取程序查询方式，假设查询操作需要100个时钟周期，求CPU为I/O查询所花费的时间比率（假设进行足够的查询以避免数据丢失）。  
2）采用中断方式进行控制，每次传输的开销（包括中断处理）为80个时钟周期。求CPU为传输硬盘所花费的时间比率。  

3）采用DMA的方式，假定DMA的启动需要1000个时钟周期，DMA完成时后处理需要500个时钟周期。若平均传输的数据长度为4KB（此处 $K=1000$ ），试问硬盘工作时CPU将用多少时间比率进行输入/输出操作？忽略DMA申请总线的影响。  

07.【2009统考真题】某计算机的CPU主频为 $500\mathrm{MHz}$ ，CP1为5（即执行每条指令平均需5个时钟周期）。假定某外设的数据传输速率为 $0.5\mathrm{MB/s}$ ，采用中断方式与主机进行数据传送，以32位为传输单位，对应的中断服务程序包含118条指令，中断服务的其他开销相当于2条指令的执行时间。回答下列问题，要求给出计算过程。  

1）在中断方式下，CPU用于该外设I/O的时间占整个CPU时间的百分比是多少？  

2）当该外设的数据传输速率达到5MB/s时，改用DMA方式传送数据。假定每次DMA传送块大小为5000B，且DMA预处理和后处理的总开销为500个时钟周期，则CPU用于该外设I/O的时间占整个CPU时间的百分比是多少（假设DMA与CPU之间没有访存冲突）？  

08.【2012统考真题】假定某计算机的CPU主频为  $80\mathrm{MHz}$  ，CPI为4，平均每条指令访存1.5 次，主存与Cache之间交换的块大小为16B，Cache的命中率为 $99\%$ ，存储器总线宽带为32位。回答下列问题。  

1）该计算机的MIPS数是多少？平均每秒Cache缺失的次数是多少？在不考虑DMA传送的情况下，主存带宽至少达到多少才能满足CPU的访存要求？  

2）假定在Cache缺失的情况下访问主存时，存在 $0.0005\%$ 的缺页率，则CPU平均每秒产生多少次缺页异常？若页面大小为4KB，每次缺页都需要访问磁盘，访问磁盘时DMA传送采用周期挪用方式，磁盘I/O接口的数据缓冲寄存器为32位，则磁盘I/O接口平均每秒发出的DMA请求次数至少是多少？  

3）CPU和DMA控制器同时要求使用存储器总线时，哪个优先级更高？为什么？  

4）为了提高性能，主存采用4体低位交叉存储模式，工作时每1/4个存储周期启动一个体。若每个体的存储周期为50ns，则该主存能提供的最大带宽是多少？  

09.【2016统考真题】假定CPU主频为 $50\mathrm{MHz}$ ，CPI为4。设备D采用异步串行通信方式向主机传送7位ASCII码字符，通信规程中有1位奇校验位和1位停止位，从D接收启动命令到字符送入I/0端口需要 $0.5\mathrm{ms},$ ，回答下列问题，要求说明理由。  

1）每传送一个字符，在异步串行通信线上共需传输多少位？在设备D持续工作过程中，每秒最多可向1/O端口送入多少个字符？  

2）设备D采用中断方式进行输入/输出，示意图如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b44e7762da75e00edfd7fd3b274cd2f67a6259a68fb27c827dead1ba5c145a31.jpg)  

1/0端口每收到一个字符申请一次中断，中断响应需10个时钟周期，中断服务程序共有20条指令，其中第15条指令启动D工作。若CPU需从D读取1000个字符，则完成这一任务所需时间大约是多少个时钟周期？CPU用于完成这一任务的时间大约是多少个时钟周期？在中断响应阶段CPU进行了哪些操作？  
0.【2018统考真题】假定计算机的主频为 $500\mathrm{MHz}$ ，CPI为4。现有设备A和B，其数据传 $40\mathrm{MB/s}$ ，对应1/0接口中各有一个32位数据缓冲寄存器。回答下列问题，要求给出计算过程。1）若设备A采用定时查询I/0方式，每次输入/输出都至少执行10条指令。设备A最CPU总时间的百分比至少是多少？2）在中断10方式下，若每次中断响应和中断处理的总时钟周期数至少为400，则设备B能否采用中断I/O方式？为什么？3）若设备B采用DMA方式，每次DMA传送的数据块大小为1000B，CPU用于DMA总时间的百分比最多是多少？11.【2022统考真题】假设某磁盘驱动器中有4个双面盘片，每个盘面有20000个磁道，每 个磁道有500个扇区，每个扇区可记录512字节的数据，盘片转速为 $7200\mathrm{rpm}$ (转/分），平均寻道时间为5ms。请回答下列问题。1）每个扇区包含数据及其地址信息，地址信息分为3个字段。这3个字段的名称各是什么？对于该磁盘，各字段至少占多少位？2）一个扇区的平均访问时间约为多少？3）若采用周期挪用DMA方式进行磁盘与主机之间的数据传送，磁盘控制器中的数据缓冲区大小为64位，则在一个扇区的读/写过程中，DMA控制器向CPU发送了多少次总线请求？若CPU检测到DMA控制器的总线请求信号时也需要访问主存，则DMA控制器是否可以获得总线使用权？为什么？  

# 7.3.5 答案与解析  

# 一、单项选择题  

01.B  

当有多个中断请求同时出现时，中断服务系统必须能从中选出当前最需要给予响应的且最重要的中断请求，这就需要预先对所有的中断进行优先级排队，这个工作可由中断判优逻辑来完成排队的规则可由软件通过对中断屏蔽寄存器进行设置来确定。  

02.C  

中断服务程序是处理器处理的紧急事件，可理解为一种服务，是事先编好的某些特定的程序，一般属于操作系统的模块，以供调用执行，A正确。中断向量由向量地址形成部件，即由硬件产生，并且不同的中断源对应不同的中断服务程序，因此通过该方法，可以较快速地识别中断源，B正确。中断向量是中断服务程序的入口地址，中断向量地址是内存中存放中断向量的地址，即中断服务程序入口地址的地址，C错误。重叠处理中断的现象称为中断嵌套，D正确。  

03.D  

外部事件如按Esc键以退出运行的程序等，属于外中断，I正确。Cache完全是由硬件实现的，不会涉及中断层面，Ⅱ错误。虚拟存储器失效如缺页等，会发出缺页中断，属于内中断，Ⅲ正确。浮点数运算下溢，直接当作机器零处理，而不会引发中断，IV错误。浮点数上溢，表示超过了浮点数的表示范围，属于内中断，√正确。  

04.C  

DMA方式不需要CPU干预传送操作，仅在开始和结尾借用CPU一点时间，其余不占用CPU任何资源：中断方式是程序切换，每次操作需要保护和恢复现场，所以DMA优先级高于中断请求，从而可以加快处理效率，I正确。从I的分析可知，程序中断需要中断现行程序，因此需保扩现场，以便中断执行完后还能回到原来的点去继续没有完成的工作；DMA方式不需要中断现行程序，CPU仅仅做一些辅助性工作，因为主存和DMA接口之间有一条数据通路，所以无须使用CPU内部寄存器，也就无须保护现场，ⅡI正确。IⅡI的说法正好相反。  
# 注意  

程序中断的保护现场是由中断服务子程序完成的，不同中断源对应的中断子程序是不同的，可以理解为因DMA方式无须使用CPU内部寄存器，所以其对应的中断服务子程序也无须保存CPU现场。此外，“DMA方式无须保护现场”是唐朔飞老师所撰教材中的原话。  

05.B  

程序中断过程是由硬件（称中断隐指令）和中断服务程序共同完成的，I正确。在每条指令执行结束时（而不是执行过程中），CPU统一扫描各个中断源，检查有无中断请求，ⅡI错误。CPU会在每个存储周期（总线周期）结束后检查是否有DMA请求，而不是在一条指令执行过程的末尾，Ⅲ错误。中断服务程序的最后指令通常是中断返回指令，与无条件转移指令不同的是，它不仅要修改PC值，而且要将CPU中的所有寄存器都恢复到中断前的状态，IV错误。  

06.B  

只有具有DMA接口的设备才能产生DMA请求，即使当前设备是高速设备或需要与主机批量交换数据，若没有DMA接口的话，也不能产生DMA请求。  

07. C  

中断向量地址是中断向量表的地址，因为中断向量表保存着中断服务程序的入口地址，所以中断向量地址是中断服务程序入口地址的地址。  

08.C  

CPU响应中断必须满足下列3个条件：  $\textcircled{\scriptsize{1}}$  CPU接收到中断请求信号。首先中断源要发出中 断请求，同时CPU还要收到这个中断请求信号。 $\circledcirc$ CPU允许中断，即开中断。 $\circledast$ 一条指令执行完毕。因此中断响应是在指令执行末尾，C正确。  

09.B  

DMA操作结束、机器出现故障、执行“软中断”指令时都会产生中断请求。一条指令执行 完毕可能响应中断请求，但它本身不会引起中断请求。  

10.A  

用户程序需要输入/输出时，需要调用操作系统提供的接口（请求操作系统服务），此时会使得访管中断，系统由用户态转为核心态。  

11.B  

屏蔽字“1”表示不可被中断，“0”表示可被中断。由3级中断的屏蔽字可知，它屏蔽所有中断，优先级最高；再由1级中断的屏蔽字可知，它屏蔽除3外的所有中断，优先级次之；以此类推，可知选B。  

【另解】“1”越多表示优先级越高，因此屏蔽其他中断源就越多。  

12. C  

中断隐指令并不是一条由程序员安排的真正的指令，因此不可能把它预先编入程序中，只能在响应中断时由硬件直接控制执行。中断隐指令不在指令系统中，因此不属于程序控制指令。  

13.A 在中断响应周期，CPU主要完成关中断、保护断点、发中断响应信号并形成中断向量地址的工作，即执行中断隐指令。  
14.D  

CPU总是在一条指令结束时检查外中断请求，因此对外中断的响应只可能发生在一条指令结束时。中断I/O方式下，CPU执行中断服务程序时会执行相应的I/O指令，实现CPU的通用寄存器和外设接口中的寄存器之间的直接数据交换。中断请求就是要求CPU执行程序来处理发生的相关事件。选项D在下列两种情况下错误： $\textcircled{\scriptsize{1}}$ 关中断时，CPU检测不到中断请求，因此不会进入中断响应周期； $\circledcirc$ 当有中断请求的请求源被中断屏蔽字屏蔽时，也不会进入中断响应周期。  

15.A  

在中断响应周期中，采用硬件方法保护并更新PC内容，而不由软件完成，这样可以避免因为软件保存和恢复PC内容而造成的时间开销和错误风险，提高中断处理的效率和正确性。  

16.C  

因为CPU无法对发生的中断请求立即进行处理，因此需要在I/O接口中设置中断触发器，以保存是哪些外设发出了中断请求，等CPU当前的指令周期结束后，响应中断并进行处理。  

17.B  

允许中断触发器置0表示关中断，在中断响应周期由硬件自动完成，即中断隐指令完成。虽然关中断指令也能实现关中断的功能，但在中断响应周期，关中断是由中断隐指令完成的。在恢复现场和屏蔽字的时候，也需要关中断的操作，此时是由关中断指令来完成的。  

18. C  

只有先关中断，才可以保护断点。若先不保护断点，则可能会丢失当前程序的断点。同理，在恢复现场前也要关中断。这个过程和操作系统中的信号量PV操作类似，都是将内部过程变为不可打断的原子操作。  

19.D  

中断优先级包括响应优先级和处理优先级，中断屏蔽标志改变的是处理优先级。中断响应优先级是由中断查询程序或中断判优电路决定的，它反映的是多个审断同时请求时哪个先被响应，即审断服务程序开始执行的顺序。在多重中断系统中，中断处理优先级决定了本中断是否能打断正在执行的中断服务程序，决定了多个中断服务程序执行完的次序。  

20.B  

PC的内容是被中断程序尚未执行的第一条指令地址，PSW寄存器保存各种状态信息。CPU响应中断后，需要保护中断的CPU现场，将PC和PSW压人堆栈，这样等到中断结束后，就可以将压入堆栈的原PC和PSW的内容恢复到相应的寄存器，原程序从断点开始继续执行。  

21.B、D  

在程序查询方式中，CPU与外设串行工作，传送与主程序串行工作。在中断方式中，CPU与外设并行工作，当数据准备好时仍需中断主程序以执行数据传送，因此传送与主程序仍是串行的。在DMA方式中，CPU与外设、传送与主程序都是并行的。  

22. C  

按启动查询方式的不同，程序查询方式可分为定时查询方式和独占查询方式。在程序查询方式中，由CPU负责数据的传送。每完成一次数据传送后，将主存地址加1，计数值减1。  

23. C  

在DMA方式中，由外部设备向DMA控制器发出DMA请求信号，然后由DMA控制器向CPU发出总线请求信号。DMA控制器在传送期间有总线控制权，此时CPU不能响应I/O中断。  
24.C  

程序中断方式在数据传输时，首先要发出中断请求，此时CPU中断正在进行的操作，转而进行数据传输，直到数据传送结束，CPU才返回中断前执行的操作。DMA方式只是在后处理阶段需要用中断方式请求CPU做结束处理，但在整个数据传送过程，并不需要中断请求，A错误。DMA方式和程序中断方式都有中断请求，但自的不同，程序中断方式的中断请求是为了进行数据传送，而DMA方式的中断请求是在DMA传送结束后请求CPU做DMA结束处理，B错误、C正确。CPU对DMA的响应可在指令执行过程中的任何两个存取周期之间，D错误。  

25.A  

一个完整的DMA过程主要由DMA控制器控制，但也需要CPU参与控制，只是CPU干预比较少，只需在数据传输开始和结束时干预，从而提高了CPU的效率。  

26.A  

每个机器周期结束后，CPU就可以响应DMA请求。注意区别：DMA在与主存交互数据时通过周期窃取方式，窃取的是存取周期。  

27.B  

DMA请求的是总线的使用权，因此CPU对DMA请求的响应时机是一个总线周期结束时。在流水线CPU中，流水段的长度以最复杂的操作所花的时间为准，总线周期（访存时间）通常是耗时最长的，因此通常可认为总线周期、存取周期、机器周期和流水段长度是等价的。  

28.A  

DMA连接的是高速设备，其优先级高于中断请求，以防止高速设备数据丢失，A正确。DMA请求的响应时间可以发生在每个机器周期结束时，只要CPU不占用总线：审断请求的响应时间只能发生在每条指令执行完毕，B错误。DMA的优先级要比外中断（非屏蔽中断、可屏蔽中断）高，C错误。若不开中断，则内中断和非屏蔽中断仍可响应，D错误。  

29.B  

DMA方式只能用于数据传输，它不具有对异常事件的处理能力，不能中断现行程序，而键盘和鼠标均要求CPU立即响应，因此无法采用DMA方式。  

30.C  

只有DMA方式是靠硬件电路实现的，三种基本的程序控制方式即直接程序传送、程序中断、通道控制都需要程序的干预。  

31.A 中断发生时，程序计数器内容的保护和更新是由硬件自动完成的，即由中断隐指令完成。  

32.B DMA传送数据时，挪用周期不会改变CPU现场，因此无须占用CPU的PC和寄存器。  

33.B  

DMA方式的数据传送不经过CPU，但需要经过DMA控制器中的数据缓冲寄存器。输入时，数据由外设（如磁盘）先送往DMA的数据缓冲寄存器，再通过数据总线送到主存。反之，输出时，数据由主存通过数据总线送到DMA的数据缓冲寄存器，然后送到外设。  

34.D  

当采用周期挪用进行DMA数据传送时，每当CPU收到DMAC的总线申请，就将下一个总线周期的总线控制权交给DMAC。DMAC利用这个总线周期完成一个数据字的传送后，立即将总线控制权交回给CPU，因此这里的总线周期也等于存取周期的长度。  

35.D  

DIMA方式主要用于磁盘等高速设备的成批数据传送，这类高速设备的记录方式多采用数据块组织方式，因此每启动一次DMA传送，外设和主机之间就完成一个数据块的数据传送。  
36.C  

传送信息所在的通用寄存器编号不包含在初始化信息中，因为数据不是通过CPU中的通用寄存器来传输的，而是直接通过DMA控制器进行数据传输的。  

37.A  

外部中断是指CPU执行指令以外的事件产生的中断，通常指来自CPU与内存以外的中断。选项A中键盘输入属于外部事件，每次键盘输入CPU都需要执行中断以读入输入数据，所以能引起外部中断。选项B中除数为O属于异常，也就是内中断，发生在CPU内部。选项C中浮点运算下溢将按机器零处理，不会产生中断。而选项D中访存缺页属于CPU执行指令时产生的中断，也不属于外部中断。所以能产生外部中断的只能是输入设备键盘。  

38.A  

在单级（或单重）中断系统中，不允许中断嵌套。中断处理过程为： $\textcircled{\scriptsize{1}}$ 关中断； $\circledcirc$ 保存断点；

 $\textcircled{3}$ 识别中断源： $\textcircled{4}$ 保存现场； $\circledast$ 中断事件处理； $^\mathrm{\textregistered}$ 恢复现场； $\circleddash$ 开中断； $^\mathrm{\textregistered}$ 中断返回。其中 $\textcircled{\scriptsize{1}}$  $\textcircled{3}$ 由硬件完成， $\scriptstyle(4)\sim\left(8\right)$ 由中断服务程序完成。  

39. D  

中断响应优先级是由硬件线路（或查询程序）决定的，不便改动，而中断处理优先级可以利用屏蔽字技术来动态调整。1表示屏蔽该中断源的请求，0表示可以被该中断源中断。从中断处理优先级来看， $\mathrm{L}_{1}$ 只能屏蔽 $\mathrm{L}_{3}$ 和其自身，因此中断屏蔽字 $\mathrm{M}_{4}\mathrm{M}_{3}\mathrm{M}_{2}\mathrm{M}_{1}\mathrm{M}_{0}\,{=}\,01010$  

40.C  

每秒至少查询200次，每次查询至少500个时钟周期，则每秒最少占用  $200{\times}500=100000$  个 时钟周期，因此占CPU时间的百分比为 $100000/50\mathbf{M}=0.20\%$  

41.B  

在响应外部中断的过程中，中断隐指令完成的操作包括： $\textcircled{\scriptsize{1}}$ 关中断： $\circledcirc$ 保存断点； $\textcircled{3}$ 引出中断服务程序（形成中断服务程序入口地址并送PC），所以只有I、IⅢI正确。ⅡI中保存通用寄存器的内容是在进入中断服务程序后首先进行的操作。  

42.D  

中断I/O方式：在I/O设备输入每个数据的过程中，由于无须CPU干预，因此可使CPU与I/O设备并行工作。仅当输完一个数据时，才需CPU花费极短的时间去做一些中断处理。因此中断申请使用的是CPU处理时间，发生的时间是在一条指令执行结束之后，数据在软件的控制下完成传送。而DMA方式与之不同。DMA方式：数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；DMA方式每次申请的是总线的使用权，所传送的数据是从设备直接送入内存的，或者相反；仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在控制器的控制下完成的。中断I/O方式不适合高速外设；多路型DMA控制器也适合同时为多个慢速外设服务，D错误。  

43.B  

每 $400\mathrm{ns}$ 发出一次中断请求，而响应和处理时间为 $100\mathrm{ns}$ ，其中允许的延迟为干扰信息，因为在50ns内，无论怎么延迟，每 $400\mathrm{ns}$ 仍要花费 $100\mathrm{ns}$ 处理中断，所以该设备的1/O时间占整个CPU时间的百分比为 $100\mathrm{ns}/400\mathrm{ns}=25\%$  

44.B  

在程序中断I/O方式中，CPU和打印机直接交换，打印字符直接传输到打印机的I/O端口，不会涉及主存地址。而CPU和打印机通过I/O端口中的状态口和控制口来实现交互。  
45.B  

多重中断在保护被中断进程现场时关中断，执行中断处理程序时开中断，B错误。CPU一般在一条指令执行结束的阶段采样中断请求信号，查看是否存在中断请求，然后决定是否响应中断，A、D正确。中断是指来自CPU执行指令以外的事件，C正确。  

46.C  

中断优先级分为响应优先级和处理优先级，响应优先级由硬件排队器（或中断查询程序）决定，处理优先级由屏蔽字决定，而非请求的先后次序决定。中断隐指令完成的工作有： $\textcircled{\scriptsize{1}}$ 关中断： $\textcircled{2}$ 保存断点： $\textcircled{3}$ 引出中断服务程序，通用寄存器的保护由中断服务程序完成。中断充许状态（即开中断后），才能响应外部设备的中断请求，外部设备通常不能发出不可屏蔽中断，外部设备的中断请求通常是为了输入/输出，这些事件并不是系统级的紧急事件，可以被屏蔽或延迟处理，若充许外部设备发出不可屏蔽中断，则可能影响系统的稳定性和安全性。有中断请求时，若是关中断的状态，或新中断请求的优先级较低，则不能响应新的中断请求。  

47.A  

设备接口中的数据缓冲寄存器为32位，即一次中断可以传输4B数据，设备数据传输速率为50kB/s，共需要12.5k次中断，每次中断开销为1000个时钟周期，CPU主频为1GHz，则CPU用于该设备输入/输出的时间占整个CPU时间的百分比最多是（ $12.5\mathrm{k}{\times}1000){\div}1\mathrm{G}=1.25\%.$  

# 48.D  

每类设备都配置一个设备驱动程序，设备驱动程序向上层用户程序提供一组标准接口，负责实现对设备发出各种具体操作指令，用户程序不能直接和DMA打交道。DMA的数据传送过程分为预处理、数据传送和后处理3个阶段。预处理阶段由CPU完成必要的准备工作，数据传送前由DMA控制器请求总线使用权；数据传送由DMA控制器直接控制总线完成；传送结束后，DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理。  

49.C  

访存时缺页属于内部异常，I错误；定时器到时描述的是时钟中断，属于外部中断，Ⅱ正确；网络数据包到达描述的是CPU执行指令以外的事件，属于外部中断，IⅢI正确。  

# 50.B  

由CPU内部产生的异常称为内中断，内中断是不可屏蔽中断。通过中断请求线INTR和NMI，从CPU外部发出的中断请求称为外中断，通过INTR信号线发出的外中断是可屏蔽中断，而通过下M信号线发出的是不可屏蔽中断。不可屏蔽中断即使在关中断！ $(\mathrm{IF}=0$ ）情况下也被响应，A正确。不可屏蔽中断的优先级最高，任何时候只要发生不可屏蔽中断，都要中正现行程序的执行，转到不可屏蔽中断处理程序执行，C正确。CPU响应中断需要满足3个条件： $\textcircled{\scriptsize{1}}$ 中断源有中断请求： $\circledcirc$ CPU允许中断及开中断： $\textcircled{3}$ 一条指令执行完毕，且没有更紧道的任务。所以B错误。  

51.C  

周期挪用法由DMA控制器挪用一个或几个主存周期来访问主存，传送完一个数据字后立即释放总线，是一种单字传送方式，每个字传送完后CPU可以访问主存，C错误。停止CPU访存法则是指在整个数据块的传送过程中，使CPU脱离总线，停止访问主存。  

52.A  

中断服务程序在内核态下执行，若只能在用户态下检测和响应中断，则显然无法实现多重中断（中断嵌套），A错误。在多重中断中，CPU只有在检测到中断请求信号后（中断处理优先级更低的中断请求信号是检测不到的），才会进入中断响应周期。进入中断响应周期时，说明此时CPU一定处于中断允许状态，否则无法响应该中断。若所有中断源都被屏蔽（说明该中断的处理优先级最高），则CPU不会检测到任何中断请求信号。  
53.C  

中断1/O方式适用于字符型设备，此类设备的特点是数据传输速率慢，以字符或字为单位进行传输，A正确。若采用中断I/O方式，当外设准备好数据后，向CPU发出中断请求，CPU暂时中止现行程序，转去运行中断服务程序，由中断服务程序完成数据传送，B正确。若外设准备数据的时间小于中断处理时间，则可能导致数据丢失，以输入设备为例，设备为进程准备的数据会先写入设备控制器的缓冲区（缓冲区大小有限），缓冲区每写满一次，就向CPU发出一次中断请求，CPU响应并处理中断的过程，就是将缓冲区中的数据“取走”的过程，因此若外设准备数据的时间小于中断处理时间，则可能导致外设往缓冲区写入数据的速度快于CPU从缓冲区取走数据的速度，从而导致缓冲区的数据被覆盖，进而导致数据丢失，C错误。若采用中断1/O方式，则外设为某进程准备数据时，可令该进程阻塞，CPU运行其他进程，D正确。  

54.D  

A和B显然正确。开中断时，CPU在执行完一条指令时检测中断请求信号，若检测到中断请 求信号，就立即响应；即便是多重中断，CPU正在处理某个中断的过程中，由于中断屏蔽字的存在，因此CPU检测不到处理优先级更低的中断请求信号，若检测到中断请求信号，则说明其处理优先级更高，同样也立即响应，C正确。外设通过中断控制器向CPU发中断请求信号，CPU响应中断请求后开始执行中断服务程序，中断服务程序执行结束后CPUJ自行返回（中断服务程序的最后一条指令是返回指令），无须外设发中断结束信号，D错误。  

55.C  

DMA在预处理和后处理阶段需要CPU来处理，而数据传输阶段由DMA控制器完成。  

# 二、综合应用题  

01.【解答】  

没有。通常所说的DMA方式在主存和I/O设备之间建立一条“直接的数据通路”，使得数据在主存和1/O设备之间直接进行传送，其含义并不是在主存和1/O之间建立一条物理直接通路，而是主存和1/O设备通过1/O设备接口、系统总线及总线桥接部件等相连，建立一个信息可以相互通达的通路，这在逻辑上可视为直接相连的。其“直接”是相对于要通过CPU才能和主存相连这种方式而言的。  

02.【解答】  

I/O设备传送一个数据的时间为 $1\!\cdot\!(4\!\times\!10^{4})\mathrm{s}\,=\,25\upmu\mathrm{s}$ ，所以请求中断的周期为 $25\upmu\mathrm{s}$ ，而相应中断处理程序的执行时间为 $40\upmu\mathrm{s}$ ，大于请求中断的周期，会丢失数据（单位时间内I/O请求数量比中断处理的多，自然会丢失数据），所以不能采用中断方式。  

03.【解答】  

1）CPU每秒对鼠标进行30次查询，所需的时钟周期数为  $100\!\times\!30=3000$  。CPU的时钟频 率为 $50\mathrm{MHz}$ ，即每秒 $50\!\times\!10^{6}$ 个时钟周期，因此对鼠标的查询占用CPU的时间比率为 $[3000\div(50\times10^{6})]\times100\%=0.006\%$  可见，对鼠标的查询基本不影响CPU的性能。  

2）对于硬盘，每32位（4B）被CPU查询一次，因此每秒查询次数为 $2{\times}2^{20}\mathrm{B}{\div}4\mathrm{B}=512\mathrm{K}$ 则每秒查询的时钟周期数为  
因此对硬盘的查询占用CPU的时间比率为  

$$
[52.4{\times}10^{6}{\div}(50{\times}10^{6})]{\times}100\%=105\%
$$  

可见，即使CPU将全部时间都用于对硬盘的查询，也不能满足磁盘传输的要求，因此CPU一般不采用程序查询方式与磁盘交换信息。  

04.【解答】  

1）中断屏蔽字“1”表示不可被中断，“0”表示可被中断。根据表中“1”的个数的降序排列可知，4个中断源的处理次序是 $3{\rightarrow}1{\rightarrow}4{\rightarrow}2$  

2）当4个中断源同时有中断请求时，由于硬件排队的优先次序是 $1{\rightarrow}2{\rightarrow}3{\rightarrow}4$ ，因此CPU先响应1的请求，执行1的服务程序。该程序中设置了屏蔽字1101，因此开中断指令后转去执行3服务程序，且3服务程序执行结束后文回到了1服务程序。1服务程序结束后，CPU还有2、4两个中断源请求未响应。由于2的响应优先级高于4，因此CPU先响应2的请求，执行2服务程序。在2服务程序中由于设置了屏蔽字0100，意味着1、3、4可中断2服务程序。而1、3的请求已经结束，因此在开中断指令后转去执行4服务程序，4服务程序执行结束后又回到2服务程序的断点处，继续执行2服务程序，直至该程序执行结束。CPU执行程序的轨迹如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9a199a4504ab4a6368665d690ca8f3a11784f3bb23a4586c960f5b40abcbf3c6.jpg)  

# 05.【解答】  

根据字符设备的传输速率为 $9600{\mathrm{b/s}}$ ，得每秒能传输 $9600/8=1200\mathrm{B}$ ，即1200个字符（本题中字符、字节不加以区分）  

1）若采用DMA方式，传输1200个字符共需1200个存取周期，考虑到每传400个字符需中断处理一次，因此DMA方式每秒因数据传输占用处理器的时间是  

$$
5\upmu\mathrm{s}\times(1200/400)=15\upmu\mathrm{s}
$$  

2）若采用中断方式，每秒因数据传输占用处理器的时间是  

$$
5\upmu\mathrm{s}{\times}1200=6000\upmu\mathrm{s}
$$  

06.【解答】  

1）采用程序查询方式，硬盘传输速率为1MB/s，一个字为 $32\mathrm{{bit}\ensuremath{\mathbf{=4}}\mathrm{{B}}}$ ，每秒查询的次数为 $1\mathrm{MB}/4\mathrm{B}=2.5{\times}10^{5}$ ，每秒查询所需的总时钟周期数为 $2.5{\times}10^{5}{\times}100=2.5{\times}10^{7}$  

CPU的时钟频率为 $50\mathrm{MHz}$ 因此，I/O查询所花费的时间比率为 $2.5{\times}10^{7}{\div}50\mathbf{M}=2.5{\times}10^{7}{\div}(5{\times}10^{7})=50\%$  

2）采用中断方式时，每传输一个字便进行一次中断处理。  

每秒产生的中断次数为 $1\,\mathrm{MB}/4\mathrm{B}=2.5{\times}10^{5}$ 次。每秒用于传输的开销为 $2.5{\times}10^{5}{\times}80=2{\times}10^{7}$ 个时钟周期。因此花费的时间比率为 $(2{\times}10^{7})\div(5{\times}10^{7})=40\%$  

3）采用DMA方式时，CPU所花时间仅为启动时间和后处理时间。每传输一次数据CPU所花的时间为 $1000+500=1500$ 个时钟周期。  
DMA平均传送长度为4000B，每秒产生的DMA次数为 $1\mathrm{MB/s}\!\cdot\!(4\!\times\!10^{3}{\bf B})=250$ 因此，CPU为DMA所花费时间的比率为（ $(1500{\times}250){\div}50\mathrm{M}=0.75\%$  

07.【解答】  

1）按题意，外设每秒传送 $0.5\mathrm{MB}$ ，中断时每次传送 $32\mathrm{bit}=4\mathrm{B}$ 。由于CPI为5，在中断方式下，CPU每次用于数据传送的时钟周期为 $5{\times}18+5{\times}2=100$ （中断服务程序 $^+$ 其他开销）。为达到外设 $0.5\mathrm{MB/s}$ 的数据传输速率，外设每秒申请的中断次数为 $0.5\mathrm{MB}/4\mathrm{B}=125000$ 。1秒内用于中断的开销为 $100{\times}125000=12500000=12.5\mathrm{M}$ 个时钟周期。CPU用于外设I/O的时间占整个CPU时间的百分比为 $12.5\mathrm{M}/500\mathrm{M}=2.5\%\,.$  

2）当外设数据传输速率提高到5MB/s时改用DMA方式传送，每次DMA传送一个数据块，大小为5000B，则1秒内需产生的DMA次数为 $5\mathrm{MB}/5000\mathrm{B}=1000$ CPU用于DMA处理的总开销为 $1000\!\times\!500=500000=0.5{\bf M}$ 个时钟周期。CPU用于外设I/O的时间占整个CPU时间的百分比为 $0.5\mathbf{M}/500\mathbf{M}=0.1\%\,_{\circ}$  

08.【解答】  

本题涉及多个考点：计算机的性能指标、存储器的性能指标、DMA的性能分析、DMA方式的特点及多体交叉存储器的性能分析。1）平均每秒CPU执行的指令数为 $80\mathbf{M}/4=20\mathbf{M}$ ，因此MIPS数为20。平均每条指令访存1.5次，因此平均每秒Cache缺失的次数 $=20\mathrm{M}{\times}1.5{\times}(1-99\%)=300\mathrm{K}$ 。当Cache缺失时，CPU访问主存，主存与Cache之间以块为传送单位，此时主存带宽为 $16\mathrm{B}{\times}300\mathrm{k/s}\,{=}\,4.8\mathrm{MB/s}.$ 在不考虑DMA传送的情况下，主存带宽至少达到4.8MB/s才能满足CPU的访存要求。2）题中假定在Cache缺失的情况下访问主存，平均每秒产生缺页中断 $300000{\times}0.0005\%=1.5$ 次。因为存储器总线宽度为32位，所以每传送32位数据，磁盘控制器发出一次DMA请求，因此平均每秒磁盘DMA请求的次数至少为 $1.5{\times}4\mathrm{KB}/4\mathrm{B}=1.5\mathrm{K}=1536.$ 3）CPU和DMA控制器同时要求使用存储器总线时，DMA请求的优先级更高。因为，若DMA请求得不到及时响应，I/O传输数据可能会丢失。4）4体交叉存储模式能提供的最大带宽为 $\scriptstyle4\times4\mathrm{B}/50\mathrm{ns}\,=\,320\mathrm{MB}/\mathrm{s}\,.$  

09.【解答】  

1）每传送一个ASCII码字符，需要传输的位数有1位起始位、7位数据位（ASCII码字符占7位）、1位奇校验位和1位停止位，因此总位数为 $1+7+1+1=10.3$ ?I/O端口每秒最多可接收 $1000/0.5=2000$ 个字符。  

2）一个字符传送时间包括：设备D将字符送1/O端口的时间、中断响应时间和中断服务程序前15条指令的执行时间。时钟周期为 $1\dot{-}50\mathrm{MHz}=20\mathrm{ns}$ ，设备D将字符送I/O端口的时间为 $0.5\mathrm{ms}/20\mathrm{ns}\,{=}\,2.5{\times}10^{4}$ 个时钟周期。一个字符的传送时间约为 $2.5{\times}10^{4}+10+15{\times}4=25070$ 个时钟周期。完成1000个字符传送所需的时间约为 $1000{\times}25070=25070000$ 个时钟周期。CPU用于该任务的时间约为 $1000{\times}(10+20{\times}4)=9{\times}10^{4}$ 个时钟周期。在中断响应阶段，CPU主要进行以下操作：关中断、保护断点和程序状态、识别中断源。  

10.【解答】  

1）程序定时向缓存端口查询数据，由于缓存端口大小有限，必须在传输完端口大小的数据时访问端口，以防正部分数据未被及时读取而丢失。设备A准备32位数据所用的时间为 $\begin{array}{r}{4\mathbf{B}/2\mathbf{MB}=2\upmu\mathrm{s},}\end{array}$ ，所以最多每隔 $2\upmu\mathrm{s}$ 必须查询一次，每秒的查询次数至少是 $1\mathrm{s}/2\upmu\mathrm{s}=5{\times}10^{5}$ 每秒CPU用于设备A输入/输出的时间至少为 $5{\times}10^{5}{\times}10{\times}4\,=\,2{\times}10^{7}$ 个时钟周期，占整个CPU时间的百分比至少是 $2{\times}10^{7}{\div}500\mathbf{M}=4\%.$  
2）中断响应和中断处理的时间为 $400{\times}(1/500\mathrm{M})=0.8\upmu\mathrm{s}$ ，这时只需判断设备B准备32位数据要多久，若准备数据的时间小于中断响应和中断处理的时间，则数据被刷新，造成丢失。经过计算，设备B准备32位数据所用的时间为 $4{\bf B}/40\,\mathrm{MB}=0.1\upmu\mathrm{s}$ ，因此设备B不适合采用中断1/0方式。  

3）在DMA方式中，只有预处理和后处理需要CPU处理。设备B每秒的DMA次数最多为 $40\mathbf{MB}/\mathrm{s}{\div}1000\mathbf{B}=40000$ ，CPU用于设备B输入/输出的时间最多为 $40000{\times}500=2{\times}10^{7}$ 个时钟周期，占CPU总时间的百分比最多为 $(2\!\times\!10^{7})/500\mathbf{M}=4\%$  

# 11.【解析】  

1）3个字段的名称为柱面号（或磁道号）、磁头号（或盘面号）、扇区号。由于每个盘面有20000个磁道，因此该磁盘共有20000个柱面，柱面号字段至少占 $\left\lceil\log_{2}20000\right\rceil\!=\!15$ 位：由于该磁盘共有4个盘片，每个盘片有2个盘面，因此磁头号字段至少占 $\log_{2}(4{\times}2)=3$ 位；由于每个磁道有500个扇区，因此扇区号字段至少占 $\left\lceil\log_{2}500\right\rceil\!=\!9$ 位。  

2）一个扇区的访问时间由寻道时间、延迟时间、传输时间三部分组成。平均寻道时间为5ms，平均延迟时间等于磁盘转半圈所需要的时间，平均传输时间等于一个扇区划过磁头下方所需要的时间。而该磁盘转一圈的时间为 $(60\!\times\!10^{3})/7200\!\approx\!8.33\mathrm{ms}$ ，因此一个扇区的平均访问时间约为 $5+8.33/2+8.33/500\,{\approx}\,9.18\mathrm{ms}\,.$  

3）磁盘控制器中的数据缓冲区每充满一次，DMA控制器就需要发出一次总线请求，将这64bit数据通过总线传送到主存，因此，在一个扇区的读/写过程中，DMA控制器向CPU发送了 $512\mathrm{B}/64\mathrm{bit}=64\$ 次总线请求。由于采用周期挪用DMA方式，因此当CPU和DMA控制器都需要访问主存时，DMA控制器可以优先获得总线使用权。因为一旦磁盘开始读/写，就必须按时完成数据传送，否则数据缓冲区中的数据会发生丢失。  

# 7.4 本章小结  

本章开头提出的问题的参考答案如下。  

1）1/O设备有哪些编址方式？各有何特点？  

统一编址和独立编址。统一编址是在主存地址中划出一定的范围作为I/O地址，以便通过访存指令即可实现对1/O的访问，但主存的容量相应减少。独立编址是指1/O地址和主存是分开的，I/O地址不占主存空间，但访存需专门的I/O指令。  

2）CPU响应中断应具备哪些条件？  

$\textcircled{\scriptsize{1}}$ 在CPU内部设置的中断屏蔽触发器必须是开放的。 $\circledcirc$ 外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。 $\textcircled{3}$ 外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至CPU。具备上述三个条件时，CPU在现行指令结束的最后一个状态周期响应中断。  

# 7.5常见问题和易混淆知识点  

在开中断情况下，CPU总在每条指令执行结束时采样中断信号，此时若检测到中断请求信号，则会立即响应。即便是多重中断，CPU正在处理某个中断的过程中，由于币断屏蔽字的存在，CPU检测不到处理优先级更低的中断请求信号，因此若检测到中断请求信号，则说明新中断源的处理优先级更高，同样也会立即响应。  
# 2.向量中断、中断向量、向量地址三个概念是什么关系？  

中断向量：每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。  

向量地址：中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。  

向量中断：指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。  

3.程序中断和调用子程序有何区别？  

两者的根本区别主要表现在服务时间和服务对象上不一样。  

1）调用子程序过程发生的时间是已知的和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序过程，调用指令所在位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的。2）子程序完全为主程序服务，两者属于主从关系。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是平行关系。3）主程序调用子程序的过程完全属于软件处理过程，不需要专门的硬件电路；而中断处理系统是一个软/硬件结合的系统，需要专门的硬件电路才能完成中断处理的过程。4）子程序嵌套可实现若干级，嵌套的最多级数受计算机内存开辟的堆栈大小限制；而中断 嵌套级数主要由中断优先级来决定，一般优先级数不会很大。  
# 参考文献  

[1]

 [2]袁春风.计算机组成与系统结构[M].北京：清华大学出版社，2015.

[3]袁春风.计算机系统基础习题解答与教学指导：北京：机械工业出版社，2019

[4]唐朔飞.计算机组成原理[M].北京：高等教育出版社，2008.

[5]唐朔飞.计算机组成原理一学习指导与习题解答[M].北京：高等教育出版社.2012.

[6]RandalE.Bryant.深入理解计算机系统[M].北京：机械工业出版社，2016.

[7]李春葆，肖忠付，杭小庆.计算机组成原理联考辅导教程[M].北京：清华大学出版社，2010

[8]本书编写组.全国硕士研究生入学统一考试计算机专业基础综合考试大纲解析DM].北京：高等教育出版社，2014.

[9]徐爱萍.计算机组成原理考研指导[M]：北京：清华大学出版社，2003.

[10]谭志虎.计算机组成原理（微课版）[M].北京：人民邮电出版社，2022  
