# 1.2.7 答案与解析  

# 一、单项选择题  

01.D A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。  

02.A  

冯·诺依曼机的基本工作方式是控制流驱动方式，也就是按照指令的执行序列，依次读取指令，然后根据指令所含的控制信息，调用数据信息进行处理。因此，在执行程序的过程中，始终以控制信息流为驱动工作的因素，而数据信息流则是被动地被调用处理。  

03.B  

A是不存在的机器，B是对“存储程序”的阐述，因此正确。C是与题干无关的选项。D是相联存储器的特点。  

04.D 软件和硬件具有逻辑功能上的等价性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性。执行频繁、硬件实现代价不是很高的功能通常由硬件实现。  
05.D  

IR存放当前执行的指令代码，PC存放下一条指令的地址，不要将它们混淆。此外，MAR用来存放待访问的存储单元地址，MDR则用来存放取处存储单元的数据。  

06.A 在CPU中，PC用来跟踪下一条要执行的指令在主存储器中的地址。  

07. C  

地址译码器是主存储器的构成部分，不属于CPU。地址寄存器虽然一般属于主存储器，但现代计算机中绝大多数CPU内集成了地址寄存器。  

08.A  

地址寄存器（MAR）存放访存地址，因此位数与地址码长度相同。数据寄存器（MDR）用于暂存要从存储器中读或写的信息，因此位数与存储字长相同。  

09. D  

运算器的核心是ALU。地址寄存器位于CPU内，但并未集成到运算器与控制器中。地址寄存器用来保存当前CPU所访问的内存单元的地址。因为内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止。  

10.C  

寄存器在CPU内部，速度最快。Cache采用高速的SRAM制作，而内存常用DRAM制作，其速度较Cache慢。本题也可根据存储器层次结构的速度关系得出答案。  

11.C 8位计算机表明计算机字长为8位，即一次可以处理8位的数据；而16位表示地址码的长度，因此该机器有 $2^{16}\!=\!65536$ 个地址空间。  

12.B 计算机只能从主存储器中取指令与操作数，不能直接与外存交换数据。  

13.C  

编译程序是先完整编译后运行的程序，如C、 $\mathrm{C++}$ 等；解释程序是逐句翻译且边翻译边执行的程序，如JavaScript、Python等。由于解释程序要边翻译成机器语言边执行，因此一般速度较编译程序慢。为增加对该过程的理解，附C语言编译链接的过程：源程序(. c) C编译器 $\rightarrow$ 汇编源程序—汇编程序 $\rightarrow$ 目标程序—链接程序 $\rightarrow$ 可执行程序  

14.C  

机器语言是计算机唯一可以直接执行的语言，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。  

15.D  

解释程序的特点是翻译一句执行一句，边翻译边执行；由高级语言转化为汇编语言的过程称为编译，把汇编语言源程序翻译成机器语言程序的过程称为汇编。  

16.D  

在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编程序转换成机器指令。特定的汇编语言与特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。  

17.B 计算机只能直接执行机器指令，而汇编指令需要通过汇编程序转换成机器指令才能被计算机直接执行。  
18.C  

全面代表计算机性能的是实际软件的运行情况。向后兼容是指时间上向后兼容，即新机器兼容使用以前机器的指令系统。软件和硬件在逻辑功能上是等价的，如浮点运算即可以用专门的浮点运算器实现，也可以通过编写一段子程序实现。  

19.B  

CPU由运算器和控制器两个部件组成，而运算器和控制器中都含有寄存器。存储器是一个独立的部件。  

20.C  

相联存储器既可以按地址寻址又可以按内容（通常是某些字段）寻址，为与传统存储器区别，也称按内容寻址的存储器。  

21.A  

硬件能直接执行的只能是机器语言（二进制编码），汇编语言是增强机器语言的可读性和记忆性的语言，经过汇编后才能被执行。  

22. C  

翻译程序是指把高级语言源程序转换成机器语言程序的软件。翻译程序有两种：一种是编译程序，它将源程序一次全部翻译成目标程序，并且会生成目标代码文件。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，翻译一句执行一句，并且不会生成目标代码文件。汇编程序也是一种翻译程序，它把汇编语言源程序翻译为机器语言程序。  

23.C  

冯·诺依曼结构计算机的功能部件包括输入设备、输出设备、存储器、运算器和控制器，程序的功能都通过中央处理器（运算器和控制器）执行指令，A正确。指令和数据以同等地位存放于存储器内，形式上无差别，只在程序执行时具有不同的含义，B正确。指令按地址访问，数据由指令的地址码指出，除立即寻址外，数据均存放在存储器内，C错误。在程序执行前，指令和数据需预先存放在存储器中，中央处理器可以从存储器存取代码，D正确。  

24.A  

将源程序转换为可执行目标文件的过程分为预处理、编译、汇编、链接四个阶段。  



# 1.3.4 答案与解析  

# 一、单项选择题  

01.D  

CPU主频指CPU的时钟脉冲频率，CPI是执行一条指令平均使用的CPU时钟数。  

02.B  

存储体由许多存储单元组成，每个存储单元又包含若干存储元件，每个存储元件能寄存一位二进制代码“0”或“1”。可见，一个存储单元可存储一串二进制代码，称这串二进制代码为一个存储字，称这串二进制代码的位数为存储字长。  

03.C  

计算机中一个字的长度可以是16、32、64位等，一般是8的整数倍，不一定都是32位。  

04. C  

机器字长、存储字长和指令字长，三者在数值上可以相等也可以不等，视不同机器而定。机器字长等于CPU内部的运算器位数和通用寄存器宽度。一个存储单元中的位数称为存储字长，它等于MDR的位数。指令字长取决于指令的功能和格式，可以是单字长、半字长或双字长。  

05.D  

机器字长会影响硬件的造价。它将直接影响加法器（或ALU），内部总线宽度及寄存器的位数。所以机器字长不能只从数据的精度和表示范围来考虑，还要考虑硬件成本和效率。  

06.B  

计算机的位数是指机器字长，也就是计算机一次能处理的二进制数的长度，通常等于ALU的宽度或通用寄存器的位数。操作系统的位数是指操作系统可寻址的位数，它与机器字长不同。  

07.C  

MFLOPS是指每秒执行多少百万次浮点运算，该参数用来描述计算机的浮点运算性能，而用于科学计算的计算机主要评估浮点运算的性能。  

08.D  

CPU执行时间 $=$ 指令条数 $\times\mathrm{CPI}\times$ 时钟周期的长度，程序在M1和M2上的平均CPI相等，但影响CPU执行时间的因素还有指令条数和时钟周期的长度，此外相同的高级语言程序在不同计算机上编译生成的机器指令条数可能不同，因此无法确定哪台机器执行该类程序的速度快。  
09.C  

机器字长是CPU一次可以处理的二进制代码的位数，因此该机一次可处理 $4{\times}8=32$ 位的二进制代码。计算机的数据表示格式有多种，不同的表示方式所能表示的数据范围不同。  

10.B  

汇编程序员可以通过JIMP指令来设置PC的值。状态寄存器、通用寄存器只有为汇编程序员可见，才能实现编程，而IR、MAR、MDR是CPU的内部工作寄存器，对程序员均不可见。  

11.A  

时钟周期即CPU频率的倒数，是最基本的时间单位，其余选项均大于时钟周期。另外，CPU周期也称机器周期，它由多个时钟周期组成。  

12.A  

CPI是执行一条指令所需的时钟周期数，系统结构、指令集、计算机组织都会影响CPI，而时钟频率并不会影响CPI，但可加快指令的执行速度。例如，执行一条指令需要10个时钟周期，则一台主频为1GHz的CPU，执行这条指令要比一台主频为 $100\mathrm{MHz}$ 的 CPU快。  

13.B  

主频、主存储器容量和指令系统（间接影响CPI）并不是综合性能的体现。吞吐率指系统在单位时间内处理请求的数量，是评价计算机系统性能的综合参数。  

14.D  

提高CPU主频、扩大主存储器容量对性能的提升是有限度的。采用并行技术是实现高性能计算的重要途径，现今超级计算机均采用多处理器来增强并行处理能力。  

15.C  

兼容是指计算机软件或硬件的通用性，因此A、D错误。对于B，它们在任何计算机间可以通用，错误。对于C，兼容通常在同一系列的不同型号计算机间，正确。  

16.B  

机器的速度与基准程序在该机器上的运行时间呈相反关系，因此可知：机器B的速度/机器A的速度 $=$ 基准程序在机器A上的运行时间/基准程序在机器B上的运行时间 $=20\mathrm{s}\dot{\cdot}16\mathrm{s}=1.25$ 因此，可以说，机器B的速度是机器A的1.25倍，或者机器A的速度是机器B的0.8倍。  

17.D  

该程序在机器A上需要的时钟周期数为 $12\!\times\!800\mathrm{M}=9600\mathrm{M}$ ，因为在机器B上运行该程序所需的时钟周期数为在A上的1.5倍，所以在B上需要的时钟周期数为 $9600\mathbf{M}\!\times\!1.5\:=\:14400\mathbf{M}\:=$ 14.4G，要求运行时间为8s，故B的时钟频率为 $14.4\mathrm{G}\dot{\cdot}8=1.8\mathrm{GHz}\circ$  

18.D  

显然，MIPS、CPI、字长都是评价计算机系统的性能指标。IPC表示每个时钟周期运行多少条指令，它是CPI的倒数。  

19.D  

机器字长越长，数据的位数越多，定点数或浮点数所表示及运算的精度就越高，D正确。机器字长与运算速度的关系不大，机器字长与存取速度和内存容量基本没有关系。  

20.D  

$\mathrm{{MIPS}=}$ 主频 $_{(\mathrm{CPI}\times10^{6})}$ ，主频 $=$ 1/时钟周期 $=1/2\mathrm{ns}\,{=}\,500\mathrm{M}$ ，序列一的 $\mathrm{CPI}=(1{\times}1+1{\times}2+4{\times}3){\div}6=$  $15\dot{\cdot}6=2.5$ ，序列二的 $\mathrm{CPI}=(2{\times}1+1{\times}2+2{\times}3){\div}5=10{\div}5=2$ ，故序列一的 $_\mathrm{MIPS}=500\mathrm{M}+(2.5{\times}10^{6})=200$ 序列二的 $\mathrm{MIPS}=500\mathbf{M}+(2\times10^{6})=250\circ$ CPU执行时间 $=$ 指令条数 $\mathbf{\times}\mathbf{CPI\times}$ 时钟周期 $=$ 程序的时钟周期数 $\times$ 时钟周期，序列一所需的时钟周期数是15，序列二所需的时钟周期数是10，故序列一的执行时间为 $15{\times}2\mathrm{ns}\,{=}\,30\mathrm{ns}$ ，序列二的执行时间为 $10{\times}2\mathrm{ns}\,{=}\,20\mathrm{ns}$  
21.D  

采用更快的处理器，可以减少单条指令的执行时间：增加处理器的个数，可以增加程序执行的并行性，缩短程序的执行时间；优化编译代码，可以减少指令之间的各种冲突；访存时间占指令执行的大部分时间，减少访存时间同样可以大大加快指令的执行时间。  

22.D  

CPU时钟频率（主频）越高，完成指令的一个执行步骤所用的时间就越短，执行指令的速度就越快，I正确。数据通路的功能是实现CPU内部的运算器和寄存器及寄存器之间的数据交换，优化数据通路结构，可以有效提高计算机系统的吞吐量，从而加快程序的执行，Ⅱ正确。计算机程序需要先转化成机器指令序列才能最终得到执行，通过对程序进行编译优化可以得到更优的指令序列，从而使得程序的执行时间也越短，ⅢI正确。  

23. D  

MIPS是每秒执行多少百万条指令，适用于衡量标量机的性能。CPI是平均每条指令的时钟周期数。IPC是CPI的倒数，即每个时钟周期执行的指令数。MFLOPS是每秒执行多少百万条浮点数运算，用来描述浮点数运算速度，适用于衡量向量机的性能。  

24.D  

程序A的运行时间为100s，除去CPU时间 $90s$ ，剩余10s为I/O时间。CPU提速 $50\%$ 后运行基准程序A所耗费的时间是 $T\,{=}\,90{\div}\,1.5+10=70s\,\mathrm{c}$  

误区：CPU速度提高 $50\%$ ，而误认为CPU时间减少一半，从而误选A。  

25.C  

基准程序的 $\mathrm{CPI}=2{\times}0.5+3{\times}0.2+4{\times}0.1+5{\times}0.2=3$ 。计算机的主频为1.2GHz，即1200MHz，因此该机器的 $\mathrm{MIPS}=1200\div3=400.$  

26.D  

假设原来的指令条数为 $x$ ，则原CPI为 $20f/x$  $(f$ 为CPU的时钟频率），经过编译优化后，指令条数减少到原来的 $70\%$ ，即指令条数为 $0.7x$ ，而CPI增加到原来的1.2倍，即 $24f/x$ ，则现在P在M上的执行时间就为：（指令条数 $\times\mathrm{CPI})/f{=}\,(0.7x{\times}24{\times}f/x)/f{=}\,24{\times}0.7{=}\,16.8\mathrm{s}$  

27. C  

运行时间 $=$ 指令数 $\times\mathrm{CPI}/\$ 主频。MI的时间 $=$ 指令数 $\times2\dot{\cdot}1.5$ ，M2的时间 $=$ 指令数 $\times1/1.2$ 两者之比为 $(2/1.5){\cdot}(1/1.2)=1.6$  

28.B  

机器字长是指CPU内部用于整数运算的数据通路的宽度。数据通路是指数据在指令执行过程中所经过的路径及路径上的部件，主要是CPU内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致才能相互匹配。因此，机器字长等于ALU位数和通用寄存器宽度。  

29.D  

PFLOPS $=$ 每秒1000万亿（ $10^{15}$ ）次浮点运算。故93.0146PFLOPS $\approx$ 每秒 $9.3{\times}10^{16}$ 次浮点运算，即每秒9.3亿亿次浮点运算。  

30.A  

CPI指平均每条指令的执行需要多少个时钟周期。由于 $80\%$ 的指令执行平均需要1个时钟周期， $20\%$ 的指令执行平均需要10个时钟周期，因此 $\mathrm{CPI}=80\%\!\times\!1+20\%\!\times\!10=2.8$ 6计算机主频为1GHz，程序P共执行10000条指令，平均每条指令需要2.8个时钟周期，因此，CPU执行时间 $=$  $(10000\times2.8){\div}10^{9}\!=\!2.8{\times}10^{-5}\,\mathrm{s}=28\upmu\mathrm{s}.$  
31.C  

程序P的指令条数为 $5{\times}10^{5}$ ，平均CPI为1.2，程序P的总时钟周期数为 $5{\times}10^{5}{\times}1.2=6{\times}10^{5}$ 主频1.5GHz说明1s有 $1.5\mathrm{G}\,=\,1.5{\times}10^{9}$ 个时钟周期。因此，指令执行速度 $=$ 主频/平均CPI $=$  $1.5\mathrm{G}{\div}1.2=1.25\mathrm{G}\mathrm{IPS}$ ，用户CPU时间 $\mathbf{\Sigma}=6{\times}10^{5}\mathbf{\dot{\Sigma}}(1.5{\times}10^{9})\mathbf{s}=4{\times}10^{4}\mathbf{s}=0.4\mathbf{ms}.$  

# 二、综合应用题  

01.【解答】  

因为主存储器容量为 $64\mathrm{K}\!\times\!32$ 位，且 $2^{16}\,{=}\,64\mathrm{K}$ ，所以地址总线宽度为16位，32位表示数据总线宽度，于是MAR为16位，PC为16位，MDR为32位。  

因为指令字长 $=$ 存储字长 $=$ 机器字长，所以IR、ACC、MQ、X均为32位。  

寄存器之间的信息通路有：  

PC→MAR Ad（IR)→MAR MDR→IR 取数：MDR→ACC，存数：ACC→MDRMDR→X  

02.【解答】  

CPI即执行一条指令所需的时钟周期数。本标准测试程序共包含4种指令，则CPI就是这4种指令的数学期望，即  

$$
\mathrm{CPI}=1\times60\%+2\times18\%+4\times12\%+8\times10\%=2.24
$$  

MIPS即每秒执行的百万条指令数。已知处理器时钟频率为 $40\mathrm{MHz}$ ，即每秒包含 $40\mathrm{M}$ 个时钟周期，因此  

$$
{\mathrm{MIPS}}=40/{\mathrm{CPI}}=40{\div}2.24=17.9
$$  

程序的执行时间 $T=\mathrm{CPI}{\times}\mathrm{T\_IC}{\times}I,$ ，其中T_IC是一个CPU时钟的时间长度，是CPU时钟频率 $f$ 的倒数，因此有  

$$
T\!=\!\mathrm{CPI}\!\times\!\mathrm{T\_IC}\!\times\!I\!=\!\mathrm{CPI}\!\times\!(1/f)\!\times\!I\!=5.6\!\times\!10^{-8}\!\times\!I
$$  

本题中的 $I$ 对于解题应无作用，程序的执行时间应是指令的期望即CPI乘以时钟的时间长度，即  $T\!=\!\mathrm{CPI\!\times\!T\!_{\!\_\mathrm{IC}}}$  

03.【解答】  

1）A机的CPU主频为8MHz，所以A机的CPU时钟周期 $=1\dot{-}8\mathrm{MHz}=0.125\upmu\mathrm{s}$  

2）A机的平均指令周期 $=1\div0.4\mathrm{MIPS}=2.5\upmu\mathrm{s}$  

3）A机平均每条指令的时钟周期数 $=2.5\upmu\mathrm{s}\dot{\cdot}0.125\upmu\mathrm{s}=20.$  

因微机A和B的片内逻辑电路完全相同，所以B机平均每条指令的时钟周期数也为20。  

因为B机的CPU主频为 $12\mathrm{MHz}$ ，所以B机的CPU时钟周期 $=1\dot{\cdot}12\mathrm{MHz}=1/12\upmu\mathrm{s},$  

B机的平均指令周期 $=20\!\times\!(1/12)\!=\!5/3\upmu\mathrm{s}$ B机的平均指令执行速度 $=1\div(5/3)\upmu\mathrm{s}\,{=}\,0.6\mathrm{MIPS}\,\mathrm{s}$  

【另解】B机的平均指令执行速度 ${\mathbf{\tau}}=\operatorname{A}$ 机的平均指令执行速度 $\times(12/8)=0.4\mathrm{MPS}\times(12/8)=$ 0.6MIPS  
04.【解答】  

$\textcircled{\scriptsize{1}}$ 本处理机共包含4种指令，则CPI就是这4种指令的数学期望，即  

$$
\mathrm{CPI}=1\times43\%+2\times21\%+2\times12\%+2\times24\%=1.57
$$  

$\circledcirc$ 设原指令总数为 $M$ ，由于新增的算术操作有取操作数的功能，替代了LOAD的功能，所以新指令总数为  

$$
M+(0.25\times0.43M)^{-}(0.25\times0.43M)^{-}(0.25\times0.43M)^{=}0.8925M
$$  

增加另一种算术逻辑指令后，每种指令所占的比例及CPI数如下表所示：  

所以 $\mathrm{CPI}^{\prime}\!=\!1\!\times\!0.3613+2\!\times\!0.1204+2\!\times\!0.1149+2\!\times\!0.1345+3\!\times\!0.2689\!=\!1.9076$ 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2485e9a7c459ad22743446bd533d8f53aaf1c7a8f5213475fbbacea781d73eac.jpg)  


# 2.1.6 答案与解析  

# 一、单项选择题  

01.B  

十进制数转换成八进制数，整数部分采用除基取余法：将整数除以8，所得余数即为转换后的八进制数的个位数码，再将商除以8，余数为八进制数十位上的数码，如此反复进行，直到商是0为止。小数部分采用乘基取整法：将小数乘以8，所得积的整数部分即为八进制数十分位上的数码，再将此积的小数部分乘以8，得到百分位上的数码，如此反复直到积是1.0为止。经转换得到的八进制数为211.40。  
02.B 一个16位无符号二进制数的表示范围是 $0{\sim}2^{16}\mathrm{-}1$ ，即 $0{\sim}65535$  

U3.D  

A、B、C明显正确，二进制整数和十进制整数可以相互转换，仅仅是每位的位权不同而已。而二进制的小数位只能表示 $1/2,1/4,1/8,\cdots,1/2^{n}$ ，因此无法表示所有的十进制小数，D错误。  

04.B 假设位数为5位(含1位符号位)， $[+0]_{\#}=00000,\,[-0]_{\#}=10000,\,[+0]_{\#}=00000,\,[-0]_{\#}=11111,$  $[+0]_{*}=[-0]_{*}=00000$  $[+0]_{\#}=[-0]_{\#}=10000$ 。可知，0的补码和移码的表示是唯一的。  

05.B 若 $X$ 为负数，则其补码转换成原码的规则是“符号位不变，数值位取反，末位加1"，即 $[X]_{i i}\!=$  $0010101+1=0010110.$  

06.D 不论 $X$ 是正数还是负数，由 $[X]_{+}$ 求[-X]的方法是连同符号位一起，每位取反，末位加1。  

07. C  

8个二进制位有 $2^{8}\!=\!256$ 种不同表示。原码中0有两种表示，因此原码能表示的不同数据为 $2^{8}\mathrm{-}1=255$ 个。由于〇在反码中也有两种表示，因此若题目改为反码，答案也为C。0在补码与移码中只有一种表示，因此题目若改为补码或移码，答案为D。  

08.D  $n+1$   $-2^{n}+1{\leqslant}x{\leqslant}2^{n}-1$  

09.D  $n$ 位二进制有符号定点整数，数值位只有 $n-1$ 位最高位为符号位，所以最大值为 $2^{n-1}$ -1。  

10.A  $N$ 位二进制小数共有 $2^{N}$ 种状态，每种状态都能表示一个不同的小数，而十进制小数能表示的数的个数为 $10^{N}$ ，二者的商为 $(0.2)^{N}$ 。这也是为何在计算机的运算中会出现误差情况的原因，它表明仅有 $(0.2)^{N}$ 概率的十进制数可以精确地用二进制表示。  

11. C 对于长度为 $n+1$ （含1位符号位）定点整数 $x$ ，用补码表示时， $x_{\sqrt[[object Object]]{x}}\!=\!-2^{n}$ ，这里 $n\!=\!63$  

12.B 以机器字长5位为例， $[0]_{\#}\!=\!00000$  $[0]_{\#}=2^{4}+0=10000$  $[0]_{\#}\neq[0]_{\#}$ ，表示不相同，但在补码或移码中的表示形式是唯一的。  

13. C  

对于此类题型，先写出特定值的机器码表示，然后根据机器数判断大小的规则来推导数值位的特点（若条件允许，也可以取特殊值来推断）。 $-32$ 的补码为1,100000，根据负数补码判断大小的规则：数值位部分越小，其绝对值越大，即负得越多。因此，若要 $\scriptstyle{x\,>\,-32}$ ，数值位 $x_{1}x_{2}x_{3}x_{4}x_{5}x_{6}$ 需大于100000，即 $x_{1}$ 必须为1，而 $x_{2}\cdots x_{6}$ 中至少有一位为1。  

【特殊值法】对于A，取1,000000，真值为-64，错误。对于B，取1,100000，真值为-32，错误。对于C，取1,100001，真值为-31，符合。对于D，取1.000001，真值为-63，错误。  
14.C  

解题思路与上题类似（也可以采用特殊值解法，请读者自行思考）， $-16$ 的补码为110000根据负数补码判断大小的规则：数值位部分越小，其绝对值越大，即负得越多。因此，若要 $x<-16$ 数值位 $x_{1}x_{2}x_{3}x_{4}x_{5}$ 需小于10000，即 $x_{1}$ 必为0，而 $x_{2}{\sim}x_{5}$ 任意。  

15.D  

当 $x$ 为0或为正数时，满足 $[-x^{*}]_{\#}=[-x]_{\#}$ ，B为充分条件，因此B错误。而 $x$ 为负数时， $-x$ 为正数，而 $-x^{*}$ 为负数，补码的表示是唯一的，显然二者不等，因此C错误。  

16.B  $x\!=\!-66$ 用二进制表示， $[x]_{^{18}}=11000010$ ，则有 $[x]_{*}=10111110=\mathrm{BH}$  

17.C  $\mathrm{9BH}\,{=}\,(1001\ 1011)_{2}$ ，最高位的1表示负数，故其真值为 $(11100101)_{2}\,{=}\,{-}(64+32+4+1)\,{=}\,{-}101$  

18.A  

值等于-0说明只可能是原码或反码（因为补码和移码表示 $0$ 时是唯一的，没有 $+0$ 和-0之分）， $[-0]_{\mathbb{R}}=10000000$ ， $[-0]_{\bar{\kappa}}=$ 11111111。  

19. D  

这里寄存器长度为8， $[+127]_{^{11}\!}=[+127]_{^{12}\!}=[+127]_{^{1*}}\!=0111111$ ，又知同一数值的移码和补码除最高位相反外，其他各位相同，则 $[+127]_{\mathfrak{C}}=11111111$ 或 $[+127]_{\mathrm{\#}}=2^{7}+01111111=1111111\,\mathrm{.}$  

20.B 这里寄存器长度为8， $[-1]_{\#}=[10000001]_{\#}=$ 11111111.  

21.D 这里寄存器长度为8， $[-128]_{\#}=2^{7}+(-10000000)=00000000.$  

22.C 真值-0.1101，对应的原码表示为1.1101，补码表示为1.0011，反码表示为1.0010，移码通常用于表示阶码，不用来表示定点小数。  

23.B 选项B对应8位最小的值-128，而- $-x=128$ 发生溢出，因此无法表示其移码。  

24.A  

若采用补码表示，要使得数值最大，就要让符号位为0，且把“1”放在高位，得到的补码为0111 $1110\mathbf{B}=126$ ：要使得数值最小，就要让符号位为1，且把“1”放在低位，得到的补码为 $1001\ 1111\mathrm{B}=-97.$ 。若采用移码表示，偏置值为128时，要使得数值最大，就要把“1”放在高位，得到的移码为 $1111\ 1100\mathbf{B}-1000\ 0000\mathbf{B}=252-128=124$ ：偏置值为127时，要使得数值最小，则应把“1”放在低位，得到的移码为 $0011\ 1111\mathbf{B}-0111\ 1111\mathbf{B}=1100\ 0000\mathbf{B}=-64$ ，A正确。  

25. D  

$[+0]*$ 和[-0]是相同的，所以1正确。在进行补码定点数的加减运算时，符号作为数的一部分参加运算，Ⅱ正确， $[A]_{*}-[B]_{*}=[A]_{*}+[-B]_{*}$ ，即将减法采用加法实现，IV正确。实际上，补码和其真值的对应关系远不如原码和其真值的对应关系简单直观，Ⅲ错误。  

26.D 主存地址都是正数，因此不需要符号位，因此直接采用无符号数表示。  

27.B  

16位扩展为32位，符号位不变，附加位是符号位的扩展。该数是一个负数，需用1来填补。A是一个正数，C的数值位发生变化，D用0来填充附加位，均不正确。  
28.B  

将一个16位unsignedshort型数转换成32位unsignedint型数时，因为都是无符号数，新表示形式的高位用0填充。16位无符号整数所能表示的最大值为65535，其十六进制表示为FFFFH，因此×的十六进制表示为FFFFH-5H $=$ FFFAH，所以y的十六进制表示为0000FFFAH。  

排除法：先直接排除C、D，然后分析余下选项的特征。由于A、B的值相差几乎近1倍，因此可以算出 $0001\;0000\mathrm{H}$ （接近B且好算的数）的值后，再推断出答案。  

29.B  

原码很容易判断大小。而负数的补码很难直接判断大小，可采用如下规则快速判断：对于负数，数值位部分越小，其绝对值越大，即负得越多。采用补码整数表示时，负数的符号位为1，因此剩下的两个“1”放在末位时其值最小，补码形式为 $1000\;0011$ ，转换为真值为-125。此外，考虑负数的补码转换为原码的方法，从右向左找到第一个数值为1的位，之后的每位进行取反操作，符号位不变，不难发现，当符号位为1，剩下的两个“1”放在末位时，补码的绝对值最大。  

30.D  

因C语言中的数据在内存中为补码表示形式，si对应的补码二进制表示为1000000000000001B，最前面的一位“1”为符号位，表示负数，即-32767。由signed型转换为等长的unsigned型数据时，符号位成为数据的一部分，即负数转换为无符号数（即正数）时，其数值将发生变化。usi对应的补码二进制表示与si的表示相同，但表示正数，为32769。  

31.D  

对于I，二进制只有0和1两种数值，运算规则较简单，都通过ALU转换成加法运算。对于IⅡI，二进制只需要高电平和低电平两个状态就可表示，这样的物理器件很容易制造。对于Ⅲ，二进制与逻辑量相吻合。二进制的0和1正好与逻辑量的“真”和“假”相对应，因此用二进制数表示二值逻辑显得十分自然，采用逻辑门电路很容易实现运算。  

32.A  

unsigned short，长度为2字节，unsigned short usi码即1111111111111111。short型为短整型，长度为2字节，在采用补码的机器上，shortsi的二进制代码为1111111111111111，因此si的值为-1。  

33.D  

若 $x,y$ 和 $z$ 均为无符号整数，则 $x>y>z$ ，A和B错误。若 $x,y$ 和 $z$ 均为有符号整数，补码的最高位是符号位，0表示正数，1表示负数，因此 $z$ 为正数，而 $x$ 和 $y$ 为负数。对于 $x$ 和 $y$ 的比较，数值位取反加1，可知 $x\!=\!-3$ ， $y=-33$ ，故 $x\!>\!y$ 。D正确。  

34.B  

$n$ 位补码整数的最小值是 $1{,}00_{\dots}0$ （即 $-2^{n-1}$ )；最大值是 $0{,}11{\ldots}1$ （即 $2^{n-1}-1)$ 。 $n$ 位补码整数所能表示的范围是 $-2^{n-1}\sim2^{n-1}-1$ ，32位补码整数所能表示的范围是 $-2^{31}\!\sim\!2^{31}\!-\!1$ 。  


# 2.2.6 答案与解析  

# 一、单项选择题  

01.B  

ALU是由组合逻辑电路构成的，最基本的部件是并行加法器。由于单纯的ALU不能够存储运算结果和中间变量，因此往往将ALU和寄存器或暂存器相连。  
02.D  

ALU为运算器核心，C正确；数据总线供ALU与外界交互数据使用，B正确；溢出标志即为一个状态寄存器，A正确。地址寄存器不属于运算器，而属于存储器，D错误。  

03. C  

ALU既能进行算术运算又能进行逻辑运算。  

04.B  

该数是一个正数（最高位为0），按照补码算术移位规则，算术左移两位后，移出了最高位01，低位补0，因此算术左移两位后的结果是 $0101\;0100$ 。虽然移位后该数的符号位仍为0，但是移出了有效位1，所以本次算术移位发生了溢出。  

05.D  

$80\mathrm{H}\!=\!(1000\,0000)\!<<\!1=\!000000000,$ ，左移前的符号位为1，左移后的符号位为0，溢出。 $\mathrm{90H\!=\!(1001}$  $0000\!\ll\!1\!=\!0010\,0000,$ ，左移前的符号位为1，左移后的符号位为0，溢出。 $\mathrm{B0H}\,{=}\,(1011\;0000)\,{<}\,1\,{=}\,0110$ 0000，左移前的符号位为1，左移后的符号位为0，溢出。  $\mathrm{C0H}=(1100\,0000)<<1=10000000$  ，左 移前的符号位为1，左移后的符号位为1，未溢出，D正确。  

06. D  

该数是一个负数（最高位为1），按照算术补码移位规则，负数右移添1，负数左移添0，所以10010101右移一位后的值为 $1100\ 1010$  

07.C 在十六进制数的加减法中，逢十六进一，因此有7E5 $\mathrm{H}+4\mathrm{D}3\mathrm{\,H}\!=\!\mathrm{C}\mathrm{B}8\mathrm{\,H}.$ 08.C 算术左移时，低位补0；算术右移时，高位补符号位。 $\mathrm{BAH}=(1011\;1010)_{2}$ ，算术左移 $1$ 位得(0111 $0100)_{2}=74\mathrm{H}$ ，左移前后的符号位不同，溢出；算术右移1位得 $(1101\;1101)_{2}=\mathrm{{DOH}}$ 09.C  

三种溢出判别方法，均须有溢出判别电路，可用“异或”门来实现。  

10.A 机器运算发生溢出的根本原因是计算机的字长有限，所以不能表示超过一定范围的数据。  

11. C  

首先将 $r_{1}$ 和 $r_{2}$ 转换为真值， $\mathrm{F}5\mathrm{H}=1111\ 0101$ ，转换为原码是10001011，真值为-11；EEH $=$ 11101110，转换为原码是 $1001\ 0010$ ，真值为-18，8位补码的表示范围为[-128，127)， $r_{1}\!\times\!r_{2}$ 的结果为198，超出了8位补码的表示范围，发生溢出。  

12.B  

模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题，A错误。需要注意的是，存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的，B正确。只在把两个模4补码的数送往ALU完成加减运算时，才把每个数的符号位的值同时送到ALU的双符号位中，即只在ALU中采用双符号位，C、D错误。  

13.B  

采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出。若第二位和第一位符号相同，则未溢出；若不同，则溢出。若发生正溢出，则双符号位为01，若发生负溢出，则双符号位为10。  
14.D  

采用进位位来判断溢出时，当最高有效位进位和符号位进位的值不相同时才产生溢出。两正数相加，当最高有效位产生进位（ $C_{1}=1$ ）而符号位不产生进位（ $C_{0}\!=\!0$ ）时，发生正溢出；两负数相加，当最高有效位不产生进位（ $C_{1}\!=\!0$ ）而符号位产生进位（ $C_{0}\!=\!1$ ）时产生负溢出。因此溢出条件为 $\overline{{{C_{0}}}}C_{1}+C_{0}\overline{{{C_{1}}}}=C_{0}\oplus C_{1}.$  

15. C  

用两位符号位判断溢出时，两个符号位不同时表示溢出，即01时表示正溢出；10时表示负溢出；两个符号位相同时（11或00）表示未溢出。  

16.B  

补码左移时，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出。补码左移时， $X_{0}$ 移出， $X_{1}$ 取代 $X_{0}$ 成为新的符号位，因此若 $X_{0}\!\neq\!X_{1}$ ，则表示发生了溢出。  

17.A  

原码一位乘法中，符号位与数值位是分开进行运算的。运算结果的数值部分是乘数与被乘数数值位的乘积，符号是乘数与被乘数的符号位的异或。  

18.B  

在原码一位乘法中，符号位不参加运算，符号位单独处理，同号为正，异号为负。  

19.C  

原码的符号位为1表示负数，为0表示正数。原码乘法时，符号位单独处理，乘积的符号是两个操作数的符号相“异或”的结果，同号为正，异号为负。  

20.D  

对于左移操作，逻辑左移和算术左移的结果都一样，高位移出，低位补0。逻辑移位不考虑符号位的问题，逻辑左移时，若最高位移出的是1，表示发生溢出。算术左移时，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，表示发生溢出。因此I、ⅡI、Ⅲ均正确。  

21.B  

不管是补码减法，还是无符号数减法，都是用被减数加上减数的负数的补码来实现的。根据求补公式，减数 $y$ 的负数的补码 $[-y]_{\#}\!=\!\overline{{Y}}+1$ ，因此，在加法器的Y'输入端用一个反向器实现，并用控制端Sub控制多路选择器是否将 $y$ 的各位取反后，输入Y'端，同时将Sub作为低位进位送到加法器。当Sub为1时，做减法， ${\mathrm{Sub}}=1$ 控制将 $\overrightharpoon{Y}$ 输入到加法器Y端，即实现“各位取反”功能；同时将 $\mathrm{Sub}\,=\,1$ 作为低位进位送到加法器，实现“末位加1”功能。69的二进制数为01000101；38的二进制数为00100110，各位取反得 $1101\;1001$ 。做减法时，低位进位为Sub，即为1。  

> attention  

若仅记忆补码加减运算的过程，而未掌握加法电路的原理，则本题易误选 $\mathrm{D}$  

22.A  

对于补码减法运算，控制端Sub为1，故低位进位输入位 $\mathrm{\Delta=\Delta u b=l\,,}$  $[x]_{*}\,{=}\,1111\,0101$  $[y]_{\#}\!=\!0111$ 1110，  $[-y]_{*}=1000\,0001+1$   $[x]_{*}-[y]_{*}=[x]_{*}+[-y]_{*}=1111\,0101+1000\,\,0010=0111\,0111$  ，进位丢 掉，参与运算的两个数的符号均为1，结果的符号位为0，故溢出标志0F为1。  

23.C  

[x/2  $+2y]_{*}=[x]_{*}>>1+[y]_{*}<<1=0100\,0100>>1+1101\,1100<<1=0010\,0010+\,1011\,1000=$   $101\ 1010=\mathrm{D}$ AH。 $x$ 右移移出了0，没有溢出或损失精度； $y$ 为负数，左移后，符号位仍为1，没有溢出；且从最后一步加法操作来看，一个正数和一个负数相加，必然不会溢出。  
24.A  

$[x]_{^{\#}}=44\mathrm{H}=0100\;0100$  $[y]_{+}=\mathrm{DCH}=1101\ 1100$ 。执行 $x-2y$ 时，先将 $y$ 算术左移一位，得到10111000，未溢出，然后各位取反，再与 $x$ 相加，做减法时sub $=1$ ，即 $0100\,0100+0100\,0111+1=$ 10001100(8CH)，两个加数的符号都为0，而结果的符号为1，因此发生了溢出，即 $\mathrm{OF}=1$  

25.D  

C语言中的整型数据为补码形式，int型为32位，short型为16位，因此 $\mathbf{X}_{\mathbf{Y}}$ y的机器数写为0000007F、FFF7H。执行 ${\mathrm{z=x+y}}$ 时，由于 $_\mathrm{x}$ 为int型，y为short型，因此需将y的类型强制转换为int型，在机器中通过符号位扩展实现，由于y的符号位为1，因此在y的前面添加16个1，即可将y强制转换为int型，其十六进制形式为FFFFFFF7H。然后执行加法，即0000007FH $^+$ FFFFFFF7H $=00000076\mathrm{H}$ ，其中最高位的进位1自然丢弃。  

26.B  

本题的真正意图是考查补码的表示范围，采用补码乘法规则计算出四个选项是费力不讨好的做法，且极易出错。8位补码所能表示的整数范围为- $-128\!\sim\!+127$ 。将四个数全部转换为十进制数： $r_{1}\,{=}\,{-}2$ ， $r_{2}\,{=}\,{-}14$ ， $r_{3}\,{=}\,{-}112$ ， $r_{4}\,{=}\,{-}8$ ，得 $r_{2}\!\times\!r_{3}=1568$ ，远超出了表示范围，发生溢出。  

27. A  

$x^{*}2$ ，将 $x$ 算术左移一位为11101000； $y/2$ ，将 $y$ 算术右移一位为11011000，均无溢出或丢失精度。补码相加为 $1\ 1101000+1\ 1011000=1\ 1000000$ ，亦无溢出。  

28.C  

8位定点补码表示的数据范围为- $\cdot128\!\sim\!127$ ，若运算结果超出这个范围，则会溢出。对于A， $x+$  $y\,{=}\,103-25\,{=}\,78,$ ，符合范围。对于B， $-x+y=-103-25=-128$ ，符合范围。对于D， $-x\!-\!y\!=\!-103+$  $25=-78$ ，符合范围。对于C， $x-y=103+25=128$ ，超过127。  

29.C  

利用补码转换成原码的规则：负数的符号位不变数值位取反加1：正数补码等于原码。两个机器数对应的原码是 $[x]_{\mathrm{I\!I}}=8000002\,\mathrm{I\!H}$ ，对应的数值是-33， $[y]_{\#}\,{=}\,[y]_{*}\,{=}\,0000041\mathrm{H}\,{=}\,65$ 。排除A、D。 $x-y$ 直接利用补码减法准则， $[x]_{^{\#}}-[y]_{^{\#}}=[x]_{^{\#}}+[-y]_{^{\#}}$  $-y$ 的补码是连同符号位取反加1，最终减法变成加法，得出结果为FFFFFF9EH。  

30.B  

逻辑移位：左移和右移空位都补0，且所有数字参与移动；补码算术移位：仍然是所有数字参与移动，右移空位补符号位，左移空位补0。根据该规则，轻松选出B。  

31.A  

$[x]_{^{\#}}-[y]_{^{\#}}=[x]_{^{\#}}+[-y]_{^{\#}}$  $[-\mathrm{R}2]_{\#}=0000010\mathrm{H}$ ，很明显R1 $]*+[-\mathrm{R}2]$ 补的最高位进位和符号位进位都是1（当最高位进位和符号位进位的值不相同时才产生溢出），可以判断溢出标志0F为0。同时，减法操作只需判断借位标志，R1大于R2，所以借位标志为0。  

32.B  

ALU生成标志位时只负责计算，而不管运算对象是有符号数还是无符号数， $\mathrm{CF}\,=\,1$ 表示当作无符号数运算时溢出， $\mathrm{OF}=1$ 表示当作有符号数运算时溢出。当作有符号数时， $x=10$  $\scriptstyle{y=-20}$  $x-y=30$ ，未超过32位有符号数范围，不溢出， $\mathrm{OF}=0$ 。当作无符号数时， $x^{\prime}\!=10,\;\;y^{\prime}\!=2^{32}\!-20$ （符号位读作数值位）， $x^{\prime}-y^{\prime}=30-2^{32}$ ，为负，超过32位无符号数范围，溢出， $\mathrm{CF}=1$  

# 二、综合应用题  

01.【解答】  

为判断溢出，采用双符号位。  
因为 $A\,{=}\,-1001\,,\,\,\,B\,{=}\,-0101$ ，所以 $[A]_{*}=11,0111$ ， $[B]_{*}\!=\!11$ ,1011, $[-B]_{*}\,{=}\,00,0101$  

则 $[A]_{*}+[B]_{*}=11$  $0111+11$  $1011=11$ ,0010。  

则  $[A]_{*}-[B]_{*}=[A]_{*}+[-B]_{*}=11,0111+00,0101=11,1100\,.$  

加/减运算结果的两个符号位都相同，无溢出，结果正确。  

02.【解答】  

1）对于无符号数，所有二进制位均为数值位。乘以2和除以2运算，相当于无符号数的逻辑左移和逻辑右移。 $x$ 的真值为 $2^{31}+2^{2}$ 。R1中的机器码逻辑右移一位（高位补0）为40000002H，相当于除以2，故 $x/2$ 的真值为 $2^{30}\!+2$ 。R1中的机器码逻辑左移一位（低位补0）为 $\ensuremath{0000\,0008}\mathrm{H}$ ，相当于是乘以2，高位丢1，结果溢出， $_{2x}$ 的真值为 $2^{3}$ （溢出）。  

2）对于有符号数（补码），最高位为符号位。乘以2和除以2运算，相当于补码的算术左移和算术右移。 $8000\ \mathrm{\Omega}0004\mathrm{H}$ 对应二进制数的最高位为1，即为负数，其真值为- $(2^{31}\!-\!2^{2})$ 。R1中的机器码算术右移一位（高位补1）为 $\mathrm{C000\,0002H}$ ，相当于除以2， $x/2$ 的真值为 $\cdot(2^{30}\!-\!2)$ R1中的机器码算术左移一位（低位补0）为 $0000\,0008\mathrm{H}$ ，相当于乘以2，移位前后的符号位不同，表示溢出， $_{2x}$ 的真值为- $(2^{31}\!-2^{3})$ （溢出）。 
03.【解答】  

1）因为  $x\!=\!-68\!=\!-(100~0100)_{2}$  ，则  $[-68]_{*}=1011\ 1100=\mathrm{BCH}$  ：因  $y\!=\!-80\!=\!-(101~0000)_{2}$  ，则  $[-80]_{\#}=1011\ 0000=\mathrm{B0H}$ ，所以寄存器A和 $\mathrm{B}$ 中的内容分别是BCH、 $\mathrm{B0H}$  

1) $[x+y]_{*}=[x]_{*}+[y]_{*}=1011\ 1100+1011\ 0000=(1)\,0110\ 1100=6\mathrm{CH}\,.$ ，所以寄存器C中的内容是6CH，其真值为108。此时，溢出标志OF为1，表示溢出，说明寄存器C中的内容不是正确结果；符号标志SF为0，表示结果为正数（OF为1，说明SF也是错的）。  

3） $[x-y]_{*}=[x]_{*}+[-y]_{*}=1011\ 1100+0101\ 0000=(1)\ 0000\ 1100=0\mathrm{CH}$ ，最高位前面的一位被丢弃（取模运算），结果为12，所以寄存器D中的内容是0CH，其真值为12。此时，溢出标志OF为0，表示不溢出，也就是说，寄存器D中的内容是正确的结果；符号标志SF为0，表示结果为正数。  

04.【解答】  

1）因为 $134=128+6=1000\ 0110\mathrm{B}$ ，所以 $x$ 的机器数为10000110B，因此R1的内容为 $86\mathrm{H}$  $246\,{=}\,255\,{-}\,9\,{=}\,1111\;\;0110\mathrm{B}$ ，所以 $y$ 的机器数为11110110B， $x\!-\!y\!=\!1000\ 0110\ +\ 0000$  $1010\,{=}\,(0)1001\;0000$ ，括号中为加法器的进位，因此R5的内容为 $90\mathrm{H}$ 。 $x+y=1000\,0110+$  $1111\ 0110\,{=}\,(1)0111\ 1100$ ，括号中为加法器的进位，因此R6的内容为7CH。2） $m$ 的机器数与 $x$ 的机器数相同，皆为 $86\mathrm{H}=1000\,0110\mathrm{B}$ ，解释为有符号整数 $m$ （用补码表示）时，其值为一 $111\ 1010\mathrm{B}\!=\!-122$ 。 $m-n$ 的机器数与 $x-y$ 的机器数相同，皆为 $90\mathrm{H}\,{=}\,1001$ 0000B，解释为有符号整数 $_{\mathrm{kl}}$ （用补码表示）时，其值为 $-111\ 0000\mathbf{B}\!=\!-112$ 3）能。 $n$ 位加法器实现的是模 $2^{n}$ 无符号整数加法运算。对于无符号整数 $a$ 和 $^b$ ， $a+b$ 可以直接用加法器实现，而 $a-b$ 可用 $^a$ 加- $\cdot b$ 的补数实现，即 $a-b=a+[-b]*$ (mod $2^{n}$ ），所以 $n$ 位无符号整数加减运算都可在 $n$ 位加法器中实现。因为有符号整数用补码表示，补码加减运算公式为 $[a+b]_{*}\!=[a]_{*}+[b]_{*}\,\,(\mathrm{mod}\,2^{n}),\,\,[a-b]_{*}\!=$  $[a]_{*}+[-b]_{*}$ (mod $2^{n}$ ），所以 $n$ 位有符号整数加减运算都可在 $n$ 位加法器中实现。4）有符号整数加减运算的溢出判断规则为：若加法器的两个输入端（加法）的符号相同，且不同于输出端（和）的符号，则结果溢出，或加法器完成加法操作时，若次高位（最高数位）的进位和最高位（符号位）的进位不同，则结果溢出。最后一条语句执行时会发生溢出。因为 $1000\ 0110+1111\ 0110\,{=}\,(1)0111\ 1100$ ，括号中为加法器的进位，根据上述溢出判断规则可知结果溢出。或者，因为两个有符号整数均为  
负数，它们相加之后，结果小于8位二进制所能表示的最小负数。  

05.【解答】  

1）乘法运算可以通过加法和移位来实现。编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法和移位等指令实现乘法运算。  

2）控制逻辑的作用是控制循环次数，控制加法和移位操作。  

3）a最长，c最短。对于a，需要用循环程序段实现乘法操作，因而需要反复执行很多条指令，而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长；对于b和c，都只需用一条乘法指令实现乘法操作，不过b中的乘法指令需要多个时钟周期才能完成，而c中的乘法指令可在一个时钟周期内完成，所以c的执行时间最短。  

4）当 $n=32$  $x=2^{31}\!-1,y=2$ 时，有符号整数和无符号整数乘法指令得到的64位乘积都是00000000FFFFFFFEH。int型的表示范围为 $[-2^{31}$  $2^{31}\mathrm{-}1]$ ，故函数imulO的结果溢出；unsigned in t[ $),2^{32}\!-\!1]$ ，故函数umulO的结果不溢出。对于无符号整数乘法，若乘积高 $n$ 位全为0，即使低 $n$ 位全为1也正好是 $2^{32}\!-1$ ，不溢出，否则溢出。  

注意，无论是无符号数还是有符号数，用 $2n$ 位来表示两个 $n$ 位整数的相乘结果都不会溢出，因为 $2n$ 位可以完整地存储两个 $n$ 位整数的乘积。但是，若只用低 $n$ 位来表示结果，则可能溢出。因此，要保证低 $n$ 位转换成的真值与 $2n$ 位转换成的真值相等才算是不溢出。对于无符号数，只要高 $n$ 位全为0，就不会溢出，因为高 $n$ 位在转换成真值后不会影响低 $n$ 位的值。对于有符号数，要考虑符号位的影响。当结果是正数时，符号位为0，要求高 $n$ 位也全为0，且低 $n$ 位的最高位也为0（否则正数变负数）。当结果是负数时，符号位为1，要求高 $n$ 位也全为1，且低 $n$ 位的最高位也为1（否则负数变正数）。因此，在有符号数的情况下，高 $n+1$ 位相同表示不溢出。  


# 2.3.6 答案与解析  

# 一、单项选择题  

01.C  

不同类型的数据混合运算时，遵循的原则是“类型提升”，即较低类型转换为较高类型，最double。4 char→int→long→double。  

例如，long型数据与int型数据一起运算时，需先将int型转换为long型，然后两者再进行运算，结果为long型。float型数据和double型数据一起运算时，虽然它们同为实型，但两者精度不同，仍要先将float型转换成double型再进行运算，结果亦为double型。所有这些转换都是由系统自动进行的，这种转换通常称为隐式转换。  

注意在强制类型转换中，从int型转换为float型时，虽然不会发生溢出，但因尾数位数的关系，可能有数据舍入，而转换为double型则能保留精度。double型转换为float型时亦是如此。从float型或double型转换为int型时，小数部分被截断，且由于int型的表示范围更小，还可能发生溢出。  

02.B  

在浮点数总位数不变的情况下，阶码位数越多，尾数位数越少；即表示的数的范围越大，精度越差（数变稀疏）。  

03.B  

基数是浮点数的进制，决定了阶码变化的权重。基数越大，阶码每变化一位，尾数小数点需要移动的位数越多，表示的数的绝对值就越大，范围就越大。但是，在浮点数的总位数不变的情况下，能表示的不同状态个数是一定的。若范围增大，则意味着浮点数的离散程度增大，相邻两个浮点数之间的间隔就越大，精度就越低。例如，假设符号为S、尾数为 $M_{\sun}$ 阶码为 $E$ ，则基数为2时的浮点数表示形式为 $(-1)^{S}{\times}M{\times}2^{N}$ ，基数为4时的浮点数表示形式为 $(-1)^{S}{\times}M{\times}4^{N}$ ，显然基数为4时的表示范围大，但数据的离散程度也增大，精度降低。  

04. C  

变形补码，即用两个二进制位来表示数字的符号位，其余与补码相同，所以并不能避免溢出，A错误。定点数和浮点数运算都可能产生溢出，但是溢出判断有区别，因此B错误、C正确。在定点运算中，当运算结果超出数的表示范围时，就发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出，D错误。  

05.C  

考查浮点数的规格化。当尾数为补码表示，且为 $1.0\times\times\times\times$ 形式时为规格化数，因此该尾数需左移一位，阶码同时应减1，才为规格化数。  

06.B  

原码表示时，正数的规格化形式为 $0.1\times_{...}\times$ ，负数的规格化形式为 $1.1\times_{...}\times$ ，因此B错误。  

07.C  
对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况，因而A、B错误。  

08.A  

IEEE754标准中尾数采用原码表示，阶码部分用移码表示。  

09.B  

长浮点数，其阶码11位，尾数52位，采取隐藏位策略，因此其最小规格化负数为阶码取最大值 $2^{+1023}$  $1023=2^{11-1}(-1)$ ，尾数取最大值 $2-2^{-52}$ （注意其有隐藏位要加1)，符号位为负。  

10.D  

在IEEE754单精度浮点数中，最高位为符号位；其后是8位阶码，以2为底，用移码表示，阶码的偏置值为127：其后23位是尾数数值位。对于规格化的二进制浮点数，数值的最高位总是“1”，为了能使尾数多表示一位有效值，将这个“1”隐藏，因此尾数数值实际上是24位。隐藏的“1”是一位整数。在浮点格式中表示出来的23位尾数是纯小数，用原码表示。41A4C000H写成二进制为 $0100\,0001\,1010\,0100\,1100\,0000\,0000\,0000$ ，第一位为符号位0，表示是正数。之后的8位10000011表示阶码，真值为（ $100)_{\mathrm{B}}$ ，即4。剩下的是隐藏了最高1的尾数，故而为1.01001001100000000000000，数值左移四位后整数部分10100表示为20。  

11.D  

浮点数表示中基数的值是约定好的，因此将其隐含。  

12.D  

这个机器数的最高位为1，对于原码、补码、单精度浮点数而言为负数，对于移码而言为正数，所以移码最大，而补码为 $-2^{28}$ ，原码为· $-(2^{30}+2^{29}+2^{28})$ ，单精度浮点数为一 $\cdot1.0\times2^{97}$ ，大小依次递减。  

13.D  

与非规格化浮点数相比，采用规格化浮点数的目的主要是为了增加数据的表示精度。14.D I正确；正数的原码、反码和补码都相同，Ⅱ错误；因为是规格化正浮点数，所以 $M_{1}$ 、 $M_{2}$ 均为 $0.1x x$ 形式，有 $N_{1}$ 阶码至少比 $N_{2}$ 大1，所以 $N_{1}>N_{2}$ ，ⅢI正确。  

15.A  

运算结果在0至规格化最小正数之间时称为正下溢，运算结果在 $0$ 至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。  

16.C  

判断浮点数运算是否溢出，取决于阶码是否上溢。阶码下溢可以通过非规格化数来表示。尾数上溢或下溢，可以通过左移或右移进行调整。  

17.B  

写成二进制表示为 $0100\;0101\;0001\;0000\;0000\;0000\;0000\;0000$ ，第一位为符号位，0表示正数，随后8位（float型）10001010是用移码表示的阶码，因此减去01111111后得十进制数11，而IEEE754标准中单精度浮点数在阶码不为0时隐藏1，因此尾数为 $(1.0010)_{\mathrm{B}}\,{=}\,(1.125)_{\mathrm{D}}$ ，因此该数值为 $(+1.125)_{10}{\times}2^{11}$  

18.A  

规格化IEEE754浮点数尾数部分的数值范围为[1,2)， $\mathrm{x}=-111110\mathrm{B}=-1.111110\mathrm{B}{\times}2^{6},$  $\mathbf{y}=$  $1111.11\mathrm{B}=1.1111\mathrm{B}{\times}2^{3}$ ，故浮点数x、y的阶数分别为6和3。对阶操作是小阶向大阶看齐，即y的阶数变为6，移码表示为 $6+127=133$ ，即10000101B，y的尾数右移3位，变为0.00111111B。  

19.A  
在IEEE754标准格式中，阶码全为0，尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行下去。  

20.C  

在位数相同的条件下，移码和补码的表示范围是相同的，故阶码的表示范围不变，因此浮点数的表示范围不变，只是改变了浮点数的表示形式。  

21.D  

为使浮点数取正数最大，可使尾数取正数最大，阶码取正数最大。尾数为8位补码（含符号位），正值最大为0.1111111，即 $1-2^{-7}$ ，阶码为4位补码（含符号位），正值最大为0111，即7，则最大正数为 $(1-2^{-7}){\times}2^{7}\!=2^{7}\!-1$  

22.D  

浮点数加减运算时，首先要进行对阶，根据对阶的规则，阶码和尾数将进行相应的操作。  

对阶的规则是小阶码向大阶码看齐，即阶码小的数的尾数算术右移，每右移一位，阶码加1，直到两数的阶码相等为止。  

23. D  

补码的规格化表示是小数点后一位与符号位不同。  

24.C 原码表示的规格化小数是小数点后2位（基数为4，用2位表示）不全为0的小数。  

25.C  

舍入是浮点数的概念，定点数没有舍入的概念。浮点数舍入的情况有两种：对阶、右规格化。舍入不一定产生误差，如向下舍入11.00到11.0时是没有误差的。  

26.D  

信息在存储器中按边界对齐方式存储的含义是信息单元的存储地址是其字节长度的整数倍。这样可以保证对一个字长数据的读/写只需要一次存储器访问，提高了访存效率，但有时会导致存储空间的浪费。因此，这是一种以空间换时简的办法。  

27.D  

1非永真，因为 $\mathrm{x+y}$ 可能会溢出，而dx+dy不会溢出。ⅡI永真，double型采用IEEE754表示，尾数采用原码小数，符号和数值部分分开计算，不管结果是否溢出，都不会影响乘积的符号。IⅢI非永真，dx和dy中只要有一个为0、另一个不为0就不相等。IV永真，因为dx、dy和dz是由32位int型转换得到的，double型可以精确地表示int型，且对阶时尾数移动位数不会超过52位，因此尾数不会舍入，因而不会发生大数吃小数的情况。  

28.A  

二维数组b的元素是short型，占2字节，采用按行优先存储，b[0]I0]的地址为0x8049820，b[0][1]的地址为0x8049822，以此类推，b[1][2]的地址为 $\mathrm{0x804982c}$ 。b[1][2]的值为-6，补码表示为1111111111111010，采用小端方式存储，因此地址0x804982c存放的是低位字节FAH。  

29.D  

小端方式是将最低有效字节存储在最小位置。在数01234567H中，最低有效字节为 $67\mathrm{H}$  

30.A  

结构体按边界对齐存放的要求：数据成员的起始地址是其数据类型大小的整数倍，char型占1字节，char型的起始地址必须是1字节的整数倍；unsigned型占4字节，故unsigned型的起始 地址必须是4字节的整数倍。据此分析，id的起始地址为0x8049820，p0st的起始地址为0x8049824，故phone的起始地址为0x8049828。结构体x的存放方式如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/44bbb5f9a4bf2cebbda8e70f5ef9ba1dbea27c70cec06ce1d17ccb04c07d2a7a.jpg)  

31.A  

int型强制转换为unsignedint型后，两个变量对应的每一位都是一样的，强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。因此，m的值仍为AIB6H，逻辑移位后的值为50DBH，由于采用大端方式，内存的低地址存放高位字节，因此低字节地址的内容为 $50\mathrm{H}$  

32.D  

对于A和B，int型的有效位数不会超过31位，float型的有效位数比double型的小得多，因此都能精确转换为具有53位有效位的double型。对于C， $12345<1024{\times}16=2^{14}$ ，因此12345对应的二进制的位数一定小于14，因此可精确转换为具有24位有效位的float型。对于 $\mathrm{D},\mathrm{f}=1234.5$ 转换为int型后，小数点后面的数字丢失，因此与原来的f不相等。  

33.B  

整数与整数运算，结果为整数，所以  $\mathrm{m}/2$  的结果为6。实数与整数运算，结果为实数，所以  $\mathrm{a}/2$ 的结果为6.3，相加为12.3。C语言的输出格式可使输出值保留小数点后6位，输出为12.300000。  

34.D  

$X$ 的浮点数格式为00,111;00,11101（分号前为阶码，分号后为尾数），Y的浮点数格式为00101；00，10100。然后根据浮点数的加法步骤进行运算。  

$\textcircled{\scriptsize{1}}$ 对阶。 $X_{\backprime}$ Y阶码相减，即 $00,111-00,101=00,111+11,011=00,010$ ，可知 $X$ 的阶码比Y的价码大2（这一步可直接目测）。根据小阶码向大阶码看齐的原则，将 $Y$ 的阶码加2，尾数右移2位，将 $Y$ 变为00,111;00,00101。 $\circledcirc$ 尾数相加。即 $00,11101+00$  $00101=01$ ，00010，尾数相加结果符号位为01，因此需要右规。 $\textcircled{3}$ 规格化。将尾数右移1位，阶码加1，得 $X+Y$ 为01,000;00,10001。 $\textcircled{4}$ 判断溢出。阶码符号位为01，说明发生溢出。  

本题容易误选B、C，因为B、C本身并无计算错误，只是它们不是最终结果，B少了第3步和第4步，C少了第4步。  

35.B  

题中三种数据类型强制类型转换的顺序为int一float $\rightarrow$ double。float in t，小数位部分会被舍去，int型是精确到32位的整数，而float型只保存到 $1\!+23$ 位，因此一个32位的int型整数在转换为float型时可能会有损失，具体判断方法如下：先将int型整数转换成二进制真值，然后将真值写为 $\pm1.x...x{\times}2^{n}$ 的形式，若小数点后的位数超过23位，则转换为float型会发生精度损失。本题中 $\mathrm{i}=785$ ，转换成二进制真值为 $1.100010001{\times}2^{9}$ ，小数点后只有9位，不会发生精度损失，I正确。对于ⅡI，将float型的f转换为int型，小数点后的数位丢失，结果非真。double型的精度和范围都比float型的大，float型转换为double型不会有损失，Ill正确。对于IV，初看似乎没有问题，但浮点运算d+f时需要对阶，对阶后f的尾数有效位被舍去而变为0，因此d+f仍然为d，再减去d后结果为0，结果非真。注意，从int型转换为float型时，虽然不会发生溢出，但由于尾数位数的关系，可能有数据舍入，影响精度，而转换为double型则能保留精度。  
36.A  

本题的目的在于考查IEEE754单精度浮点数的表示。首先先将 $\mathbf{X}$ 转换成二进制为- $\cdot1000.01=$  $-1.000~01{\times}2^{3}$ ，然后计算阶码 $E$ ，根据IEEE754单精度浮点数格式，有 $E-127=3$ ，因此 $E=130$ 转换成二进制为 $1000\,0010$ 。最后，根据IEEE754标准，最高位的“1”是被隐藏的。  

IEEE754单精度浮点数格式：符号（1位） $^+$ 阶码（8位） $^+$ 尾数（23位）。  

因此FRI的内容为 $\textsf{J l;}1000\,0010;\,0000\,1000\,0000\,0000\,0000\,0000$  

即  $1100\;0001\;0000\;0100\;0000\;0000\;0000={\mathrm{C}}104\;0000{\mathrm{H}}_{\odot}$  

本题易误选D，未考虑IEEE754标准隐藏最高位1的情况，把偏置值认为是128。  

37.D  

IEEE754单精度浮点数是尾数用采取隐藏位策略的原码表示，且阶码用移码（偏置值为127）表示的浮点数。规格化短浮点数的真值为 $!(-1)^{S_{\times}}\!1.m{\times}2^{E-127}$ ，其中 $S$ 为符号位，阶码 $E$ 的取值为 $1\!\sim$ 254（8位表示），尾数 $m$ 为23位，共32位；因此，float类型能表示的最大整数是 $1.111...1\times2^{254-127}{}=$  $2^{127}\times(2-2^{-23})=2^{128}-2^{104}$  

【另解】IEEE754单精度浮点数的格式如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0236cda08b6b16996b5379d1ba9b1656d27d754fb8d87587b7d9c89a6a53d209.jpg)  

表示最大正整数时：符号取0；阶码取最大值127；尾数部分隐藏了整数部分的“1”，23位尾数全取1时尾数最大，为 $2-2^{-23}$ ，此时浮点数的大小为 $(2-2^{-23}){\times}2^{127}=2^{128}-2^{104}$  

38.D  

尽管record大小为7B（成员a有4B，成员b有1B，成员c有2B），由于数据按边界对齐方式存储，因此record共占用 $^{88}$ 。record.a的十六进制表示为 $0\mathrm{x}00000111$ ，由于采用小端方式存放数据，因此地址 $\mathrm{0xC008}$ 中的内容应为低字节0xll；record.b只占1B，后面的1B留空；record.c占2B，因此其地址为 $\mathrm{0xCO0E}$ 。各字节的存储分配如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f5351bf45f96323cd5f75907c05404bf54817a27e004f2ffd4a3c328e8609f0.jpg)  

39.A  

IEEE754单精度浮点数格式为  $\mathrm{C640~\,0000H}$  ，二进制格式为110001100100000000000000 00000000，转换为标准的格式为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1b3fe6adbb2ebd90953acc28cd63a2280d5c40dc3f273dc94da1fc43adcedb3.jpg)  

符号为1表示负数；阶码值为 $1000\ 1100-0111\ 1111=0000\ 1101=13$ ：尾数值为1.5（注意其有隐藏位，要加1)。因此，浮点数的值为一 $\cdot1.5\!\times\!2^{13}$  

40.A  

(f1)和(f2)对应的二进制分别是( $(110011001001...)_{2}$ 和(101100001100...)2，根据IEEE754浮点数标准，可知(f1)的符号为1，阶码为10011001，尾数为1.001，而(f2)的符号为1,阶码为01100001，尾数为1.1，可知两数均为负数，符号相同，B、D排除；（f1)的绝对值为 $1.001\!\times\!2^{26}$ ，(f2）的绝对值为 $1.1\!\times\!2^{-30}$ ， (fl)的绝对值比(f2)的绝对值大，而符号为负，真值大小相反，即(fI)的真值比(f2)的真值小，即 $\mathbf x<\mathbf y$  

41.D  
对阶是较小的阶码向较大的阶码对齐，所以对阶后的阶码是当前那个较大的阶码而不会导致阶码溢出，I正确。右规和尾数舍入过程，阶码加1而可能上溢，ⅡI正确，同理ⅢI也正确。尾数溢出时可能仅产生误差，结果不一定溢出，IV正确。  

42.A  

大端方式：一个字中的高位字节存放在内存中这个字区域的低地址处。小端方式：一个字中的低位字节存放在内存中这个字区域的低地址处。各字节的存储分配如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31089bcbd5b7eed2faf310d6328ba4a33abfc1670c921a2fd7161a6201a0bb6b.jpg)  

从而存储单元 $0000\ 8046\mathrm{H}$ 中存放的是 $22\mathrm{H}$  

43.A  

IEEE754单精度浮点数的符号位、阶码位、尾数位（省去正数位1）所占的位数分别是1、8、23。最小正数，符号位取0，移码的取值范围是 $1\!\sim\!254$ ，取1，得阶码值 $1-127\!=\!-126$ (127为我们规定的偏置值），尾数取全0，最终推出最小规格化正数为A。  

44.A  

按字节编址，采用小端方式，低位的数据存储在低地址位、高位的数据存储在高地址位，并且按照一字节相对不变的顺序存储。由题意，存储0的位数是后32位，则我们只需要把-64的补码按字节存储在其中即可，而-64表示成32位的十六进制是FFFFFFC0，根据小端方式的特点，低位字节存储在低地址，就是COFFFFFF。  

45.D  

在32位计算机中，按字节编址，根据小端方式和按边界对齐的定义，变量a的存放方式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80ff7c6f8d324c2640621c9861d81dd4e54116bc12873d7b61cec657125553a1.jpg)  

于是，34H所在存储单元的地址为2020FE06H。  

46. A  

$\mathrm{C800\,\,0000H}\,{=}\,1100\,\,1000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,0000\,\,$  

将其转换为对应的float型或int型。  

1）若为float型，则尾数隐藏最高位1，符号为1表示负数，阶码 $1001\;0000\!=\!2^{7}\!+2^{4}\!=\!128+16$ 再减去偏置值127得到17，算出 $x$ 值为 $\cdot2^{17}$  

2）若为int型，则有符号补码，为负数，数值部分取反加1，得 $011\;1000\;0000\;0000\;0000\;0000$ 00000000，算出 $x$ 值为 $-7\!\times\!2^{27}$  

47.A  

使用排除法。选项B： $1.25\!=\!1.01\mathbf{B}\!\times\!2^{\scriptscriptstyle0}$ ；选项C： $2.0=1.0{\bf B}{\times}2^{1}$ ；选项D： $2.5=1.01\mathrm{B}{\times}2^{1}$ 。因此，B、C和D均可以用IEEE754浮点格式精确表示。选项A的十进制小数1.2转换成二进制的结果是无限循环小数 $1.001100110011...$ ，无法用精度有限的IEEE754格式精确表示。  

48. A  
IEEE754单精度浮点数格式中依次为符号1位、阶码8位（偏置值127）、尾数23位（隐藏1位)。  $-\,0.4375=-\,1.75\times2^{-2}$  ，保证小数点前是1。根据单精度浮点数格式，符号为1；阶码为移 码表示， $-2\ +\ 127=125$ ，写成8位二进制数为01111101；尾数隐藏小数点前的1，剩下的0.75写成二进制数为0.11，所以尾数部分是 $1100\cdots0$ 。该浮点数的二进制格式为1011111011100000 $0000\:0000\:000\:0000$ ，对应的十六进制格式为BEE0 $\mathrm{0000H}$  

49.A  

short型变量是补码表示的16位有符号整数。x是负数，可先求出8190的机器数， $8190=8192\,-$  $2=2^{13}-2^{1}$ ，8190的机器数为 $\mathrm{0010~0000~0000~0000B-0000~0000~0000~0010B=0001}$ 1111 11111110B，因此-8190的机器数为 $1110\ 0000\ 0000\ 0010\mathbf{B}=\mathrm{E}002\mathrm{H}$ （按位取反，末位加1）。  

50.A  

把x的机器数按二进制展开， $8020\ 0000\mathrm{H}=\underline{{1000\ 0000\ 0010\ 0000\ 0000\ 0000\ 0000\ 0000B}}$ ，符号为负，阶码全为0，尾数不全为0，由下表可知，这是非规格化数，对于32位非规格化负数，若尾数的二进制为f，则真值为  $-2^{-126}{\times}0.f{=}-2^{-126}{\times}0.01{=}-2^{-128}{\mathrm{e}}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0928cf9558746fb8b10be920e780e68c65160cbe0e30ea91e4ff460c74226f07.jpg)  

# 二、综合应用题  

01.【解答】  

1）最高位为符号位，符号位为1，表示是一个负数，对应真值的二进制为 $-111\;0000\;0001\;0000\;0100\;0000\;0000\;0000$ （数值位取反，末位加1）  

对应的十进制值为- $(2^{30}+2^{29}+2^{28}+2^{20}+2^{14})$  

2）全部32位均为数值位，按权相加可知其十进制值为  $2^{31}+2^{27}+2^{26}+2^{25}+2^{24}+2^{23}+2^{22}+2^{21}+2^{19}+2^{18}+2^{17}+2^{16}+2^{15}+2^{14}$  

3）表示一个IEEE754标准的单精度浮点数：  

符号阶码尾数00011111 11011111100000000000000  

因为阶码为00011111，所以对应的十进制数为31。1EEE754标准中的阶码用移码表示，其偏置值为127，所以阶码的十进制真值为 $31-127\,{=}\,{-}96$  

因为尾数为1.11011111100000000000000。1EEE754标准中的尾数用原码表示，且采用隐藏尾数最高数位“1”的方法，隐藏的“1”是一位整数。所以尾数真值为  

$$
1+2^{-1}+2^{-2}+2^{-4}+2^{-5}+2^{-6}+2^{-7}+2^{-8}+2^{-9}
$$  

因为符号为1，表示这个浮点数是个负数。所以单精度浮点数的真值为  

$$
-(1+2^{-1}+2^{-2}+2^{-4}+2^{-5}+2^{-6}+2^{-7}+2^{-8}+2^{-9})\times2^{-96}
$$  

02.【解答】  

强制类型转换，转换过程有两个，unsigned in t→int→long→double，二是float→double， 从后向前转换会使得数据丢失，进而使等号不成立。  

1）是。因为double型比int型精度高，所以int型变量转换为double型变量时不会有精度损失。 2）不是。因为float型有小数部分，而int型没有小数部分，所以把float型变量转换为int  
型变量时，可能会丢失小数部分。  

3）是。因为double型比float型精度高，所以float型变量转换为double型变量时不会有精 度损失。  

4）不是。因为float型比double型的有效位数少，所以double型变量转换为float型变量时 会有精度损失。  

03.【解答】  

1）float型变量在计算机中都被表示成IEEE754单精度格式。 $\begin{array}{r}{X\!=\!-68=\!-(1000100)_{2}\!=}\end{array}$  $-1.0001{\times}2^{6}$ ，符号位为1，阶码为 $127+6\,{=}\,128+5\,{=}\,(1000\;0101)_{2}$ ，尾数为1.0001，所以小数部分为 $000\ 1000\ 0000\ 0000\ 0000\ 0000$ ，合起来整个浮点数表示为110000101000 $1000\:0000\:0000\:0000\:0000$ ，写成十六进制为 $C2880000\mathrm{H}$  $Y\!=\!-8.25\!=\!-(1000.01)_{2}\!=\!-1.00001\!\times\!2^{3}$ ，符号位为1，阶码为 $127\ +\ 3=128\ +\ 2=(1000$  $0010)_{2}$ ，尾数为1.00001，所以小数部分为 $000\ 0100\ 0000\ 0000\ 0000\ 0000$ ，合起来整个浮点数表示为 $1\ 1000\ 0010\ 000\ 0100\ 0000\ 0000\ 0000\ 0000$ ，写成十六进制为 $\mathrm{C1040000H}$ 因此，寄存器A和B的内容分别为C2880000H、C1040000H。  

2）两个浮点数相加的步骤如下。  

$\textcircled{\scriptsize{1}}$ 对阶： $E_{x}\!=\!10000101$ ， $E_{y}\!=\!10000010$ ，则 $[E_{x}-E_{y}]_{*}=[E_{x}]_{*}+[-E_{y}]_{*}\,\,=10000101+01111110=00000011$   $E_{x}$ 大于 $E_{y}$ ，所以对 $y$ 进行对阶。对阶后， $y\,{=}\,{-}0.00100001{\times}2^{6}$  

$\circledcirc$ 尾数相加： $x$ 的尾数为 $-1.000\ 1000\ 0000\ 0000\ 0000\ 0000,y$ 的尾数为-0.00100001000000000000000，用原码加法运算实现，两数的符号相同，做加法，结果为-1.001100010000000 00000000。即 $x$ 加 $y$ 的结果为 $-1.001\ 1000\ 1{\times}2^{6}$ ，所以符号位为1，尾数为00110001000000000000000，阶码为 $127+6=128+5$ ，即10000101。合起来为11000010100110001000000000000000，转换为十六进制形式为 $\mathrm{C}2988000\mathrm{H}$ 。所以C寄存器中的内容是 $C2988000\mathrm{H}$  

3）两个浮点数相减的步骤同加法，对阶的结果也一样，只是尾数相减。  

尾数相减： $x$ 的尾数为-1.00010000000000000000000， $y$ 的尾数为-0.00100001000000000000000。  

用原码减法运算实现，两数的符号相同，做减法；符号位：取大数的符号，负数，为1；数值部分：大数加小数负数的补码：  

$$
{\begin{array}{l l l l l l l l}{1.}&{000}&{1000}&{0000}&{0000}&{0000}&{0000}\\ {+}&{1.}&{110}&{1111}&{1000}&{0000}&{0000}&{0000}\\ {\;\;\;0.}&{111}&{0111}&{1000}&{0000}&{0000}&{0000}\end{array}}
$$  

$x$ 减 $y$ 的结果为- $-0.11101111\times2^{6}\,{=}\,{-1.1101111\times2^{5}}$ ，所以符号位为1，尾数为 $110\;1111\;0000\;0000$ 00000000，阶码为 $127+5\!=\!128+4$ ，即 $1000\,0100$  

合起来为 $1\ 1000\ 0100\ 110\ 1111\ 0000\ 0000\ 0000\ 0000\,0000\,.$ ，转换为十六进制形式为 $_{\mathrm{C26F0000H.}}$ 所以寄存器D中的内容是 $\mathrm{C26F0000H}$  

> 提示  

若为选择题，则第二问可先将十进制的 $x+y,x-y$ 计算后的结果再转成IEEE754。  
04.【解答】  

1）因为该数的阶码字段内容为0，符号位为0，尾数字段内容也为0，所以它表示1IEEE浮点格式的 $+0$  

2）该数的阶码字段内容为132，尾数字段内容为 $100\,0000\,0000\,0000\,0000\,0000$ ，因为阶码字段的内容既不全部为0，也不全部为1，所以它表示一个规格化数，其实际值为 $(1.1)_{2}{\times}2^{5}\!=\!48$  

3）因为该数的阶码字段内容全部为0，且尾数字段内容不全部为0，所以它表示一个非规格化数，其实际值为 $(-0.1)_{2}{\times}2^{-126}\!=\!-2^{-127}\!=\!-5.877{\times}10^{-39}$ （表示成4位有效数字形式）。  

4）因为该数的阶码字段内容全部为1，且尾数字段内容为0，符号位为1，所以它表示负无究大。  

05.【解答】  

1）由于i和n是unsigned型，因此‘ $\mathrm{\mathrm{"i<=n-l}"}$ 是无符号数比较， $\mathrm{n\,{=}\,0}$ 时， $\mathrm{n-1}$ 的机器数为全1，值是 $2^{32}\mathbf{-1}$ ，为unsigned型可表示的最大数，条件 ${\mathrm{\Delta}}^{\mathrm{..}}\mathrm{_1\,<=\,n-1}$ ”永真，因此出现死循环。若i和 $\boldsymbol{\mathrm{n}}$ 改为int型，则不会出现死循环。  

因为“ $\mathrm{i}<=\mathrm{n}{-}\mathrm{l}$ ”是有符号整数比较，当 $\boldsymbol{\mathrm{n}}=\boldsymbol{\mathrm{0}}$ 时， $\mathrm{n}-1$ 的值是-1，当 $\mathrm{i}=0$ 时，条件“i $<=\mathsf{n}\mathrm{-}\mathsf{l}$ ”不成立，此时退出for循环。  

2）f1(23)与f2(23)的返回值相等。 $\operatorname{f}(23)=2^{23+1}-1=2^{24}-1$ ，其二进制形式是24个1。int型数占32位，没有溢出。float型数有1个符号位，8个指数位，23个底数位，23个底数位可以表示24位的底数，所以两者返回值相等。fI(23)的机器数是00FFFFFFH，f2(23)的机器数是4B7FFFFFH。显而易见，前者是24个1，即0000000011111111111111111111 $1111_{(2)}$ ，后者的符号位是0，指数位为 $23+127_{(10)}\!=\!1001\,0110_{(2)}$ ，底数位是111 1111 111111111111 $1111_{(2)}$  

3）当 $\mathfrak{n}=24$ 时， $\mathrm{f}(24)=1$ 111111111111111111111111B，而float型数只有24位有效位，舍入后数值增大，所以f2(24)比fl(24)大1。  

4）显然31)已超出了int型数的表示范围，用31)实现时得到的机器数为32个1，作为int型解释时其值为-1，即f131)的返回值为-1。因为int型最大可表示的数是0后面加31个1，因此使fl(n)的返回值与fn)相等的最大n值是30。  

5）IEEE754标准使用“阶码全1、尾数全0”表示无穷大。f2的返回值为float型，机器数 $7\mathrm{F}80~0000\mathrm{H}$ 对应的值是 $+\infty$ 。当 $\mathsf{n}=126$ 时， $\mathrm{f}(126)=2^{127}-1=1.1...1\times2^{126}$ ，对应的阶码为 $127+126=253$ ，尾数部分舍入后阶码加1，最终阶码为254，是IEEE754单精度格式表示的最大阶码。因此使f2结果不溢出的最大n值为126。  

当 $\mathfrak{n}=23$ 时，f23)为24位1，float型数有24位有效位，所以不需要舍入，结果精确。因此使f2获得精确结果的最大 $\mathsf{n}$ 值为23。  





