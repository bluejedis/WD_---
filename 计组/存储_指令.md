# 3.1.5 答案与解析  

单项选择题  

01.D 磁盘属于直接存取存储器，其速度介于随机存储器和顺序存取存储器之间。  

02.C  

存取时间 $T_{\mathrm{a}}$ 是指从存储器读出或写入一次信息所需要的平均时间：存取周期 $T_{\mathrm{m}}$ 是指连续两次访问存储器之间所必需的最短时间间隔。对 $T_{\mathrm{m}}$ 一般有 $T_{\mathrm{m}}=T_{\mathrm{a}}+T_{\mathrm{r}},$ 其中 $T_{\mathrm{r}}$ 为复原时间；对SRAM指存取信息的稳定时间，对DRAM指刷新的文一次存取时间。D指的是存取时间。  

03.B  

16MB $=\!2^{24}\mathrm{B}$ ，字长为32位，现按半字（2B）寻址，可寻址单元数为 $2^{24}\mathrm{B}/2\mathrm{B}\!=\!2^{23}$  

04.D  

相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是按内容或地址进行寻址的，价格较为昂贵。一般用来制作TLB、相联Cache等。  

05.A CPU不能直接访问硬盘，需先将硬盘中的数据调入内存才能被CPU访问。  

06.C 每个存储周期读出16bit $=$ 2B，因此数据传输速率为 $2\mathrm{B}{\cdot}(250{\times}10^{-9})\mathrm{s}$ ，即 $8{\times}10^{6}\mathrm{B/s}$  

07.B 机器字长位64位，即8B，按字编址，因此可寻址的单元个数是 $128\mathrm{{MB}/8{B}=16\mathrm{{M}}}$  

08.B  

存储器有三个主要特性：速度、容量和价格/位（简称位价）。存储器采用分级方式是为了解决这三者之间的矛盾。  
09.D  

计算机的存储系统包括CPU内部寄存器、Cache、主存和外存。  

10.D  

Cache中的内容只是主存内容的部分副本（拷贝），因而“Cache-主存”结构并未增加主存容量，目的是解决主存与CPU速度不匹配的问题。  

11.D  

在存储器分层结构中，寄存器在CPU中，因此速度最快，Cache次之，主存再次之，最慢的是辅存（如磁盘、光盘等）。  

12.D  

假设命中率为 $x$ ，可得 $100x+1000(1-x){\leqslant}100{\times}(1+15\%)$ ，简单计算后得结果为 $x\!\geqslant\!98.33\%$ 因此命中率至少为 $99\%$  

> attention  

本题采用同时访问Cache和主存的方式，此时不命中的访问时间为 $1000\mathrm{ns}$ ，但若题中没有说明（通常有说明），则默认Cache不命中的时间为访问Cache和主存的时间之和。  

13.A  

主存和辅存之间的数据调动是由硬件和操作系统共同完成的，仅对应用级程序员透明。CPU与主存可直接交换信息。  

14.B  

随机存取是指CPU可对存储器的任意一个存储单元中的内容随机存取，而且存取时间与存储单元的物理位置无关。A、C和D均采用随机存取方式，CD-ROM即光盘，采用串行存取方式

（直接存取）。注意，CD-ROM是只读型光盘存储器，不属于只读存储器ROM。  

  
# 3.2.6 答案与解析  

一、单项选择题  

01.C  

芯片容量为 $1024{\times}8$ 位，8位说明数据线要8根，地址线数要10根（ $1024=2^{10}$ ）。故该芯片的地址引脚和数据引脚总数至少需要18根。  

02.C 该芯片16位，所以数据线为16根，寻址空间 $32\mathrm{K}=2^{15}$ ，所以地址线为15根。  

03.B  

DRAM的刷新按行进行。  

04.B  

集中刷新必然存在死时间。采用分散刷新时，机器的存取周期中的一段用来读/写，另一段用来刷新，因此不存在死时间，但存取周期变长。异步刷新虽然缩短了死时间，但死时间依然存在。  

05.B  

DRAM芯片的集成度高于SRAM，I正确；SRAM芯片的速度高于DRAM，III错误；可以推出DRAM芯片的成本低于SRAM，II错误：SRAM芯片工作时不需要刷新，DRAM芯片工作时需要刷新，IV正确。本题要求选择描述错误的表述，故选II和IⅢI。  

06.C  

RAM属于易失性半导体，SRAM和DRAM的区别在于是否需要动态刷新。  

07.A  

主存由RAM和ROM构成，两者统一编址，A错误。B描述的是随机访问特性，正确。RAM芯片具有随机访问特性和易失性，C正确。ROM芯片具有随机访问特性和非易失性，D正确。  

08.A  

同一个存储器中，每个存储单元的宽度必须相同，即每个存储单元存储的比特位数必须相同。  

09.D  

SRAM依靠双稳态电路的两个稳定状态来分别存储0和1：SRAM速度较快，不需要动态刷新，但集成度稍低，功耗大，单位价格高。DRAM依靠电容暂存电荷来存储信息，电容上有电荷为1，无电荷为0；DRAM集成度高，功耗小，单位价格较低，需定时刷新，速度慢。  

10.B  

$1024{\times}8$ 位，寻址范围是 $1024=2^{10}$ 。采用地址复用技术时，分两次传送行、列地址，地址引脚减半为5根，数据引脚仍为8根，因此地址引脚和数据引脚总数至少为13根。  

注意SRAM和DRAM的区别，DRAM采用地址复用技术，而SRAM不采用。  

11.A Cache由SRAM组成，掉电后信息即消失，属于易失性存储器。  

12.C  

U盘采用Flash存储器技术，它是在E²PROM的基础上发展起来的，属于ROM的一种。由于擦写速度和性价比均很可观，因此其常用作辅存。  

> attention  

随机存取与随机存储器（RAM）不同，只读存储器（ROM）也是随机存取的。因此，支持随机存取的存储器并不一定是RAM。  
13.C  

因计算机的操作系统保存于硬盘上，所以需要BIOS的引导程序将操作系统引导到主存（RAM）中，而引导程序则固化于ROM中。  

14.B  

EPROM可多次改写，但改写较为烦琐，写入时间过长，且改写的次数有限，速度较慢，因此不能作为需要频繁读/写的RAM使用。  

15.C  

动态半导体存储器利用电容存储电荷的特性记录信息，由于电容会放电，因此必须在电荷流失前对电容充电，即刷新。方法是每隔一定的时间，根据原存内容重新写入一遍，因此1错误。这里的读并不是把信息读入CPU，也不是从CPU向主存存入信息，它只是把信息读出，通过一个刷新放大器后又重新存回存储单元，而刷新放大器是集成在RAM上的。因此，这里只进行了一次访存，也就是占用一个存取周期，ⅡI、IV正确，ⅢI错误。  

16.A  

$64\mathrm{K}\!\times\!1$ 位的DRAM芯片由一个 $256{\times}256$ 的位平面组成。构成存储器的所有芯片同时按行刷新，每个芯片有256行，故存储器所有单元刷新一遍至少需要256次刷新操作。若采用异步刷新方式，则相邻两次刷新信息的时间间隔为 $2\mathrm{ms}/256\approx7.8\upmu\mathrm{s}.$ 若采用集中刷新方式，则整个存储器刷新一遍最少需256个读/写周期，在刷新过程中，存储器不能进行读/写操作。  

17.D  

刷新也是一个读取的过程，根据读出内容对相应单元进行重写，因此会和CPU的访存冲突，会有访存“死时间”。刷新是指每隔一定的时间必须向栅极电容补充一次电荷，并以行为单位。  

18.C  

SDRAM（同步DRAM）与SRAM不同，其与CPU采用同步方式交换数据。SDRAM也是DRAM的一种，需要定期刷新。行缓冲器用来缓存指定行中整行的数据，通常用SRAM实现。  

19.B  

DRAM芯片采用地址线复用技术，行地址和列地址分时复用，每增加1根地址线，则行地址和列地址各增加1位，所以行数和列数各增加1倍，因此容量至少提高到原来的4倍。  

20.B  

DRAM芯片的容量 $=$ 位平面数 $\times$ 行数 $\times$ 列数，即由位平面数、存储阵列的行数和列数决定。故一个DRAM芯片的容量为 ${\bf4096{\times}4096{\times}4b}={\bf8M B}$ ，故内存条的总容量为 $8\mathrm{MB}{\times}16=128\mathrm{MB}$  

21.D  

低位交叉编址多模块存储器，采用轮流启动的方式时，类似于流水线的工作方式，为保证某个模块再次启动时，其上次的存取操作已完成（流水线不间断），要求两次启动间隔的时间必须大于或等于一个存储周期，即“模块数 $\cdot\times$ 总线周期≥存储周期”，得出存储体数应大于或等于11。  

22.B  

低位交叉存储器采用流水线技术，可以在一个存取周期内连续访问4个模块，32位 $\times4=128$ 位。本题答案为B。注：本题若作为计算题来考虑，从第一个字的读/写请求发出，到第4个字读/写结束，共需要 $350\mathrm{ns}$ ，但这里考查的是整体工作性能，可从以下角度理解：1）连续取 $m$ 个字耗时 $t_{1}=T+(m-1)r$ ，平均每个字的存取时间是 $t_{1}/m$ ，实际工作时 $m$ 非常大，因此 $t_{1}/m$ 也就非常接近 $r$ ，可认为存储器在每个总线周期 $r$ 都能给CPU提供一个字。2）流水线充分流动起来后，每个总线周期后都能完成一个字的读/写，所以本题中每4个总  
线周期（200ns）都能完成4个字的读/写。  

23.C  

1）在每轮读取存储器的前6个 $T/4$ 时间（共3T/2）内，依次进入各体。下一轮欲读取存储器时，最近访问的 $\mathbf{M}_{1}$ 还在占用审（才过 $T/2$ 的时间），因此必须再等待 $T/2$ 的时间才能开始新的读取（ $\mathbf{M}_{1}$ 连续完成两次读取，也即总共 $2T$ 的时间才可进入下一轮）。  

> attention  

进入下一轮不需要第6个字读取结束，第5个字读取结束时 $\mathbf{M}_{1}$ 就已空出，即可马上进入下一轮。  

最后一轮读取结束的时间是本轮第6个字读取结束，共 $(6-1){\times}(T/4)+T\,{=}\,2.25\,T.$ 情况1）的总时间为 $(80-1){\times}2T+2.25T{=}160.25T.$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/153b9d5bdf206a094cb694d14323915d7457d1260621994882de465cba4006b8.jpg)  

2）每轮读取8个存储字刚好经过 $2T$ 的时间，每轮结束后，最近访问的 $\mathbf{M}_{1}$ 刚好经过了时间T，此时可以立即开始下一轮的读取。  

最后一轮读取结束的时间是本轮第8个字读取结束，共 $(8-1){\times}(T/4)+T\,{=}\,2.75T.$ 情况2）的总时间为 $(60-1){\times}2T+2.75T{=}120.75T.$ 因此情况1）和2）所花费的总时间比为4:3。  

24.D  

$64\mathrm{K}\!\times\!8$ 位/ $16K{\times}8$ 位 $=4$ ，可知芯片数为4。芯片各单元采用交叉编址，所以每个芯片的片选信号由最低两位地址确定，高14位为片内地址。4个芯片内各存储单元的最低两位地址分别为00、01、10、11，即最小地址分别为0000H、0001H、0002H、0003H。地址BFFFH最低两位为11，因此该存储单元所在芯片的最小地址为 $0003\mathrm{H}$  

25.A  

单体多字存储器主要解决访存速度的问题，并没有解决主存容量太小的问题。在单体多字存储器中，每个存储单元存储多个字，当指令和数据连续存放，且没有过多的跳转指令时，单体多字存储器能有效地提高主存的读/写速度。  

26.B  

多模块存储器各模块有独立的读/写电路，可以实现并行操作，故多模块存储器能进行高速的读/写操作。采用低位交叉编址的多模块存储器各单元地址不连续。  

27.A  

RAM（分DRAM和SRAM）断电后会失去信息，而ROM断电后不会丢失信息，它们都采用随机存取方式。Cache一般采用高速的SRAM制成，而ROM只可读，不能用作Cache，III错误。DRAM需要定期刷新，而ROM不需要刷新，故IV错误。  
28.A  

闪存是 $\mathrm{E^{2}P R O M}$ 的进一步发展，可读可写，用MOS管的浮栅上有无电荷来存储信息。闪存依然是ROM的一种，写入时必须先擦除原有数据，所以写速度要比读速度慢。闪存是一种非易失性存储器，它采用随机访问方式。现在常见的SSD固态硬盘，即由Flash芯片组成。  

29.A  

$4{\bf{M}}{\times}8$ 位的芯片数据线应为8根，地址线应为 $\log_{2}\!4\mathbf{M}=22$ 根，而DRAM采用地址复用技术，地址线是原来的1/2，且地址信号分行、列两次传送。地址线数为 $22/2=11$ 根，所以地址引脚与数据引脚的总数为 $11+8=19$ 根，选A。此题需要注意DRAM采用的是传两次地址的策略，所以地址线为正常的一半，这是很多考生容易忽略的地方。  

30.B  

DRAM使用电容存储，所以必须隔一段时间刷新一次，若存储单元未被刷新，则存储的信息就会丢失。同步动态随机存储器SDRAM是现在最常用的一种DRAM。  

31.D  

每个访存地址对应的存储模块序号（0，1,2，3）如下所示：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8e912d9bd3833a3cfe3a2e1adcc07bab81903b2a12a15b4c9f3c74e6a49264e.jpg)  

其中，模块序号 $=$ 访存地址%存储器交叉模块数。  

判断可能发生访存冲突的规则如下：给定的访存地址在相邻的四次访问中出现在同一个存储模块内。据此，根据上表可知8004和8000对应的模块号都为0，即表明这两次的访问出现在同一模块内且在相邻的访问请求中，满足发生冲突的条件。  

32.C  

交叉编址多模块存储器有轮流启动和同时启动两种方式，本题中所有存储模块一次并行读/写的总位数正好等于系统总线中的数据线数，故可以判定采用的是同时启动方式。在同时启动方式下，一个存储周期可以对所有芯片的同一行都读取一个字节。double型变量占64位（8B）。其主存地址 $804\;001\,\mathrm{AH}$ 的最低两位是10，说明它从编号为2的芯片开始存储（编号从0开始），共占3行，因此需要同时启动3轮才能完成对double型变量的读取。从本题也可发现，采用同时启动方式时，一次读行也许会有没用的数据读入。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/316df9934e3d1e7df954feb12767b55b3494d5b22292de4d2e33837230279dc2.jpg)  

33.C  

由题意，首先根据DRAM采用的是行列地址线复用技术，我们尽量选用行列差值不要太大的选项B、C的地址线只需6根（取行或列所需地址线的最大值），轻松排除A和D。其次，为了减小刷新开销，而DRAM一般是按行刷新的，所以应选行数值较少的。  

34.C  

$8{\times}8192{\times}8192{\times}8\mathrm{bit}=512\mathrm{MB}$ ，内存条的容量为512MB，A正确。存储器总线宽度 $64=8{\times}8\mathrm{bit}$ 而每个芯片一次只能传输8bit，需要8体多模块交叉编址采用同时启动方式才能实现，B正确。芯片容量为 $8192{\times}8192{\times}8{\mathrm{bit}}$ ，按字节编址，地址线数应为 $\log_{2}(8192{\times}8192)=26$ ，DRAM采用地址复用技术，地址信号分行、列两次传送，因此地址引脚数为 $26/2=13$ 根，C错误。芯片内行数是8192，一行的大小是 $8192{\times}8\mathrm{bit}$ ，行缓冲长度就是一行的大小，D正确。  
# 二、综合应用题  

01.【解答】  

1）因为刷新带宽  $W_{1}=$  分辨率  $\times$  像素点颜色深度×刷新速率  ${\begin{array}{l}{=1024{\times}768{\times}3\mathrm{B}{\times}72/\mathrm{s}}\\ {=169869\mathrm{KB}/\mathrm{s}}\end{array}}$  

所以刷新总带宽 $W_{0}=W_{1}(W_{0}/W_{1})$  $=169869\mathrm{KB/s}{\times}100/50=339738\mathrm{KB/s}$   $=339.738\mathrm{MB/s}$ （其中 $1\mathrm{K}=1000$ 一  

2）要提高刷新存储器带宽，可采用以下技术： $\textcircled{\scriptsize{1}}$ 采用高速DRAM芯片； $\circledcirc$ 采用多体交叉存储结构； $\textcircled{3}$ 刷新存储器到显示控制器的内部总线宽度加倍； $\textcircled{4}$ 采用双端口存储器将刷新端口和更新端口分开。  

02.【解答】  

1）一个存取周期，四体并行交叉存储器可取32位 $\times4=128$ 位，其中32位为总线宽度，4为交叉存储器内的存储体个数。  

2）该说法不正确。因为在 $0.1\upmu\mathrm{s}$ 内整个存储器可向CPU提供32位二进制信息，但每个存储体必须经过 $400\mathrm{ns}$ 才能向CPU提供32位二进制信息。  

03.【解答】  

顺序存储器和交叉存储器连续读出  $m=4$  个字的信息总量均是  

顺序存储器和交叉存储器连续读出4个字所需的时间分别是  

$t_{1}=m T=4{\times}200\mathrm{ns}=800\mathrm{ns}=8{\times}10^{-7}\mathrm{s}$   $t_{2}=T+(m-1)r=200\mathrm{ns}+3\times50\mathrm{ns}=350\mathrm{ns}=35\times10^{-8}\mathrm{s}$  

顺序存储器和交叉存储器的带宽分别是  

$$
\begin{array}{c}{{W_{1}=q/t_{1}=256^{+}(8\!\times\!10^{-7})=32\!\times\!10^{7}\!\mathrm{b/s}}}\\ {{W_{2}=q/t_{2}=256^{+}(35\!\times\!10^{-8})=73\!\times\!10^{7}\!\mathrm{b/s}}}\end{array}
$$  

04.【解答】  

交叉存储器在统考真题中曾多次考查，希望能引起读者重视，本题是这一类题中较难的。  

1）因为每个体的存取周期是 $200\mathrm{ns}$ 。四体交叉工作，每两个体间读出操作的延时为1/4个存储周期，理想情况是每个存取周期平均可读出4个数据字，读出一个数据字的时间平均为 $200\mathrm{ns}/4=50\mathrm{ns}$ 。数据字长为32位，数据传输速率为32位 $\mathrm{\Delta/50ns=640Mb/s=80MB/s}.$  

2）若对多体结构的存储器选用高位地址交叉，通常起不到提高存储器读/写速度的作用，因为它不符合程序运行的局部性原理，一次连续读出彼此地址相差一个存储体容量的4个字的机会太少。因此，通常只有一个存储模块在不停地忙碌，其他存储模块是空闲的。  

3）若把存储器的字长扩大为原来的4倍，实现的则是一个单体4字结构的存储器，每次读可以同时读出4个字的内容，有利于提高存储器每个字的平均读/写速度，但其灵活性不如多体单字结构的存储器，还会多用到几个缓冲寄存器。  
4）多端口存储器是对同一个存储体使用多套读/写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则充许在同一个存储周期对几个存储体执行写入操作。  

05.【解答】  

对于四体交叉访问的存储系统，每个存储模块的地址分布如下：  

Bank0:0,4,8,12,16,.. Bank1:1,5,9,13,17,.….,37.….,41... Bank2:2,6,10,14,18, Bank3:3,7,11,15,19,.…·,51,·.,67  

若给定的访存地址在相邻的4次访问中出现在同一个Bank内，则可能发生访存冲突。所以17和9、37和17、13和37、8和4可能发生冲突。易错点：虽然41和13号单元也在同一个模块内，并且访问间隔小于4，但是由于访问8号单元发生冲突而使其访问延迟3个间隔，从而使41号单元的访问也延迟3个间隔，因此其访问不会和13号单元的访问发生冲突。  



# 3.3.6 答案与解析  

一、单项选择题  

01.D 字方向扩展了 $64\mathrm{K}/16\mathrm{K}=4$ 倍，位方向扩展了8bit/1bit $=8$ 倍。  

02.A 因为以4B为编址单位，要扩展到32KB，即扩展到 $8K{\times}32\mathrm{bit}$ ，所以只用进行位扩展。  

03.D  $256\mathrm{KB}=2^{18}\mathrm{B}$ ，按字寻址，且字长为 $16\mathrm{bit}=2\mathrm{B}$ ，可寻址的单元数 $=2^{18}\mathrm{B}/2\mathrm{B}=2^{17}$ ，其寻址范围是 $0{\sim}2^{17}{-}1$ 。  

04.A  

4个 $16K{\times}8$ 位的存储芯片构成的存储器容量 $=4{\times}16\mathrm{K}{\times}8$ 位 $=512\mathrm{K}$ 位或64KB，只有选项A的容量为64KB。注意，若有某项为 $128K\times4$ 位，则此选项不能选，因为芯片为8位，不可能将字长“扩展”成4位。  
05.C  

设存储容量为 $M_{c}$ 则有 $(M\!\times\!16)\!+\!(2\!\times\!4)=16$ ，因此 $M\!=\!8K$  

06.D  

地址线为24根，寻址范围是 $2^{24}$ ：数据线为32根，字长为32位。主存的总容量 $=2^{24}{\times}32$ 位因此所需存储芯片数 $=(2^{24}{\times}32){\div}(512\mathrm{K}{\times}8)=128$  

07.A  

由于 $\mathrm{A}_{15}$ 为地址线的低位，接入各芯片地址端的是地址线的低12位，即 $\mathrm{A}_{4}{\sim}\mathrm{A}_{15}$ ，共有8个芯片 $[16\mathrm{{KB}/4\mathrm{{K}=4\mathrm{{B}}}}$ ，并且位扩展时每组两片分为4组）组成16KB的存储器，因此由高两位地址线 $\mathrm{A}_{2}\mathrm{A}_{3}$ 作为译码器的输入。  

08.C  

$43\mathrm{FF}-4000+1=400\mathrm{H}$ ，即内存区域为1K个单元，总容量为 $1K{\times}16$ 位。现由4片存储芯片构成，则构成该内存的芯片容量为 $1\mathrm{K}\!\times\!16$ 位 $'4=256{\times}16$ 位。  

09.D  

CFFFF $-90000+1=40000\mathrm{H}$ ，即内存区域有256K个单元。若用存储容量为 $16K{\times}8$ 位的芯片，则需要的芯片数 $=(256\mathrm{K}{\times}8){\div}(16\mathrm{K}{\times}8)=16$ 片。  

10.B  

$32\mathrm{K}\!\times\!16$ 的存储芯片有地址线15根（片内地址），片选地址为3位，因此地址总位数为18位现高3位为111，则首地址为 $11100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000$ ，末地址为111111111111111111 $=$ 3FFFFH。  

11.D  

这是一个部分译码的片选信号，高8位地址中有2位 $(\mathbf{A}_{14}$ 和 $\mathrm{{A}_{16}}$ ）未参与译码，根据译码器电路，译码输出的逻辑表达式应为  

$$
\overline{{\mathrm{CS}}}=\overline{{\mathrm{A}_{19}(\mathrm{A}_{18}\!+\mathrm{A}_{17})\,\mathrm{A}_{15}\,\mathrm{A}_{13}\,\mathrm{A}_{12}}}
$$  

因此不属于此译码空间的是这几位不合该逻辑表达式的，A选项为AB，即10101011，去掉14位和16位为101111：B选项为101111：C选项为111111：D选项为 $111\ 110$ 。由逻辑表达式可知A17与A18至少有一个为1， $\mathrm{A_{19}A_{15}A_{13}A_{12}}$ 应全为1，仅D无法满足。  

12.D  

首先确定ROM的个数，ROM区为4KB，选用 $2\mathrm{K}\!\times\!8$ 位的ROM芯片，需要 $(4\mathrm{K}{\times}8){\div}(2\mathrm{K}{\times}8)=2$ 片，采用字扩展方式：RAM区为60KB，选用 $4K{\times}4$ 位的RAM芯片，需要 $(60\mathrm{K}{\times}8)^{\div}(4\mathrm{K}{\times}4)=30$ 片，采用字和位同时扩展的方式。  

13.D  

用 $2K{\times}4$ 位的芯片组成一个 $8K{\times}8$ 位存储器，共需8片 $2\mathrm{K}\!\times\!4$ 位的芯片，分为4组，每组由2片 $2K{\times}4$ 位的芯片并联组成 $2\mathrm{K}\!\times\!8$ 位的芯片，各组芯片的地址分配如下：  

第一组（两个芯片并联）： $0000\mathrm{{H}}{\sim}07\mathrm{{F}}\mathrm{{H}}.$ 第二组（两个芯片并联）： $0800\mathrm{H}{\sim}0\mathrm{FFH}\,.$ 第三组（两个芯片并联）： $1000\mathrm{H}{\sim}17\mathrm{F}\mathrm{H}.$ 第四组（两个芯片并联）：1800H\~1FFFH。地址0B1FH所在的芯片属于第二组，故其所在芯片的最小地址为 $0800\mathrm{H}$  

主存按字节编址，地址空间大小为64MB，MAR的寻址范围为 $64\mathrm{M}=2^{26}$ ，因此是26位。实际的主存容量32MB不能代表MAR的位数，考虑到存储器扩展的需要，MAR应保证能访问到整个主存地址空间，反过来，MAR的位数决定了主存地址空间的大小。  
15.C  

5FFF $-4000+1\,{=}\,2000\mathrm{H}$ ，即ROM区容量为 $2^{13}\mathrm{B}=8\mathrm{KB}\ \ (2000\mathrm{H}=2{\times}16^{3}=2^{13})$ ，RAM区容量为56KB(64KB- $8\mathrm{{KB}}=56\mathrm{{KB}}$ )。需要 $8K\!\times\!4$ 位的SRAM芯片的数量为14（ $56\mathrm{KB}/8\mathrm{K}{\times}4$ 位 $=14)$ 。  

16.C  

000000\~3FFFFF，共有3FFFI  $\mathrm{FWHM}-000000\mathrm{H}+1\mathrm{H}=400000\mathrm{H}=2^{22}$  个地址，按字编址，字长为32 位（4B)，因此RAM区大小为 $2^{22}{\times}4\mathrm{B}=2^{22}{\times}32\mathrm{b}$ it。每个RAM芯片的容量为 $512\mathrm{K}{\times}8\mathrm{bit}=2^{19}{\times}8\mathrm{b}$ it，所以需要RAM芯片的数量为 $(2^{22}{\times}32\mathrm{bit})\div(2^{19}{\times}8\mathrm{bit})=32$  

17. C  

地址空间为 $2^{30}$ ，地址范围 $0000\,0000\mathrm{H}{\sim}3\mathrm{FI}$ FFFFFH。RAM $\mathrm{\cdotROM}=3\cdot1$ ，则ROM可分配的地址空间为 $2^{28}$ ，3 FFFFFF FH $2^{28}$ 个地址，即ROM的地址范围是30000000H～3FFFFFFFH.  

# 二、综合应用题  

01.【解答】  

在主存储器中，地址寄存器MAR用来存放当前CPU访问的内存单元地址，或存放CPU写入内存的内存单元地址。数据寄存器MDR用来存放由内存中读出的信息或写入内存的信息。  

1）按字节编址， $1\mathrm{MB}=2^{20}{\times}8$ 位，地址寄存器为20位，数据寄存器位数由存储字长决定，为32位，编址范围为 $0000\mathrm{H}\!\sim$ FFFFFH（FFFFFH $-\ensuremath{00000}\mathrm{H}+1=\ensuremath{100000}\mathrm{H}=2^{20})$ 。2）按字编址， $1\mathbf{MB}=2^{18}{\times}32$ 位，地址寄存器为18位，数据寄存器为32位，编址范围为0000OH  $\sim$  3FFFFH（3FFFFH  $\mathrm{I}-00000\mathrm{H}+1=40000\mathrm{H}=2^{18})$  

02.【解答】  

1）因为所需的组成存储器的最终容量为 $4\mathrm{M}{\times}32$ 位，所以需要32根数据线。而存储器又是按字编址的，所以此时不需要将存储器的容量先转换成 $16{\bf{M}}{\times}8$ 位，直接是 $4{\bf{M}}{\times}32$ 位中的4M，所以只需要22根地址线 $(2^{22}\,{=}\,4\mathrm{M})$ 。2）采用 $512\mathrm{K}{\times}8$ 位的Flash存储芯片组成 $4\mathrm{M}{\times}32$ 位的存储器时，需要同时进行位扩展和字扩展。位扩展：4片 $512\mathrm{K}{\times}8$ 位的Flash存储芯片位扩展可组成 $512\mathrm{K}{\times}32$ 位的Flash存储芯片。字扩展：8片 $512\mathrm{K}{\times}32$ 位的Flash存储芯片字扩展可组成 $4{\bf{M}}{\times}32$ 位的存储器。综上可知，一共需要 $4\!\times\!8=32$ 片 $512\mathrm{K}{\times}8$ 位的存储芯片。3）在CPU的22根地址线中 $(\mathbf{A}_{0}{\sim}\mathbf{A}_{21})$ ，地址线的作用分配如下：首先，此时不需要指定 $\mathrm{A}_{0},\ \mathrm{A}_{1}$ 来标识每组中的4片存储器，因为此时是按字寻址的，所以4片每次都是一起取的，而不是按字节编址时需要取4片中的某一片。 $\mathrm{A_{0}}{\sim}\mathrm{A_{18}}$ ：每片都是512K，所以需要19位（ $(2^{19}=512\mathrm{K}$ ）来表示。 $\mathrm{A_{19}}$  $\mathrm{A}_{20}$ 、 $\mathrm{A}_{21}$ ：因为在扩展中4片一组，一共有8组 $(=2^{3})$ ，所以需要用3位地址线来决定取哪一组（通过3/8译码器形成片选信号）。  

03.【解答】  

1）存储器总容量为 $16\mathrm{K}\!\times\!16$ 位，RAM芯片为 $1K\times4$ 位，因此所需芯片总数为( $16K\!\times\!16$ 位/ $\mathrm{1K\times4}$ 位 $=64$ 片。2）采用异步刷新方式，在 $2\mathrm{ms}$ 时间内分散地把芯片64行刷新一遍，因此刷新信号的时间间隔为 $2\mathrm{ms}/64=31.25\upmu\mathrm{s}$ ，即可取刷新信号周期为 $31\upmu\mathrm{s}$  
> attention  

刷新周期也可取 $30\upmu\mathrm{s}$ ，只要小于 $31.25\upmu\mathrm{s}$ 即可，但通常取刷新间隔的整数部分。  


# 3.4.4 答案与解析  

# 一、单项选择题  

01.B  

闪存是在EPROM的基础上发展起来的，本质上是只读存储器。RAID将多个物理盘组成像单个逻辑盘，不会影响磁记录密度，也不可能提高磁盘利用率。在磁盘的格式化过程中，要对磁盘划分扇区，每个扇区要写入一些控制信息，扇区尾部还要留有一定的空隙，这些均需占用一些存储空间，因此导致格式化后的实际容量比非格式化的容量要小。  
02.A  

因为每个盘面对应一个磁头，所以盘面号和磁头号是同一个概念，显然A的说法是错误的，磁盘地址应该由磁道号（柱面号）、磁头号（盘面号）和扇区号组成。  

03.D  

磁盘存储器以成批（组）方式进行数据读/写，CPU中没有那么多通用寄存器用于存放交换的数据，且磁盘与通用寄存器的速度相差过大，因此磁盘存储器通常直接和主存交换信息。  

04.C  

磁盘存取的步骤为：启动磁头、寻找磁道（寻道时间）、查找扇区（旋转延迟时间）、传输数据，转速提高对寻道时间无影响；存取速度取决于所有步骤的时间，虽然会提高，但不会提高一倍；平均旋转延迟时间为旋转半圈的时间，因此会减少一半；转速提高则传输速率也提高。  

05.B  

固态硬盘的擦除以块为单位，读/写以页为单位，B错误。固态硬盘的写入速度比读取速度要慢很多，因为在写入时需要擦除，且写入次数有限，否则该块就会因为磨损而无法再次写入。  

06.D  

固态硬盘基于闪存技术，没有机械部件，随机读/写不需要机械操作，因此速度明显高于磁盘，A和B正确。选项C已在考点讲解中解释过。SSD常用作外存而非主存，D错误。  

07.C  

磁盘的转速为7200转/分 $=\,120$ 转/秒，转一圈经过160个扇区，每个扇区为512B，所以磁盘每秒传输的数据量为 $120{\times}160{\times}512/1024=9600\mathrm{KB}$  

08.D  

每个磁道的容量 $=60\mathrm{MB}/200=0.3\mathrm{MB}$ ，读一个磁道数据的时间等于磁盘旋转一周的时间减去通过扇区间隙的总时间（每个磁道有8个间隙），即 $25\mathrm{ms}-1.25\mathrm{ms}{\times}8=15\mathrm{ms},$ ，数据传输速率 $=$  $0.3\mathrm{{MB}/15\mathrm{{ms}=20\mathrm{{MB}/s.}}}$  

09.B  

磁盘转速是10000转/分，转一圈的时间为6ms，因此平均查询扇区的时间为 $3\mathrm{ms}$ ，平均寻道时间为6ms，读取4KB扇区信息的时间为 $4\mathrm{KB}{\div}20\mathrm{MB/s}=0.2\mathrm{ms}$ ，磁盘控制器延迟为 $0.2\mathrm{ms}$ ，总时间为 $3+6+0.2+0.2=9.4\mathrm{ms}$  

10.B  

RAID0方案是无余和无校验的磁盘阵列，而RAID1～RAID5方案均是加入了余（镜像）或校验的磁盘阵列。因此，提高RAID可靠性的措施主要是对磁盘进行镜像和奇偶校验，其余选项不符合条件。条带化是一种将数据分片，分别存储至不同的磁盘，提高读/写速度的技术。条带化的优点是读/写速度快，缺点是没有允余，若其中一块磁盘损坏，则数据就会丢失。因此，条带化通常和其他技术如磁盘镜像或奇偶校验结合使用，形成不同的RAID级别。  

11.B  

存取时间 $=$ 寻道时间 $^+$ 延迟时间 $^+$ 传输时间。存取一个扇区的平均延迟时间为旋转半周的时间，即 $(60/7200)/2=4.17\mathrm{ms}$ ，传输时间为 $(60/7200)/1000=0.01\mathrm{ms}$ ，因此访问一个扇区的平均存取时间为 $4.17+0.01+8=12.18\mathrm{ms}$ ，保留一位小数则为 $12.2\mathrm{ms}$  

12.C 磁盘存储器的最小读/写单位为一个扇区，即磁盘按块存取。磁盘存储数据之前需要进行格式化，将磁盘分成扇区，并写入信息，因此磁盘的格式化容量比非格式化容量小。磁盘扇区中包含数据、地址和校验等信息。磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成。  
# 二、综合应用题  

01.【解答】  

1）有效存储区域 $=15.5-10=5.5\mathrm{cm}$ ，道密度 $=60$ 道/cm，因此每个面为 $60\!\times\!5.5=330$ 道，即有330个柱面，因此磁道总数 $=4{\times}330=1320$ 个磁道。  

2）外层磁道的长度为 $2\pi R=2\!\times\!3.14\!\times\!15.5=97.34\mathrm{cm}.$ 每道信息量 $\mathbf{\tau}=600\mathbf{b}\mathrm{i}/\mathbf{cm}\times97.34\mathbf{cm}=58404\mathrm{b}\mathrm{i}=7300\mathbf{B}.$ 利用1）的结果，可得磁盘总容量 $\mathbf{\Pi}=7300\mathbf{B}\mathbf{\times}1320=9636000\mathbf{B}$ （非格式化容量）。  

3）若长度超过一个磁道容量的文件，将它记录在同一个柱面上是比较合理的，因为不需要重新寻找磁道，这样数据读/写速度快。  

4）采用定长数据块格式，直接寻址的最小单位是一个扇区，每个扇区记录固定字节数目的信息，在定长记录的数据块中，活动头磁盘组的编址方式可用如下格式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8cfd8412ea63a0e85eaa0d0e4f85ff011096379c573fc7eb8cb2c1d6fc700b0a.jpg)  

此地址格式表示共有4个记录面，每面有128个磁道，每道最多可有16个扇区。  

5）读一个扇区中数据所用的时间 $=$ 找磁道的时间 $^+$ 找扇区的时间 $^+$ 磁头扫过一个扇区的时间。找磁道的时间是指磁头从当前所处磁道运动到目标磁道的时间，一般选用磁头在磁盘径向方向上移动1/2个半径长度所用的时间为平均值来估算，题中给出的是 $10.5\mathrm{ms}$ 找扇区的时间是指磁头从当前所处扇区运动到目标扇区的时间，一般选用磁盘旋转半周所用的时间作为平均值来估算，题中给出磁盘转速为6000转/分，即100转/秒，所以磁盘转一周用时 $10\mathrm{ms}$ ，转半周用时 $5\mathrm{ms}$ 题中给出每个磁道有12个扇区，磁头扫过一个扇区用时为 $10/12\,=\,0.83\mathrm{ms}$ ，因此磁盘平  

均存取时间为 $10.5+5+0.83=16.33\mathrm{ms}$  



# 3.5.7 答案与解析  

# 一、单项选择题  

01.B  

选项A为干扰项。各层次的存储系统不是孤立工作的，三级结构的存储系统是围绕主存储器来组织、管理和调度的存储器系统，它们既是一个整体，又要遵循系统运行的原理，其中包括包含性原则。因为Cache中存放的是主存中某一部分信息的副本，所以不能认为总容量为两个层次容量的简单相加。  

02.C  

一个块通常由若干字组成，CPU与Cache（或主存）间信息交互的单位是字，而Cache与主存间信息交互的单位是块。当CPU访问的某个字不在Cache中时，将该字所在的主存块调入Cache，这样CPU下次要访问的字才有可能在Cache中。  

03.C  

Cache命中时的存取时间为2ns；Cache不命中时先访问Cache，再访问主存，总存取时间为42ns。设Cache命中率为 $x$ ，则平均存取时间为 $2\!\times\!x+42\!\times\!(1-x)=3$ ，解得 $x=97.5\%$  

04.D  

在写不命中时，加载相应的低一层中的块到高速缓存（Cache）中，然后更新这个高速缓存块，称为写分配法；而避开Cache，直接把这个字写到主存中，则称为非写分配法。这两种方法都是在不命中Cache的情况下使用的，而回写法和全写法是在命中Cache的情况下使用的。在写Cache时，写分配法和回写法搭配使用，非写分配法和全写法搭配使用。  

05.A  

写操作比较密集，采用回写法速度快，更适合访问密集型的应用。全写法每次均写入主存和Cache，能够随时保持主存数据的一致性，适合安全性要求很高的应用。  

06.C  

时间局部性是指一个内存位置被重复引用，循环体中的变量i和sum具有良好的时间局部性。空间局部性是指若一个内存位置被引用，则它附近的位置很快也会被引用，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式存储的，v具有良好的空间局部性。  

07.B  

空间局部性是指程序在一段时间内所访问的存储空间的集中度。为了提高空间局部性，应尽量按照数组在内存中的存储顺序依次访问数组元素。根据C语言的规定，数组a在内存中是按最右下标变化最快的方式存储的，即a[0][0][0],a[0][0][1]..,a[0][0][n-1],a[0][1][0]..,a[0][n-1][n-1]a1][0][0]..，an-1]n-1][n-1]。因此，若将代码的第2行与第4行互换，则可使得对数组a的访问变成顺序访问，从而提高空间局部性。  

08.A  

Cache的功能完全由硬件实现，A正确。Cache替换时的单位是块，而不是字或字节，因为Cache和主存是以块为单位进行数据交换的。Cache地址空间和主存地址空间相互独立，通过地址映射把主存地址空间映射到Cache地址空间。Cache中的信息不一定与主存中的信息一致，因为Cache可能采用回写策略，只有当被修改的块被换出时才写回主存。  
09.D  

指令Cache通常比数据Cache具有更好的空间局部性，这是因为指令流通常是顺序执行的，而数据流跳转或随机访问的概率较高，1正确。由于空间局部性，同一主存块中的数据的访问概率较高，因此增加Cache块大小会提高命中率，IⅡ正确。写回法只有在被修改的块被换出时才写回主存，而写直达法每次写操作都会同时写回主存，Ⅲ正确。  

10.A  

LRU表如下：
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca95328eda743bf11e48cf9d6cae6c3cd6b2972d0ef00bd22e02aed0822228e.jpg)  
可见页面失效率是 $6/20=30\%$  

1.  A  

访存1000次，访问第2级Cache后，仍有10条不命中，故总命中率为 $1-10/1000=99\%.$  

12.A  

$K=1$ 即一块为一组，每个主存块映射到唯一的Cache块，为直接映射，A正确，B错误。 $K\!=\!M$ 即每个主存块可映射到所有Cache块中，为全相联映射，C错误。D应为 $K_{\uparrow}$ 路组相联映射。  

13.C  

LRU算法根据程序访问局部性原理选择近期使用得最少的存储块作为替换的块。  

14.D  

地址映射表即标记阵列，由于Cache被分为64个块，因此Cache有64行，采用直接映射，一行相当于一组。因此标记阵列每行存储一个标记项，其中主存标记项为12位（ $.2^{12}=4096$ ，是Cache容量的4096倍，即地址长度比Cache长12位），加上1位有效位，因此为 $64\!\times\!13$ 位。  

15.C  

块大小为16B，所以块内地址字段为4位；Cache容量为128KB，采用8路组相联，共有  $128\mathrm{{KB}{\div}}(16\mathrm{{B}{\times}}8)=1024$ 组，组号字段为10位；剩下的为标记字段。1234567H转换为二进制数0001 $0010\,0011\,0100\,0101\,0110\,0111$ ，标记字段对应高14位，即 $048\mathrm{DH}$  

16.A  

先写出主存地址的二进制形式，然后分析Cache块内地址、Cache字块地址和主存字块标记。主存地址的二进制数 $0011\;0101\;0011\;0000\;0001$ ，根据直接映射的地址结构，字块内地址为低5位（每个字块32B， $2^{5}=32$ ，因此为5位），主存字块标记为高6位 $(1\mathrm{{MB}/16\mathrm{{KB}=64}}$  $2^{6}=64$ ，因此为6位），其余 $01\ 0011\ 000$ 即为Cache字块地址，转换为十进制数152。  

17.C  

当CPU访存时，先要到Cache中查看该主存地址是否在Cache中，所以发送的是主存物理地址。只有在虚拟存储器中，CPU发出的才是虚拟地址，这里并未指出是虚拟存储系统。磁盘地址是外存地址，外存中的程序由操作系统调入主存中，然后在主存中执行，因此CPU不可能直接访问磁盘。  

18. C  

对于逻辑地址，因为 $\ 8=2^{3}$ 页，所以表示页号的地址有3位，又因为每页有 $1024=2^{10}\mathrm{B}$ ，所以页内地址有10位，因此逻辑地址共13位。  
对于物理地址，块内地址和页内地址一样有10位，内存至少有 $32=2^{5}$ 个物理块，所以表示块号的地址至少有5位，因此物理地址至少有15位。  

19.B  

组相联映射的主存地址结构为：tag标记 $^+$ Cache组号 $^+$ 字块内地址。Cache块大小增加一倍，则字块内地址的位数增加1位。Cache组数 $=$ (Cache总容量/Cache块大小)/n，敌Cache组数减少一半；Cache组号  $=$  主存块号MODCache组数，故Cache组号也减少1位。主存总容量不 变，则主存地址总长度不变，字块内地址和Cache组号一个增1一个减1，因此tag字段的位数不变。  

20.B  

块大小为 $16\mathrm{B}=2^{4}\mathrm{B}$ ，所以块内地址占4位。若采用直接映射，Cache共16行，主存地址中块内地址的前4位为Cache行号，Cache行号 $=$ 主存块号%Cache总行数 $=$ （主存地址 $/16)\%16$ 选项B的地址48和308的Cache行号均为3，产生冲突。若采用2-路组相联映射，共有 $16/2=8$ 组，主存地址中块内地址的前3位为Cache组号，Cache组号 $=$ 主存块号%Cache组数 $=$ （主存地址 $/16)\%8$ ，选项B的地址48和308的Cache组号均为3，可能产生冲突。  

21.D  

主存块大小为1个字，即32位，按字节编址，所以块内地址占2位。在全相联映射方式下，主存地址只有两个字段，所以标志占 $32-2=30$ 位。因采用回写法，故需1位修改位；因为采用随机替换策略，故无须替换控制位。每个Cache行的总位数为32bit（数据位） $+\,30\,\mathrm{bit}$ （tag位） $^+$ Ibit（修改位） $^+$ Ibit（有效位） $=$ 64bit。综上，Cache总容量至少应有 $32\mathrm{K}\!\times\!64\mathrm{bit}=2048\mathrm{K}$ bit。  

22.A  

主存块大小为32字节，按字节编址，所以块内地址占5位。采用四路组相联映射方式，共64行，分 $64/4=16$ 组，故组号占4位。因为 $2593=0\cdots0101\ 0001\ 00001$ ，根据主存地址划分的结果，可以看出第2593号存储单元所在主存块的Cache组号为 $0001$  

23.C  

一次缺失损失需要从主存读出一个主存块（64B），每个总线事务读取8B，因此需要8个总线事务。每个总线事务所用的时间为 $1+8+1=10$ 个时钟周期，共需要80个时钟周期。  

24.A  

一次缺失损失需要从主存读出一个主存块（64B），每个突发传送总线事务可读取 $8\mathrm{B}{\times}8{=}64\mathrm{B}$ 因此只需要一个突发传送总线事务。首先，发送首地址和读命令需要一个时钟周期，然后轮流启动每个存储器模块，每隔一个时钟周期启动一个存储器模块，采用流水线工作方式，所以每个突发传送总线事务所用的时间为 $1+8+8=17$ 个时钟周期，因此共需17个时钟周期。  

25.B  

对于直接映射，主存中的每一块只能装入Cache中的唯一位置，若产生块冲突，原来的块将被无条件换出，因此无须考虑替换问题，而组相联映射和全相联映射都需要考虑替换问题。先进先出算法需要对每个Cache行打一个时间戳，记录何时装入了一个新主存块。  

26.D  

主存块太小，不能很好地利用空间局部性，从而导致缺失率变高；但主存块太大也会使得Cache行数变少，即Cache中可以存放主存块的位置变少，从而也会降低命中率。因此，主存块大小应该适中，既不能太大，又不能太小，通常为几十字节到上百字节。  
27.D  

命中率 $=$ Cache命中次数/总访问次数。注意看清题目，题中说明的是缺失50次，而不是命中50次，仔细审题是做对题的第一步。  

28. C  

由于Cache共有16块，采用二路组相联，共分为8组，组号为 $0,\,1,\,2,\cdots,\,7$ ，组号占3位。主存块大小为32B，按字节编址，块内地址占5位。主存单元地址 $129=0^{\cdots0}\;100\;00001$ ，后5位是块内地址，块内地址的前3位是组号，因此将映射到组号4的任意一个Cache块中。  

29.C  

地址映射采用二路组相联，主存字地址为 $0{\sim}1\!\cdot\!4{\sim}5\!\cdot\!8{\sim}9$ 可映射到第0组Cache中，主存地址为 $2{\sim}3{\sim}~6{\sim}7$ 可映射到第1组Cache中。Cache置换过程如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5c6d3488af8e8163b07751cb16ce02d55798381ef41b13fc464e42476c0971b7.jpg)  
注：“”表示当前访问块，“\*”表示本次访问命中。  

> attention  

在不同的计算机组成原理教材中，关于组相联映射的介绍并不相同。通常是采用上题中的方式，也是本书及唐朔飞所编教材中的方式，但本题中采用的是蒋本珊所编教材中的方式。可以推断两次命题的老师应该不是同一老师，这也给考生答题带来了困扰。  

30.C  

分析语句“ $\mathsf{\tilde{a}[k]}=\mathsf{a[k]}+32^{\circ}$ ”：首先读取ak]需要访问一次ak]，之后将结果赋值给ak]需要访问一次，共访问两次。第一次访问ak未命中，并将该字所在的主存块调入Cache对应的块中，对该主存块中的4个整数的两次访问中，只在访问第一次的第一个元素时发生缺失，其他的7次访问中全部命中，因此该程序段执行过程中访问数组a的Cache缺失率约为1/8。  

31.A  

时间局部性是指最近的未来要用到的信息，很可能是现在正在使用的信息，本题的外层循环每次都会访问一次数组a，体现了时间局部性。空间局部性是指最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，本题在访问数组a的过程中是顺序访问的，体现了空间局部性。  

32.A  

Cache数据区大小为32KB，主存块的大小为32B，于是Cache中共有1K个Cache行，物理地址中偏移量部分的长度为5bit。因为采用直接映射方式，所以1K个Cache行映射到1K个分组，物理地址中组号部分的长度为10bit。32bit的主存地址除去5bit的偏移量和10bit的组号后，还剩17bit的tag部分。又因为Cache采用回写法，所以Cache行的总位数应为32B（数据位） $^+$ 17bit(tag位） $^+$ 1bit（脏位） $^+$ 1bit（有效位） $=$ 275bit。  

33.A  

Cache采用组相联映射，主存地址结构应分为Tag标记、组号、块内地址三部分。主存块大小 $=$ Cache块大小 $=64\mathrm{B}=2^{6}\mathrm{B}$ ，因此块内地址占6位。Cache数据区容量为32KB，每个Cache块大小为64B，则Cache总块数 $=\,32\mathrm{{KB}/64B}\,=\,2^{9}$ ，由于采用8路组相联映射，即每8个Cache块为一个分组，因此总共被分为 $2^{9}/8=2^{6}$ 组，因此，组号占6位。除了块内地址和组号，剩余的位为Tag标记，占 $32-6-6=20$ 位。地址结构如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6367334f9ded4fbae6a7b359ccdaedc1d6194c5bbf1663799c71f6d287334c98.jpg)  

Cache采用8路组相联映射，因此在访问一个物理地址时，要先根据组号定位到某一分组，然后用物理地址的高20位（Tag标记）与分组中8个Cache行的Tag标记做并行比较（用8个20位“比较器”实现），若某个Cache行的Tag标记与物理地址的高20位完全一致，则选中该Cache行。综上所述，在组相联映射的Cache中，“比较器”用于并行地比较分组中所有Cache行的Tag标记位与要访问物理地址的Tag标记位，因此比较器的个数就是分组中的Cache行数8，比较器的位数就是Tag标记位数20。  

# 二、综合应用题  

01.【解答】  

回写法（WriteBack）减少了访存次数，但存在不一致的隐患。因此若题目中出现了“较高的安全要求”，则尽量要使用写直通法（WriteThrough）。  

1）采用WriteBack策略较好，可减少访存次数。2）采用WriteThrough策略较好，能保证数据的一致性  

02.【解答】  

块大小为64B，因此块内地址字段占6位；Cache中有128个主存块，采用四路组相联，故Cache分为32组（ $128/4=321$ ），因此组号字段占5位；标记字段为剩余的 $32-5-6=21$ 位。  

数据Cache的总位数应包括标记项的总位数和数据块的位数。每个Cache块对应一个标记项，标记项中应包括标记字段、有效位和“脏”位（仅适用于回写法）。  

1）主存地址中Tag为21位，位于主存地址前部；组号Index为5位，位于主存地址中部；块内地址Offset为6位，位于主存地址后部。  

2）标记项的总位数 $=128{\times}(21+1+1)=128{\times}23=2944$ 位，数据块位数 $=128\!\times\!64\!\times\!8\!=\!65536$ 位，所以数据Cache的总位数 $=2944+65536=68480$ 位。  

03.【解答】  

1）由于 $64\mathrm{{KB}}/128\mathrm{{B}}=512$ ，因此有512行。而该Cache是四路组相联，所以 $512/4=128$ 组。  

2）每行有一个标记项，因此有512个标记项。主存字块标记长度就是标记位的长度，因为该Cache有128组 $(=2^{7})$ ），所以7位为组地址。而行长128B $(=2^{7})$ ），7位为字块内地址，因此该标记项中的标记位长度为 $32-7-7=18$ 位。  

3）LRU替换策略要记录每个Cache行的生存时间，因此每个标记项有两位替换控制位。而全写法没有“脏”位（一致性控制位），再加一个有效位即可。因此每个标记项位数是 $18+2+1=21$ 位，因此总大小为 $512\!\times\!21=10752$ 位。  

回写式则是每个标记项加一个一致性控制位，因此为 $512\!\times\!22=11264$ 位。  

04.【解答】  

块大小为32B，数组起始地址正好是一个主存块的开始，因此每8个数组元素占一个主存块：Cache共有 $256\mathrm{B}/32\mathrm{B}=8$ 行，采用2-路组相联映射时，Cache有4组。下面分析两种情况。  

1）直接映射。当  $s=64$  时：访存顺序为a[0],a[64];a[0],a[64]"；循环10000次。因为a[0] 所在主存块和a[64]所在主存块正好相差8个主存块，在直接映射方式下，除以8同余，  
这两个主存块会映射到同一个Cache行，每次都会发生冲突，缺失率为 $100\%$ 。当 $s=63$ 时：访存顺序为a[0],a[63],a[126]:a[0],a[63],a[126]；循环10000次。因为a[63]所在主存块和a[1261所在主存块正好相差8个主存块，在直接映射方式下，这两个主存块会映射到同一个Cache行，每次都会发生冲突，而a[0]不会发生冲突，缺失率约为 $67\%$  

2）2-路组相联映射。当  $s\,{=}\,64$  时：访存顺序为a[0],a[64]；a[0],a[64]，；循环10000次。因 为a[0]所在主存块和a[64]所在主存块正好相差8个主存块，在2-路组相联映射方式下，除以4同余，这两个主存块会映射到同一组，可放在同一组的不同Cache行中，不会发生冲突，总缺失次数仅为2次，缺失率近似为0.当  $s=63$  时：访存顺序为a[0],a[63],a[126] a[0],a[63]，a[126]，；循环10000次。因为a[63]所在主存块和a[126]所在主存块正好相差8个主存块，这两个主存块会映射到同一组，可放在同一组的不同Cache行中，而a[0]不会发生冲突，总缺失次数仅为3次，缺失率近似为0。  

05.【解答】  

1）每个Cache行对应一个标记项，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5b8b46f643df17cfaede8b1aa0b4e4b3f0c7a24d95f225e459403c0e5a084b5d.jpg)  

不考虑用于Cache一致性维护和替换算法的控制位。地址总长度为28位 $(2^{28}=256\mathrm{M})$ ，块内地址6位 $2^{6}\!=\!64)$ ，Cache块号3位 $\ 2^{3}=8$ ），因此Tag的位数为 $28-6-3=19$ 位，还需使用一个有效位，因此题中数据Cache行的结构如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb5acc0009f8543760c114f98c5cd228eb0b76b77dd344f3567ea462668afe6e.jpg)  

数据Cache共有8行，因此数据Cache的总容量为 ${\bf8}\!\times\!(64+20/8)\mathrm{{\bfB}}=532\mathrm{{\bfB}}$  

2）数组a在主存的存放位置及其与Cache之间的映射关系如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2bb734350f3df8989ece04f9459fe312b57e24670735ad7b4f962b26e81f7f78.jpg)  

数组按行优先方式存放，首地址为320，数组元素占4B。a[0][31]所在的主存块对应的Cache行号为 $(320+(0{\times}256+31){\times}4)\mathrm{div}2^{6}]\ \mathrm{mod}2^{3}=6;$ a[1][1]所在的主存块对应的Cache行号为 $(320+(1\!\times\!256+1)\!\times\!4)\mathrm{div}2^{6}]\bmod2^{3}=5.$  

【另解】由1）可知主存和Cache的地址格式如下图所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1c6ed13a6f46155b86b2d616d6569c490fbe99a61d5bef41a08d41b179c3c3c7.jpg)  

数组按行优先方式存放，首地址为320，数组元素占4B。a[0][31]的地址为 $320+31{\times}4=$  $1\ 1011\ 1100_{\mathrm{B}}$ ，因此其对应的Cache行号为 $110_{\mathrm{B}}=6$ ；a[1][1]的地址为 $320+256{\times}4+1{\times}4=$  $1348=101\,0100\,0100_{\mathrm{B}}$ ，因此其对应的Cache行号为 $101_{\mathrm{B}}=5$  

3）编译时ijsum均分配在寄存器中，所以数据访问命中率仅考虑数组a的情况。  

数组a的大小为 $256{\times}256{\times}4\mathrm{B}=2^{18}\mathrm{B}$ ，占用 $2^{18}/64=2^{12}$ 个主存块，按行优先存放，程序A逐行访问数组a，共需访问的次数为 $2^{16}$ 次，未命中次数为 $2^{12}$ 次（即每个字块的第一个数未命中)，因此程序A的命中率为 $(2^{16}-2^{12})/2^{16}\times100\%=93.75\%$  

【另解】数组a按行存放，程序A按行存取。每个字块中存放16个int型数据，除访问的第一个不命中外，随后的15个全都命中，访问全部字块都符合这一规律，且数组大小为字块大小的整数倍，因此程序A的命中率为 $15/16=93.75\%$  

程序B逐列访问数组a，Cache总数据容量为 $64\mathrm{B}{\times}8=512\mathrm{B}$ ，数组a一行的大小为1KB，正好是Cache容量的2倍，可知不同行的同一列数组元素使用的是同一个Cache单元，因此逐列访问每个数据时，都会将之前的字块置换出，即每次访问都不会命中，命中率为0。  

因为从Cache读数据比从主存读数据快很多，所以程序A的执行比程序B快得多。  

06.【解答】  

1）CPU的时钟周期是主频的倒数，即  $1/800\mathrm{MHz}=1.25\mathrm{ns}$  总线的时钟周期是总线频率的倒数，即 $1/200\mathrm{MHz}=5\mathrm{ns}$ 总线宽度为32位，因此总线带宽为 $4\mathrm{B}{\times}200\mathrm{MHz}=800\mathrm{MB}/\mathrm{s}$ 或 $4\mathrm{B}/5\mathrm{ns}=800\mathrm{MB}/\mathrm{s}.$  

2）Cache块大小是32B，因此Cache缺失时需要一个读突发传送总线事务读取一个主存块。  

3）一次读突发传送总线事务包括一次地址传送、32B数据准备和传送：用一个总线时钟周期传输地址；之后每隔 $40\mathrm{ns}/8=5\mathrm{ns}$ 启动一个存储体（各进行一次读操作），第一个体准备数据花费 $40\mathrm{ns}$ ，之后这个字的传送操作与下一个字的准备操作重叠；用8个总线时钟周期传送数据。读突发传送总线事务时间为 $5\mathrm{ns}+40\mathrm{ns}+8{\times}5\mathrm{ns}=85\mathrm{ns}$  

另解：首先5ns的传送地址和命令，然后把存储体准备数据的时间视为流水线，因为总线周期是5ns，存储体的存储周期是 $40\mathrm{ns}$ ，所以相当于准备数据是一个8段流水线，因此准备8个数据的时间是 $40+5{\times}7,$ ，最后再花5ns传输最后一个数据，因为之前的7个存储体的数据的传输时间和其下一个存储体准备数据的时间是并行的，所以共需要 $5+40+5{\times}7+$  $5=85\mathrm{{ns}}$ 。也可以这样理解，将从数据准备到传输结束视为一个完整的流水线，也就是共视为9个流水段，每个流水段的时间是5ns，这样总共花费的时间就是 $5+45+7{\times}5=85\mathrm{ns}.$ 只要是有关于流水线思想的，最关键的就是分清楚流水段，剩下的就是简单计算，不同的算法不是关键，本质上都是一样的。  

4）CPU执行时间 $=$ Cache命中时的指令执行时间 $^+$ Cache未命中时的额外访存开销 $\times$ 缺失率。一条指令在Cache命中时的执行时间 $=$ Cache C PIx $\mathrm{\Omega}=\mathrm{\Omega}4{\times}1.25\mathrm{ns}\,=$ 5ns。一条指令因Cache缺失而导致的平均访存开销 $=$ 平均访存次数 $\times$ 一次突发传送总线事务时间 $=1.2{\times}85{\mathrm{ns}}\,=\,102{\mathrm{ns}}$ 。因此BP的CPU执行时间 $=(5\mathrm{ns}\ +\ 102\mathrm{ns}\!\times\!5\%)\!\times\!100\ =$  $1010\mathrm{ns}$ 。100条指令中，平均有 $95\%$ 的指令Cache命中，只需要5ns；平均有 $5\%$ 的指令Cache缺失，需要  $5\mathrm{ns}+102\mathrm{ns}=\!107\mathrm{ns}$  。本题说明了408真题采用先访问Cache再访问主 存的方式。  
07.【解答】  

1）主存块大小为  $64\mathrm{B}=2^{6}$  字节，故主存地址低6位为块内地址，Cache组数为  $32\mathrm{KB}{\cdot}(64\mathrm{B}{\times}8)=$   $64=2^{6}$ ，故主存地址中间6位为Cache组号，主存地址中高 $32-6-6\,{=}\,20$ 位为标记，采用8路组相联映射，故每行中的LRU位占3位，采用直写方式，故没有修改位。  

2） $\mathrm{0080\,000C0H}=\mathrm{0000\,0000\,1000\,0000\,0000\,0000\,1100\,0000B}$ ，主存地址的低6位为块内地址，为全0，故s位于一个主存块的开始处，占 $1024\times4\mathrm{B}/64\mathrm{B}=64$ 个主存块；在执行程序段的过程中，每个主存块中的 $64\mathrm{B}/4\mathrm{B}=16$ 个数组元素依次读、写1次，因而对每个主存块，总是第一次访问缺失，此时会将整个主存块调入Cache，之后每次都命中。综上，数组s的数据Cache访问缺失次数为64次。  

1) $\begin{array}{r}{0001\ 0003\mathrm{H}=0000\ 0000\ 0000\ 0001\ 0000\ 00000\ 000011\mathrm{B},}\end{array}$ 根据主存地址划分可知，组索引为O，故该地址所在主存块被映射到指令Cache的第0组；因为Cache初始为空，所有Cache行的有效位均为O，所以Cache访问缺失。此时，将该主存块取出后存入指令Cache的第0组的任意一行，并将主存地址高20位（00010H）填入该行标记字段，设置有效位，修改LRU位，最后根据块内地址000011B从该行中取出相应的内容。  



# 3.6.7 答案与解析  

# 一、单项选择题  

01.C  

虚拟存储系统利用的是局部性原理，程序应当具有较好的局部性，C正确。而含有输入、输出操作产生中断，与虚存无关，A错误。大小较小但可以多个程序并发执行，也可以发挥虚存的作用，B错误。。顺序执行的指令应当占较大比重为宜，这样可增强程序的局部性，D错误。  

02.A  

局部性原理的含义是在一个程序的执行过程中，其大部分情况下是顺序执行的，某条指令或数据使用后，在最近一段时间内有较大的可能再次被访问（时间局部性）：某条指令或数据使用后，其邻近的指令或数据可能在近期被使用（空间局部性）。在虚拟存储管理系统中，程序只能访问主存获得指令和数据，A正确。选项B、C、D均是局部性原理的一个方面而已。  

03.D  

页式虚拟存储方式对程序分页，采用页进行交互；段页式则先按照逻辑分段，然后分页，以页为单位和主存交互，D正确。  

04.A  

虚存需要通过对操作系统实现地址映射，因此对操作系统的设计者即系统程序员是不透明的。而应用程序员写的程序所使用的是逻辑地址（虚地址），因此对其是透明的。  

05.D  

虚拟存储器中，地址映射由操作系统来完成，但需要一部分硬件基础的支持，如快表、地址映射系统等。  
06.B  

引入虚拟存储器的目的是为了解决内存容量不够大的问题。  

07.D  

页表不命中，表示该页面没有调入主存，而Cache是页面的副本，因此Cache一定也不命中，I正确。Cache不命中时只需从主存读取数据，页表不命中时需要从辅存读取数据，而辅存的速度比主存慢很多，IⅡI错误。Cache缺失处理由硬件完成，TLB缺失处理既可以由硬件完成，又可以由软件完成，IⅢI错误。虚拟存储器的实际容量小于或等于主存和辅存的容量之和，IV错误。  

08.D  

段的分界与程序的逻辑分界相对应，使得它易于编译、修改、保护和共享。  

09.B  

虚拟存储管理的目的是让程序员可以在一个比主存地址空间大得多的虚拟地址空间中编程，显然逻辑地址空间比主存空间大，因此逻辑地址的位数比物理地址的位数多，B错误。在执行程序时，由CPU中的MIMU进行逻辑地址到物理地址的转换。在转换过程中，MMU需要查找对应的页表项，根据页表项中的装入（有效）位是否为1来确定是否发生缺页。  

10.D  

选项A、B和C都正确。页表中的每个表项反映的是对应虚拟页面的位置和使用等信息，通常只能由操作系统和硬件进行访问，虚拟存储管理机制对用户进程来说是透明的，D错误。  

11.B  

缺页是CPU在执行指令过程中进行取指令或读/写数据时发生的一种故障，属于内部异常。  

12.D  

选项A、B和C都正确。分段方式对低级语言程序员和编译器来说是不透明的，因为低级语信程序员需要使用段号来编程，编译器需要使用段号来链接，D错误。  

13.D  

快表采用高速相联存储器，它的速度快来源于硬件本身，而不是依赖搜索算法来查找的；慢表存储在内存中，通常是依赖于查找算法，故A和B错误。快表与慢表的命中率没有必然联系，快表仅是慢表的一个部分拷贝，不能够得到比慢表更多的结果，C错误。  

14.D  

Cache的内容是主存的一部分副本，TLB的内容是Page（页表）的一部分副本。在同时具有TLB和Cache的虚拟存储系统中，CPU发出访存命令，先查找对应的Cache块。1）若Cache命中，则说明所需内容在Cache内，其所在页面必然已调入主存，因此Page必然命中，但TLB不一定命中。2）若Cache未命中，则并不能说明所需内容未调入主存，和TLB、Page命中与否没有联系。但若TLB命中，Page也必然命中；而当Page命中，TLB则未必命中，因此D不可能发生。  

15.A  

按字节编址，页面大小为4KB，页内地址共12位。地址空间大小为4GB，虚拟地址共32位，前20位为页号。虚拟地址为03FFF180H，因此页号为03FFFH，页内地址为 $180\mathrm{H}$ 。查找页标记03FFFH所对应的页表项，页框号为0153H，页框号与页内地址拼接即为物理地址 $015\,3180\mathrm{H}$  

16.B  

上述指令的执行过程可划分为取数、运算和写回过程，取数时读取xaddr可能不需要访问主存而直接访问Cache，而直写方式需要把数据同时写入Cache和主存，因此至少访问1次。  
17.C  

直接映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/29a5cd848995adbcdc0b0a61ee30283897b0755702526a702eedcbfd9f298149.jpg)  

按字节编址，块大小为  $4{\times}32$  位  ${\it\Omega}=16{\mathrm{B}}=2^{4}{\mathrm{B}}$  ，则“字块内地址”占4位；“能存放4K字数据 的Cache”即Cache 的存储容量为4K字（注意单位），则Cache共有 $1\mathrm{K}=2^{10}$ 个Cache行，Cache字块标记占10位；主存字块标记占  $32-10-\,4=18$  位。  

Cache的总容量包括：存储容量和标记阵列容量（有效位、标记位、一致性维护位和替换算 法控制位）。标记阵列中的有效位和标记位一定存在，而一致性维护位（脏位）和替换算法控制位的取舍标准是看词眼，题目中明确说明了采用回写法，则一定包含一致性维护位，而关于替换算法的词眼题目中未提及，所以不予考虑。因此，每个Cache行标记项包含 $18+1+1=20$ 位，标记阵列容量为  $2^{10}{\times}20$  位  $=20\mathrm{K}$  位，存储容量为  $4K\!\times\!32$  位  $=128\mathrm{K}$  位，总容量为  $128\mathrm{K}+20\mathrm{K}=$  148K位。  

18. D  

在请求分页系统中，每当要访问的页面不在内存中时，CPU检测到异常，便会产生缺页中断，请求操作系统将所缺的页调入内存。缺页处理由缺页中断处理程序完成，根据发生缺页故障的地址从外存读入所缺失的页，缺页处理完成后回到发生缺页的指令继续执行。选项D中描述回到发生缺页的指令的下一条指令执行，明显错误。  

19.D  

Cache由SRAM组成；TLB也由SRAM组成。DRAM需要不断刷新，性能偏低，不适合组成TLB和Cache。选项A、B C T LB Cache。  

20.C  

页大小为  $4\mathrm{KB}=2^{12}\mathrm{B}$  ，按字节编址，故页内地址为12位。虚拟地址空间大小为  $4\mathrm{GB}=2^{32}\mathrm{B}$  故虚拟地址共32位，其中低12位为页内地址，高20位为虚页号。题中给出的虚拟地址为00082840H，虚页号为高20位即00082H（页内地址为低12位即840H），82H对应的十进制数为130（注意题中页表的虚页号部分末尾未写H，所以是十进制数，故查找时要先将虚页号转换为十进制数），查页表命中，并且存在位为1，对应页框号为018H。将查找到的页框号018H和页内地址840H拼接，得到主存地址为 $01\ 8840\mathrm{H}$  

# 二、综合应用题  

01.【解答】  

所有地址均可转换为页号和页内偏移量。地址转换时，先取出逻辑页号，然后查找页表，得到页框号，再将页框号与页内偏移量拼接，即可获得物理地址。根据题意，计算逻辑地址的页号和页内偏移量，拼接的物理地址如下表所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/35e3d360d5c97ebd6263089d17a2af929bf5def7da1edfb5365702b009e69319.jpg)  
注：在本题中，物理地址 $=$ 页框号×1024B $^+$ 页内偏移量，页内偏移量 $=$ 逻辑地址-逻辑页号x1024B，逻辑页号 $=$ 逻辑地址/1024B（结果向下取整）。  
02.【解答】  

1）虚拟地址1的页号为15，页内地址为0324，在左表中页号15对应的主存起始位置为80000，则主存的实地址码为 $0324+80000=80324$  

2）按1）中的方法易知，主存的实地址码为 $0128+96000=96128$  

3）虚拟地址3的页号为48，在左表中无对应项，因此该页面在快表（页表）中无记录。  

03.【解答】  

1）LRU替换策略是换出最近最久未使用的页面，因此每个页号访问请求之后存放在主存中的位置如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5d97e102b608f5c205626050b04deabe246839b152fb0bfb7da24dcff7349ab.jpg)  

2）共30次访存，有13次命中，因此主存的命中率为 $13/30=43\%$  

04.【解答】  

1）存储器按字节编址，虚拟地址空间大小为 $16\mathrm{MB}=2^{24}\mathrm{B}$ ，因此虚拟地址为24位；页面大小为 $4\mathrm{KB}=2^{12}\mathrm{B}$ ，因此高12位为虚页号。主存地址空间大小为 $1\mathrm{MB}=2^{20}\mathrm{B}$ ，因此物理地址为20位；由于页内地址为12位，因此高8位为物理页号。  

2）因为Cache采用直接映射方式，所以物理地址各字段的划分如下  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0a7e72355443358451452532f9144a08fa1fe2e9dda183d0e916ebb4a4e3f9f0.jpg)  

由于块大小为32B，因此字块内地址占5位；Cache共8行，因此Cache字块标记占3位；主存字块标记占 $20-5-3=12$ 位。  

3）虚拟地址001C60H的前12位为虚页号，即 $001\mathrm{H}$ ，查看 $001\mathrm{H}$ 处的页表项，其对应的有效位为1，因此虚拟地址 $001\mathrm{C}60\mathrm{H}$ 所在的页面在主存中。页表 $001\mathrm{H}$ 处的页框号为 $\mathrm{04H}$ ，与页内偏移（虚拟地址后12位）拼接成物理地址 $04\mathrm{C}60\mathrm{H}_{\circ}$ 物理地址 $\mathrm{04C60H}=0000\ 0100$  $1100\ 0110\ 0000\mathrm{B}$ ，主存块只能映射到Cache的第3行（即第011B行），由于该行的有效位 $=1$ ，标记（值为105H） $\neq04\mathrm{CH}$ （物理地址高12位），因此未命中。  

4）由于TLB采用四路组相联，因此TLB被分为 $8/4=2$ 个组，因此虚页号中高11位为TLB标记、最低1位为TLB组号。虚拟地址  $\mathrm{024BACH}=0000\ 0010\ 0100\ 1011\ 1010\ 1100B}$  ，虚 页号为 $\mathrm{0000\0010\ 0100B}$ ，TLB标记为 $\mathrm{0000\0010\ 010B}$ （即012H），TLB组号为0B，因此该虚拟地址所对应的物理页面只能映射到TLB的第0组。组O中存在有效位 $=1$ 、标记 $=012\mathrm{H}$ 的项，因此访问TLB命中，即虚拟地址024BACH所在的页面在主存中。  

05.【解答】  

1）页大小为8KB，页内偏移地址为13位，因此 ${\mathrm{A}}={\mathrm{B}}=32-13=19;{\mathrm{~}}{\mathrm{D}}=13;{\mathrm{~}}{\mathrm{C}}=24-13=$ 11；主存块大小为64B，因此 $\mathrm{G}=6$ 。二路组相联，每组数据区容量有 $64\mathrm{B}{\times}2=128\mathrm{B}$ ，共有 $64\mathrm{{KB}}/128\mathrm{{B}}=512$ 组，因此 $\mathrm{F}=9$  $\mathrm{E}=24-\mathrm{G}-\mathrm{F}=24-6-9=9\,.$  

因而 $\mathbf{A}=19$ ， $\mathbf{B}=19$ ， $C=11$ ， $\mathrm{D}=13$ ， $\mathrm{E}=9$ ，F=9，G=6。TLB中标记字段B的内容是虚页号，表示该TLB项对应哪个虚页的页表项。  

2）块号 $4099=00\;0001\;0000\;0000\;0011\mathrm{B}$ ，因此所映射的Cache组号为 $0\ 0000\ 0011\mathbf{B}=3$ ，对  
应的H字段内容为 $0\,\,0000\,\,1000\mathrm{B}$  

3）Cache缺失带来的开销小，而处理缺页的开销大。因为缺页处理需要访问磁盘，而Cache缺失只要访问主存。  

4）因为采用直写策略时需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以在Cache-主存层次，Cache可以采用直写策略，而在主存-外存（磁盘）层次，修改页面内容时总是采用回写策略。  

06.【解答】  

1）物理地址由实页号和页内地址拼接，因此其位数为 $16+12=28$ ；或直接得 $20+3+5\!=\!28$  

2）TLB采用全相联映射，可把页表内容调入任意一块空TLB项中，TLB中的每项都有一个比较器，没有映射规则，只要空闲就行。TLB采用静态存储器（SRAM），读/写速度快，但成本高，多用于容量较小的高速缓冲存储器。  

3）图中可看到，Cache中每组有两行，因此采用二路组相联映射方式。因为是二路组相联并采用LRU替换算法，所以每行需要1位LRU位；因为采用回写策略，所以每行有1位修改位（脏位），根据脏位判断数据是否被更新，若脏位为1，则需要写回内存。28位物理地址中Tag字段占20位，组索引字段占3位，块内偏移地址占5位，因此Cache共有 $2^{3}\!=\!8$ 组，每组2行，每行有 $2^{5}\,{=}\,32\mathrm{B}$ ；Cache的总容量为 $8{\times}2{\times}(20+1+1+1+32{\times}8)=4464{\tt b}=558{\tt B}$ Cache中有效位用来指出所在Cache行中的信息是否有效。  

4）虚拟地址分为两部分：虚页号、页内地址；物理地址分为两部分：实页号、页内地址。利用虚拟地址的虚页号部分去查找TLB表（缺失时从页表调入），将实页号取出后和虚拟地址的页内地址拼接，形成物理地址。虚页号0008CH恰好在TLB表中对应实页号0040H（有效位为1，说明存在），虚拟地址的后3位为页内地址 $040\mathrm{H}$ ，对应的物理地址是0040040H。物理地址为0040040H，其中高20位00400H为标志字段，低5位00000B为块内偏移量，中间3位010B为组号2，因此将00400H与Cache中的第2组两行中的标志字段同时比较，可以看出，虽然有一个Cache行中的标志字段与00400H相等，但对应的有效位为0，而另一Cache行的标志字段与00400H不相等，因此访问Cache不命中。因为物理地址的低12位与虚拟地址的低12位相同，即为 $0010\,0110\,0000\mathrm{B}$ 。根据物理地址的结构，物理地址的后八位01100000B的前三位011B是组号，因此该地址所在的主存映射到Cache组号为3。  

07.【解答】  

注意：对于本题的TLB，需要采用处理Cache的方式求解。1）按字节编址，页面大小为 $4\ \mathrm{KB}=2^{12}\mathrm{B}$ ，页内地址为12位。虚拟地址中高 $30-12=18$ 位表示虚页号，虚拟地址中低12位表示页内地址。2）TLB采用二路组相联方式，共 $8\,=\,2^{3}$ 组，用3位来标记组号。虚拟地址（或虚页号）中高 $18-3=15$ 位为TLB标记，虚拟地址中随后3位（或虚页号中低3位）为TLB组号。3）虚页号4对应的TLB表项被替换。因为虚页号与TLB组号的映射关系为TLB组号 $=$ 虚页号modTLB组数 $=$ 虚页号 $\mod8$ ，因此，虚页号10,12，16,7,26,4,12,20映射到的TLB组号依次为 $2,4,0,7,2,4,4,4$ 。TLB采用二路组相联方式，从上述映射到的TLB组号序列可以看出，只有映射到4号组的虚页号数量大于2，相应虚页号依次是12，4，12和20。根据LRU替换策略，当访问第20页时，虚页号4对应的TLB表项被替换出来。4）虚拟地址位数增加到32位时，虚页号增加了 $32\!-\!30\,=\,2$ 位，使得每个TLB表项中的标  
记字段增加2位，因此，每个TLB表项的位数增加2位。  

08.【解答】  

1）数组a的起始地址为 $0042\,2000\mathrm{H}$ ，页大小为4KB，所以页内偏移量占12位，数组a共有 $24{\times}64=1536$ 个元素，每个int型数据占4字节，因此数组a共占 $1536\!\times\!4\mathrm{B}=6\mathrm{KB}$ ，故分布在2个相邻的页面中。页号分别为00422H和00423H，当访问这两个页面的第一个数组元素的地址时，因为页面尚未调入内存，所以会发生2次缺页异常，两个页故障地址分别是00422000H和 $0042\,3000\mathrm{H}$  

2）若不考虑变量i和j，该程序段的数据访问只涉及对数组元素的访问，由于每个数组元素只访问一次，因此该程序段的数据访问没有时间局部性。  

3）在组相联映射方式下，物理地址结构为Tag标记 $^+$ Cache组号 $^+$ 块内地址，主存块大小为32B，故块内地址占5位；Cache数据区共有 $\mathrm{8KB^{\cdot}\!32B=\!256}$ 行，采用4路组相联，共有64组，故Cache组号占6位，因此虚拟地址中低5位（ $\mathrm{A4\!\sim\!A0})$ ）用作块内地址：低11位虚拟地址中高6位 $(\mathrm{A}10{\sim}\mathrm{A}5)$ 用作Cache组号。a[1][o]的虚拟地址为 $0042\ 2000\mathrm{H}+$  $1{\times}64{\times}4\ +\ 0{\times}4\ =0042\ 2100\mathrm{H}$ 。虚拟地址为32位，页框大小为4KB，虚拟地址的低12位表示页内偏移量，因此物理地址的低12位和虚拟地址的低12位相同，因此a[1]I0]所在主存块对应的Cache组号为 $001000\mathbf{B}=8$  

4）数组a占  $24{\times}64{\times}4\mathrm{B}{\div}32\mathrm{B}=192$  个主存块。每个主存块存放  $32\mathrm{B}{\cdot}4\mathrm{B}=8$  个数组元素，访问 数组a的Cache命中率为 $(8-1)/8=87.5\%\,8$ 行数组元素占 $8{\times}64{\times}4\mathrm{B}{\div}32\mathrm{B}=64$ 个主存块，分别映射到64个Cache组的某Cache行，数组a共有24行，因此每个Cache组中只有 $24/8=3$ 个Cache行存放数组a中的数据，而每个Cache组有4行，因而不会发生替换，访问数组a的Cache命中率为 $7/8=87.5\%$  


# 4.1.7 答案与解析  

# 一、单项选择题  

01.D  

指令集体系结构（ISA）完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的。指令系统是计算机硬件的语言系统，这显然和机器语言有关。  

02.A  

指令集体系结构（ISA）是软件和硬件之间接口的一个完整定义，包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断和异常处理及外部I/O。ISA规定了执行每条指令时所需要的操作码、操作数、寻址方式等信息，以及指令的功能和效果。控制信号是由控制单元根据ISA生成的，它属于微架构层面的实现细节，而不是ISA层面的抽象定义。  

03.A PC存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址。  

04.A 运算型指令寻址的是操作数，而转移型指令寻址的是下次欲执行的指令的地址。  

05.D 程序控制类指令用于改变程序执行的顺序，并使程序具有测试、分析、判断和循环执行的能力。  

06.C  
程序控制类指令主要包括无条件转移、有条件转移、子程序调用和返回指令、循环指令等。中断隐指令是由硬件实现的，并不是指令系统中存在的指令，更不可能属于程序控制类指令。  

07. C  

特权指令是指仅用于操作系统或其他系统软件的指令。为确保系统与数据安全起见，这类指令不提供给用户使用。  

08.C 零地址的运算类指令也称堆栈运算指令，参与的两个操作数来自栈顶和次栈顶单元。  

> attention  

堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。若是软堆栈（堆栈区由内存实现），则对于双目运算需要访问4次内存：取指令、取源数1、取源数2、存结果。若是硬堆栈（堆栈区由寄存器实现），则只需在取指令时访问一次内存。  

09.B  

指令的地址个数与指令的长度是否固定没有必然联系，即使是单地址指令，也可能由于单地址的寻址方式不同而导致指令长度不同。  

10.B  

单地址指令中只有一个地址码，在完成两个操作数的算术运算时，一个操作数由地址码指出，另一个操作数通常存放在累加寄存器（ACC）中，属于隐含寻址。  

11.B  

$16\mathbf{M}=2^{24}$ ，字长为32位，现在按半字（16位）寻址，相当于有8M $(=2^{23}$ ）个存储单元，每个存储单元中存放16位。  

12.B  

因 $128=2^{7}<200<2^{8}=256$ ，因此采用定长操作码时，至少需要8位。  

13.C 扩展操作码并未改变指令的长度，而是使操作码长度随地址码的减少而增加。  

14.D  

地址码为12位，二地址指令的操作码长度为 $32-12-12=8$ 位，已定义了250条二地址指令， $2^{8}\!-250=6$ ，即可以设计出单地址指令 $6{\times}2^{12}=3{\times}2^{13}$ 条。  

15.A  

三地址指令有29条，所以其操作码至少为5位。以5位进行计算，它剩余 $32\mathrm{~-~}29=3$ 种操作码给二地址。而二地址额外多了6位给操作码，因此其数量最大达 $3{\times}64=192$ 。所以指令字长最少为23位，因为计算机按字节编址，需要是8的倍数，所以指令字长至少应该是24位。  

16.B  

指令集体系结构处于软/硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由ISA规定。两个CPU可以有不同的时钟周期，但指令集可以相同；加法器的进位方式涉及电路设计，这两项都属于计算机的硬件部分，不由ISA规定。  

17.D  

地址码为6位，一条二地址指令会占用 $2^{6}$ 条一地址指令的空间，一条一地址指令会占用 $2^{6}$ 条零地址指令的空间。若全都是零地址指令，则最多有 $2^{16}$ 条，减去一地址指令和二地址指令所占用的零地址指令空间，即 $2^{16}{-}254{\times}2^{6}{-}12{\times}2^{6}{\times}2^{6}{=}(2^{10}{-}254{-}12{\times}2^{6}){\times}2^{6}{=}2{\times}2^{6}{=}128{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{6}{\times}2^{$  

另解：二地址指令有12条，则剩余 $16-12=4$ 种操作码给一地址指令，一地址指令有254条，剩余 $4{\times}64-254=2$ 种操作码给0地址指令，所以0地址一共有 $2\!\times\!2^{6}\!=128$ 条。  
# 二、综合应用题  

01.【解答】  

1）因为有142条指令，所以至少需要8位才能确定各条指令的操作码（ $.2^{8}\!=\!256$ ）。由于该处理器有32个寄存器，也就是说要用5位对寄存器ID编码，而每个立即数需要16位。因此，有： $20\%$ 的一个输入寄存器和一个输出寄存器指令需要 $8+5+5=18$ 位，长度对齐到8的倍数，便是24位。  

$30\%$ 的两个输入寄存器和一个输出寄存器指令需要 $8+5+5+5=23$ 位，对齐到24位 $25\%$ 的一个输入寄存器、一个输出寄存器、一个立即数寄存器指令需要 $8+5+5+16=34$ 位，对齐到40位。  

$25\%$ 的一个立即数输入寄存器和一个输出寄存器指令需要 $8+16+5=29$ 位，对齐到32位。  

2）因为变长指令最长的长度为40位，所以定长指令编码每条指令的长度均为40位。而采用变长编码，将各个指令长度和其概率相乘，得出平均长度为30位。所以该程序中，变长编码比定长编码少占用 $25\%$ 的存储空间。  

02.【解答】  

1）根据操作数地址码为6位，得到二地址指令中操作码的位数为 $16-6-6=4$ ，这4位操作码可有16种操作。由于操作码固定，因此除了零地址指令有 $M$ 种，一地址指令有 $N$ 种，剩下的二地址指令最多有 $16-M{-}N$ 种。妆  

2）采用扩展操作码技术，操作码位数可随地址数的减少而增加。对于二地址指令，指令字长16位，减去两个地址码共12位，剩下4位操作码，共16种编码，去掉一种编码（如1111）用于一地址指令扩展，二地址指令最多可有15种操作。  

3）采用扩展操作码技术，操作码位数可变，二地址、一地址和零地址的操作码长度分别为4 位、10位和16位。这样，二地址指令操作码每减少一个，就可以多构成 $2^{6}$ 条一地址指令操作码：一地址指令操作码每减少一个，就可以多构成  $2^{6}$  条零地址指令操作码。设一地址 指令有 $R$ 条，则一地址指令最多有 $(2^{4}\!-\!P)\!\times\!2^{6}$ 条，零地址指令最多有 $[(2^{4}\!-\!P)\!\times\!2^{6}\!-\!R]\!\times\!2^{6}$ 条。根据题中给出零地址指令为 $\mathcal{Q}$ 条，即 $Q\,=\,[(2^{4}-\,P)\!\times\!2^{6}-\,R]\times2^{6}$ ，得 $R\,=\,(2^{4}-\,P){\times}2^{6}\,-$  $\left\lceil Q\times2^{-6}\right\rceil$ 。  

03.【解答】  

1)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/38ef7b4e68e3a7b08474f441f81ab33eeb932a184a4e8eb051d0d03f765b7674.jpg)  

2)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0f3da896c1d01c426c5089e207779cc1657223d154581f5519ec6cd7b1635e45.jpg)  
3)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c690c5f72307ac5a540da94ad269c4415aaf881198bac8f305dbd7ea59543837.jpg)  

# 4.2.4 答案与解析  

# 一、单项选择题  

01.B  

采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度。程序控制是靠转移指令而非寻址方式实现的。  

02.A  

转移指令有条件/无条件、直接/间接、相对/绝对三种属性。条件转移是指需要先判断条件是否成立，才决定是否转移；无条件转移是指不用判断条件就可以转移，典型的是函数调用和返回。直接转移是指转移目标地址直接放在指令中，执行时直接将地址码送入PC：间接转移是指转移目标地址存放在寄存器或内存单元中。相对转移是指转移目标地址为当前PC值加上偏移量，偏 移量一般在指令中；绝对转移是指转移目标地址直接由指令或寄存器给出。  

03.D  

CPU中寄存器的数量都不会太多，用很短的编码就可以指定寄存器，寄存器寻址需要的地址段位数为log(通用寄存器个数)，因此能有效地缩短地址段的位数。立即寻址，操作数直接保存在指令中，若地址段位数太小，则操作数表示的范围会很小：变址寻址，EA $=$ 变址寄存器IX的内容 $^+$ 形式地址A，A与主存寻址空间有关：间接寻址中存放的仍然是主存地址。  

04.B  

隐含寻址不明显给出操作数地址，而在指令中隐含操作数的地址，因此可以简化地址结构。  

05.B  

立即寻址最快，指令直接给出操作数；寄存器寻址次之，只需访问一次寄存器；直接寻址再次之，访问一次内存；间接寻址最慢，要访问内存两次或以上。  

06.A  

指令字中的形式地址为操作数的有效地址，这种方式为直接寻址。  

07.B  

变址寻址的有效地址是 $\mathrm{(X)+A}$ ，再进行间址，即把 $\mathrm{(X)+A}$ 中取出的内容作为真实地址EA，即  $\mathrm{EA}=((\mathrm{(X)}+\mathrm{A})$  

寄存器中的内容和指令地址码相加得到的是操作数的地址码。  

08.B  

变址寻址便于处理数组问题。基址寻址与变址寻址的区别见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e8049d7cf56958be7a1f660caf7f89e2bc1af43f990c17979558b13f34996147.jpg)  

09.B  

进、出堆栈时对栈顶指针的操作顺序是不同的，进栈时是先压入数据 $(\mathbf{A}){\rightarrow}\mathbf{M}_{\mathrm{SP}}$ ，后修改指针 $(\mathrm{SP})-1{\rightarrow}\mathrm{SP}$ ，说明栈指针是指向栈顶的空单元的，所以出栈时要先修改指针 $(\mathrm{SP})+1{\rightarrow}\mathrm{SP}$ ，然后才能弹出数据 $(\mathbf{M}_{\mathrm{SP}}){\rightarrow}\mathbf{A}$  
10.D  

相对寻址中，有效地址 $\mathrm{EA}\,{=}\,(\mathrm{PC})+\mathrm{A}$ （A为形式地址），执行本条指令时，PC已完成加1操作，PC中保存的是下一条指令的地址，因此以下一条指令的地址为基准位置的偏移量。  

11.C  

堆栈是主存（或寄存器）中一块特定的、按后进先出原则管理的存储区，寄存器堆栈称为硬堆栈，主存中划分出来的区域作为堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。  

12. C  

跳跃寻址通过转移类指令（如相对寻址）来实现，可用来实现程序的条件或无条件转移  

13.B  

寄存器R2中的值是1234H，内存单元1234H中的值是56H，1235H中的值是78H，由于采用小端方式，因此实际存储的数据为7856H，取出后存放到R1，因此R1的值为 $7856\mathrm{H}$  

14.C  

主存按字编址，指令字长为1个字（2字节），因此取出该指令后，PC自动加1，相对偏移量为06H，所以该转移指令执行后的PC值为 $4000\mathrm{H}+06\mathrm{H}+1\mathrm{H}=4007\mathrm{H}.$  

15. D  

将指令2222H展开成二进制为 $0010\ 001{\underline{{0}}}\ 0010\ 0010B$ ，因此寻址特征位 $\mathrm{X}=10$ ，即使用X2进行变址寻址，其有效地址为 $1188\mathrm{H}+22\mathrm{H}=$ 11AAH。  

16.C  

指令字长为16位，2字节，因此取指令后PC的内容为 $(\mathrm{PC})+2=2002\mathrm{H}$ ：无条件转移指令将下一条指令的地址送至PC，形式地址为 $40\mathrm{H}$ ，指令执行后 $\mathrm{PC}=2002\mathrm{H}+0040\mathrm{H}=2042\mathrm{H}.$  

17.A  

操作码位数固定，且能完成97种操作，则操作码位数是 $\scriptstyle{\overline{{\log_{2}\!97}}}\,=\,7$ 位；具有六种寻址方式，则寻址特征位数是 $\left.\overline{{\log_{2}\!6}}\,\right|\!=3$ 位；指令字长为16位，因此地址码位数是 $16-3-7=6$ 位，6位补码的表示范围为- $-32\!\sim\!+31$ ，即为相对寻址的偏移量范围。  

18.B  

机器按字寻址，程序计数器（PC）给出下一条指令字的访存地址（指令在内存中的地址），因此取决于存储器的字数；指令寄存器（IR）用于接收取得的指令，因此取决于指令字长。  

19.D  

直接寻址200访问的操作数是300，A错误。寄存器间接寻址（R）的访问结果与I一样，B错误。存储器间接寻址（200）表示主存地址200中的内容为有效地址，有效地址为300，访问的操作数是400，C错误。寄存器寻址R表示寄存器R的内容为操作数，只有D正确。  

20. A 寄存器间接寻址中操作数的有效地址 $\mathrm{EA}=(\mathrm{R}_{i})$ ，8号寄存器内容为1200H，因此 $\mathrm{EA}=1200\mathrm{H}$  

21. D、C  

首先需要讲解一下补码扩充的问题。补码的扩充只需使用符号位补足即可，也就是说正数补码的扩充只要补0，负数补码的扩充只需补1（这是由补码的性质决定的）。理解了该性质，这道题就变成了十进制转换为十六进制的简单问题。  

1）PC的当前值为240，该指令取出后PC的值为243，要求转移到290，即相对位移量为 $290-243=47$ ，转换成补码为 $2\mathrm{FH}$ 。由于数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为2FH，由于47是正数，因此只需在高位补0，所以第三字节为 $\mathrm{00H}$  
2）PC的当前值为240，该指令取出后PC的值为243，要求转移到200，即相对位移量为 $200-243=-43$ ，转换成补码为D5H。由于数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为D5H，由于-43是负数，因此只需在高位补1，所以第三字节为FFH。  

22.D  

基址寻址的操作数的有效地址为基址寄存器内容加上形式地址，即 $\mathrm{C000~0000H+FF00H=C000}$  $\ensuremath{0000\mathrm{H}}+$ FFFFFI $\mathrm{{F00H}=}$ BFFFFF00H。由于是大端方式，因此LSB的存放地址为BFFFFF03H。  

23.D  

算术与逻辑运算指令用于完成对一个（如自增、取反等）或两个数据的算术运算或逻辑运算，A错误。移位操作用于把一个操作数左移或右移一位或多位，B错误。转移指令、子程序调用与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求，C错误。  

24.C  

相对寻址 $\mathrm{EA}=(\mathrm{PC})+\mathrm{A}$ ，首先计算取指令后的PC值。转移指令由2字节组成，每取一字节PC加1，取指令后的PC值为2002H，因此 $\mathrm{{EA}=(\mathrm{{PC})+A}=2002H+06H=2008H.}$ 本题易误选A或B，选项A未考虑PC值的自动更新，选项B虽然考虑了PC值的自动更新，但未注意到该转移指令是一条2字节指令，PC值应是“ $^{+2}$ ”而不是“ $+1$ ”。  

25.A  

间接寻址不需要寄存器， $\mathrm{EA}=(\mathrm{A})$ 。基址寻址 $\mathrm{EA}=\mathbf{A}+$ 基址寄存器BR的内容：相对寻址 $\mathrm{EA}=\mathrm{A}+$ 程序计数器PC的内容：变址寻址 $\mathrm{EA}=\mathrm{A}+$ 变址寄存器IX的内容。后三者都是将某个寄存器的内容与一个形式地址相加而形成有效地址，所以统称偏移寻址。  

26.C  

假设两个无符号整数 $A$ 和 $B$ ，bgt指令会将 $A$ 和 $B$ 进行比较，也就是将 $A$ 和 $B$ 相减。若 $A>B$ 则 $A-B$ 肯定无进位/借位，也不为0（为 $0$ 时表示两数相等），因此CF和ZF均为O，选C。其余选项中用到了符号标志SF和溢出标志OF，SF表示结果的符号，OF是有符号整数的溢出标志位，对于无符号数运算，SF和OF没有意义，显然应当排除。  

27.D  

根据变址寻址的方法，变址寄存器的内容（1000H）与形式地址的内容（2000H）相加，得到操作数的实际地址（3000H)，根据实际地址访问内存，获取操作数 $4000\mathrm{H}$ ，如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c0c2f4c24c538e3a48ebd79d22813dfd68fdf5bf3e8d5b13850ae4e8cabb7579.jpg)  

28.A  

采用32位定长指令字，其中操作码为8位，两个地址码共占用 $32\textrm{--}8\textrm{=}24$ 位，而STORE指令的源操作数和自的操作数分别采用寄存器直接寻址和基址寻址，机器中共有16个通用寄存器，因此寻址一个寄存器需要 $\log_{2}\!16=4$ 位，源操作数中的寄存器直接寻址用掉4位，而目的操作数采用基址寻址也要指定一个寄存器，同样用掉4位，则留给偏移量的位数为 $24-4-4=16$ 位，而偏移量用补码表示，因此16位补码的表示范围为-3 $2768\!\sim\!+32767$  

29.C  

变址寻址中，有效地址（EA）等于指令字中的形式地址D与变址寄存器I的内容之和，即 $\mathrm{EA}=(\mathrm{I})+\mathrm{D}$ 。间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数地址的地址，即 $\mathrm{EA}=(\mathrm{D})$ 。从而该操作数的有效地址是 $\mathrm{((I)+D)}$  
30.D  

在变址操作时，将计算机指令中的地址与变址寄存器中的地址相加，得到有效地址，指令提供数组首地址，由变垃寄存器来定位数据中的各元素。所以它最适合按下标顺序访问一维数组元素，选D。相对寻址以PC为基地址，以指令中的地址为偏移量确定有效地址。寄存器寻址则在指令中指出需要使用的寄存器。直接寻址在指令的地址字段直接指出操作数的有效地址。  

31.B  

根据变址寻址的公式 $\mathrm{EA}\,{=}\,(\mathrm{IC})+\mathrm{A}$ ，有 $\mathrm{\Delta(IV)=2100H-\Delta2000H=100H=256,}$ ，sizeof(double) $=8$ （双精度浮点数用8位字节表示），因此数组的下标为 $256/8=32\$  

32.D  

注意，内存地址是无符号数。  

操作数采用基址寻址方式， $\mathrm{EA}=(\mathrm{BR})+\mathrm{A}$ ，基址寄存器BR的内容为 $\mathrm{F}000\,\,0000\mathrm{H}$ ，形式地址用补码表示为FF12H即 $1111\ 1111\ 0001\ 0010\mathrm{B}$ ，因此有效地址为 $\mathrm{F000\000H+(-00E E H)=E F F}$ FF12H。计算机采用大端方式编址，所以低位字节存放在字的高地址处，机器数一共占4字节，该操作数的LSB所在的地址是EFFFFF12H $+\,3=$ EFFFFF15H。  

33.A  

48条指令需要6位操作码字段 $(2^{5}<48<2^{6}$ )，4种寻址方式需要2位寻址特征位（ $4\!=\!2^{2}$ 还剩 $16-6-2=8$ 位作为地址码，所以直接寻址范围为 $_{0\sim255}$ 。注意，主存地址不能为负。  

34.A  

指令字由操作码、寻址特征和地址码三个字段组成，寻址特征字段用来指明指令属于哪种寻址方式。若寻址方式是寄存器直接寻址，则地址码所指的通用寄存器中存放的是操作数，若寻址方式是寄存器间接寻址，则对应通用寄存器中存放的是操作数的地址。  

# 二、综合应用题  

01.【解答】  

1）因为OP字段长为5位，所以指令能定义 $2^{5}\,{=}\,32$ 种指令。  

2）、3）各种寻址方式的有效地址EA的计算公式、寻址范围见下表。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea424a1fc017761cda43997f3930c83a8dc8761ce95ab6d12e32fe4e4dae0e98.jpg)  

02.【解答】  

1）直接寻址时，有效地址是指令中的地址码部分500，装入ACC的是800。  

2）立即寻址时，指令的地址码部分是操作数而不是地址，所以将500装入ACC。  

3）间接寻址时，操作数的有效地址存储在地址为500的单元中，由此得到有效地址为800，操作数是300。  

4）相对寻址时，有效地址 $\mathrm{EA}=(\mathrm{PC})+\mathrm{A}=202+500=702$ ，所以装入ACC的操作数是325。这是因为指令是双字长，在该指令的执行阶段，PC的内容已经加2，更新为下一条指令的地址202。  
5）变址寻址时，有效地址 $\mathrm{EA}=(\mathrm{NR})+\mathrm{A}=100+500=600$ ，所以装入ACC的操作数是900。6）寄存器寻址时，R1的内容400装入ACC。7）寄存器间接寻址时，有效地址是R1的内容400，装入ACC的操作数是700。  

03.【解答】  

取指令后， $\mathrm{PC}=1235\mathrm{H}$ （注意，不是 $1236\mathrm{H}$ ，因主存按字编址）。 $\textcircled{\scriptsize{1}}$  $\mathrm{X}=00$ ， $\mathrm{D}=20\mathrm{H}$ ，有效地址 $\mathrm{EA}=20\mathrm{H}$  $\circledcirc$  $X=10$ ， $\mathrm{D}=44\mathrm{H}$ ，有效地址 $\mathrm{EA}=1122\mathrm{H}+44\mathrm{H}=1166\mathrm{H}.$  $\textcircled{3}$  $X=11$ ， $\mathrm{D}=22\mathrm{H}$ ，有效地址 $\mathrm{{EA}}=1235\mathrm{{H}}+22\mathrm{{H}}=1257\mathrm{{H}}$  $\textcircled{4}$  $X=01$ ， $\mathrm{D}=21\mathrm{H}$ ，有效地址 $\mathrm{EA}=0037\mathrm{H}+21\mathrm{H}=0058\mathrm{H}$  $\circledast$  $X=11$ ， $\mathrm{D}=23\mathrm{H}$ ，有效地址 $\mathrm{{EA}}=1235\mathrm{{H}}+23\mathrm{{H}}=1258\mathrm{{H}}$  

04.【解答】  

1）因为PC的增量是2，且每条指令占2字节，所以编址单位是字节。  

2）根据“大于”条件判断表达式，可以看出该bg指令实现的是有符号整数比较。因为无符号数比较时，其判断表达式中没有溢出标志OF。继续分析该逻辑表达式，bgt指令的含义是当两数相减的结果大于0时，执行转移操作。因此，要满足bgt指令的条件，必须保 证如下两个条件：一是结果不为0，即零标志位ZF为0：二是结果的符号位与溢出标志位OF相同，即SFOF为O（两数相减结果大于0，有两种情况：第一种情况是结果没有溢出，此时OF位和SF位都为O：第二种情况是结果发生了溢出，此时OF和SF位都为1)。综上所述，逻辑表达式可表示为 $\mathrm{ZF}+(\mathrm{SF}\oplus\mathrm{OF})=0$ 。3）偏移地址 $\mathrm{Imm9}$ 为补码表示，说明转移目标地址可能在bgt指令之后。计算转移目标地址时，偏移量为 $\mathrm{Im}\mathrm{m}8{\times}2$ ，说明 $\mathrm{Immm8}$ 不是相对地址，而是相对指令数。 $\mathrm{Imm9}$ 的范围为 $-128\!\sim$ 127，所以转移目地址的范围是 $\mathrm{PC}+2+(-128{\times}2){\sim}\mathrm{PC}+2+127{\times}2$ ，也即转移目标地址的范围是相对于bgt指令的前127条指令到后128条指令之间。  

05.【解答】  

直接寻址：寄存器的内容是有效地址EA，所以直接寻址的有效地址为300，根据题给出的表格可知，地址300对应的内容为400。间接寻址：根据寄存器的内容寻找到的内容才是真正的有效地址，所以根据寄存器内容300找到的400才是间接寻址的有效地址，因此有效地址为400，地址400对应的内容为700。相对寻址：寄存器的内容加上PC的内容为有效地址，PC的当前值为200，所以当取出一条指令后，变为202，因此有效地址为 $202+300=502$ ，地址502对应的内容为900。变址寻址：变址寻址的有效地址为变址寄存器的内容加上累加器的内容，所以有效地址为 $100\,+$  $300=400$ ，地址400对应的内容为700。基址寻址：基址寻址的有效地址为基址寄存器的内容加上累加器的内容，所以有效地址为 $200+300=500$ ，地址500对应的内容为 $600$ 先变址后间址：先变址，即先让变址寄存器的内容加上累加器的内容，即400：再间址，意思就是根据地址400找到的内容才是有效地址，所以先变址后间址的有效地址为700。地址700对应的内容为401。  

先间址后变址：先间址，即先根据累加器的内容300找到间址的有效地址400；再变址，即400再加上变址寄存器的内容，也就是 $400+100=500$ ，地址500对应的内容为600。  

综上，得到下表：  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c2079d2980d724c722e492928f99eb8be47eca3321f95d3c4077b578c024322.jpg)  

06.【解答】  

1）操作码占4位，则该指令系统最多可有 $2^{4}\!=\!16$ 条指令。操作数占6位，其中寻址方式占3位、寄存器编号占3位，因此该机最多有 $2^{3}\,=\,8$ 个通用寄存器。主存地址空间大小为128KB，按字编址，字长为16位，共有 $128\mathrm{{KB}}/2\mathrm{{B}}=2^{16}$ 个存储单元，因此MAR至少为16位；本题已说明了存储字长为16位，因此MDR至少为16位。  

2）寄存器字长为16位，PC可表示的地址范围为 $0{\sim}2^{16}{-}1$ ，Rn可表示的相对偏移量为 $\cdot2^{15}{\sim}2^{15}$ -1，而主存地址空间为 $2^{16}$ ，因此转移指令的目标地址范围为0000H～FFFFH $(0{\sim}2^{16}{-}1)$  

3）汇编语句“add(R4), $({\tt R}5)^{+}$ ”对应的机器码为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2409d3635499b265dd349dd8bd5f98585f11ca964ca8d7908e2b6e732ec6a1c8.jpg)  

将对应的机器码写成十六进制形式为 $0010\,0011\ 0001\ 0101\mathrm{B}=2315\mathrm{H}\,.$  

该指令的功能是将R4的内容所指的存储单元的数据与R5的内容所指的存储单元的数据相加，并将结果送入R5的内容所指的存储单元中。 $(\mathrm{R4})=1234\mathrm{H}$ ， $(1234\mathrm{H})=5678\mathrm{H}$  $(\mathrm{R}5)=5678\mathrm{H}$  $(5678\mathrm{H})=1234\mathrm{H},$ ：执行加法操作 $5678\mathrm{H}+1234\mathrm{H}=68\mathrm{ACH}.$ 。之后R5自增。  

该指令执行后，R5和存储单元5678H的内容会改变，R5的内容从5678H变为5679H，存储单元5678H中的内容变为该指令的计算结果68ACH。  

07.【解答】  

1）因为指令长度为16位，且下一条指令地址为 $(\mathrm{PC})+2$ ，因此编址单位是字节。  

相对偏移量OFFSET为8位补码，表示范围为 $-128\!\sim\!127$ ，根据转移目标地址为 $(\mathrm{PC})+2+$  $2\times0$ OFFSET，若要向后跳转，则要求OFFSET必须为负数，OFFSET的最小值为-128，但在执行转移指令之前，PC进行了自增 $^{+2}$ 的操作，所以向后最多可跳转127条指令。  

2）指令中 $C=0$ ， $Z=1$ ， $\Nu=1$ ，因此应根据ZF和NF的值来判断是否转移。 $\mathrm{CF}=0$ ， $Z\mathrm{F}=0$  $\mathrm{NF}=1$ 时，需转移。已知指令中的偏移量为 $1110\ 0011\mathrm{B}=\mathrm{E}3\mathrm{H}$ ，符号扩展后为FFE3H，左移一位（乘以2）后为FFC6H，因此PC的值（即转移目标地址）为 $200\mathrm{CH}+2+\mathrm{FFC6H}=$ 1FD4H。 $\mathrm{CF}=1$ ， $Z\mathrm{F}=0$ ， ${\mathrm{NF}}=0$ 时不转移。PC的值为 $200\mathrm{CH}+2=200\mathrm{EH}.$  

3）指令中的C、Z和 $_\mathrm{N}$ 应分别设置为 $C=Z=1$ ， $\Nu\,{=}\,0$ 。两个数之间的大小比较通常是对两个数做减法运算，即两个数相减当结果为0或为负时转移，若为0，则ZF标志应当是1，若为负，则借位标志应该是1，而无符号数并不涉及符号标志NF。  

4）部件 $\textcircled{\scriptsize{1}}$ 用于存放当前指令，不难得出为指令寄存器；多路选择器根据符号标志C/Z/N来决定下一条指令的地址是PC+2还是 $\mathrm{PC}+2+2\times6$ OFFSET，因此多路选择器左边线  
上的结果应是 $\mathrm{PC}+2+2\times$ OFFSET。根据运算的先后顺序及与 $\mathrm{PC}+2$ 的连接，部件 $\circledcirc$ 用于左移一位实现乘以2，为移位寄存器。部件 $\mathcal{B}$ 用于 $\mathrm{PC}+2$ 和 $2\times$ OFFSET相加，为加法器。  

部件 $\circledcirc$ ：移位寄存器（用于左移一位）；部件 $\mathcal{B}$ ：加法器（地址相加）。  

08.【解答】  

1）指令操作码有7位，因此最多可定义 $2^{7}=128$ 条指令。  

2）各条指令的机器代码如下：  

$\textcircled{\scriptsize{1}}$ “incR1”的机器码为 $0000001\;0\;01\;0\;00\;0\;00$ ，即 $0240\mathrm{H}$  $\circledcirc$ “ $\mathrm{shbar}\,\mathrm{R}2$ ，R1”的机器码为 $0000010\ 0\ 10\ 0\ 01\ 0\ 00$ ，即 $0488\mathrm{H}$  $\textcircled{3}$ “subR3,（R1),R2”的机器码为 $0000011\;0\;11\;1\;01\;0\;10$ ，即06EAH。  

3）各标号处的控制信号或控制信号取值如下： $@00$  $\circledcirc$ mov; $\textcircled{3}$ mova; $\textcircled{4}$ left; $\circledast$ read; $^\mathrm{\textregistered}$ sub; $\textcircled{\scriptsize{2}}$ mov; $\circledast$ SRout。  

4）指令“subR1,R3，（R2)”的执行阶段至少包含4个时钟周期；指令“incR1”的执行阶段至少包含2个时钟周期。  

09.【解答】  

1）ALU的宽度为16位，ALU的宽度即ALU运算对象的宽度，通常与字长相同。地址线为20位，按字节编址，可寻址主存空间大小为 $2^{20}$ 字节（或1MB）。指令寄存器有16位，和单条指令长度相同。MAR有20位，和地址线位数相同。MDR有8位，和数据线宽度相同。  

2）R型格式的操作码有4位，最多有 $2^{4}$ （或16）种操作。I型和J型格式的操作码有6位，因为它们的操作码部分重叠，所以共享这6位的操作码空间，且前6位全为0的编码已被R型格式占用，因此I和J型格式最多有 $2^{6}\!-\!1=63$ 种操作。从R型和I型格式的寄存器编号部分可知，只用2位对寄存器编码，因此通用寄存器最多有4个。  

3）指令 $\mathrm{01B2H=000000\ 01\ 10\ 11\ 0010B}$ 为一条R型指令，操作码0010表示有符号整数减法指令，其功能为 $\mathrm{R}[3]\!\leftarrow\!\mathrm{R}[1]\!-\!\mathrm{R}[2],$ ，执行指令01B2H后， $\mathrm{R}[3]=\mathrm{B}052\mathrm{H}-0008\mathrm{H}=\mathrm{B}04\mathrm{AH},$ 结果未溢出。指令 $\mathrm{01B3H}=\mathrm{000000}\,\mathrm{01}\,\mathrm{10\,11\,0011B}.$ ，操作码0011表示有符号整数乘法指令，执行指令01B3H后， $\mathrm{R}[3]\!=\!\mathrm{R}[1]\!\times\!\mathrm{R}[2]\!=\!\mathrm{B}052\mathrm{H}\!\times\!0008\mathrm{H}\!=\!8290\mathrm{H},\mathrm{B}052\mathrm{H}$ 乘以8相当于将B052H算术左移3位，由于B052H是一个负数，符号位为1，在算术左移的过程中移出了101，不全为1，由此可以判断结果溢出。  

4）在进行指令的跳转时，既可能向前跳转，又可能向后跳转，偏移量是一个有符号整数，因此在地址计算时，应对imm进行符号扩展。  

5）无条件转移指令可以采用J型格式，将target部分写入PC的低10位，完成跳转。  



# 4.3.6 答案与解析  

# 一、单项选择题  

01.C  

该指令是Intel格式，add指令的目的寄存器为ax。add指令的补码加法过程为111111111110 $1000+0111\;1111\;1110\;0110=\!(1)0111\;1111\;1100\;1110$ （7FCEH），两个操作数的符号不同，必然不会溢出， $\mathrm{OF}\!=\!0$ ：结果的符号位为0， $\mathrm{SF}\!=\!0$ ；有进位， $\mathrm{CF}=\mathrm{C}\oplus\mathrm{Sub}=1\oplus0=1$ ：非0， $\mathrm{{ZF}\,{=}\,0}$  

> attention  

无论是无符号数还是有符号数，都以二进制代码形式无差别地存放在计算机内。即便两个有符号数相加，也会导致CF的变动，只是CF值对有符号数运算是没有意义的。同理，两个无符号数相加，也会导致OF和SF的变动，只是OF值和SF值仅对有符号数运算有意义。  

02.B  

该指令是Intel格式，sub指令的目的寄存器为bx。sub减法运算用补码加法实现，被减数 $^+$ 减数逐位取反  $+\ 1=1111\ 1111\ 1110\ 1000+1000\ 0000\ 0001\ 1001+1=(1)1000\ 0000\ 0000\ 0010$  （8002H），两个操作数的符号位都是1，结果的符号位也是1，无溢出， $\mathrm{OF}\!=\!0$ ；结果为负数， $\mathrm{SF}=1$ 进位输出  $\mathrm{C_{out}}\mathrm{=}\mathrm{1}$  ，低位进位  ${\mathrm{Sub}}=1$  ，  $\mathrm{CF}=\mathrm{C}_{\mathrm{out}}\oplus\mathrm{Sub}=1\oplus1=0$  ：非  $0$  ，  $Z\mathrm{F}=0$  6  

03.C  

imm的值为-3，转换成二进制为1111111111111101B，即FFFDH，因为该计算机采用小端存储，先存储低位字节，所以该指令对应的机器码为2DFDFFH，OF是有符号数运算的溢出标志位，7-（-3)显然没有溢出，因此0F标志位为0。  

04.A  

b间][O]所在的地址在edx中，j在esi中，一个数组元素占4字节，所以b间的]的地址为R[edx]+R[esij $^{1*4}$ ，指令格式为Intel格式，第一个为目的操作数，第二个为源操作数，于是A正确。  

05. C  

指令的一个源操作数在内存单元中，地址为R[ea $\mathrm{x]+R[e b x]^{*}4=080480B4H+0000011H^{*}4=}$ 080480F8H。指令的功能是 $\mathrm{R}[\mathrm{ex}]\!\leftarrow\!\!\mathrm{M}[080480\mathrm{F}8\mathrm{H}]^{*}(-16)=(\!-\!000000\mathrm{B}0\mathrm{H})<<\!4=$ FFFFFF50H<<4 $=$ FFFFF $500\mathrm{H}$ 。目的操作数保存在eax中，所以主存单元 $080480\mathrm{F}8\mathrm{H}$ 中的内容不会改变。  

06.D  

$\mathrm{i}=105$  $\mathrm{j}=100$ ，即edx的内容为100，eax的内容为105，cmp指令就是对这两个数做减法，显然  $100<105$  ，满足jle指令小于或等于的条件，jle指令长度为2字节，所以jle指令执行后将 转移到当前PC值 $^+$ 偏移量 $=84846{\mathrm{H}}+2+0{\mathrm{d}}{\mathrm{H}}=804847{\mathrm{b}}{\mathrm{H}}$ 处执行。  
07.C  

每个double型的数组元素占8字节，数组a的首地址为  $80498\mathrm{c0H}$  ,i存储在ecx中，所以a[i] 在主存中的地址可表示为[ecx $\mathrm{{}^{*}8+80498c0H]}$ ，因此汇编指令可以是moveax, $\left[\mathrm{exc^{*}8+80498c0H}\right]$  

08.C  

子程序调用指令需要将程序断点保存至堆栈，这个过程会改变SP的值，同时也会改变PC的值以跳转到子程序执行。  

09.D  

在if语句的机器级代码中，comp_A后面紧接着有一个条件跳移指令，条件成立则转跳到statementB，statement B，会转跳到if-else的下一条语句，A、B和C正确。statementB不一定在statementC之前，这取决于条件转移指令的类型和方向，D错误。  

10.D  

循环结构循环体内最后会有一条条件转移指令，判断是否跳出循环，可以用比较指令（CMP）来实现，A和C正确，D错误。循环结构不一定包含无条件转移指令，B正确。  

11.D  

为了能保证从被调用过程返回到调用过程继续执行，必须确定并保存返回地址，这个地址是调用指令随后的指令的地址，返回地址只能由调用指令来计算并保存，因为执行调用指令后就跳转到了被调用过程，因此无法获取返回地址。为了保证嵌套调用时能够返回到调用过程，必须将返回地址压栈，若不压栈而保存在特定寄存器中，则后面执行的调用指令会将前面调用指令保存 的返回地址覆盖掉。调用指令执行时将无条件转移到目标地址处，这个目标地址就是被调用过程第一条指令的地址，它一定在调用指令中明显给出，因此D错误。  

12.C  

过程调用的具体过程已在4.3.4节中介绍  

# 二、综合应用题  

01.【解答】  

1）M为CISC。M的指令长短不一，不符合RISC指令系统的特点。2）fl的机器代码占96B。因为fl的第一条指令“pushebp”所在的虚拟地址为 $0040\ 1020\mathrm{H}$ ，最后一条指令“ret”所在的虚拟地址为0040107FH，所以fl的机器指令代码长度为0040 $107\mathrm{H}-\,0040\,1020\mathrm{H}+1=60\mathrm{H}=96\mathrm{B}.$  3) $\mathrm{CF}=1$ 。cmp指令实现i与 $\mathrm{n-1}$ 的比较功能，进行的是减法运算。在执行f1(0的过程中， $\mathtt{n}\,{=}\,0$ ，当 $\mathrm{i}\!=\!0$ 时， $\mathrm{i}=0000\ 0000\mathrm{H}$ ，并且 $\mathrm{n-1}=$ FFFFFFFFH。因此，执行第20条指令时，在补码加/减运算器中执行“ $0$ 减FFFFFFFFH"操作，即 $0000\ 0000\mathrm{H}+0000000\mathrm{H}+1=0000$  $0001\mathrm{H}$ ，此时进位输出 $C_{\mathrm{out}}\!=\!0$ ，低位进位 $\mathrm{Sub}=1,\;\;\mathrm{CF}=C_{\mathrm{out}}\oplus\mathrm{Sub}=0\oplus1=1.$ 4）f2中不能用shl指令实现power $^{*}2$ 。因为 $\mathrm{shl}$ 指令把一个整数的所有有效数位整体左移，而f2中的变量power是float型，其机器数中不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能实现“乘以2”的功能，因此f2中不能用shi指令实现power  $^{*}2$  。浮点数运算比整型运算要复杂，耗时也较长。  

02.【解答】  

1）计算 $f(10)$ 需要调用函数f1共10次，执行第16行的call指令会递归调用f1。2）第12行的le指令是条件转移指令，其含义为小于或等于时转移，本行代码的意义为：当 $n{\leqslant}1$ 时，跳转至地址 $0040\ 1035\mathrm{H}.$ 第16行的call指令为函数调用指令，第20行的jmp指令为无条件转移指令，第30行的ret指令为子程序的返回指令，这三条指令一定会使  
程序跳转执行。  

3）在计算机M上按字节编址，第16行的call指令的虚拟地址为00401025H，长度为5字节，因此第17行的指令的虚拟地址为 $0040\ 1025\mathrm{H}+5=0040\ 102\mathrm{AH}.$ ，第16行的call指令采用相对寻址方式，即目标地址 $\mathbf{\mu=}\,(\mathbf{PC})+$ 偏移量，call指令的目标地址为 $0040~1000\mathrm{H}$ 所以偏移量 $=$ 目标地址- $\mathrm{{(PC)}=0040\ 1000H\mathrm{{~-~}0040\ 102A H=F F F\ F D6H\mathrm{{.}}}}$ 根据第16行的call指令的偏移量字段为D6FFFFFF，可以确定M采用小端方式。  

4)因为 $\mathcal{f}\!\!\left(13\right)\,=\,6227020800$ ，其结果超出了32位int型数据可表示的最大范围，因此（13)的返回值是一个发生了溢出的错误结果。为使f1(13)能返回正确结果，可将函数f1的返double（或longlong，long double，或float）类型。  

5）若乘积的高33位不全为0或不全为1，则 $\mathrm{OF}=1$ 。编译器应在imul指令后加一条“溢出自陷指令”，使得CPU自动查询溢出标志OF，当 $\mathrm{OF}=1$ 时调出“溢出异常处理程序”。  

03.【解答】  

因为页大小为4KB，所以虚拟地址的高20位为虚拟页号。第1行的push指令和第30行的ret指令的虚拟地址的高20位都是 $00401\mathrm{H}$ ，因此两条指令在同一页中。  

指令Cache有64块，采用4路组相联映射方式，因此指令Cache共有 $64/4\,=\!16$ 组，Cache组号共4位。主存块大小为64B，因此块内地址为低6位。综上所述，在32位主存地址中，低6位为块内地址，中间4位为组号，高22位为标记。  

因为页大小为4KB，所以虚拟地址和物理地址的最低12位完全相同，因此call指令虚拟地址 $0040\ 1025\mathrm{H}$ 中的 $025\mathrm{H}=0000\,0010\,0101\mathrm{B}$ 为物理地址的低12位，对应的 $7{\sim}10$ 位为组号，因此对应的Cache组号为0。  

04.【解答】  

1）第19条指令的虚拟地址为004010AEH，且第19条指令占11字节，因此第20条指令的虚拟地址为 $004010\mathrm{AED+11}$ （十进制） $\mathrm{\Omega}=0040\ 10B9\mathrm{H}$  

2）第2条指令的虚拟地址为00401079H，占2字节，取该指令后， $\mathrm{PC}+2$ ，变为0040107AH，转移指令的目标地址为00401084H，因此偏移量为 $00401084\mathrm{H}-0040107\mathrm{AH}=09\mathrm{H}$ ，根据第2条指令的机器码可知，09H恰好是第2条指令给出的偏移量。第7条指令的分析同理。因此，第2条jmp和第7条jge指令都采用相对寻址方式。第2条指令jmp的跳转目标地址 $=0040\ 1079\mathrm{H}+2$ （十进制） $\mathrm{~\ensuremath~{~+~}~09H=0040~1084H}$  

3）第19条指令的源操作数为0AH，直接在机器指令中（ $.0\mathrm{A}\;00\;00\;00$ ）给出，因此采用立即（数）寻址方式。数组a的一行有64个元素，每个元素占4字节，因此a回的地址应为 $\mathrm{00422000h+i}{\times}64{\times}4+\mathrm{j}{\times}4=00422000\mathrm{h+i}{\times}256+\mathrm{j}{\times}4$ ，根据汇编指令中给出的计算公式ecx $^+$  $\mathrm{{edx^{*}4+00422000h}}$ 可知，ecx中存放的是 $\mathrm{i}{\times}256$ 。M采用小端方式。  

4）第一次执行第19条指令时，取指令过程中不会发生缺页异常。因为第19条指令所在的该程序段都在页号为 $00401\mathrm{H}$ 的同一个页面中，执行第19条指令时，该页已在主存，因此取指令过程中不会发生缺页异常。  



# 4.4.5 答案与解析  

# 单项选择题  

01.A  

RISC必然采用流水线技术，这也是由其指令的特点决定的。而CISC则无此强制要求，但为了提高指令执行速度，CISC也往往采用流水线技术，因此流水线技术并非RISC的专利。CISC机可以兼容很多不同的高级语言和软件，而RISC机的指令系统简单精简，只包含一些基本的指令，这些指令需要通过组合来实现复杂的功能，从而增加了编译器的设计难度和程序员的编程难度，因此CISC机的兼容性更好。CPU配备很多通用寄存器是RISC机的主要特点。  

02.B  

A、C和D都是RISC的特点。对于B，寻址方式种类尽量减少是RISC的特点，而增强指令的功能则是CISC的特点。RISC指令功能简单，复杂指令的功能由简单指令的组合来实现。  

03.D  

RISC选择一些常用的寄存器型指令，并不是为了兼容CISC，RISC也不可能兼容CISC，A错误。RISC只是CPU的结构发生变化，基本不影响整个计算机的结构，并且即使是采用RISC技术的CPU，其架构也不可能像早期一样简单，B错误。RISC的指令功能简单，通过简单指令的组合来实现复杂指令的功能，C错误，但RISC的主要目标是减少指令数是正确的。  

04.C  

CISC指令格式种类多，增大了编译优化的复杂性，因此不利于编译优化。  

05.A  

相对于CISC，RISC的特点是：指令条数少；指令长度固定，指令格式和寻址种类少；只有取数/存数指令访问存储器，其余指令的操作均在寄存器之间进行：CPU中通用寄存器多；大部分指令在一个时钟周期内完成；以硬布线逻辑为主，不用或少用微程序控制。B、C和D都是RISC的特点。由于RISC的速度快，因此普遍采用硬布线控制器，A错误。  

